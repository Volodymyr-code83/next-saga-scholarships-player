"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@firebase";
exports.ids = ["vendor-chunks/@firebase"];
exports.modules = {

/***/ "(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/app/dist/esm/index.esm2017.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: () => (/* reexport safe */ _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError),\n/* harmony export */   SDK_VERSION: () => (/* binding */ SDK_VERSION),\n/* harmony export */   _DEFAULT_ENTRY_NAME: () => (/* binding */ DEFAULT_ENTRY_NAME),\n/* harmony export */   _addComponent: () => (/* binding */ _addComponent),\n/* harmony export */   _addOrOverwriteComponent: () => (/* binding */ _addOrOverwriteComponent),\n/* harmony export */   _apps: () => (/* binding */ _apps),\n/* harmony export */   _clearComponents: () => (/* binding */ _clearComponents),\n/* harmony export */   _components: () => (/* binding */ _components),\n/* harmony export */   _getProvider: () => (/* binding */ _getProvider),\n/* harmony export */   _isFirebaseApp: () => (/* binding */ _isFirebaseApp),\n/* harmony export */   _isFirebaseServerApp: () => (/* binding */ _isFirebaseServerApp),\n/* harmony export */   _registerComponent: () => (/* binding */ _registerComponent),\n/* harmony export */   _removeServiceInstance: () => (/* binding */ _removeServiceInstance),\n/* harmony export */   _serverApps: () => (/* binding */ _serverApps),\n/* harmony export */   deleteApp: () => (/* binding */ deleteApp),\n/* harmony export */   getApp: () => (/* binding */ getApp),\n/* harmony export */   getApps: () => (/* binding */ getApps),\n/* harmony export */   initializeApp: () => (/* binding */ initializeApp),\n/* harmony export */   initializeServerApp: () => (/* binding */ initializeServerApp),\n/* harmony export */   onLog: () => (/* binding */ onLog),\n/* harmony export */   registerVersion: () => (/* binding */ registerVersion),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"(ssr)/./node_modules/idb/build/index.js\");\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class PlatformLoggerServiceImpl {\n    constructor(container){\n        this.container = container;\n    }\n    // In initial implementation, this will be called by installations on\n    // auth token refresh, and installations will send this string.\n    getPlatformInfoString() {\n        const providers = this.container.getProviders();\n        // Loop through providers and get library/version pairs from any that are\n        // version components.\n        return providers.map((provider)=>{\n            if (isVersionServiceProvider(provider)) {\n                const service = provider.getImmediate();\n                return `${service.library}/${service.version}`;\n            } else {\n                return null;\n            }\n        }).filter((logString)=>logString).join(\" \");\n    }\n}\n/**\r\n *\r\n * @param provider check if this provider provides a VersionService\r\n *\r\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\r\n * provides VersionService. The provider is not necessarily a 'app-version'\r\n * provider.\r\n */ function isVersionServiceProvider(provider) {\n    const component = provider.getComponent();\n    return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\" /* ComponentType.VERSION */ ;\n}\nconst name$p = \"@firebase/app\";\nconst version$1 = \"0.10.3\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(\"@firebase/app\");\nconst name$o = \"@firebase/app-compat\";\nconst name$n = \"@firebase/analytics-compat\";\nconst name$m = \"@firebase/analytics\";\nconst name$l = \"@firebase/app-check-compat\";\nconst name$k = \"@firebase/app-check\";\nconst name$j = \"@firebase/auth\";\nconst name$i = \"@firebase/auth-compat\";\nconst name$h = \"@firebase/database\";\nconst name$g = \"@firebase/database-compat\";\nconst name$f = \"@firebase/functions\";\nconst name$e = \"@firebase/functions-compat\";\nconst name$d = \"@firebase/installations\";\nconst name$c = \"@firebase/installations-compat\";\nconst name$b = \"@firebase/messaging\";\nconst name$a = \"@firebase/messaging-compat\";\nconst name$9 = \"@firebase/performance\";\nconst name$8 = \"@firebase/performance-compat\";\nconst name$7 = \"@firebase/remote-config\";\nconst name$6 = \"@firebase/remote-config-compat\";\nconst name$5 = \"@firebase/storage\";\nconst name$4 = \"@firebase/storage-compat\";\nconst name$3 = \"@firebase/firestore\";\nconst name$2 = \"@firebase/vertexai-preview\";\nconst name$1 = \"@firebase/firestore-compat\";\nconst name = \"firebase\";\nconst version = \"10.12.0\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The default app name\r\n *\r\n * @internal\r\n */ const DEFAULT_ENTRY_NAME = \"[DEFAULT]\";\nconst PLATFORM_LOG_STRING = {\n    [name$p]: \"fire-core\",\n    [name$o]: \"fire-core-compat\",\n    [name$m]: \"fire-analytics\",\n    [name$n]: \"fire-analytics-compat\",\n    [name$k]: \"fire-app-check\",\n    [name$l]: \"fire-app-check-compat\",\n    [name$j]: \"fire-auth\",\n    [name$i]: \"fire-auth-compat\",\n    [name$h]: \"fire-rtdb\",\n    [name$g]: \"fire-rtdb-compat\",\n    [name$f]: \"fire-fn\",\n    [name$e]: \"fire-fn-compat\",\n    [name$d]: \"fire-iid\",\n    [name$c]: \"fire-iid-compat\",\n    [name$b]: \"fire-fcm\",\n    [name$a]: \"fire-fcm-compat\",\n    [name$9]: \"fire-perf\",\n    [name$8]: \"fire-perf-compat\",\n    [name$7]: \"fire-rc\",\n    [name$6]: \"fire-rc-compat\",\n    [name$5]: \"fire-gcs\",\n    [name$4]: \"fire-gcs-compat\",\n    [name$3]: \"fire-fst\",\n    [name$1]: \"fire-fst-compat\",\n    [name$2]: \"fire-vertex\",\n    \"fire-js\": \"fire-js\",\n    [name]: \"fire-js-all\"\n};\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @internal\r\n */ const _apps = new Map();\n/**\r\n * @internal\r\n */ const _serverApps = new Map();\n/**\r\n * Registered components.\r\n *\r\n * @internal\r\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst _components = new Map();\n/**\r\n * @param component - the component being added to this app's container\r\n *\r\n * @internal\r\n */ function _addComponent(app, component) {\n    try {\n        app.container.addComponent(component);\n    } catch (e) {\n        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);\n    }\n}\n/**\r\n *\r\n * @internal\r\n */ function _addOrOverwriteComponent(app, component) {\n    app.container.addOrOverwriteComponent(component);\n}\n/**\r\n *\r\n * @param component - the component to register\r\n * @returns whether or not the component is registered successfully\r\n *\r\n * @internal\r\n */ function _registerComponent(component) {\n    const componentName = component.name;\n    if (_components.has(componentName)) {\n        logger.debug(`There were multiple attempts to register component ${componentName}.`);\n        return false;\n    }\n    _components.set(componentName, component);\n    // add the component to existing app instances\n    for (const app of _apps.values()){\n        _addComponent(app, component);\n    }\n    for (const serverApp of _serverApps.values()){\n        _addComponent(serverApp, component);\n    }\n    return true;\n}\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n *\r\n * @returns the provider for the service with the matching name\r\n *\r\n * @internal\r\n */ function _getProvider(app, name) {\n    const heartbeatController = app.container.getProvider(\"heartbeat\").getImmediate({\n        optional: true\n    });\n    if (heartbeatController) {\n        void heartbeatController.triggerHeartbeat();\n    }\n    return app.container.getProvider(name);\n}\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n * @param instanceIdentifier - service instance identifier in case the service supports multiple instances\r\n *\r\n * @internal\r\n */ function _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) {\n    _getProvider(app, name).clearInstance(instanceIdentifier);\n}\n/**\r\n *\r\n * @param obj - an object of type FirebaseApp or FirebaseOptions.\r\n *\r\n * @returns true if the provide object is of type FirebaseApp.\r\n *\r\n * @internal\r\n */ function _isFirebaseApp(obj) {\n    return obj.options !== undefined;\n}\n/**\r\n *\r\n * @param obj - an object of type FirebaseApp.\r\n *\r\n * @returns true if the provided object is of type FirebaseServerAppImpl.\r\n *\r\n * @internal\r\n */ function _isFirebaseServerApp(obj) {\n    return obj.settings !== undefined;\n}\n/**\r\n * Test only\r\n *\r\n * @internal\r\n */ function _clearComponents() {\n    _components.clear();\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const ERRORS = {\n    [\"no-app\" /* AppError.NO_APP */ ]: \"No Firebase App '{$appName}' has been created - \" + \"call initializeApp() first\",\n    [\"bad-app-name\" /* AppError.BAD_APP_NAME */ ]: \"Illegal App name: '{$appName}'\",\n    [\"duplicate-app\" /* AppError.DUPLICATE_APP */ ]: \"Firebase App named '{$appName}' already exists with different options or config\",\n    [\"app-deleted\" /* AppError.APP_DELETED */ ]: \"Firebase App named '{$appName}' already deleted\",\n    [\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */ ]: \"Firebase Server App has been deleted\",\n    [\"no-options\" /* AppError.NO_OPTIONS */ ]: \"Need to provide options, when not being deployed to hosting via source.\",\n    [\"invalid-app-argument\" /* AppError.INVALID_APP_ARGUMENT */ ]: \"firebase.{$appName}() takes either no argument or a \" + \"Firebase App instance.\",\n    [\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */ ]: \"First argument to `onLog` must be null or a function.\",\n    [\"idb-open\" /* AppError.IDB_OPEN */ ]: \"Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.\",\n    [\"idb-get\" /* AppError.IDB_GET */ ]: \"Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.\",\n    [\"idb-set\" /* AppError.IDB_WRITE */ ]: \"Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.\",\n    [\"idb-delete\" /* AppError.IDB_DELETE */ ]: \"Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.\",\n    [\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */ ]: \"FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.\",\n    [\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */ ]: \"FirebaseServerApp is not for use in browser environments.\"\n};\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory(\"app\", \"Firebase\", ERRORS);\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class FirebaseAppImpl {\n    constructor(options, config, container){\n        this._isDeleted = false;\n        this._options = Object.assign({}, options);\n        this._config = Object.assign({}, config);\n        this._name = config.name;\n        this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled;\n        this._container = container;\n        this.container.addComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(\"app\", ()=>this, \"PUBLIC\" /* ComponentType.PUBLIC */ ));\n    }\n    get automaticDataCollectionEnabled() {\n        this.checkDestroyed();\n        return this._automaticDataCollectionEnabled;\n    }\n    set automaticDataCollectionEnabled(val) {\n        this.checkDestroyed();\n        this._automaticDataCollectionEnabled = val;\n    }\n    get name() {\n        this.checkDestroyed();\n        return this._name;\n    }\n    get options() {\n        this.checkDestroyed();\n        return this._options;\n    }\n    get config() {\n        this.checkDestroyed();\n        return this._config;\n    }\n    get container() {\n        return this._container;\n    }\n    get isDeleted() {\n        return this._isDeleted;\n    }\n    set isDeleted(val) {\n        this._isDeleted = val;\n    }\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */ checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"app-deleted\" /* AppError.APP_DELETED */ , {\n                appName: this._name\n            });\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class FirebaseServerAppImpl extends FirebaseAppImpl {\n    constructor(options, serverConfig, name, container){\n        // Build configuration parameters for the FirebaseAppImpl base class.\n        const automaticDataCollectionEnabled = serverConfig.automaticDataCollectionEnabled !== undefined ? serverConfig.automaticDataCollectionEnabled : false;\n        // Create the FirebaseAppSettings object for the FirebaseAppImp constructor.\n        const config = {\n            name,\n            automaticDataCollectionEnabled\n        };\n        if (options.apiKey !== undefined) {\n            // Construct the parent FirebaseAppImp object.\n            super(options, config, container);\n        } else {\n            const appImpl = options;\n            super(appImpl.options, config, container);\n        }\n        // Now construct the data for the FirebaseServerAppImpl.\n        this._serverConfig = Object.assign({\n            automaticDataCollectionEnabled\n        }, serverConfig);\n        this._finalizationRegistry = new FinalizationRegistry(()=>{\n            this.automaticCleanup();\n        });\n        this._refCount = 0;\n        this.incRefCount(this._serverConfig.releaseOnDeref);\n        // Do not retain a hard reference to the dref object, otherwise the FinalizationRegisry\n        // will never trigger.\n        this._serverConfig.releaseOnDeref = undefined;\n        serverConfig.releaseOnDeref = undefined;\n        registerVersion(name$p, version$1, \"serverapp\");\n    }\n    toJSON() {\n        return undefined;\n    }\n    get refCount() {\n        return this._refCount;\n    }\n    // Increment the reference count of this server app. If an object is provided, register it\n    // with the finalization registry.\n    incRefCount(obj) {\n        if (this.isDeleted) {\n            return;\n        }\n        this._refCount++;\n        if (obj !== undefined) {\n            this._finalizationRegistry.register(obj, this);\n        }\n    }\n    // Decrement the reference count.\n    decRefCount() {\n        if (this.isDeleted) {\n            return 0;\n        }\n        return --this._refCount;\n    }\n    // Invoked by the FinalizationRegistry callback to note that this app should go through its\n    // reference counts and delete itself if no reference count remain. The coordinating logic that\n    // handles this is in deleteApp(...).\n    automaticCleanup() {\n        void deleteApp(this);\n    }\n    get settings() {\n        this.checkDestroyed();\n        return this._serverConfig;\n    }\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */ checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */ );\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The current SDK version.\r\n *\r\n * @public\r\n */ const SDK_VERSION = version;\nfunction initializeApp(_options, rawConfig = {}) {\n    let options = _options;\n    if (typeof rawConfig !== \"object\") {\n        const name = rawConfig;\n        rawConfig = {\n            name\n        };\n    }\n    const config = Object.assign({\n        name: DEFAULT_ENTRY_NAME,\n        automaticDataCollectionEnabled: false\n    }, rawConfig);\n    const name = config.name;\n    if (typeof name !== \"string\" || !name) {\n        throw ERROR_FACTORY.create(\"bad-app-name\" /* AppError.BAD_APP_NAME */ , {\n            appName: String(name)\n        });\n    }\n    options || (options = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)());\n    if (!options) {\n        throw ERROR_FACTORY.create(\"no-options\" /* AppError.NO_OPTIONS */ );\n    }\n    const existingApp = _apps.get(name);\n    if (existingApp) {\n        // return the existing app if options and config deep equal the ones in the existing app.\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(options, existingApp.options) && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(config, existingApp.config)) {\n            return existingApp;\n        } else {\n            throw ERROR_FACTORY.create(\"duplicate-app\" /* AppError.DUPLICATE_APP */ , {\n                appName: name\n            });\n        }\n    }\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(name);\n    for (const component of _components.values()){\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseAppImpl(options, config, container);\n    _apps.set(name, newApp);\n    return newApp;\n}\nfunction initializeServerApp(_options, _serverAppConfig) {\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isBrowser)()) {\n        // FirebaseServerApp isn't designed to be run in browsers.\n        throw ERROR_FACTORY.create(\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */ );\n    }\n    if (_serverAppConfig.automaticDataCollectionEnabled === undefined) {\n        _serverAppConfig.automaticDataCollectionEnabled = false;\n    }\n    let appOptions;\n    if (_isFirebaseApp(_options)) {\n        appOptions = _options.options;\n    } else {\n        appOptions = _options;\n    }\n    // Build an app name based on a hash of the configuration options.\n    const nameObj = Object.assign(Object.assign({}, _serverAppConfig), appOptions);\n    // However, Do not mangle the name based on releaseOnDeref, since it will vary between the\n    // construction of FirebaseServerApp instances. For example, if the object is the request headers.\n    if (nameObj.releaseOnDeref !== undefined) {\n        delete nameObj.releaseOnDeref;\n    }\n    const hashCode = (s)=>{\n        return [\n            ...s\n        ].reduce((hash, c)=>Math.imul(31, hash) + c.charCodeAt(0) | 0, 0);\n    };\n    if (_serverAppConfig.releaseOnDeref !== undefined) {\n        if (typeof FinalizationRegistry === \"undefined\") {\n            throw ERROR_FACTORY.create(\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */ , {});\n        }\n    }\n    const nameString = \"\" + hashCode(JSON.stringify(nameObj));\n    const existingApp = _serverApps.get(nameString);\n    if (existingApp) {\n        existingApp.incRefCount(_serverAppConfig.releaseOnDeref);\n        return existingApp;\n    }\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(nameString);\n    for (const component of _components.values()){\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseServerAppImpl(appOptions, _serverAppConfig, nameString, container);\n    _serverApps.set(nameString, newApp);\n    return newApp;\n}\n/**\r\n * Retrieves a {@link @firebase/app#FirebaseApp} instance.\r\n *\r\n * When called with no arguments, the default app is returned. When an app name\r\n * is provided, the app corresponding to that name is returned.\r\n *\r\n * An exception is thrown if the app being retrieved has not yet been\r\n * initialized.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return the default app\r\n * const app = getApp();\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return a named app\r\n * const otherApp = getApp(\"otherApp\");\r\n * ```\r\n *\r\n * @param name - Optional name of the app to return. If no name is\r\n *   provided, the default is `\"[DEFAULT]\"`.\r\n *\r\n * @returns The app corresponding to the provided app name.\r\n *   If no app name is provided, the default app is returned.\r\n *\r\n * @public\r\n */ function getApp(name = DEFAULT_ENTRY_NAME) {\n    const app = _apps.get(name);\n    if (!app && name === DEFAULT_ENTRY_NAME && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)()) {\n        return initializeApp();\n    }\n    if (!app) {\n        throw ERROR_FACTORY.create(\"no-app\" /* AppError.NO_APP */ , {\n            appName: name\n        });\n    }\n    return app;\n}\n/**\r\n * A (read-only) array of all initialized apps.\r\n * @public\r\n */ function getApps() {\n    return Array.from(_apps.values());\n}\n/**\r\n * Renders this app unusable and frees the resources of all associated\r\n * services.\r\n *\r\n * @example\r\n * ```javascript\r\n * deleteApp(app)\r\n *   .then(function() {\r\n *     console.log(\"App deleted successfully\");\r\n *   })\r\n *   .catch(function(error) {\r\n *     console.log(\"Error deleting app:\", error);\r\n *   });\r\n * ```\r\n *\r\n * @public\r\n */ async function deleteApp(app) {\n    let cleanupProviders = false;\n    const name = app.name;\n    if (_apps.has(name)) {\n        cleanupProviders = true;\n        _apps.delete(name);\n    } else if (_serverApps.has(name)) {\n        const firebaseServerApp = app;\n        if (firebaseServerApp.decRefCount() <= 0) {\n            _serverApps.delete(name);\n            cleanupProviders = true;\n        }\n    }\n    if (cleanupProviders) {\n        await Promise.all(app.container.getProviders().map((provider)=>provider.delete()));\n        app.isDeleted = true;\n    }\n}\n/**\r\n * Registers a library's name and version for platform logging purposes.\r\n * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)\r\n * @param version - Current version of that library.\r\n * @param variant - Bundle variant, e.g., node, rn, etc.\r\n *\r\n * @public\r\n */ function registerVersion(libraryKeyOrName, version, variant) {\n    var _a;\n    // TODO: We can use this check to whitelist strings when/if we set up\n    // a good whitelist system.\n    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\n    if (variant) {\n        library += `-${variant}`;\n    }\n    const libraryMismatch = library.match(/\\s|\\//);\n    const versionMismatch = version.match(/\\s|\\//);\n    if (libraryMismatch || versionMismatch) {\n        const warning = [\n            `Unable to register library \"${library}\" with version \"${version}\":`\n        ];\n        if (libraryMismatch) {\n            warning.push(`library name \"${library}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        if (libraryMismatch && versionMismatch) {\n            warning.push(\"and\");\n        }\n        if (versionMismatch) {\n            warning.push(`version name \"${version}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        logger.warn(warning.join(\" \"));\n        return;\n    }\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(`${library}-version`, ()=>({\n            library,\n            version\n        }), \"VERSION\" /* ComponentType.VERSION */ ));\n}\n/**\r\n * Sets log handler for all Firebase SDKs.\r\n * @param logCallback - An optional custom log handler that executes user code whenever\r\n * the Firebase SDK makes a logging call.\r\n *\r\n * @public\r\n */ function onLog(logCallback, options) {\n    if (logCallback !== null && typeof logCallback !== \"function\") {\n        throw ERROR_FACTORY.create(\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */ );\n    }\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setUserLogHandler)(logCallback, options);\n}\n/**\r\n * Sets log level for all Firebase SDKs.\r\n *\r\n * All of the log types above the current log level are captured (i.e. if\r\n * you set the log level to `info`, errors are logged, but `debug` and\r\n * `verbose` logs are not).\r\n *\r\n * @public\r\n */ function setLogLevel(logLevel) {\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setLogLevel)(logLevel);\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const DB_NAME = \"firebase-heartbeat-database\";\nconst DB_VERSION = 1;\nconst STORE_NAME = \"firebase-heartbeat-store\";\nlet dbPromise = null;\nfunction getDbPromise() {\n    if (!dbPromise) {\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DB_NAME, DB_VERSION, {\n            upgrade: (db, oldVersion)=>{\n                // We don't use 'break' in this switch statement, the fall-through\n                // behavior is what we want, because if there are multiple versions between\n                // the old version and the current version, we want ALL the migrations\n                // that correspond to those versions to run, not only the last one.\n                // eslint-disable-next-line default-case\n                switch(oldVersion){\n                    case 0:\n                        try {\n                            db.createObjectStore(STORE_NAME);\n                        } catch (e) {\n                            // Safari/iOS browsers throw occasional exceptions on\n                            // db.createObjectStore() that may be a bug. Avoid blocking\n                            // the rest of the app functionality.\n                            console.warn(e);\n                        }\n                }\n            }\n        }).catch((e)=>{\n            throw ERROR_FACTORY.create(\"idb-open\" /* AppError.IDB_OPEN */ , {\n                originalErrorMessage: e.message\n            });\n        });\n    }\n    return dbPromise;\n}\nasync function readHeartbeatsFromIndexedDB(app) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME);\n        const result = await tx.objectStore(STORE_NAME).get(computeKey(app));\n        // We already have the value but tx.done can throw,\n        // so we need to await it here to catch errors\n        await tx.done;\n        return result;\n    } catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        } else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-get\" /* AppError.IDB_GET */ , {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nasync function writeHeartbeatsToIndexedDB(app, heartbeatObject) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME, \"readwrite\");\n        const objectStore = tx.objectStore(STORE_NAME);\n        await objectStore.put(heartbeatObject, computeKey(app));\n        await tx.done;\n    } catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        } else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-set\" /* AppError.IDB_WRITE */ , {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nfunction computeKey(app) {\n    return `${app.name}!${app.options.appId}`;\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const MAX_HEADER_BYTES = 1024;\n// 30 days\nconst STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;\nclass HeartbeatServiceImpl {\n    constructor(container){\n        this.container = container;\n        /**\r\n         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate\r\n         * the header string.\r\n         * Stores one record per date. This will be consolidated into the standard\r\n         * format of one record per user agent string before being sent as a header.\r\n         * Populated from indexedDB when the controller is instantiated and should\r\n         * be kept in sync with indexedDB.\r\n         * Leave public for easier testing.\r\n         */ this._heartbeatsCache = null;\n        const app = this.container.getProvider(\"app\").getImmediate();\n        this._storage = new HeartbeatStorageImpl(app);\n        this._heartbeatsCachePromise = this._storage.read().then((result)=>{\n            this._heartbeatsCache = result;\n            return result;\n        });\n    }\n    /**\r\n     * Called to report a heartbeat. The function will generate\r\n     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\r\n     * to IndexedDB.\r\n     * Note that we only store one heartbeat per day. So if a heartbeat for today is\r\n     * already logged, subsequent calls to this function in the same day will be ignored.\r\n     */ async triggerHeartbeat() {\n        var _a, _b;\n        const platformLogger = this.container.getProvider(\"platform-logger\").getImmediate();\n        // This is the \"Firebase user agent\" string from the platform logger\n        // service, not the browser user agent.\n        const agent = platformLogger.getPlatformInfoString();\n        const date = getUTCDateString();\n        if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null) {\n            this._heartbeatsCache = await this._heartbeatsCachePromise;\n            // If we failed to construct a heartbeats cache, then return immediately.\n            if (((_b = this._heartbeatsCache) === null || _b === void 0 ? void 0 : _b.heartbeats) == null) {\n                return;\n            }\n        }\n        // Do not store a heartbeat if one is already stored for this day\n        // or if a header has already been sent today.\n        if (this._heartbeatsCache.lastSentHeartbeatDate === date || this._heartbeatsCache.heartbeats.some((singleDateHeartbeat)=>singleDateHeartbeat.date === date)) {\n            return;\n        } else {\n            // There is no entry for this date. Create one.\n            this._heartbeatsCache.heartbeats.push({\n                date,\n                agent\n            });\n        }\n        // Remove entries older than 30 days.\n        this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((singleDateHeartbeat)=>{\n            const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();\n            const now = Date.now();\n            return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;\n        });\n        return this._storage.overwrite(this._heartbeatsCache);\n    }\n    /**\r\n     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\r\n     * It also clears all heartbeats from memory as well as in IndexedDB.\r\n     *\r\n     * NOTE: Consuming product SDKs should not send the header if this method\r\n     * returns an empty string.\r\n     */ async getHeartbeatsHeader() {\n        var _a;\n        if (this._heartbeatsCache === null) {\n            await this._heartbeatsCachePromise;\n        }\n        // If it's still null or the array is empty, there is no data to send.\n        if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0) {\n            return \"\";\n        }\n        const date = getUTCDateString();\n        // Extract as many heartbeats from the cache as will fit under the size limit.\n        const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);\n        const headerString = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(JSON.stringify({\n            version: 2,\n            heartbeats: heartbeatsToSend\n        }));\n        // Store last sent date to prevent another being logged/sent for the same day.\n        this._heartbeatsCache.lastSentHeartbeatDate = date;\n        if (unsentEntries.length > 0) {\n            // Store any unsent entries if they exist.\n            this._heartbeatsCache.heartbeats = unsentEntries;\n            // This seems more likely than emptying the array (below) to lead to some odd state\n            // since the cache isn't empty and this will be called again on the next request,\n            // and is probably safest if we await it.\n            await this._storage.overwrite(this._heartbeatsCache);\n        } else {\n            this._heartbeatsCache.heartbeats = [];\n            // Do not wait for this, to reduce latency.\n            void this._storage.overwrite(this._heartbeatsCache);\n        }\n        return headerString;\n    }\n}\nfunction getUTCDateString() {\n    const today = new Date();\n    // Returns date format 'YYYY-MM-DD'\n    return today.toISOString().substring(0, 10);\n}\nfunction extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {\n    // Heartbeats grouped by user agent in the standard format to be sent in\n    // the header.\n    const heartbeatsToSend = [];\n    // Single date format heartbeats that are not sent.\n    let unsentEntries = heartbeatsCache.slice();\n    for (const singleDateHeartbeat of heartbeatsCache){\n        // Look for an existing entry with the same user agent.\n        const heartbeatEntry = heartbeatsToSend.find((hb)=>hb.agent === singleDateHeartbeat.agent);\n        if (!heartbeatEntry) {\n            // If no entry for this user agent exists, create one.\n            heartbeatsToSend.push({\n                agent: singleDateHeartbeat.agent,\n                dates: [\n                    singleDateHeartbeat.date\n                ]\n            });\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                // If the header would exceed max size, remove the added heartbeat\n                // entry and stop adding to the header.\n                heartbeatsToSend.pop();\n                break;\n            }\n        } else {\n            heartbeatEntry.dates.push(singleDateHeartbeat.date);\n            // If the header would exceed max size, remove the added date\n            // and stop adding to the header.\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                heartbeatEntry.dates.pop();\n                break;\n            }\n        }\n        // Pop unsent entry from queue. (Skipped if adding the entry exceeded\n        // quota and the loop breaks early.)\n        unsentEntries = unsentEntries.slice(1);\n    }\n    return {\n        heartbeatsToSend,\n        unsentEntries\n    };\n}\nclass HeartbeatStorageImpl {\n    constructor(app){\n        this.app = app;\n        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\n    }\n    async runIndexedDBEnvironmentCheck() {\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {\n            return false;\n        } else {\n            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)().then(()=>true).catch(()=>false);\n        }\n    }\n    /**\r\n     * Read all heartbeats.\r\n     */ async read() {\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return {\n                heartbeats: []\n            };\n        } else {\n            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);\n            if (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) {\n                return idbHeartbeatObject;\n            } else {\n                return {\n                    heartbeats: []\n                };\n            }\n        }\n    }\n    // overwrite the storage with the provided heartbeats\n    async overwrite(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        } else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: heartbeatsObject.heartbeats\n            });\n        }\n    }\n    // add heartbeats\n    async add(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        } else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: [\n                    ...existingHeartbeatsObject.heartbeats,\n                    ...heartbeatsObject.heartbeats\n                ]\n            });\n        }\n    }\n}\n/**\r\n * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped\r\n * in a platform logging header JSON object, stringified, and converted\r\n * to base 64.\r\n */ function countBytes(heartbeatsCache) {\n    // base64 has a restricted set of characters, all of which should be 1 byte.\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(// heartbeatsCache wrapper properties\n    JSON.stringify({\n        version: 2,\n        heartbeats: heartbeatsCache\n    })).length;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function registerCoreComponents(variant) {\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(\"platform-logger\", (container)=>new PlatformLoggerServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(\"heartbeat\", (container)=>new HeartbeatServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n    // Register `app` package.\n    registerVersion(name$p, version$1, variant);\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n    registerVersion(name$p, version$1, \"esm2017\");\n    // Register platform SDK identifier (no version).\n    registerVersion(\"fire-js\", \"\");\n}\n/**\r\n * Firebase App\r\n *\r\n * @remarks This package coordinates the communication between the different Firebase components\r\n * @packageDocumentation\r\n */ registerCoreComponents(\"\");\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9FO0FBQ3VCO0FBQzZGO0FBQ3pJO0FBQ2xCO0FBRTdCOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELE1BQU1lO0lBQ0ZDLFlBQVlDLFNBQVMsQ0FBRTtRQUNuQixJQUFJLENBQUNBLFNBQVMsR0FBR0E7SUFDckI7SUFDQSxxRUFBcUU7SUFDckUsK0RBQStEO0lBQy9EQyx3QkFBd0I7UUFDcEIsTUFBTUMsWUFBWSxJQUFJLENBQUNGLFNBQVMsQ0FBQ0csWUFBWTtRQUM3Qyx5RUFBeUU7UUFDekUsc0JBQXNCO1FBQ3RCLE9BQU9ELFVBQ0ZFLEdBQUcsQ0FBQ0MsQ0FBQUE7WUFDTCxJQUFJQyx5QkFBeUJELFdBQVc7Z0JBQ3BDLE1BQU1FLFVBQVVGLFNBQVNHLFlBQVk7Z0JBQ3JDLE9BQU8sQ0FBQyxFQUFFRCxRQUFRRSxPQUFPLENBQUMsQ0FBQyxFQUFFRixRQUFRRyxPQUFPLENBQUMsQ0FBQztZQUNsRCxPQUNLO2dCQUNELE9BQU87WUFDWDtRQUNKLEdBQ0tDLE1BQU0sQ0FBQ0MsQ0FBQUEsWUFBYUEsV0FDcEJDLElBQUksQ0FBQztJQUNkO0FBQ0o7QUFDQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU1AseUJBQXlCRCxRQUFRO0lBQ3RDLE1BQU1TLFlBQVlULFNBQVNVLFlBQVk7SUFDdkMsT0FBTyxDQUFDRCxjQUFjLFFBQVFBLGNBQWMsS0FBSyxJQUFJLEtBQUssSUFBSUEsVUFBVUUsSUFBSSxNQUFNLFVBQVUseUJBQXlCO0FBQ3pIO0FBRUEsTUFBTUMsU0FBUztBQUNmLE1BQU1DLFlBQVk7QUFFbEI7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTUMsU0FBUyxJQUFJbEMsb0RBQU1BLENBQUM7QUFFMUIsTUFBTW1DLFNBQVM7QUFFZixNQUFNQyxTQUFTO0FBRWYsTUFBTUMsU0FB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RnRDLGdCQUFnQjVGLFFBQVFDLFdBQVc7SUFDbkMsaURBQWlEO0lBQ2pEMkYsZ0JBQWdCLFdBQVc7QUFDL0I7QUFFQTs7Ozs7Q0FLQyxHQUNEMEgsdUJBQXVCO0FBRTRVLENBQ25XLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZyZWUtbmV4dGpzLWFkbWluLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanM/NzJjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIENvbXBvbmVudENvbnRhaW5lciB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgTG9nZ2VyLCBzZXRVc2VyTG9nSGFuZGxlciwgc2V0TG9nTGV2ZWwgYXMgc2V0TG9nTGV2ZWwkMSB9IGZyb20gJ0BmaXJlYmFzZS9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JGYWN0b3J5LCBnZXREZWZhdWx0QXBwQ29uZmlnLCBkZWVwRXF1YWwsIGlzQnJvd3NlciwgRmlyZWJhc2VFcnJvciwgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcsIGlzSW5kZXhlZERCQXZhaWxhYmxlLCB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuZXhwb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IG9wZW5EQiB9IGZyb20gJ2lkYic7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFBsYXRmb3JtTG9nZ2VyU2VydmljZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICB9XHJcbiAgICAvLyBJbiBpbml0aWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdpbGwgYmUgY2FsbGVkIGJ5IGluc3RhbGxhdGlvbnMgb25cclxuICAgIC8vIGF1dGggdG9rZW4gcmVmcmVzaCwgYW5kIGluc3RhbGxhdGlvbnMgd2lsbCBzZW5kIHRoaXMgc3RyaW5nLlxyXG4gICAgZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVycygpO1xyXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBwcm92aWRlcnMgYW5kIGdldCBsaWJyYXJ5L3ZlcnNpb24gcGFpcnMgZnJvbSBhbnkgdGhhdCBhcmVcclxuICAgICAgICAvLyB2ZXJzaW9uIGNvbXBvbmVudHMuXHJcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyc1xyXG4gICAgICAgICAgICAubWFwKHByb3ZpZGVyID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzVmVyc2lvblNlcnZpY2VQcm92aWRlcihwcm92aWRlcikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzZXJ2aWNlLmxpYnJhcnl9LyR7c2VydmljZS52ZXJzaW9ufWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5maWx0ZXIobG9nU3RyaW5nID0+IGxvZ1N0cmluZylcclxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHByb3ZpZGVyIGNoZWNrIGlmIHRoaXMgcHJvdmlkZXIgcHJvdmlkZXMgYSBWZXJzaW9uU2VydmljZVxyXG4gKlxyXG4gKiBOT1RFOiBVc2luZyBQcm92aWRlcjwnYXBwLXZlcnNpb24nPiBpcyBhIGhhY2sgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcHJvdmlkZXJcclxuICogcHJvdmlkZXMgVmVyc2lvblNlcnZpY2UuIFRoZSBwcm92aWRlciBpcyBub3QgbmVjZXNzYXJpbHkgYSAnYXBwLXZlcnNpb24nXHJcbiAqIHByb3ZpZGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNWZXJzaW9uU2VydmljZVByb3ZpZGVyKHByb3ZpZGVyKSB7XHJcbiAgICBjb25zdCBjb21wb25lbnQgPSBwcm92aWRlci5nZXRDb21wb25lbnQoKTtcclxuICAgIHJldHVybiAoY29tcG9uZW50ID09PSBudWxsIHx8IGNvbXBvbmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50LnR5cGUpID09PSBcIlZFUlNJT05cIiAvKiBDb21wb25lbnRUeXBlLlZFUlNJT04gKi87XHJcbn1cblxuY29uc3QgbmFtZSRwID0gXCJAZmlyZWJhc2UvYXBwXCI7XG5jb25zdCB2ZXJzaW9uJDEgPSBcIjAuMTAuM1wiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvYXBwJyk7XG5cbmNvbnN0IG5hbWUkbyA9IFwiQGZpcmViYXNlL2FwcC1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRuID0gXCJAZmlyZWJhc2UvYW5hbHl0aWNzLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJG0gPSBcIkBmaXJlYmFzZS9hbmFseXRpY3NcIjtcblxuY29uc3QgbmFtZSRsID0gXCJAZmlyZWJhc2UvYXBwLWNoZWNrLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGsgPSBcIkBmaXJlYmFzZS9hcHAtY2hlY2tcIjtcblxuY29uc3QgbmFtZSRqID0gXCJAZmlyZWJhc2UvYXV0aFwiO1xuXG5jb25zdCBuYW1lJGkgPSBcIkBmaXJlYmFzZS9hdXRoLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGggPSBcIkBmaXJlYmFzZS9kYXRhYmFzZVwiO1xuXG5jb25zdCBuYW1lJGcgPSBcIkBmaXJlYmFzZS9kYXRhYmFzZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRmID0gXCJAZmlyZWJhc2UvZnVuY3Rpb25zXCI7XG5cbmNvbnN0IG5hbWUkZSA9IFwiQGZpcmViYXNlL2Z1bmN0aW9ucy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRkID0gXCJAZmlyZWJhc2UvaW5zdGFsbGF0aW9uc1wiO1xuXG5jb25zdCBuYW1lJGMgPSBcIkBmaXJlYmFzZS9pbnN0YWxsYXRpb25zLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGIgPSBcIkBmaXJlYmFzZS9tZXNzYWdpbmdcIjtcblxuY29uc3QgbmFtZSRhID0gXCJAZmlyZWJhc2UvbWVzc2FnaW5nLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDkgPSBcIkBmaXJlYmFzZS9wZXJmb3JtYW5jZVwiO1xuXG5jb25zdCBuYW1lJDggPSBcIkBmaXJlYmFzZS9wZXJmb3JtYW5jZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQ3ID0gXCJAZmlyZWJhc2UvcmVtb3RlLWNvbmZpZ1wiO1xuXG5jb25zdCBuYW1lJDYgPSBcIkBmaXJlYmFzZS9yZW1vdGUtY29uZmlnLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDUgPSBcIkBmaXJlYmFzZS9zdG9yYWdlXCI7XG5cbmNvbnN0IG5hbWUkNCA9IFwiQGZpcmViYXNlL3N0b3JhZ2UtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkMyA9IFwiQGZpcmViYXNlL2ZpcmVzdG9yZVwiO1xuXG5jb25zdCBuYW1lJDIgPSBcIkBmaXJlYmFzZS92ZXJ0ZXhhaS1wcmV2aWV3XCI7XG5cbmNvbnN0IG5hbWUkMSA9IFwiQGZpcmViYXNlL2ZpcmVzdG9yZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSA9IFwiZmlyZWJhc2VcIjtcbmNvbnN0IHZlcnNpb24gPSBcIjEwLjEyLjBcIjtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGFwcCBuYW1lXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9FTlRSWV9OQU1FID0gJ1tERUZBVUxUXSc7XHJcbmNvbnN0IFBMQVRGT1JNX0xPR19TVFJJTkcgPSB7XHJcbiAgICBbbmFtZSRwXTogJ2ZpcmUtY29yZScsXHJcbiAgICBbbmFtZSRvXTogJ2ZpcmUtY29yZS1jb21wYXQnLFxyXG4gICAgW25hbWUkbV06ICdmaXJlLWFuYWx5dGljcycsXHJcbiAgICBbbmFtZSRuXTogJ2ZpcmUtYW5hbHl0aWNzLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRrXTogJ2ZpcmUtYXBwLWNoZWNrJyxcclxuICAgIFtuYW1lJGxdOiAnZmlyZS1hcHAtY2hlY2stY29tcGF0JyxcclxuICAgIFtuYW1lJGpdOiAnZmlyZS1hdXRoJyxcclxuICAgIFtuYW1lJGldOiAnZmlyZS1hdXRoLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRoXTogJ2ZpcmUtcnRkYicsXHJcbiAgICBbbmFtZSRnXTogJ2ZpcmUtcnRkYi1jb21wYXQnLFxyXG4gICAgW25hbWUkZl06ICdmaXJlLWZuJyxcclxuICAgIFtuYW1lJGVdOiAnZmlyZS1mbi1jb21wYXQnLFxyXG4gICAgW25hbWUkZF06ICdmaXJlLWlpZCcsXHJcbiAgICBbbmFtZSRjXTogJ2ZpcmUtaWlkLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRiXTogJ2ZpcmUtZmNtJyxcclxuICAgIFtuYW1lJGFdOiAnZmlyZS1mY20tY29tcGF0JyxcclxuICAgIFtuYW1lJDldOiAnZmlyZS1wZXJmJyxcclxuICAgIFtuYW1lJDhdOiAnZmlyZS1wZXJmLWNvbXBhdCcsXHJcbiAgICBbbmFtZSQ3XTogJ2ZpcmUtcmMnLFxyXG4gICAgW25hbWUkNl06ICdmaXJlLXJjLWNvbXBhdCcsXHJcbiAgICBbbmFtZSQ1XTogJ2ZpcmUtZ2NzJyxcclxuICAgIFtuYW1lJDRdOiAnZmlyZS1nY3MtY29tcGF0JyxcclxuICAgIFtuYW1lJDNdOiAnZmlyZS1mc3QnLFxyXG4gICAgW25hbWUkMV06ICdmaXJlLWZzdC1jb21wYXQnLFxyXG4gICAgW25hbWUkMl06ICdmaXJlLXZlcnRleCcsXHJcbiAgICAnZmlyZS1qcyc6ICdmaXJlLWpzJyxcclxuICAgIFtuYW1lXTogJ2ZpcmUtanMtYWxsJ1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBfYXBwcyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3QgX3NlcnZlckFwcHMgPSBuZXcgTWFwKCk7XHJcbi8qKlxyXG4gKiBSZWdpc3RlcmVkIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuY29uc3QgX2NvbXBvbmVudHMgPSBuZXcgTWFwKCk7XHJcbi8qKlxyXG4gKiBAcGFyYW0gY29tcG9uZW50IC0gdGhlIGNvbXBvbmVudCBiZWluZyBhZGRlZCB0byB0aGlzIGFwcCdzIGNvbnRhaW5lclxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9hZGRDb21wb25lbnQoYXBwLCBjb21wb25lbnQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXBwLmNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gZmFpbGVkIHRvIHJlZ2lzdGVyIHdpdGggRmlyZWJhc2VBcHAgJHthcHAubmFtZX1gLCBlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoYXBwLCBjb21wb25lbnQpIHtcclxuICAgIGFwcC5jb250YWluZXIuYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoY29tcG9uZW50KTtcclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIGNvbXBvbmVudCAtIHRoZSBjb21wb25lbnQgdG8gcmVnaXN0ZXJcclxuICogQHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGNvbXBvbmVudCBpcyByZWdpc3RlcmVkIHN1Y2Nlc3NmdWxseVxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQubmFtZTtcclxuICAgIGlmIChfY29tcG9uZW50cy5oYXMoY29tcG9uZW50TmFtZSkpIHtcclxuICAgICAgICBsb2dnZXIuZGVidWcoYFRoZXJlIHdlcmUgbXVsdGlwbGUgYXR0ZW1wdHMgdG8gcmVnaXN0ZXIgY29tcG9uZW50ICR7Y29tcG9uZW50TmFtZX0uYCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgX2NvbXBvbmVudHMuc2V0KGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudCk7XHJcbiAgICAvLyBhZGQgdGhlIGNvbXBvbmVudCB0byBleGlzdGluZyBhcHAgaW5zdGFuY2VzXHJcbiAgICBmb3IgKGNvbnN0IGFwcCBvZiBfYXBwcy52YWx1ZXMoKSkge1xyXG4gICAgICAgIF9hZGRDb21wb25lbnQoYXBwLCBjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBzZXJ2ZXJBcHAgb2YgX3NlcnZlckFwcHMudmFsdWVzKCkpIHtcclxuICAgICAgICBfYWRkQ29tcG9uZW50KHNlcnZlckFwcCwgY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gYXBwIC0gRmlyZWJhc2VBcHAgaW5zdGFuY2VcclxuICogQHBhcmFtIG5hbWUgLSBzZXJ2aWNlIG5hbWVcclxuICpcclxuICogQHJldHVybnMgdGhlIHByb3ZpZGVyIGZvciB0aGUgc2VydmljZSB3aXRoIHRoZSBtYXRjaGluZyBuYW1lXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2dldFByb3ZpZGVyKGFwcCwgbmFtZSkge1xyXG4gICAgY29uc3QgaGVhcnRiZWF0Q29udHJvbGxlciA9IGFwcC5jb250YWluZXJcclxuICAgICAgICAuZ2V0UHJvdmlkZXIoJ2hlYXJ0YmVhdCcpXHJcbiAgICAgICAgLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pO1xyXG4gICAgaWYgKGhlYXJ0YmVhdENvbnRyb2xsZXIpIHtcclxuICAgICAgICB2b2lkIGhlYXJ0YmVhdENvbnRyb2xsZXIudHJpZ2dlckhlYXJ0YmVhdCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFwcC5jb250YWluZXIuZ2V0UHJvdmlkZXIobmFtZSk7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBGaXJlYmFzZUFwcCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0gbmFtZSAtIHNlcnZpY2UgbmFtZVxyXG4gKiBAcGFyYW0gaW5zdGFuY2VJZGVudGlmaWVyIC0gc2VydmljZSBpbnN0YW5jZSBpZGVudGlmaWVyIGluIGNhc2UgdGhlIHNlcnZpY2Ugc3VwcG9ydHMgbXVsdGlwbGUgaW5zdGFuY2VzXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX3JlbW92ZVNlcnZpY2VJbnN0YW5jZShhcHAsIG5hbWUsIGluc3RhbmNlSWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgX2dldFByb3ZpZGVyKGFwcCwgbmFtZSkuY2xlYXJJbnN0YW5jZShpbnN0YW5jZUlkZW50aWZpZXIpO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gb2JqIC0gYW4gb2JqZWN0IG9mIHR5cGUgRmlyZWJhc2VBcHAgb3IgRmlyZWJhc2VPcHRpb25zLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlIG9iamVjdCBpcyBvZiB0eXBlIEZpcmViYXNlQXBwLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9pc0ZpcmViYXNlQXBwKG9iaikge1xyXG4gICAgcmV0dXJuIG9iai5vcHRpb25zICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBvYmogLSBhbiBvYmplY3Qgb2YgdHlwZSBGaXJlYmFzZUFwcC5cclxuICpcclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgb2JqZWN0IGlzIG9mIHR5cGUgRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9pc0ZpcmViYXNlU2VydmVyQXBwKG9iaikge1xyXG4gICAgcmV0dXJuIG9iai5zZXR0aW5ncyAhPT0gdW5kZWZpbmVkO1xyXG59XHJcbi8qKlxyXG4gKiBUZXN0IG9ubHlcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfY2xlYXJDb21wb25lbnRzKCkge1xyXG4gICAgX2NvbXBvbmVudHMuY2xlYXIoKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBFUlJPUlMgPSB7XHJcbiAgICBbXCJuby1hcHBcIiAvKiBBcHBFcnJvci5OT19BUFAgKi9dOiBcIk5vIEZpcmViYXNlIEFwcCAneyRhcHBOYW1lfScgaGFzIGJlZW4gY3JlYXRlZCAtIFwiICtcclxuICAgICAgICAnY2FsbCBpbml0aWFsaXplQXBwKCkgZmlyc3QnLFxyXG4gICAgW1wiYmFkLWFwcC1uYW1lXCIgLyogQXBwRXJyb3IuQkFEX0FQUF9OQU1FICovXTogXCJJbGxlZ2FsIEFwcCBuYW1lOiAneyRhcHBOYW1lfSdcIixcclxuICAgIFtcImR1cGxpY2F0ZS1hcHBcIiAvKiBBcHBFcnJvci5EVVBMSUNBVEVfQVBQICovXTogXCJGaXJlYmFzZSBBcHAgbmFtZWQgJ3skYXBwTmFtZX0nIGFscmVhZHkgZXhpc3RzIHdpdGggZGlmZmVyZW50IG9wdGlvbnMgb3IgY29uZmlnXCIsXHJcbiAgICBbXCJhcHAtZGVsZXRlZFwiIC8qIEFwcEVycm9yLkFQUF9ERUxFVEVEICovXTogXCJGaXJlYmFzZSBBcHAgbmFtZWQgJ3skYXBwTmFtZX0nIGFscmVhZHkgZGVsZXRlZFwiLFxyXG4gICAgW1wic2VydmVyLWFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuU0VSVkVSX0FQUF9ERUxFVEVEICovXTogJ0ZpcmViYXNlIFNlcnZlciBBcHAgaGFzIGJlZW4gZGVsZXRlZCcsXHJcbiAgICBbXCJuby1vcHRpb25zXCIgLyogQXBwRXJyb3IuTk9fT1BUSU9OUyAqL106ICdOZWVkIHRvIHByb3ZpZGUgb3B0aW9ucywgd2hlbiBub3QgYmVpbmcgZGVwbG95ZWQgdG8gaG9zdGluZyB2aWEgc291cmNlLicsXHJcbiAgICBbXCJpbnZhbGlkLWFwcC1hcmd1bWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfQVBQX0FSR1VNRU5UICovXTogJ2ZpcmViYXNlLnskYXBwTmFtZX0oKSB0YWtlcyBlaXRoZXIgbm8gYXJndW1lbnQgb3IgYSAnICtcclxuICAgICAgICAnRmlyZWJhc2UgQXBwIGluc3RhbmNlLicsXHJcbiAgICBbXCJpbnZhbGlkLWxvZy1hcmd1bWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfTE9HX0FSR1VNRU5UICovXTogJ0ZpcnN0IGFyZ3VtZW50IHRvIGBvbkxvZ2AgbXVzdCBiZSBudWxsIG9yIGEgZnVuY3Rpb24uJyxcclxuICAgIFtcImlkYi1vcGVuXCIgLyogQXBwRXJyb3IuSURCX09QRU4gKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gb3BlbmluZyBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxyXG4gICAgW1wiaWRiLWdldFwiIC8qIEFwcEVycm9yLklEQl9HRVQgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gcmVhZGluZyBmcm9tIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXHJcbiAgICBbXCJpZGItc2V0XCIgLyogQXBwRXJyb3IuSURCX1dSSVRFICovXTogJ0Vycm9yIHRocm93biB3aGVuIHdyaXRpbmcgdG8gSW5kZXhlZERCLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJyxcclxuICAgIFtcImlkYi1kZWxldGVcIiAvKiBBcHBFcnJvci5JREJfREVMRVRFICovXTogJ0Vycm9yIHRocm93biB3aGVuIGRlbGV0aW5nIGZyb20gSW5kZXhlZERCLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJyxcclxuICAgIFtcImZpbmFsaXphdGlvbi1yZWdpc3RyeS1ub3Qtc3VwcG9ydGVkXCIgLyogQXBwRXJyb3IuRklOQUxJWkFUSU9OX1JFR0lTVFJZX05PVF9TVVBQT1JURUQgKi9dOiAnRmlyZWJhc2VTZXJ2ZXJBcHAgZGVsZXRlT25EZXJlZiBmaWVsZCBkZWZpbmVkIGJ1dCB0aGUgSlMgcnVudGltZSBkb2VzIG5vdCBzdXBwb3J0IEZpbmFsaXphdGlvblJlZ2lzdHJ5LicsXHJcbiAgICBbXCJpbnZhbGlkLXNlcnZlci1hcHAtZW52aXJvbm1lbnRcIiAvKiBBcHBFcnJvci5JTlZBTElEX1NFUlZFUl9BUFBfRU5WSVJPTk1FTlQgKi9dOiAnRmlyZWJhc2VTZXJ2ZXJBcHAgaXMgbm90IGZvciB1c2UgaW4gYnJvd3NlciBlbnZpcm9ubWVudHMuJ1xyXG59O1xyXG5jb25zdCBFUlJPUl9GQUNUT1JZID0gbmV3IEVycm9yRmFjdG9yeSgnYXBwJywgJ0ZpcmViYXNlJywgRVJST1JTKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgRmlyZWJhc2VBcHBJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5faXNEZWxldGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IGNvbmZpZy5uYW1lO1xyXG4gICAgICAgIHRoaXMuX2F1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9XHJcbiAgICAgICAgICAgIGNvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENvbXBvbmVudChuZXcgQ29tcG9uZW50KCdhcHAnLCAoKSA9PiB0aGlzLCBcIlBVQkxJQ1wiIC8qIENvbXBvbmVudFR5cGUuUFVCTElDICovKSk7XHJcbiAgICB9XHJcbiAgICBnZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkO1xyXG4gICAgfVxyXG4gICAgc2V0IGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCh2YWwpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID0gdmFsO1xyXG4gICAgfVxyXG4gICAgZ2V0IG5hbWUoKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xyXG4gICAgfVxyXG4gICAgZ2V0IG9wdGlvbnMoKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbmZpZygpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcclxuICAgIH1cclxuICAgIGdldCBjb250YWluZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICAgIH1cclxuICAgIGdldCBpc0RlbGV0ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGVsZXRlZDtcclxuICAgIH1cclxuICAgIHNldCBpc0RlbGV0ZWQodmFsKSB7XHJcbiAgICAgICAgdGhpcy5faXNEZWxldGVkID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IgaWYgdGhlIEFwcCBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQgLVxyXG4gICAgICogdXNlIGJlZm9yZSBwZXJmb3JtaW5nIEFQSSBhY3Rpb25zIG9uIHRoZSBBcHAuXHJcbiAgICAgKi9cclxuICAgIGNoZWNrRGVzdHJveWVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuQVBQX0RFTEVURUQgKi8sIHsgYXBwTmFtZTogdGhpcy5fbmFtZSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsIGV4dGVuZHMgRmlyZWJhc2VBcHBJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHNlcnZlckNvbmZpZywgbmFtZSwgY29udGFpbmVyKSB7XHJcbiAgICAgICAgLy8gQnVpbGQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIGZvciB0aGUgRmlyZWJhc2VBcHBJbXBsIGJhc2UgY2xhc3MuXHJcbiAgICAgICAgY29uc3QgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID0gc2VydmVyQ29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgID8gc2VydmVyQ29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZFxyXG4gICAgICAgICAgICA6IGZhbHNlO1xyXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgRmlyZWJhc2VBcHBTZXR0aW5ncyBvYmplY3QgZm9yIHRoZSBGaXJlYmFzZUFwcEltcCBjb25zdHJ1Y3Rvci5cclxuICAgICAgICBjb25zdCBjb25maWcgPSB7XHJcbiAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgIGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBwYXJlbnQgRmlyZWJhc2VBcHBJbXAgb2JqZWN0LlxyXG4gICAgICAgICAgICBzdXBlcihvcHRpb25zLCBjb25maWcsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBhcHBJbXBsID0gb3B0aW9ucztcclxuICAgICAgICAgICAgc3VwZXIoYXBwSW1wbC5vcHRpb25zLCBjb25maWcsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vdyBjb25zdHJ1Y3QgdGhlIGRhdGEgZm9yIHRoZSBGaXJlYmFzZVNlcnZlckFwcEltcGwuXHJcbiAgICAgICAgdGhpcy5fc2VydmVyQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7IGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCB9LCBzZXJ2ZXJDb25maWcpO1xyXG4gICAgICAgIHRoaXMuX2ZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5hdXRvbWF0aWNDbGVhbnVwKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fcmVmQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuaW5jUmVmQ291bnQodGhpcy5fc2VydmVyQ29uZmlnLnJlbGVhc2VPbkRlcmVmKTtcclxuICAgICAgICAvLyBEbyBub3QgcmV0YWluIGEgaGFyZCByZWZlcmVuY2UgdG8gdGhlIGRyZWYgb2JqZWN0LCBvdGhlcndpc2UgdGhlIEZpbmFsaXphdGlvblJlZ2lzcnlcclxuICAgICAgICAvLyB3aWxsIG5ldmVyIHRyaWdnZXIuXHJcbiAgICAgICAgdGhpcy5fc2VydmVyQ29uZmlnLnJlbGVhc2VPbkRlcmVmID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHNlcnZlckNvbmZpZy5yZWxlYXNlT25EZXJlZiA9IHVuZGVmaW5lZDtcclxuICAgICAgICByZWdpc3RlclZlcnNpb24obmFtZSRwLCB2ZXJzaW9uJDEsICdzZXJ2ZXJhcHAnKTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgZ2V0IHJlZkNvdW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZDb3VudDtcclxuICAgIH1cclxuICAgIC8vIEluY3JlbWVudCB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoaXMgc2VydmVyIGFwcC4gSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkLCByZWdpc3RlciBpdFxyXG4gICAgLy8gd2l0aCB0aGUgZmluYWxpemF0aW9uIHJlZ2lzdHJ5LlxyXG4gICAgaW5jUmVmQ291bnQob2JqKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVmQ291bnQrKztcclxuICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmluYWxpemF0aW9uUmVnaXN0cnkucmVnaXN0ZXIob2JqLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBEZWNyZW1lbnQgdGhlIHJlZmVyZW5jZSBjb3VudC5cclxuICAgIGRlY1JlZkNvdW50KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0tdGhpcy5fcmVmQ291bnQ7XHJcbiAgICB9XHJcbiAgICAvLyBJbnZva2VkIGJ5IHRoZSBGaW5hbGl6YXRpb25SZWdpc3RyeSBjYWxsYmFjayB0byBub3RlIHRoYXQgdGhpcyBhcHAgc2hvdWxkIGdvIHRocm91Z2ggaXRzXHJcbiAgICAvLyByZWZlcmVuY2UgY291bnRzIGFuZCBkZWxldGUgaXRzZWxmIGlmIG5vIHJlZmVyZW5jZSBjb3VudCByZW1haW4uIFRoZSBjb29yZGluYXRpbmcgbG9naWMgdGhhdFxyXG4gICAgLy8gaGFuZGxlcyB0aGlzIGlzIGluIGRlbGV0ZUFwcCguLi4pLlxyXG4gICAgYXV0b21hdGljQ2xlYW51cCgpIHtcclxuICAgICAgICB2b2lkIGRlbGV0ZUFwcCh0aGlzKTtcclxuICAgIH1cclxuICAgIGdldCBzZXR0aW5ncygpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZlckNvbmZpZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIEVycm9yIGlmIHRoZSBBcHAgaGFzIGFscmVhZHkgYmVlbiBkZWxldGVkIC1cclxuICAgICAqIHVzZSBiZWZvcmUgcGVyZm9ybWluZyBBUEkgYWN0aW9ucyBvbiB0aGUgQXBwLlxyXG4gICAgICovXHJcbiAgICBjaGVja0Rlc3Ryb3llZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0RlbGV0ZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJzZXJ2ZXItYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5TRVJWRVJfQVBQX0RFTEVURUQgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGN1cnJlbnQgU0RLIHZlcnNpb24uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IFNES19WRVJTSU9OID0gdmVyc2lvbjtcclxuZnVuY3Rpb24gaW5pdGlhbGl6ZUFwcChfb3B0aW9ucywgcmF3Q29uZmlnID0ge30pIHtcclxuICAgIGxldCBvcHRpb25zID0gX29wdGlvbnM7XHJcbiAgICBpZiAodHlwZW9mIHJhd0NvbmZpZyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gcmF3Q29uZmlnO1xyXG4gICAgICAgIHJhd0NvbmZpZyA9IHsgbmFtZSB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7IG5hbWU6IERFRkFVTFRfRU5UUllfTkFNRSwgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkOiBmYWxzZSB9LCByYXdDb25maWcpO1xyXG4gICAgY29uc3QgbmFtZSA9IGNvbmZpZy5uYW1lO1xyXG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCAhbmFtZSkge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYmFkLWFwcC1uYW1lXCIgLyogQXBwRXJyb3IuQkFEX0FQUF9OQU1FICovLCB7XHJcbiAgICAgICAgICAgIGFwcE5hbWU6IFN0cmluZyhuYW1lKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IGdldERlZmF1bHRBcHBDb25maWcoKSk7XHJcbiAgICBpZiAoIW9wdGlvbnMpIHtcclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm5vLW9wdGlvbnNcIiAvKiBBcHBFcnJvci5OT19PUFRJT05TICovKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGV4aXN0aW5nQXBwID0gX2FwcHMuZ2V0KG5hbWUpO1xyXG4gICAgaWYgKGV4aXN0aW5nQXBwKSB7XHJcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBleGlzdGluZyBhcHAgaWYgb3B0aW9ucyBhbmQgY29uZmlnIGRlZXAgZXF1YWwgdGhlIG9uZXMgaW4gdGhlIGV4aXN0aW5nIGFwcC5cclxuICAgICAgICBpZiAoZGVlcEVxdWFsKG9wdGlvbnMsIGV4aXN0aW5nQXBwLm9wdGlvbnMpICYmXHJcbiAgICAgICAgICAgIGRlZXBFcXVhbChjb25maWcsIGV4aXN0aW5nQXBwLmNvbmZpZykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nQXBwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJkdXBsaWNhdGUtYXBwXCIgLyogQXBwRXJyb3IuRFVQTElDQVRFX0FQUCAqLywgeyBhcHBOYW1lOiBuYW1lIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb21wb25lbnRDb250YWluZXIobmFtZSk7XHJcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBfY29tcG9uZW50cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIGNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5ld0FwcCA9IG5ldyBGaXJlYmFzZUFwcEltcGwob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpO1xyXG4gICAgX2FwcHMuc2V0KG5hbWUsIG5ld0FwcCk7XHJcbiAgICByZXR1cm4gbmV3QXBwO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRpYWxpemVTZXJ2ZXJBcHAoX29wdGlvbnMsIF9zZXJ2ZXJBcHBDb25maWcpIHtcclxuICAgIGlmIChpc0Jyb3dzZXIoKSkge1xyXG4gICAgICAgIC8vIEZpcmViYXNlU2VydmVyQXBwIGlzbid0IGRlc2lnbmVkIHRvIGJlIHJ1biBpbiBicm93c2Vycy5cclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImludmFsaWQtc2VydmVyLWFwcC1lbnZpcm9ubWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfU0VSVkVSX0FQUF9FTlZJUk9OTUVOVCAqLyk7XHJcbiAgICB9XHJcbiAgICBpZiAoX3NlcnZlckFwcENvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIF9zZXJ2ZXJBcHBDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBsZXQgYXBwT3B0aW9ucztcclxuICAgIGlmIChfaXNGaXJlYmFzZUFwcChfb3B0aW9ucykpIHtcclxuICAgICAgICBhcHBPcHRpb25zID0gX29wdGlvbnMub3B0aW9ucztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFwcE9wdGlvbnMgPSBfb3B0aW9ucztcclxuICAgIH1cclxuICAgIC8vIEJ1aWxkIGFuIGFwcCBuYW1lIGJhc2VkIG9uIGEgaGFzaCBvZiB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG4gICAgY29uc3QgbmFtZU9iaiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX3NlcnZlckFwcENvbmZpZyksIGFwcE9wdGlvbnMpO1xyXG4gICAgLy8gSG93ZXZlciwgRG8gbm90IG1hbmdsZSB0aGUgbmFtZSBiYXNlZCBvbiByZWxlYXNlT25EZXJlZiwgc2luY2UgaXQgd2lsbCB2YXJ5IGJldHdlZW4gdGhlXHJcbiAgICAvLyBjb25zdHJ1Y3Rpb24gb2YgRmlyZWJhc2VTZXJ2ZXJBcHAgaW5zdGFuY2VzLiBGb3IgZXhhbXBsZSwgaWYgdGhlIG9iamVjdCBpcyB0aGUgcmVxdWVzdCBoZWFkZXJzLlxyXG4gICAgaWYgKG5hbWVPYmoucmVsZWFzZU9uRGVyZWYgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGRlbGV0ZSBuYW1lT2JqLnJlbGVhc2VPbkRlcmVmO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaGFzaENvZGUgPSAocykgPT4ge1xyXG4gICAgICAgIHJldHVybiBbLi4uc10ucmVkdWNlKChoYXNoLCBjKSA9PiAoTWF0aC5pbXVsKDMxLCBoYXNoKSArIGMuY2hhckNvZGVBdCgwKSkgfCAwLCAwKTtcclxuICAgIH07XHJcbiAgICBpZiAoX3NlcnZlckFwcENvbmZpZy5yZWxlYXNlT25EZXJlZiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJmaW5hbGl6YXRpb24tcmVnaXN0cnktbm90LXN1cHBvcnRlZFwiIC8qIEFwcEVycm9yLkZJTkFMSVpBVElPTl9SRUdJU1RSWV9OT1RfU1VQUE9SVEVEICovLCB7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgbmFtZVN0cmluZyA9ICcnICsgaGFzaENvZGUoSlNPTi5zdHJpbmdpZnkobmFtZU9iaikpO1xyXG4gICAgY29uc3QgZXhpc3RpbmdBcHAgPSBfc2VydmVyQXBwcy5nZXQobmFtZVN0cmluZyk7XHJcbiAgICBpZiAoZXhpc3RpbmdBcHApIHtcclxuICAgICAgICBleGlzdGluZ0FwcC5pbmNSZWZDb3VudChfc2VydmVyQXBwQ29uZmlnLnJlbGVhc2VPbkRlcmVmKTtcclxuICAgICAgICByZXR1cm4gZXhpc3RpbmdBcHA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBuZXcgQ29tcG9uZW50Q29udGFpbmVyKG5hbWVTdHJpbmcpO1xyXG4gICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgX2NvbXBvbmVudHMudmFsdWVzKCkpIHtcclxuICAgICAgICBjb250YWluZXIuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXdBcHAgPSBuZXcgRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsKGFwcE9wdGlvbnMsIF9zZXJ2ZXJBcHBDb25maWcsIG5hbWVTdHJpbmcsIGNvbnRhaW5lcik7XHJcbiAgICBfc2VydmVyQXBwcy5zZXQobmFtZVN0cmluZywgbmV3QXBwKTtcclxuICAgIHJldHVybiBuZXdBcHA7XHJcbn1cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBhIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSBpbnN0YW5jZS5cclxuICpcclxuICogV2hlbiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIHRoZSBkZWZhdWx0IGFwcCBpcyByZXR1cm5lZC4gV2hlbiBhbiBhcHAgbmFtZVxyXG4gKiBpcyBwcm92aWRlZCwgdGhlIGFwcCBjb3JyZXNwb25kaW5nIHRvIHRoYXQgbmFtZSBpcyByZXR1cm5lZC5cclxuICpcclxuICogQW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiB0aGUgYXBwIGJlaW5nIHJldHJpZXZlZCBoYXMgbm90IHlldCBiZWVuXHJcbiAqIGluaXRpYWxpemVkLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIFJldHVybiB0aGUgZGVmYXVsdCBhcHBcclxuICogY29uc3QgYXBwID0gZ2V0QXBwKCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIFJldHVybiBhIG5hbWVkIGFwcFxyXG4gKiBjb25zdCBvdGhlckFwcCA9IGdldEFwcChcIm90aGVyQXBwXCIpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIG5hbWUgLSBPcHRpb25hbCBuYW1lIG9mIHRoZSBhcHAgdG8gcmV0dXJuLiBJZiBubyBuYW1lIGlzXHJcbiAqICAgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGlzIGBcIltERUZBVUxUXVwiYC5cclxuICpcclxuICogQHJldHVybnMgVGhlIGFwcCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZCBhcHAgbmFtZS5cclxuICogICBJZiBubyBhcHAgbmFtZSBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgYXBwIGlzIHJldHVybmVkLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBcHAobmFtZSA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgY29uc3QgYXBwID0gX2FwcHMuZ2V0KG5hbWUpO1xyXG4gICAgaWYgKCFhcHAgJiYgbmFtZSA9PT0gREVGQVVMVF9FTlRSWV9OQU1FICYmIGdldERlZmF1bHRBcHBDb25maWcoKSkge1xyXG4gICAgICAgIHJldHVybiBpbml0aWFsaXplQXBwKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWFwcCkge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwibm8tYXBwXCIgLyogQXBwRXJyb3IuTk9fQVBQICovLCB7IGFwcE5hbWU6IG5hbWUgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwO1xyXG59XHJcbi8qKlxyXG4gKiBBIChyZWFkLW9ubHkpIGFycmF5IG9mIGFsbCBpbml0aWFsaXplZCBhcHBzLlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBcHBzKCkge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20oX2FwcHMudmFsdWVzKCkpO1xyXG59XHJcbi8qKlxyXG4gKiBSZW5kZXJzIHRoaXMgYXBwIHVudXNhYmxlIGFuZCBmcmVlcyB0aGUgcmVzb3VyY2VzIG9mIGFsbCBhc3NvY2lhdGVkXHJcbiAqIHNlcnZpY2VzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIGRlbGV0ZUFwcChhcHApXHJcbiAqICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIkFwcCBkZWxldGVkIHN1Y2Nlc3NmdWxseVwiKTtcclxuICogICB9KVxyXG4gKiAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xyXG4gKiAgICAgY29uc29sZS5sb2coXCJFcnJvciBkZWxldGluZyBhcHA6XCIsIGVycm9yKTtcclxuICogICB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUFwcChhcHApIHtcclxuICAgIGxldCBjbGVhbnVwUHJvdmlkZXJzID0gZmFsc2U7XHJcbiAgICBjb25zdCBuYW1lID0gYXBwLm5hbWU7XHJcbiAgICBpZiAoX2FwcHMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgY2xlYW51cFByb3ZpZGVycyA9IHRydWU7XHJcbiAgICAgICAgX2FwcHMuZGVsZXRlKG5hbWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoX3NlcnZlckFwcHMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgY29uc3QgZmlyZWJhc2VTZXJ2ZXJBcHAgPSBhcHA7XHJcbiAgICAgICAgaWYgKGZpcmViYXNlU2VydmVyQXBwLmRlY1JlZkNvdW50KCkgPD0gMCkge1xyXG4gICAgICAgICAgICBfc2VydmVyQXBwcy5kZWxldGUobmFtZSk7XHJcbiAgICAgICAgICAgIGNsZWFudXBQcm92aWRlcnMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChjbGVhbnVwUHJvdmlkZXJzKSB7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYXBwLmNvbnRhaW5lclxyXG4gICAgICAgICAgICAuZ2V0UHJvdmlkZXJzKClcclxuICAgICAgICAgICAgLm1hcChwcm92aWRlciA9PiBwcm92aWRlci5kZWxldGUoKSkpO1xyXG4gICAgICAgIGFwcC5pc0RlbGV0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYSBsaWJyYXJ5J3MgbmFtZSBhbmQgdmVyc2lvbiBmb3IgcGxhdGZvcm0gbG9nZ2luZyBwdXJwb3Nlcy5cclxuICogQHBhcmFtIGxpYnJhcnkgLSBOYW1lIG9mIDFwIG9yIDNwIGxpYnJhcnkgKGUuZy4gZmlyZXN0b3JlLCBhbmd1bGFyZmlyZSlcclxuICogQHBhcmFtIHZlcnNpb24gLSBDdXJyZW50IHZlcnNpb24gb2YgdGhhdCBsaWJyYXJ5LlxyXG4gKiBAcGFyYW0gdmFyaWFudCAtIEJ1bmRsZSB2YXJpYW50LCBlLmcuLCBub2RlLCBybiwgZXRjLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlclZlcnNpb24obGlicmFyeUtleU9yTmFtZSwgdmVyc2lvbiwgdmFyaWFudCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgLy8gVE9ETzogV2UgY2FuIHVzZSB0aGlzIGNoZWNrIHRvIHdoaXRlbGlzdCBzdHJpbmdzIHdoZW4vaWYgd2Ugc2V0IHVwXHJcbiAgICAvLyBhIGdvb2Qgd2hpdGVsaXN0IHN5c3RlbS5cclxuICAgIGxldCBsaWJyYXJ5ID0gKF9hID0gUExBVEZPUk1fTE9HX1NUUklOR1tsaWJyYXJ5S2V5T3JOYW1lXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbGlicmFyeUtleU9yTmFtZTtcclxuICAgIGlmICh2YXJpYW50KSB7XHJcbiAgICAgICAgbGlicmFyeSArPSBgLSR7dmFyaWFudH1gO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGlicmFyeU1pc21hdGNoID0gbGlicmFyeS5tYXRjaCgvXFxzfFxcLy8pO1xyXG4gICAgY29uc3QgdmVyc2lvbk1pc21hdGNoID0gdmVyc2lvbi5tYXRjaCgvXFxzfFxcLy8pO1xyXG4gICAgaWYgKGxpYnJhcnlNaXNtYXRjaCB8fCB2ZXJzaW9uTWlzbWF0Y2gpIHtcclxuICAgICAgICBjb25zdCB3YXJuaW5nID0gW1xyXG4gICAgICAgICAgICBgVW5hYmxlIHRvIHJlZ2lzdGVyIGxpYnJhcnkgXCIke2xpYnJhcnl9XCIgd2l0aCB2ZXJzaW9uIFwiJHt2ZXJzaW9ufVwiOmBcclxuICAgICAgICBdO1xyXG4gICAgICAgIGlmIChsaWJyYXJ5TWlzbWF0Y2gpIHtcclxuICAgICAgICAgICAgd2FybmluZy5wdXNoKGBsaWJyYXJ5IG5hbWUgXCIke2xpYnJhcnl9XCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzICh3aGl0ZXNwYWNlIG9yIFwiL1wiKWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGlicmFyeU1pc21hdGNoICYmIHZlcnNpb25NaXNtYXRjaCkge1xyXG4gICAgICAgICAgICB3YXJuaW5nLnB1c2goJ2FuZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmVyc2lvbk1pc21hdGNoKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmcucHVzaChgdmVyc2lvbiBuYW1lIFwiJHt2ZXJzaW9ufVwiIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycyAod2hpdGVzcGFjZSBvciBcIi9cIilgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbG9nZ2VyLndhcm4od2FybmluZy5qb2luKCcgJykpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KGAke2xpYnJhcnl9LXZlcnNpb25gLCAoKSA9PiAoeyBsaWJyYXJ5LCB2ZXJzaW9uIH0pLCBcIlZFUlNJT05cIiAvKiBDb21wb25lbnRUeXBlLlZFUlNJT04gKi8pKTtcclxufVxyXG4vKipcclxuICogU2V0cyBsb2cgaGFuZGxlciBmb3IgYWxsIEZpcmViYXNlIFNES3MuXHJcbiAqIEBwYXJhbSBsb2dDYWxsYmFjayAtIEFuIG9wdGlvbmFsIGN1c3RvbSBsb2cgaGFuZGxlciB0aGF0IGV4ZWN1dGVzIHVzZXIgY29kZSB3aGVuZXZlclxyXG4gKiB0aGUgRmlyZWJhc2UgU0RLIG1ha2VzIGEgbG9nZ2luZyBjYWxsLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBvbkxvZyhsb2dDYWxsYmFjaywgb3B0aW9ucykge1xyXG4gICAgaWYgKGxvZ0NhbGxiYWNrICE9PSBudWxsICYmIHR5cGVvZiBsb2dDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW52YWxpZC1sb2ctYXJndW1lbnRcIiAvKiBBcHBFcnJvci5JTlZBTElEX0xPR19BUkdVTUVOVCAqLyk7XHJcbiAgICB9XHJcbiAgICBzZXRVc2VyTG9nSGFuZGxlcihsb2dDYWxsYmFjaywgb3B0aW9ucyk7XHJcbn1cclxuLyoqXHJcbiAqIFNldHMgbG9nIGxldmVsIGZvciBhbGwgRmlyZWJhc2UgU0RLcy5cclxuICpcclxuICogQWxsIG9mIHRoZSBsb2cgdHlwZXMgYWJvdmUgdGhlIGN1cnJlbnQgbG9nIGxldmVsIGFyZSBjYXB0dXJlZCAoaS5lLiBpZlxyXG4gKiB5b3Ugc2V0IHRoZSBsb2cgbGV2ZWwgdG8gYGluZm9gLCBlcnJvcnMgYXJlIGxvZ2dlZCwgYnV0IGBkZWJ1Z2AgYW5kXHJcbiAqIGB2ZXJib3NlYCBsb2dzIGFyZSBub3QpLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsb2dMZXZlbCkge1xyXG4gICAgc2V0TG9nTGV2ZWwkMShsb2dMZXZlbCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgREJfTkFNRSA9ICdmaXJlYmFzZS1oZWFydGJlYXQtZGF0YWJhc2UnO1xyXG5jb25zdCBEQl9WRVJTSU9OID0gMTtcclxuY29uc3QgU1RPUkVfTkFNRSA9ICdmaXJlYmFzZS1oZWFydGJlYXQtc3RvcmUnO1xyXG5sZXQgZGJQcm9taXNlID0gbnVsbDtcclxuZnVuY3Rpb24gZ2V0RGJQcm9taXNlKCkge1xyXG4gICAgaWYgKCFkYlByb21pc2UpIHtcclxuICAgICAgICBkYlByb21pc2UgPSBvcGVuREIoREJfTkFNRSwgREJfVkVSU0lPTiwge1xyXG4gICAgICAgICAgICB1cGdyYWRlOiAoZGIsIG9sZFZlcnNpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHVzZSAnYnJlYWsnIGluIHRoaXMgc3dpdGNoIHN0YXRlbWVudCwgdGhlIGZhbGwtdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgLy8gYmVoYXZpb3IgaXMgd2hhdCB3ZSB3YW50LCBiZWNhdXNlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSB2ZXJzaW9ucyBiZXR3ZWVuXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgb2xkIHZlcnNpb24gYW5kIHRoZSBjdXJyZW50IHZlcnNpb24sIHdlIHdhbnQgQUxMIHRoZSBtaWdyYXRpb25zXHJcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhvc2UgdmVyc2lvbnMgdG8gcnVuLCBub3Qgb25seSB0aGUgbGFzdCBvbmUuXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9sZFZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpL2lPUyBicm93c2VycyB0aHJvdyBvY2Nhc2lvbmFsIGV4Y2VwdGlvbnMgb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRiLmNyZWF0ZU9iamVjdFN0b3JlKCkgdGhhdCBtYXkgYmUgYSBidWcuIEF2b2lkIGJsb2NraW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVzdCBvZiB0aGUgYXBwIGZ1bmN0aW9uYWxpdHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImlkYi1vcGVuXCIgLyogQXBwRXJyb3IuSURCX09QRU4gKi8sIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGJQcm9taXNlO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHJlYWRIZWFydGJlYXRzRnJvbUluZGV4ZWREQihhcHApIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCBnZXREYlByb21pc2UoKTtcclxuICAgICAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKFNUT1JFX05BTUUpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHR4Lm9iamVjdFN0b3JlKFNUT1JFX05BTUUpLmdldChjb21wdXRlS2V5KGFwcCkpO1xyXG4gICAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSB0aGUgdmFsdWUgYnV0IHR4LmRvbmUgY2FuIHRocm93LFxyXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gYXdhaXQgaXQgaGVyZSB0byBjYXRjaCBlcnJvcnNcclxuICAgICAgICBhd2FpdCB0eC5kb25lO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihlLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaWRiR2V0RXJyb3IgPSBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImlkYi1nZXRcIiAvKiBBcHBFcnJvci5JREJfR0VUICovLCB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGlkYkdldEVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5hc3luYyBmdW5jdGlvbiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQihhcHAsIGhlYXJ0YmVhdE9iamVjdCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiUHJvbWlzZSgpO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScpO1xyXG4gICAgICAgIGNvbnN0IG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoU1RPUkVfTkFNRSk7XHJcbiAgICAgICAgYXdhaXQgb2JqZWN0U3RvcmUucHV0KGhlYXJ0YmVhdE9iamVjdCwgY29tcHV0ZUtleShhcHApKTtcclxuICAgICAgICBhd2FpdCB0eC5kb25lO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oZS5tZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkYkdldEVycm9yID0gRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpZGItc2V0XCIgLyogQXBwRXJyb3IuSURCX1dSSVRFICovLCB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGlkYkdldEVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb21wdXRlS2V5KGFwcCkge1xyXG4gICAgcmV0dXJuIGAke2FwcC5uYW1lfSEke2FwcC5vcHRpb25zLmFwcElkfWA7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTUFYX0hFQURFUl9CWVRFUyA9IDEwMjQ7XHJcbi8vIDMwIGRheXNcclxuY29uc3QgU1RPUkVEX0hFQVJUQkVBVF9SRVRFTlRJT05fTUFYX01JTExJUyA9IDMwICogMjQgKiA2MCAqIDYwICogMTAwMDtcclxuY2xhc3MgSGVhcnRiZWF0U2VydmljZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW4tbWVtb3J5IGNhY2hlIGZvciBoZWFydGJlYXRzLCB1c2VkIGJ5IGdldEhlYXJ0YmVhdHNIZWFkZXIoKSB0byBnZW5lcmF0ZVxyXG4gICAgICAgICAqIHRoZSBoZWFkZXIgc3RyaW5nLlxyXG4gICAgICAgICAqIFN0b3JlcyBvbmUgcmVjb3JkIHBlciBkYXRlLiBUaGlzIHdpbGwgYmUgY29uc29saWRhdGVkIGludG8gdGhlIHN0YW5kYXJkXHJcbiAgICAgICAgICogZm9ybWF0IG9mIG9uZSByZWNvcmQgcGVyIHVzZXIgYWdlbnQgc3RyaW5nIGJlZm9yZSBiZWluZyBzZW50IGFzIGEgaGVhZGVyLlxyXG4gICAgICAgICAqIFBvcHVsYXRlZCBmcm9tIGluZGV4ZWREQiB3aGVuIHRoZSBjb250cm9sbGVyIGlzIGluc3RhbnRpYXRlZCBhbmQgc2hvdWxkXHJcbiAgICAgICAgICogYmUga2VwdCBpbiBzeW5jIHdpdGggaW5kZXhlZERCLlxyXG4gICAgICAgICAqIExlYXZlIHB1YmxpYyBmb3IgZWFzaWVyIHRlc3RpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gbnVsbDtcclxuICAgICAgICBjb25zdCBhcHAgPSB0aGlzLmNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICAgICAgdGhpcy5fc3RvcmFnZSA9IG5ldyBIZWFydGJlYXRTdG9yYWdlSW1wbChhcHApO1xyXG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2UgPSB0aGlzLl9zdG9yYWdlLnJlYWQoKS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHRvIHJlcG9ydCBhIGhlYXJ0YmVhdC4gVGhlIGZ1bmN0aW9uIHdpbGwgZ2VuZXJhdGVcclxuICAgICAqIGEgSGVhcnRiZWF0c0J5VXNlckFnZW50IG9iamVjdCwgdXBkYXRlIGhlYXJ0YmVhdHNDYWNoZSwgYW5kIHBlcnNpc3QgaXRcclxuICAgICAqIHRvIEluZGV4ZWREQi5cclxuICAgICAqIE5vdGUgdGhhdCB3ZSBvbmx5IHN0b3JlIG9uZSBoZWFydGJlYXQgcGVyIGRheS4gU28gaWYgYSBoZWFydGJlYXQgZm9yIHRvZGF5IGlzXHJcbiAgICAgKiBhbHJlYWR5IGxvZ2dlZCwgc3Vic2VxdWVudCBjYWxscyB0byB0aGlzIGZ1bmN0aW9uIGluIHRoZSBzYW1lIGRheSB3aWxsIGJlIGlnbm9yZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHRyaWdnZXJIZWFydGJlYXQoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBwbGF0Zm9ybUxvZ2dlciA9IHRoaXMuY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5nZXRQcm92aWRlcigncGxhdGZvcm0tbG9nZ2VyJylcclxuICAgICAgICAgICAgLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIFwiRmlyZWJhc2UgdXNlciBhZ2VudFwiIHN0cmluZyBmcm9tIHRoZSBwbGF0Zm9ybSBsb2dnZXJcclxuICAgICAgICAvLyBzZXJ2aWNlLCBub3QgdGhlIGJyb3dzZXIgdXNlciBhZ2VudC5cclxuICAgICAgICBjb25zdCBhZ2VudCA9IHBsYXRmb3JtTG9nZ2VyLmdldFBsYXRmb3JtSW5mb1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IGRhdGUgPSBnZXRVVENEYXRlU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFydGJlYXRzKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IGF3YWl0IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2U7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGZhaWxlZCB0byBjb25zdHJ1Y3QgYSBoZWFydGJlYXRzIGNhY2hlLCB0aGVuIHJldHVybiBpbW1lZGlhdGVseS5cclxuICAgICAgICAgICAgaWYgKCgoX2IgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWFydGJlYXRzKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90IHN0b3JlIGEgaGVhcnRiZWF0IGlmIG9uZSBpcyBhbHJlYWR5IHN0b3JlZCBmb3IgdGhpcyBkYXlcclxuICAgICAgICAvLyBvciBpZiBhIGhlYWRlciBoYXMgYWxyZWFkeSBiZWVuIHNlbnQgdG9kYXkuXHJcbiAgICAgICAgaWYgKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5sYXN0U2VudEhlYXJ0YmVhdERhdGUgPT09IGRhdGUgfHxcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMuc29tZShzaW5nbGVEYXRlSGVhcnRiZWF0ID0+IHNpbmdsZURhdGVIZWFydGJlYXQuZGF0ZSA9PT0gZGF0ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gZW50cnkgZm9yIHRoaXMgZGF0ZS4gQ3JlYXRlIG9uZS5cclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMucHVzaCh7IGRhdGUsIGFnZW50IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgZW50cmllcyBvbGRlciB0aGFuIDMwIGRheXMuXHJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5maWx0ZXIoc2luZ2xlRGF0ZUhlYXJ0YmVhdCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhiVGltZXN0YW1wID0gbmV3IERhdGUoc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBub3cgLSBoYlRpbWVzdGFtcCA8PSBTVE9SRURfSEVBUlRCRUFUX1JFVEVOVElPTl9NQVhfTUlMTElTO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHdoaWNoIGNhbiBiZSBhdHRhY2hlZCB0byB0aGUgaGVhcnRiZWF0LXNwZWNpZmljIGhlYWRlciBkaXJlY3RseS5cclxuICAgICAqIEl0IGFsc28gY2xlYXJzIGFsbCBoZWFydGJlYXRzIGZyb20gbWVtb3J5IGFzIHdlbGwgYXMgaW4gSW5kZXhlZERCLlxyXG4gICAgICpcclxuICAgICAqIE5PVEU6IENvbnN1bWluZyBwcm9kdWN0IFNES3Mgc2hvdWxkIG5vdCBzZW5kIHRoZSBoZWFkZXIgaWYgdGhpcyBtZXRob2RcclxuICAgICAqIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRIZWFydGJlYXRzSGVhZGVyKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAodGhpcy5faGVhcnRiZWF0c0NhY2hlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGl0J3Mgc3RpbGwgbnVsbCBvciB0aGUgYXJyYXkgaXMgZW1wdHksIHRoZXJlIGlzIG5vIGRhdGEgdG8gc2VuZC5cclxuICAgICAgICBpZiAoKChfYSA9IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYXJ0YmVhdHMpID09IG51bGwgfHxcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGF0ZSA9IGdldFVUQ0RhdGVTdHJpbmcoKTtcclxuICAgICAgICAvLyBFeHRyYWN0IGFzIG1hbnkgaGVhcnRiZWF0cyBmcm9tIHRoZSBjYWNoZSBhcyB3aWxsIGZpdCB1bmRlciB0aGUgc2l6ZSBsaW1pdC5cclxuICAgICAgICBjb25zdCB7IGhlYXJ0YmVhdHNUb1NlbmQsIHVuc2VudEVudHJpZXMgfSA9IGV4dHJhY3RIZWFydGJlYXRzRm9ySGVhZGVyKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzKTtcclxuICAgICAgICBjb25zdCBoZWFkZXJTdHJpbmcgPSBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeSh7IHZlcnNpb246IDIsIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNUb1NlbmQgfSkpO1xyXG4gICAgICAgIC8vIFN0b3JlIGxhc3Qgc2VudCBkYXRlIHRvIHByZXZlbnQgYW5vdGhlciBiZWluZyBsb2dnZWQvc2VudCBmb3IgdGhlIHNhbWUgZGF5LlxyXG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5sYXN0U2VudEhlYXJ0YmVhdERhdGUgPSBkYXRlO1xyXG4gICAgICAgIGlmICh1bnNlbnRFbnRyaWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy8gU3RvcmUgYW55IHVuc2VudCBlbnRyaWVzIGlmIHRoZXkgZXhpc3QuXHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID0gdW5zZW50RW50cmllcztcclxuICAgICAgICAgICAgLy8gVGhpcyBzZWVtcyBtb3JlIGxpa2VseSB0aGFuIGVtcHR5aW5nIHRoZSBhcnJheSAoYmVsb3cpIHRvIGxlYWQgdG8gc29tZSBvZGQgc3RhdGVcclxuICAgICAgICAgICAgLy8gc2luY2UgdGhlIGNhY2hlIGlzbid0IGVtcHR5IGFuZCB0aGlzIHdpbGwgYmUgY2FsbGVkIGFnYWluIG9uIHRoZSBuZXh0IHJlcXVlc3QsXHJcbiAgICAgICAgICAgIC8vIGFuZCBpcyBwcm9iYWJseSBzYWZlc3QgaWYgd2UgYXdhaXQgaXQuXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyA9IFtdO1xyXG4gICAgICAgICAgICAvLyBEbyBub3Qgd2FpdCBmb3IgdGhpcywgdG8gcmVkdWNlIGxhdGVuY3kuXHJcbiAgICAgICAgICAgIHZvaWQgdGhpcy5fc3RvcmFnZS5vdmVyd3JpdGUodGhpcy5faGVhcnRiZWF0c0NhY2hlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhlYWRlclN0cmluZztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRVVENEYXRlU3RyaW5nKCkge1xyXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xyXG4gICAgLy8gUmV0dXJucyBkYXRlIGZvcm1hdCAnWVlZWS1NTS1ERCdcclxuICAgIHJldHVybiB0b2RheS50b0lTT1N0cmluZygpLnN1YnN0cmluZygwLCAxMCk7XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdEhlYXJ0YmVhdHNGb3JIZWFkZXIoaGVhcnRiZWF0c0NhY2hlLCBtYXhTaXplID0gTUFYX0hFQURFUl9CWVRFUykge1xyXG4gICAgLy8gSGVhcnRiZWF0cyBncm91cGVkIGJ5IHVzZXIgYWdlbnQgaW4gdGhlIHN0YW5kYXJkIGZvcm1hdCB0byBiZSBzZW50IGluXHJcbiAgICAvLyB0aGUgaGVhZGVyLlxyXG4gICAgY29uc3QgaGVhcnRiZWF0c1RvU2VuZCA9IFtdO1xyXG4gICAgLy8gU2luZ2xlIGRhdGUgZm9ybWF0IGhlYXJ0YmVhdHMgdGhhdCBhcmUgbm90IHNlbnQuXHJcbiAgICBsZXQgdW5zZW50RW50cmllcyA9IGhlYXJ0YmVhdHNDYWNoZS5zbGljZSgpO1xyXG4gICAgZm9yIChjb25zdCBzaW5nbGVEYXRlSGVhcnRiZWF0IG9mIGhlYXJ0YmVhdHNDYWNoZSkge1xyXG4gICAgICAgIC8vIExvb2sgZm9yIGFuIGV4aXN0aW5nIGVudHJ5IHdpdGggdGhlIHNhbWUgdXNlciBhZ2VudC5cclxuICAgICAgICBjb25zdCBoZWFydGJlYXRFbnRyeSA9IGhlYXJ0YmVhdHNUb1NlbmQuZmluZChoYiA9PiBoYi5hZ2VudCA9PT0gc2luZ2xlRGF0ZUhlYXJ0YmVhdC5hZ2VudCk7XHJcbiAgICAgICAgaWYgKCFoZWFydGJlYXRFbnRyeSkge1xyXG4gICAgICAgICAgICAvLyBJZiBubyBlbnRyeSBmb3IgdGhpcyB1c2VyIGFnZW50IGV4aXN0cywgY3JlYXRlIG9uZS5cclxuICAgICAgICAgICAgaGVhcnRiZWF0c1RvU2VuZC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGFnZW50OiBzaW5nbGVEYXRlSGVhcnRiZWF0LmFnZW50LFxyXG4gICAgICAgICAgICAgICAgZGF0ZXM6IFtzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGVdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoY291bnRCeXRlcyhoZWFydGJlYXRzVG9TZW5kKSA+IG1heFNpemUpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBoZWFkZXIgd291bGQgZXhjZWVkIG1heCBzaXplLCByZW1vdmUgdGhlIGFkZGVkIGhlYXJ0YmVhdFxyXG4gICAgICAgICAgICAgICAgLy8gZW50cnkgYW5kIHN0b3AgYWRkaW5nIHRvIHRoZSBoZWFkZXIuXHJcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzVG9TZW5kLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhlYXJ0YmVhdEVudHJ5LmRhdGVzLnB1c2goc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlKTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIGhlYWRlciB3b3VsZCBleGNlZWQgbWF4IHNpemUsIHJlbW92ZSB0aGUgYWRkZWQgZGF0ZVxyXG4gICAgICAgICAgICAvLyBhbmQgc3RvcCBhZGRpbmcgdG8gdGhlIGhlYWRlci5cclxuICAgICAgICAgICAgaWYgKGNvdW50Qnl0ZXMoaGVhcnRiZWF0c1RvU2VuZCkgPiBtYXhTaXplKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRFbnRyeS5kYXRlcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBvcCB1bnNlbnQgZW50cnkgZnJvbSBxdWV1ZS4gKFNraXBwZWQgaWYgYWRkaW5nIHRoZSBlbnRyeSBleGNlZWRlZFxyXG4gICAgICAgIC8vIHF1b3RhIGFuZCB0aGUgbG9vcCBicmVha3MgZWFybHkuKVxyXG4gICAgICAgIHVuc2VudEVudHJpZXMgPSB1bnNlbnRFbnRyaWVzLnNsaWNlKDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoZWFydGJlYXRzVG9TZW5kLFxyXG4gICAgICAgIHVuc2VudEVudHJpZXNcclxuICAgIH07XHJcbn1cclxuY2xhc3MgSGVhcnRiZWF0U3RvcmFnZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoYXBwKSB7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZSA9IHRoaXMucnVuSW5kZXhlZERCRW52aXJvbm1lbnRDaGVjaygpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcnVuSW5kZXhlZERCRW52aXJvbm1lbnRDaGVjaygpIHtcclxuICAgICAgICBpZiAoIWlzSW5kZXhlZERCQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdHJ1ZSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGFsbCBoZWFydGJlYXRzLlxyXG4gICAgICovXHJcbiAgICBhc3luYyByZWFkKCkge1xyXG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XHJcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgaGVhcnRiZWF0czogW10gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkYkhlYXJ0YmVhdE9iamVjdCA9IGF3YWl0IHJlYWRIZWFydGJlYXRzRnJvbUluZGV4ZWREQih0aGlzLmFwcCk7XHJcbiAgICAgICAgICAgIGlmIChpZGJIZWFydGJlYXRPYmplY3QgPT09IG51bGwgfHwgaWRiSGVhcnRiZWF0T2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpZGJIZWFydGJlYXRPYmplY3QuaGVhcnRiZWF0cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkYkhlYXJ0YmVhdE9iamVjdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGhlYXJ0YmVhdHM6IFtdIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBvdmVyd3JpdGUgdGhlIHN0b3JhZ2Ugd2l0aCB0aGUgcHJvdmlkZWQgaGVhcnRiZWF0c1xyXG4gICAgYXN5bmMgb3ZlcndyaXRlKGhlYXJ0YmVhdHNPYmplY3QpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcclxuICAgICAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QgPSBhd2FpdCB0aGlzLnJlYWQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKHRoaXMuYXBwLCB7XHJcbiAgICAgICAgICAgICAgICBsYXN0U2VudEhlYXJ0YmVhdERhdGU6IChfYSA9IGhlYXJ0YmVhdHNPYmplY3QubGFzdFNlbnRIZWFydGJlYXREYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QubGFzdFNlbnRIZWFydGJlYXREYXRlLFxyXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0czogaGVhcnRiZWF0c09iamVjdC5oZWFydGJlYXRzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGFkZCBoZWFydGJlYXRzXHJcbiAgICBhc3luYyBhZGQoaGVhcnRiZWF0c09iamVjdCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xyXG4gICAgICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdCA9IGF3YWl0IHRoaXMucmVhZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gd3JpdGVIZWFydGJlYXRzVG9JbmRleGVkREIodGhpcy5hcHAsIHtcclxuICAgICAgICAgICAgICAgIGxhc3RTZW50SGVhcnRiZWF0RGF0ZTogKF9hID0gaGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUsXHJcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHMsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uaGVhcnRiZWF0c09iamVjdC5oZWFydGJlYXRzXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlIGJ5dGVzIG9mIGEgSGVhcnRiZWF0c0J5VXNlckFnZW50IGFycmF5IGFmdGVyIGJlaW5nIHdyYXBwZWRcclxuICogaW4gYSBwbGF0Zm9ybSBsb2dnaW5nIGhlYWRlciBKU09OIG9iamVjdCwgc3RyaW5naWZpZWQsIGFuZCBjb252ZXJ0ZWRcclxuICogdG8gYmFzZSA2NC5cclxuICovXHJcbmZ1bmN0aW9uIGNvdW50Qnl0ZXMoaGVhcnRiZWF0c0NhY2hlKSB7XHJcbiAgICAvLyBiYXNlNjQgaGFzIGEgcmVzdHJpY3RlZCBzZXQgb2YgY2hhcmFjdGVycywgYWxsIG9mIHdoaWNoIHNob3VsZCBiZSAxIGJ5dGUuXHJcbiAgICByZXR1cm4gYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoXHJcbiAgICAvLyBoZWFydGJlYXRzQ2FjaGUgd3JhcHBlciBwcm9wZXJ0aWVzXHJcbiAgICBKU09OLnN0cmluZ2lmeSh7IHZlcnNpb246IDIsIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNDYWNoZSB9KSkubGVuZ3RoO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyQ29yZUNvbXBvbmVudHModmFyaWFudCkge1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ3BsYXRmb3JtLWxvZ2dlcicsIGNvbnRhaW5lciA9PiBuZXcgUGxhdGZvcm1Mb2dnZXJTZXJ2aWNlSW1wbChjb250YWluZXIpLCBcIlBSSVZBVEVcIiAvKiBDb21wb25lbnRUeXBlLlBSSVZBVEUgKi8pKTtcclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KCdoZWFydGJlYXQnLCBjb250YWluZXIgPT4gbmV3IEhlYXJ0YmVhdFNlcnZpY2VJbXBsKGNvbnRhaW5lciksIFwiUFJJVkFURVwiIC8qIENvbXBvbmVudFR5cGUuUFJJVkFURSAqLykpO1xyXG4gICAgLy8gUmVnaXN0ZXIgYGFwcGAgcGFja2FnZS5cclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lJHAsIHZlcnNpb24kMSwgdmFyaWFudCk7XHJcbiAgICAvLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc201LCBlc20yMDE3LCBjanM1LCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUkcCwgdmVyc2lvbiQxLCAnZXNtMjAxNycpO1xyXG4gICAgLy8gUmVnaXN0ZXIgcGxhdGZvcm0gU0RLIGlkZW50aWZpZXIgKG5vIHZlcnNpb24pLlxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKCdmaXJlLWpzJywgJycpO1xyXG59XG5cbi8qKlxyXG4gKiBGaXJlYmFzZSBBcHBcclxuICpcclxuICogQHJlbWFya3MgVGhpcyBwYWNrYWdlIGNvb3JkaW5hdGVzIHRoZSBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlIGRpZmZlcmVudCBGaXJlYmFzZSBjb21wb25lbnRzXHJcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxyXG4gKi9cclxucmVnaXN0ZXJDb3JlQ29tcG9uZW50cygnJyk7XG5cbmV4cG9ydCB7IFNES19WRVJTSU9OLCBERUZBVUxUX0VOVFJZX05BTUUgYXMgX0RFRkFVTFRfRU5UUllfTkFNRSwgX2FkZENvbXBvbmVudCwgX2FkZE9yT3ZlcndyaXRlQ29tcG9uZW50LCBfYXBwcywgX2NsZWFyQ29tcG9uZW50cywgX2NvbXBvbmVudHMsIF9nZXRQcm92aWRlciwgX2lzRmlyZWJhc2VBcHAsIF9pc0ZpcmViYXNlU2VydmVyQXBwLCBfcmVnaXN0ZXJDb21wb25lbnQsIF9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UsIF9zZXJ2ZXJBcHBzLCBkZWxldGVBcHAsIGdldEFwcCwgZ2V0QXBwcywgaW5pdGlhbGl6ZUFwcCwgaW5pdGlhbGl6ZVNlcnZlckFwcCwgb25Mb2csIHJlZ2lzdGVyVmVyc2lvbiwgc2V0TG9nTGV2ZWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbTIwMTcuanMubWFwXG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiQ29tcG9uZW50Q29udGFpbmVyIiwiTG9nZ2VyIiwic2V0VXNlckxvZ0hhbmRsZXIiLCJzZXRMb2dMZXZlbCIsInNldExvZ0xldmVsJDEiLCJFcnJvckZhY3RvcnkiLCJnZXREZWZhdWx0QXBwQ29uZmlnIiwiZGVlcEVxdWFsIiwiaXNCcm93c2VyIiwiRmlyZWJhc2VFcnJvciIsImJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nIiwiaXNJbmRleGVkREJBdmFpbGFibGUiLCJ2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlIiwib3BlbkRCIiwiUGxhdGZvcm1Mb2dnZXJTZXJ2aWNlSW1wbCIsImNvbnN0cnVjdG9yIiwiY29udGFpbmVyIiwiZ2V0UGxhdGZvcm1JbmZvU3RyaW5nIiwicHJvdmlkZXJzIiwiZ2V0UHJvdmlkZXJzIiwibWFwIiwicHJvdmlkZXIiLCJpc1ZlcnNpb25TZXJ2aWNlUHJvdmlkZXIiLCJzZXJ2aWNlIiwiZ2V0SW1tZWRpYXRlIiwibGlicmFyeSIsInZlcnNpb24iLCJmaWx0ZXIiLCJsb2dTdHJpbmciLCJqb2luIiwiY29tcG9uZW50IiwiZ2V0Q29tcG9uZW50IiwidHlwZSIsIm5hbWUkcCIsInZlcnNpb24kMSIsImxvZ2dlciIsIm5hbWUkbyIsIm5hbWUkbiIsIm5hbWUkbSIsIm5hbWUkbCIsIm5hbWUkayIsIm5hbWUkaiIsIm5hbWUkaSIsIm5hbWUkaCIsIm5hbWUkZyIsIm5hbWUkZiIsIm5hbWUkZSIsIm5hbWUkZCIsIm5hbWUkYyIsIm5hbWUkYiIsIm5hbWUkYSIsIm5hbWUkOSIsIm5hbWUkOCIsIm5hbWUkNyIsIm5hbWUkNiIsIm5hbWUkNSIsIm5hbWUkNCIsIm5hbWUkMyIsIm5hbWUkMiIsIm5hbWUkMSIsIm5hbWUiLCJERUZBVUxUX0VOVFJZX05BTUUiLCJQTEFURk9STV9MT0dfU1RSSU5HIiwiX2FwcHMiLCJNYXAiLCJfc2VydmVyQXBwcyIsIl9jb21wb25lbnRzIiwiX2FkZENvbXBvbmVudCIsImFwcCIsImFkZENvbXBvbmVudCIsImUiLCJkZWJ1ZyIsIl9hZGRPck92ZXJ3cml0ZUNvbXBvbmVudCIsImFkZE9yT3ZlcndyaXRlQ29tcG9uZW50IiwiX3JlZ2lzdGVyQ29tcG9uZW50IiwiY29tcG9uZW50TmFtZSIsImhhcyIsInNldCIsInZhbHVlcyIsInNlcnZlckFwcCIsIl9nZXRQcm92aWRlciIsImhlYXJ0YmVhdENvbnRyb2xsZXIiLCJnZXRQcm92aWRlciIsIm9wdGlvbmFsIiwidHJpZ2dlckhlYXJ0YmVhdCIsIl9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UiLCJpbnN0YW5jZUlkZW50aWZpZXIiLCJjbGVhckluc3RhbmNlIiwiX2lzRmlyZWJhc2VBcHAiLCJvYmoiLCJvcHRpb25zIiwidW5kZWZpbmVkIiwiX2lzRmlyZWJhc2VTZXJ2ZXJBcHAiLCJzZXR0aW5ncyIsIl9jbGVhckNvbXBvbmVudHMiLCJjbGVhciIsIkVSUk9SUyIsIkVSUk9SX0ZBQ1RPUlkiLCJGaXJlYmFzZUFwcEltcGwiLCJjb25maWciLCJfaXNEZWxldGVkIiwiX29wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJfY29uZmlnIiwiX25hbWUiLCJfYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkIiwiYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkIiwiX2NvbnRhaW5lciIsImNoZWNrRGVzdHJveWVkIiwidmFsIiwiaXNEZWxldGVkIiwiY3JlYXRlIiwiYXBwTmFtZSIsIkZpcmViYXNlU2VydmVyQXBwSW1wbCIsInNlcnZlckNvbmZpZyIsImFwaUtleSIsImFwcEltcGwiLCJfc2VydmVyQ29uZmlnIiwiX2ZpbmFsaXphdGlvblJlZ2lzdHJ5IiwiRmluYWxpemF0aW9uUmVnaXN0cnkiLCJhdXRvbWF0aWNDbGVhbnVwIiwiX3JlZkNvdW50IiwiaW5jUmVmQ291bnQiLCJyZWxlYXNlT25EZXJlZiIsInJlZ2lzdGVyVmVyc2lvbiIsInRvSlNPTiIsInJlZkNvdW50IiwicmVnaXN0ZXIiLCJkZWNSZWZDb3VudCIsImRlbGV0ZUFwcCIsIlNES19WRVJTSU9OIiwiaW5pdGlhbGl6ZUFwcCIsInJhd0NvbmZpZyIsIlN0cmluZyIsImV4aXN0aW5nQXBwIiwiZ2V0IiwibmV3QXBwIiwiaW5pdGlhbGl6ZVNlcnZlckFwcCIsIl9zZXJ2ZXJBcHBDb25maWciLCJhcHBPcHRpb25zIiwibmFtZU9iaiIsImhhc2hDb2RlIiwicyIsInJlZHVjZSIsImhhc2giLCJjIiwiTWF0aCIsImltdWwiLCJjaGFyQ29kZUF0IiwibmFtZVN0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRBcHAiLCJnZXRBcHBzIiwiQXJyYXkiLCJmcm9tIiwiY2xlYW51cFByb3ZpZGVycyIsImRlbGV0ZSIsImZpcmViYXNlU2VydmVyQXBwIiwiUHJvbWlzZSIsImFsbCIsImxpYnJhcnlLZXlPck5hbWUiLCJ2YXJpYW50IiwiX2EiLCJsaWJyYXJ5TWlzbWF0Y2giLCJtYXRjaCIsInZlcnNpb25NaXNtYXRjaCIsIndhcm5pbmciLCJwdXNoIiwid2FybiIsIm9uTG9nIiwibG9nQ2FsbGJhY2siLCJsb2dMZXZlbCIsIkRCX05BTUUiLCJEQl9WRVJTSU9OIiwiU1RPUkVfTkFNRSIsImRiUHJvbWlzZSIsImdldERiUHJvbWlzZSIsInVwZ3JhZGUiLCJkYiIsIm9sZFZlcnNpb24iLCJjcmVhdGVPYmplY3RTdG9yZSIsImNvbnNvbGUiLCJjYXRjaCIsIm9yaWdpbmFsRXJyb3JNZXNzYWdlIiwibWVzc2FnZSIsInJlYWRIZWFydGJlYXRzRnJvbUluZGV4ZWREQiIsInR4IiwidHJhbnNhY3Rpb24iLCJyZXN1bHQiLCJvYmplY3RTdG9yZSIsImNvbXB1dGVLZXkiLCJkb25lIiwiaWRiR2V0RXJyb3IiLCJ3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQiIsImhlYXJ0YmVhdE9iamVjdCIsInB1dCIsImFwcElkIiwiTUFYX0hFQURFUl9CWVRFUyIsIlNUT1JFRF9IRUFSVEJFQVRfUkVURU5USU9OX01BWF9NSUxMSVMiLCJIZWFydGJlYXRTZXJ2aWNlSW1wbCIsIl9oZWFydGJlYXRzQ2FjaGUiLCJfc3RvcmFnZSIsIkhlYXJ0YmVhdFN0b3JhZ2VJbXBsIiwiX2hlYXJ0YmVhdHNDYWNoZVByb21pc2UiLCJyZWFkIiwidGhlbiIsIl9iIiwicGxhdGZvcm1Mb2dnZXIiLCJhZ2VudCIsImRhdGUiLCJnZXRVVENEYXRlU3RyaW5nIiwiaGVhcnRiZWF0cyIsImxhc3RTZW50SGVhcnRiZWF0RGF0ZSIsInNvbWUiLCJzaW5nbGVEYXRlSGVhcnRiZWF0IiwiaGJUaW1lc3RhbXAiLCJEYXRlIiwidmFsdWVPZiIsIm5vdyIsIm92ZXJ3cml0ZSIsImdldEhlYXJ0YmVhdHNIZWFkZXIiLCJsZW5ndGgiLCJoZWFydGJlYXRzVG9TZW5kIiwidW5zZW50RW50cmllcyIsImV4dHJhY3RIZWFydGJlYXRzRm9ySGVhZGVyIiwiaGVhZGVyU3RyaW5nIiwidG9kYXkiLCJ0b0lTT1N0cmluZyIsInN1YnN0cmluZyIsImhlYXJ0YmVhdHNDYWNoZSIsIm1heFNpemUiLCJzbGljZSIsImhlYXJ0YmVhdEVudHJ5IiwiZmluZCIsImhiIiwiZGF0ZXMiLCJjb3VudEJ5dGVzIiwicG9wIiwiX2NhblVzZUluZGV4ZWREQlByb21pc2UiLCJydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrIiwiY2FuVXNlSW5kZXhlZERCIiwiaWRiSGVhcnRiZWF0T2JqZWN0IiwiaGVhcnRiZWF0c09iamVjdCIsImV4aXN0aW5nSGVhcnRiZWF0c09iamVjdCIsImFkZCIsInJlZ2lzdGVyQ29yZUNvbXBvbmVudHMiLCJfREVGQVVMVF9FTlRSWV9OQU1FIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/auth/dist/node-esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@firebase/auth/dist/node-esm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionCodeOperation: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   ActionCodeURL: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.ai),\n/* harmony export */   AuthCredential: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.L),\n/* harmony export */   AuthErrorCodes: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.I),\n/* harmony export */   EmailAuthCredential: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.M),\n/* harmony export */   EmailAuthProvider: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.V),\n/* harmony export */   FacebookAuthProvider: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.W),\n/* harmony export */   FactorId: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   GithubAuthProvider: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.Y),\n/* harmony export */   GoogleAuthProvider: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.X),\n/* harmony export */   OAuthCredential: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.N),\n/* harmony export */   OAuthProvider: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.Z),\n/* harmony export */   OperationType: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.O),\n/* harmony export */   PhoneAuthCredential: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.Q),\n/* harmony export */   PhoneAuthProvider: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.P),\n/* harmony export */   PhoneMultiFactorGenerator: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   ProviderId: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   RecaptchaVerifier: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.R),\n/* harmony export */   SAMLAuthProvider: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__._),\n/* harmony export */   SignInMethod: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.S),\n/* harmony export */   TotpMultiFactorGenerator: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.T),\n/* harmony export */   TotpSecret: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   TwitterAuthProvider: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.$),\n/* harmony export */   applyActionCode: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.a7),\n/* harmony export */   beforeAuthStateChanged: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   browserLocalPersistence: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   browserPopupRedirectResolver: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   browserSessionPersistence: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   checkActionCode: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.a8),\n/* harmony export */   confirmPasswordReset: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.a6),\n/* harmony export */   connectAuthEmulator: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.K),\n/* harmony export */   createUserWithEmailAndPassword: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.aa),\n/* harmony export */   debugErrorMap: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   deleteUser: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.E),\n/* harmony export */   fetchSignInMethodsForEmail: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.af),\n/* harmony export */   getAdditionalUserInfo: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.aq),\n/* harmony export */   getAuth: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   getIdToken: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.an),\n/* harmony export */   getIdTokenResult: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.ao),\n/* harmony export */   getMultiFactorResolver: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.as),\n/* harmony export */   getRedirectResult: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   inMemoryPersistence: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.U),\n/* harmony export */   indexedDBLocalPersistence: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   initializeAuth: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.J),\n/* harmony export */   initializeRecaptchaConfig: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   isSignInWithEmailLink: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.ad),\n/* harmony export */   linkWithCredential: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.a2),\n/* harmony export */   linkWithPhoneNumber: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   linkWithPopup: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   linkWithRedirect: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   multiFactor: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.at),\n/* harmony export */   onAuthStateChanged: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   onIdTokenChanged: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   parseActionCodeURL: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.aj),\n/* harmony export */   prodErrorMap: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.H),\n/* harmony export */   reauthenticateWithCredential: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.a3),\n/* harmony export */   reauthenticateWithPhoneNumber: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   reauthenticateWithPopup: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   reauthenticateWithRedirect: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   reload: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.ar),\n/* harmony export */   revokeAccessToken: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   sendEmailVerification: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.ag),\n/* harmony export */   sendPasswordResetEmail: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.a5),\n/* harmony export */   sendSignInLinkToEmail: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.ac),\n/* harmony export */   setPersistence: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   signInAnonymously: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.a0),\n/* harmony export */   signInWithCredential: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.a1),\n/* harmony export */   signInWithCustomToken: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.a4),\n/* harmony export */   signInWithEmailAndPassword: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.ab),\n/* harmony export */   signInWithEmailLink: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.ae),\n/* harmony export */   signInWithPhoneNumber: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   signInWithPopup: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   signInWithRedirect: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   signOut: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   unlink: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.ap),\n/* harmony export */   updateCurrentUser: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.B),\n/* harmony export */   updateEmail: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.al),\n/* harmony export */   updatePassword: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.am),\n/* harmony export */   updatePhoneNumber: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   updateProfile: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.ak),\n/* harmony export */   useDeviceLanguage: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   validatePassword: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   verifyBeforeUpdateEmail: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.ah),\n/* harmony export */   verifyPasswordResetCode: () => (/* reexport safe */ _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__.a9)\n/* harmony export */ });\n/* harmony import */ var _totp_d821ac28_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./totp-d821ac28.js */ \"(ssr)/./node_modules/@firebase/auth/dist/node-esm/totp-d821ac28.js\");\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! undici */ \"(ssr)/./node_modules/undici/index.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvZGlzdC9ub2RlLWVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd2xFO0FBQ2prRTtBQUNDO0FBQ1Q7QUFDYztBQUNiO0FBQ1UsQ0FDMUIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJlZS1uZXh0anMtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL2Rpc3Qvbm9kZS1lc20vaW5kZXguanM/OGVjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBBIGFzIEFjdGlvbkNvZGVPcGVyYXRpb24sIGFpIGFzIEFjdGlvbkNvZGVVUkwsIEwgYXMgQXV0aENyZWRlbnRpYWwsIEkgYXMgQXV0aEVycm9yQ29kZXMsIE0gYXMgRW1haWxBdXRoQ3JlZGVudGlhbCwgViBhcyBFbWFpbEF1dGhQcm92aWRlciwgVyBhcyBGYWNlYm9va0F1dGhQcm92aWRlciwgRiBhcyBGYWN0b3JJZCwgWSBhcyBHaXRodWJBdXRoUHJvdmlkZXIsIFggYXMgR29vZ2xlQXV0aFByb3ZpZGVyLCBOIGFzIE9BdXRoQ3JlZGVudGlhbCwgWiBhcyBPQXV0aFByb3ZpZGVyLCBPIGFzIE9wZXJhdGlvblR5cGUsIFEgYXMgUGhvbmVBdXRoQ3JlZGVudGlhbCwgUCBhcyBQaG9uZUF1dGhQcm92aWRlciwgbSBhcyBQaG9uZU11bHRpRmFjdG9yR2VuZXJhdG9yLCBwIGFzIFByb3ZpZGVySWQsIFIgYXMgUmVjYXB0Y2hhVmVyaWZpZXIsIF8gYXMgU0FNTEF1dGhQcm92aWRlciwgUyBhcyBTaWduSW5NZXRob2QsIFQgYXMgVG90cE11bHRpRmFjdG9yR2VuZXJhdG9yLCBuIGFzIFRvdHBTZWNyZXQsICQgYXMgVHdpdHRlckF1dGhQcm92aWRlciwgYTcgYXMgYXBwbHlBY3Rpb25Db2RlLCB4IGFzIGJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQsIGIgYXMgYnJvd3NlckxvY2FsUGVyc2lzdGVuY2UsIGsgYXMgYnJvd3NlclBvcHVwUmVkaXJlY3RSZXNvbHZlciwgYSBhcyBicm93c2VyU2Vzc2lvblBlcnNpc3RlbmNlLCBhOCBhcyBjaGVja0FjdGlvbkNvZGUsIGE2IGFzIGNvbmZpcm1QYXNzd29yZFJlc2V0LCBLIGFzIGNvbm5lY3RBdXRoRW11bGF0b3IsIGFhIGFzIGNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZCwgRyBhcyBkZWJ1Z0Vycm9yTWFwLCBFIGFzIGRlbGV0ZVVzZXIsIGFmIGFzIGZldGNoU2lnbkluTWV0aG9kc0ZvckVtYWlsLCBhcSBhcyBnZXRBZGRpdGlvbmFsVXNlckluZm8sIG8gYXMgZ2V0QXV0aCwgYW4gYXMgZ2V0SWRUb2tlbiwgYW8gYXMgZ2V0SWRUb2tlblJlc3VsdCwgYXMgYXMgZ2V0TXVsdGlGYWN0b3JSZXNvbHZlciwgaiBhcyBnZXRSZWRpcmVjdFJlc3VsdCwgVSBhcyBpbk1lbW9yeVBlcnNpc3RlbmNlLCBpIGFzIGluZGV4ZWREQkxvY2FsUGVyc2lzdGVuY2UsIEogYXMgaW5pdGlhbGl6ZUF1dGgsIHQgYXMgaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZywgYWQgYXMgaXNTaWduSW5XaXRoRW1haWxMaW5rLCBhMiBhcyBsaW5rV2l0aENyZWRlbnRpYWwsIGwgYXMgbGlua1dpdGhQaG9uZU51bWJlciwgZCBhcyBsaW5rV2l0aFBvcHVwLCBnIGFzIGxpbmtXaXRoUmVkaXJlY3QsIGF0IGFzIG11bHRpRmFjdG9yLCB5IGFzIG9uQXV0aFN0YXRlQ2hhbmdlZCwgdyBhcyBvbklkVG9rZW5DaGFuZ2VkLCBhaiBhcyBwYXJzZUFjdGlvbkNvZGVVUkwsIEggYXMgcHJvZEVycm9yTWFwLCBhMyBhcyByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsLCByIGFzIHJlYXV0aGVudGljYXRlV2l0aFBob25lTnVtYmVyLCBlIGFzIHJlYXV0aGVudGljYXRlV2l0aFBvcHVwLCBoIGFzIHJlYXV0aGVudGljYXRlV2l0aFJlZGlyZWN0LCBhciBhcyByZWxvYWQsIEQgYXMgcmV2b2tlQWNjZXNzVG9rZW4sIGFnIGFzIHNlbmRFbWFpbFZlcmlmaWNhdGlvbiwgYTUgYXMgc2VuZFBhc3N3b3JkUmVzZXRFbWFpbCwgYWMgYXMgc2VuZFNpZ25JbkxpbmtUb0VtYWlsLCBxIGFzIHNldFBlcnNpc3RlbmNlLCBhMCBhcyBzaWduSW5Bbm9ueW1vdXNseSwgYTEgYXMgc2lnbkluV2l0aENyZWRlbnRpYWwsIGE0IGFzIHNpZ25JbldpdGhDdXN0b21Ub2tlbiwgYWIgYXMgc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQsIGFlIGFzIHNpZ25JbldpdGhFbWFpbExpbmssIHMgYXMgc2lnbkluV2l0aFBob25lTnVtYmVyLCBjIGFzIHNpZ25JbldpdGhQb3B1cCwgZiBhcyBzaWduSW5XaXRoUmVkaXJlY3QsIEMgYXMgc2lnbk91dCwgYXAgYXMgdW5saW5rLCBCIGFzIHVwZGF0ZUN1cnJlbnRVc2VyLCBhbCBhcyB1cGRhdGVFbWFpbCwgYW0gYXMgdXBkYXRlUGFzc3dvcmQsIHUgYXMgdXBkYXRlUGhvbmVOdW1iZXIsIGFrIGFzIHVwZGF0ZVByb2ZpbGUsIHogYXMgdXNlRGV2aWNlTGFuZ3VhZ2UsIHYgYXMgdmFsaWRhdGVQYXNzd29yZCwgYWggYXMgdmVyaWZ5QmVmb3JlVXBkYXRlRW1haWwsIGE5IGFzIHZlcmlmeVBhc3N3b3JkUmVzZXRDb2RlIH0gZnJvbSAnLi90b3RwLWQ4MjFhYzI4LmpzJztcbmltcG9ydCAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCAndHNsaWInO1xuaW1wb3J0ICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCAndW5kaWNpJztcbmltcG9ydCAnQGZpcmViYXNlL2xvZ2dlcic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJBIiwiQWN0aW9uQ29kZU9wZXJhdGlvbiIsImFpIiwiQWN0aW9uQ29kZVVSTCIsIkwiLCJBdXRoQ3JlZGVudGlhbCIsIkkiLCJBdXRoRXJyb3JDb2RlcyIsIk0iLCJFbWFpbEF1dGhDcmVkZW50aWFsIiwiViIsIkVtYWlsQXV0aFByb3ZpZGVyIiwiVyIsIkZhY2Vib29rQXV0aFByb3ZpZGVyIiwiRiIsIkZhY3RvcklkIiwiWSIsIkdpdGh1YkF1dGhQcm92aWRlciIsIlgiLCJHb29nbGVBdXRoUHJvdmlkZXIiLCJOIiwiT0F1dGhDcmVkZW50aWFsIiwiWiIsIk9BdXRoUHJvdmlkZXIiLCJPIiwiT3BlcmF0aW9uVHlwZSIsIlEiLCJQaG9uZUF1dGhDcmVkZW50aWFsIiwiUCIsIlBob25lQXV0aFByb3ZpZGVyIiwibSIsIlBob25lTXVsdGlGYWN0b3JHZW5lcmF0b3IiLCJwIiwiUHJvdmlkZXJJZCIsIlIiLCJSZWNhcHRjaGFWZXJpZmllciIsIl8iLCJTQU1MQXV0aFByb3ZpZGVyIiwiUyIsIlNpZ25Jbk1ldGhvZCIsIlQiLCJUb3RwTXVsdGlGYWN0b3JHZW5lcmF0b3IiLCJuIiwiVG90cFNlY3JldCIsIiQiLCJUd2l0dGVyQXV0aFByb3ZpZGVyIiwiYTciLCJhcHBseUFjdGlvbkNvZGUiLCJ4IiwiYmVmb3JlQXV0aFN0YXRlQ2hhbmdlZCIsImIiLCJicm93c2VyTG9jYWxQZXJzaXN0ZW5jZSIsImsiLCJicm93c2VyUG9wdXBSZWRpcmVjdFJlc29sdmVyIiwiYSIsImJyb3dzZXJTZXNzaW9uUGVyc2lzdGVuY2UiLCJhOCIsImNoZWNrQWN0aW9uQ29kZSIsImE2IiwiY29uZmlybVBhc3N3b3JkUmVzZXQiLCJLIiwiY29ubmVjdEF1dGhFbXVsYXRvciIsImFhIiwiY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkIiwiRyIsImRlYnVnRXJyb3JNYXAiLCJFIiwiZGVsZXRlVXNlciIsImFmIiwiZmV0Y2hTaWduSW5NZXRob2RzRm9yRW1haWwiLCJhcSIsImdldEFkZGl0aW9uYWxVc2VySW5mbyIsIm8iLCJnZXRBdXRoIiwiYW4iLCJnZXRJZFRva2VuIiwiYW8iLCJnZXRJZFRva2VuUmVzdWx0IiwiYXMiLCJnZXRNdWx0aUZhY3RvclJlc29sdmVyIiwiaiIsImdldFJlZGlyZWN0UmVzdWx0IiwiVSIsImluTWVtb3J5UGVyc2lzdGVuY2UiLCJpIiwiaW5kZXhlZERCTG9jYWxQZXJzaXN0ZW5jZSIsIkoiLCJpbml0aWFsaXplQXV0aCIsInQiLCJpbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnIiwiYWQiLCJpc1NpZ25JbldpdGhFbWFpbExpbmsiLCJhMiIsImxpbmtXaXRoQ3JlZGVudGlhbCIsImwiLCJsaW5rV2l0aFBob25lTnVtYmVyIiwiZCIsImxpbmtXaXRoUG9wdXAiLCJnIiwibGlua1dpdGhSZWRpcmVjdCIsImF0IiwibXVsdGlGYWN0b3IiLCJ5Iiwib25BdXRoU3RhdGVDaGFuZ2VkIiwidyIsIm9uSWRUb2tlbkNoYW5nZWQiLCJhaiIsInBhcnNlQWN0aW9uQ29kZVVSTCIsIkgiLCJwcm9kRXJyb3JNYXAiLCJhMyIsInJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWwiLCJyIiwicmVhdXRoZW50aWNhdGVXaXRoUGhvbmVOdW1iZXIiLCJlIiwicmVhdXRoZW50aWNhdGVXaXRoUG9wdXAiLCJoIiwicmVhdXRoZW50aWNhdGVXaXRoUmVkaXJlY3QiLCJhciIsInJlbG9hZCIsIkQiLCJyZXZva2VBY2Nlc3NUb2tlbiIsImFnIiwic2VuZEVtYWlsVmVyaWZpY2F0aW9uIiwiYTUiLCJzZW5kUGFzc3dvcmRSZXNldEVtYWlsIiwiYWMiLCJzZW5kU2lnbkluTGlua1RvRW1haWwiLCJxIiwic2V0UGVyc2lzdGVuY2UiLCJhMCIsInNpZ25JbkFub255bW91c2x5IiwiYTEiLCJzaWduSW5XaXRoQ3JlZGVudGlhbCIsImE0Iiwic2lnbkluV2l0aEN1c3RvbVRva2VuIiwiYWIiLCJzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZCIsImFlIiwic2lnbkluV2l0aEVtYWlsTGluayIsInMiLCJzaWduSW5XaXRoUGhvbmVOdW1iZXIiLCJjIiwic2lnbkluV2l0aFBvcHVwIiwiZiIsInNpZ25JbldpdGhSZWRpcmVjdCIsIkMiLCJzaWduT3V0IiwiYXAiLCJ1bmxpbmsiLCJCIiwidXBkYXRlQ3VycmVudFVzZXIiLCJhbCIsInVwZGF0ZUVtYWlsIiwiYW0iLCJ1cGRhdGVQYXNzd29yZCIsInUiLCJ1cGRhdGVQaG9uZU51bWJlciIsImFrIiwidXBkYXRlUHJvZmlsZSIsInoiLCJ1c2VEZXZpY2VMYW5ndWFnZSIsInYiLCJ2YWxpZGF0ZVBhc3N3b3JkIiwiYWgiLCJ2ZXJpZnlCZWZvcmVVcGRhdGVFbWFpbCIsImE5IiwidmVyaWZ5UGFzc3dvcmRSZXNldENvZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/auth/dist/node-esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/auth/dist/node-esm/totp-d821ac28.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/auth/dist/node-esm/totp-d821ac28.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ TwitterAuthProvider),\n/* harmony export */   A: () => (/* binding */ ActionCodeOperation),\n/* harmony export */   B: () => (/* binding */ updateCurrentUser),\n/* harmony export */   C: () => (/* binding */ signOut),\n/* harmony export */   D: () => (/* binding */ revokeAccessToken),\n/* harmony export */   E: () => (/* binding */ deleteUser),\n/* harmony export */   F: () => (/* binding */ FactorId),\n/* harmony export */   G: () => (/* binding */ debugErrorMap),\n/* harmony export */   H: () => (/* binding */ prodErrorMap),\n/* harmony export */   I: () => (/* binding */ AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY),\n/* harmony export */   J: () => (/* binding */ initializeAuth),\n/* harmony export */   K: () => (/* binding */ connectAuthEmulator),\n/* harmony export */   L: () => (/* binding */ AuthCredential),\n/* harmony export */   M: () => (/* binding */ EmailAuthCredential),\n/* harmony export */   N: () => (/* binding */ OAuthCredential),\n/* harmony export */   O: () => (/* binding */ OperationType),\n/* harmony export */   P: () => (/* binding */ PhoneAuthProvider),\n/* harmony export */   Q: () => (/* binding */ PhoneAuthCredential),\n/* harmony export */   R: () => (/* binding */ RecaptchaVerifier),\n/* harmony export */   S: () => (/* binding */ SignInMethod),\n/* harmony export */   T: () => (/* binding */ TotpMultiFactorGenerator),\n/* harmony export */   U: () => (/* binding */ inMemoryPersistence),\n/* harmony export */   V: () => (/* binding */ EmailAuthProvider),\n/* harmony export */   W: () => (/* binding */ FacebookAuthProvider),\n/* harmony export */   X: () => (/* binding */ GoogleAuthProvider),\n/* harmony export */   Y: () => (/* binding */ GithubAuthProvider),\n/* harmony export */   Z: () => (/* binding */ OAuthProvider),\n/* harmony export */   _: () => (/* binding */ SAMLAuthProvider),\n/* harmony export */   a: () => (/* binding */ browserSessionPersistence),\n/* harmony export */   a0: () => (/* binding */ signInAnonymously),\n/* harmony export */   a1: () => (/* binding */ signInWithCredential),\n/* harmony export */   a2: () => (/* binding */ linkWithCredential),\n/* harmony export */   a3: () => (/* binding */ reauthenticateWithCredential),\n/* harmony export */   a4: () => (/* binding */ signInWithCustomToken),\n/* harmony export */   a5: () => (/* binding */ sendPasswordResetEmail),\n/* harmony export */   a6: () => (/* binding */ confirmPasswordReset),\n/* harmony export */   a7: () => (/* binding */ applyActionCode),\n/* harmony export */   a8: () => (/* binding */ checkActionCode),\n/* harmony export */   a9: () => (/* binding */ verifyPasswordResetCode),\n/* harmony export */   aA: () => (/* binding */ _fail),\n/* harmony export */   aB: () => (/* binding */ debugAssert),\n/* harmony export */   aC: () => (/* binding */ _persistenceKeyName),\n/* harmony export */   aD: () => (/* binding */ _serverAppCurrentUserOperationNotSupportedError),\n/* harmony export */   aE: () => (/* binding */ _castAuth),\n/* harmony export */   aF: () => (/* binding */ FederatedAuthProvider),\n/* harmony export */   aG: () => (/* binding */ BaseOAuthProvider),\n/* harmony export */   aH: () => (/* binding */ _emulatorUrl),\n/* harmony export */   aI: () => (/* binding */ _performApiRequest),\n/* harmony export */   aJ: () => (/* binding */ _isIOS),\n/* harmony export */   aK: () => (/* binding */ _isAndroid),\n/* harmony export */   aL: () => (/* binding */ _isIOS7Or8),\n/* harmony export */   aM: () => (/* binding */ _createError),\n/* harmony export */   aN: () => (/* binding */ _isIframe),\n/* harmony export */   aO: () => (/* binding */ _isMobileBrowser),\n/* harmony export */   aP: () => (/* binding */ _isIE10),\n/* harmony export */   aQ: () => (/* binding */ _isSafari),\n/* harmony export */   aR: () => (/* binding */ UserImpl),\n/* harmony export */   aS: () => (/* binding */ AuthImpl),\n/* harmony export */   aT: () => (/* binding */ _getClientVersion),\n/* harmony export */   aU: () => (/* binding */ FetchProvider),\n/* harmony export */   aV: () => (/* binding */ SAMLAuthCredential),\n/* harmony export */   aa: () => (/* binding */ createUserWithEmailAndPassword),\n/* harmony export */   ab: () => (/* binding */ signInWithEmailAndPassword),\n/* harmony export */   ac: () => (/* binding */ sendSignInLinkToEmail),\n/* harmony export */   ad: () => (/* binding */ isSignInWithEmailLink),\n/* harmony export */   ae: () => (/* binding */ signInWithEmailLink),\n/* harmony export */   af: () => (/* binding */ fetchSignInMethodsForEmail),\n/* harmony export */   ag: () => (/* binding */ sendEmailVerification),\n/* harmony export */   ah: () => (/* binding */ verifyBeforeUpdateEmail),\n/* harmony export */   ai: () => (/* binding */ ActionCodeURL),\n/* harmony export */   aj: () => (/* binding */ parseActionCodeURL),\n/* harmony export */   ak: () => (/* binding */ updateProfile),\n/* harmony export */   al: () => (/* binding */ updateEmail),\n/* harmony export */   am: () => (/* binding */ updatePassword),\n/* harmony export */   an: () => (/* binding */ getIdToken),\n/* harmony export */   ao: () => (/* binding */ getIdTokenResult),\n/* harmony export */   ap: () => (/* binding */ unlink),\n/* harmony export */   aq: () => (/* binding */ getAdditionalUserInfo),\n/* harmony export */   ar: () => (/* binding */ reload),\n/* harmony export */   as: () => (/* binding */ getMultiFactorResolver),\n/* harmony export */   at: () => (/* binding */ multiFactor),\n/* harmony export */   au: () => (/* binding */ _getInstance),\n/* harmony export */   av: () => (/* binding */ _assert),\n/* harmony export */   aw: () => (/* binding */ _signInWithCredential),\n/* harmony export */   ax: () => (/* binding */ _reauthenticate),\n/* harmony export */   ay: () => (/* binding */ _link),\n/* harmony export */   az: () => (/* binding */ signInWithIdp),\n/* harmony export */   b: () => (/* binding */ browserLocalPersistence),\n/* harmony export */   c: () => (/* binding */ signInWithPopup),\n/* harmony export */   d: () => (/* binding */ linkWithPopup),\n/* harmony export */   e: () => (/* binding */ reauthenticateWithPopup),\n/* harmony export */   f: () => (/* binding */ signInWithRedirect),\n/* harmony export */   g: () => (/* binding */ linkWithRedirect),\n/* harmony export */   h: () => (/* binding */ reauthenticateWithRedirect),\n/* harmony export */   i: () => (/* binding */ indexedDBLocalPersistence),\n/* harmony export */   j: () => (/* binding */ getRedirectResult),\n/* harmony export */   k: () => (/* binding */ browserPopupRedirectResolver),\n/* harmony export */   l: () => (/* binding */ linkWithPhoneNumber),\n/* harmony export */   m: () => (/* binding */ PhoneMultiFactorGenerator),\n/* harmony export */   n: () => (/* binding */ TotpSecret),\n/* harmony export */   o: () => (/* binding */ getAuth),\n/* harmony export */   p: () => (/* binding */ ProviderId),\n/* harmony export */   q: () => (/* binding */ setPersistence),\n/* harmony export */   r: () => (/* binding */ reauthenticateWithPhoneNumber),\n/* harmony export */   s: () => (/* binding */ signInWithPhoneNumber),\n/* harmony export */   t: () => (/* binding */ initializeRecaptchaConfig),\n/* harmony export */   u: () => (/* binding */ updatePhoneNumber),\n/* harmony export */   v: () => (/* binding */ validatePassword),\n/* harmony export */   w: () => (/* binding */ onIdTokenChanged),\n/* harmony export */   x: () => (/* binding */ beforeAuthStateChanged),\n/* harmony export */   y: () => (/* binding */ onAuthStateChanged),\n/* harmony export */   z: () => (/* binding */ useDeviceLanguage)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! undici */ \"(ssr)/./node_modules/undici/index.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An enum of factors that may be used for multifactor authentication.\r\n *\r\n * @public\r\n */ const FactorId = {\n    /** Phone as second factor */ PHONE: \"phone\",\n    TOTP: \"totp\"\n};\n/**\r\n * Enumeration of supported providers.\r\n *\r\n * @public\r\n */ const ProviderId = {\n    /** Facebook provider ID */ FACEBOOK: \"facebook.com\",\n    /** GitHub provider ID */ GITHUB: \"github.com\",\n    /** Google provider ID */ GOOGLE: \"google.com\",\n    /** Password provider */ PASSWORD: \"password\",\n    /** Phone provider */ PHONE: \"phone\",\n    /** Twitter provider ID */ TWITTER: \"twitter.com\"\n};\n/**\r\n * Enumeration of supported sign-in methods.\r\n *\r\n * @public\r\n */ const SignInMethod = {\n    /** Email link sign in method */ EMAIL_LINK: \"emailLink\",\n    /** Email/password sign in method */ EMAIL_PASSWORD: \"password\",\n    /** Facebook sign in method */ FACEBOOK: \"facebook.com\",\n    /** GitHub sign in method */ GITHUB: \"github.com\",\n    /** Google sign in method */ GOOGLE: \"google.com\",\n    /** Phone sign in method */ PHONE: \"phone\",\n    /** Twitter sign in method */ TWITTER: \"twitter.com\"\n};\n/**\r\n * Enumeration of supported operation types.\r\n *\r\n * @public\r\n */ const OperationType = {\n    /** Operation involving linking an additional provider to an already signed-in user. */ LINK: \"link\",\n    /** Operation involving using a provider to reauthenticate an already signed-in user. */ REAUTHENTICATE: \"reauthenticate\",\n    /** Operation involving signing in a user. */ SIGN_IN: \"signIn\"\n};\n/**\r\n * An enumeration of the possible email action types.\r\n *\r\n * @public\r\n */ const ActionCodeOperation = {\n    /** The email link sign-in action. */ EMAIL_SIGNIN: \"EMAIL_SIGNIN\",\n    /** The password reset action. */ PASSWORD_RESET: \"PASSWORD_RESET\",\n    /** The email revocation action. */ RECOVER_EMAIL: \"RECOVER_EMAIL\",\n    /** The revert second factor addition email action. */ REVERT_SECOND_FACTOR_ADDITION: \"REVERT_SECOND_FACTOR_ADDITION\",\n    /** The revert second factor addition email action. */ VERIFY_AND_CHANGE_EMAIL: \"VERIFY_AND_CHANGE_EMAIL\",\n    /** The email verification action. */ VERIFY_EMAIL: \"VERIFY_EMAIL\"\n};\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function _debugErrorMap() {\n    return {\n        [\"admin-restricted-operation\" /* AuthErrorCode.ADMIN_ONLY_OPERATION */ ]: \"This operation is restricted to administrators only.\",\n        [\"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ ]: \"\",\n        [\"app-not-authorized\" /* AuthErrorCode.APP_NOT_AUTHORIZED */ ]: \"This app, identified by the domain where it's hosted, is not \" + \"authorized to use Firebase Authentication with the provided API key. \" + \"Review your key configuration in the Google API console.\",\n        [\"app-not-installed\" /* AuthErrorCode.APP_NOT_INSTALLED */ ]: \"The requested mobile application corresponding to the identifier (\" + \"Android package name or iOS bundle ID) provided is not installed on \" + \"this device.\",\n        [\"captcha-check-failed\" /* AuthErrorCode.CAPTCHA_CHECK_FAILED */ ]: \"The reCAPTCHA response token provided is either invalid, expired, \" + \"already used or the domain associated with it does not match the list \" + \"of whitelisted domains.\",\n        [\"code-expired\" /* AuthErrorCode.CODE_EXPIRED */ ]: \"The SMS code has expired. Please re-send the verification code to try \" + \"again.\",\n        [\"cordova-not-ready\" /* AuthErrorCode.CORDOVA_NOT_READY */ ]: \"Cordova framework is not ready.\",\n        [\"cors-unsupported\" /* AuthErrorCode.CORS_UNSUPPORTED */ ]: \"This browser is not supported.\",\n        [\"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */ ]: \"This credential is already associated with a different user account.\",\n        [\"custom-token-mismatch\" /* AuthErrorCode.CREDENTIAL_MISMATCH */ ]: \"The custom token corresponds to a different audience.\",\n        [\"requires-recent-login\" /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */ ]: \"This operation is sensitive and requires recent authentication. Log in \" + \"again before retrying this request.\",\n        [\"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */ ]: \"Another Firebase SDK was initialized and is trying to use Auth before Auth is \" + \"initialized. Please be sure to call `initializeAuth` or `getAuth` before \" + \"starting any other Firebase SDK.\",\n        [\"dynamic-link-not-activated\" /* AuthErrorCode.DYNAMIC_LINK_NOT_ACTIVATED */ ]: \"Please activate Dynamic Links in the Firebase Console and agree to the terms and \" + \"conditions.\",\n        [\"email-change-needs-verification\" /* AuthErrorCode.EMAIL_CHANGE_NEEDS_VERIFICATION */ ]: \"Multi-factor users must always have a verified email.\",\n        [\"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */ ]: \"The email address is already in use by another account.\",\n        [\"emulator-config-failed\" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */ ]: \"Auth instance has already been used to make a network call. Auth can \" + \"no longer be configured to use the emulator. Try calling \" + '\"connectAuthEmulator()\" sooner.',\n        [\"expired-action-code\" /* AuthErrorCode.EXPIRED_OOB_CODE */ ]: \"The action code has expired.\",\n        [\"cancelled-popup-request\" /* AuthErrorCode.EXPIRED_POPUP_REQUEST */ ]: \"This operation has been cancelled due to another conflicting popup being opened.\",\n        [\"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ ]: \"An internal AuthError has occurred.\",\n        [\"invalid-app-credential\" /* AuthErrorCode.INVALID_APP_CREDENTIAL */ ]: \"The phone verification request contains an invalid application verifier.\" + \" The reCAPTCHA token response is either invalid or expired.\",\n        [\"invalid-app-id\" /* AuthErrorCode.INVALID_APP_ID */ ]: \"The mobile app identifier is not registed for the current project.\",\n        [\"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */ ]: \"This user's credential isn't valid for this project. This can happen \" + \"if the user's token has been tampered with, or if the user isn't for \" + \"the project associated with this API key.\",\n        [\"invalid-auth-event\" /* AuthErrorCode.INVALID_AUTH_EVENT */ ]: \"An internal AuthError has occurred.\",\n        [\"invalid-verification-code\" /* AuthErrorCode.INVALID_CODE */ ]: \"The SMS verification code used to create the phone auth credential is \" + \"invalid. Please resend the verification code sms and be sure to use the \" + \"verification code provided by the user.\",\n        [\"invalid-continue-uri\" /* AuthErrorCode.INVALID_CONTINUE_URI */ ]: \"The continue URL provided in the request is invalid.\",\n        [\"invalid-cordova-configuration\" /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */ ]: \"The following Cordova plugins must be installed to enable OAuth sign-in: \" + \"cordova-plugin-buildinfo, cordova-universal-links-plugin, \" + \"cordova-plugin-browsertab, cordova-plugin-inappbrowser and \" + \"cordova-plugin-customurlscheme.\",\n        [\"invalid-custom-token\" /* AuthErrorCode.INVALID_CUSTOM_TOKEN */ ]: \"The custom token format is incorrect. Please check the documentation.\",\n        [\"invalid-dynamic-link-domain\" /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */ ]: \"The provided dynamic link domain is not configured or authorized for the current project.\",\n        [\"invalid-email\" /* AuthErrorCode.INVALID_EMAIL */ ]: \"The email address is badly formatted.\",\n        [\"invalid-emulator-scheme\" /* AuthErrorCode.INVALID_EMULATOR_SCHEME */ ]: \"Emulator URL must start with a valid scheme (http:// or https://).\",\n        [\"invalid-api-key\" /* AuthErrorCode.INVALID_API_KEY */ ]: \"Your API key is invalid, please check you have copied it correctly.\",\n        [\"invalid-cert-hash\" /* AuthErrorCode.INVALID_CERT_HASH */ ]: \"The SHA-1 certificate hash provided is invalid.\",\n        [\"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */ ]: \"The supplied auth credential is incorrect, malformed or has expired.\",\n        [\"invalid-message-payload\" /* AuthErrorCode.INVALID_MESSAGE_PAYLOAD */ ]: \"The email template corresponding to this action contains invalid characters in its message. \" + \"Please fix by going to the Auth email templates section in the Firebase Console.\",\n        [\"invalid-multi-factor-session\" /* AuthErrorCode.INVALID_MFA_SESSION */ ]: \"The request does not contain a valid proof of first factor successful sign-in.\",\n        [\"invalid-oauth-provider\" /* AuthErrorCode.INVALID_OAUTH_PROVIDER */ ]: \"EmailAuthProvider is not supported for this operation. This operation \" + \"only supports OAuth providers.\",\n        [\"invalid-oauth-client-id\" /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */ ]: \"The OAuth client ID provided is either invalid or does not match the \" + \"specified API key.\",\n        [\"unauthorized-domain\" /* AuthErrorCode.INVALID_ORIGIN */ ]: \"This domain is not authorized for OAuth operations for your Firebase \" + \"project. Edit the list of authorized domains from the Firebase console.\",\n        [\"invalid-action-code\" /* AuthErrorCode.INVALID_OOB_CODE */ ]: \"The action code is invalid. This can happen if the code is malformed, \" + \"expired, or has already been used.\",\n        [\"wrong-password\" /* AuthErrorCode.INVALID_PASSWORD */ ]: \"The password is invalid or the user does not have a password.\",\n        [\"invalid-persistence-type\" /* AuthErrorCode.INVALID_PERSISTENCE */ ]: \"The specified persistence type is invalid. It can only be local, session or none.\",\n        [\"invalid-phone-number\" /* AuthErrorCode.INVALID_PHONE_NUMBER */ ]: \"The format of the phone number provided is incorrect. Please enter the \" + \"phone number in a format that can be parsed into E.164 format. E.164 \" + \"phone numbers are written in the format [+][country code][subscriber \" + \"number including area code].\",\n        [\"invalid-provider-id\" /* AuthErrorCode.INVALID_PROVIDER_ID */ ]: \"The specified provider ID is invalid.\",\n        [\"invalid-recipient-email\" /* AuthErrorCode.INVALID_RECIPIENT_EMAIL */ ]: \"The email corresponding to this action failed to send as the provided \" + \"recipient email address is invalid.\",\n        [\"invalid-sender\" /* AuthErrorCode.INVALID_SENDER */ ]: \"The email template corresponding to this action contains an invalid sender email or name. \" + \"Please fix by going to the Auth email templates section in the Firebase Console.\",\n        [\"invalid-verification-id\" /* AuthErrorCode.INVALID_SESSION_INFO */ ]: \"The verification ID used to create the phone auth credential is invalid.\",\n        [\"invalid-tenant-id\" /* AuthErrorCode.INVALID_TENANT_ID */ ]: \"The Auth instance's tenant ID is invalid.\",\n        [\"login-blocked\" /* AuthErrorCode.LOGIN_BLOCKED */ ]: \"Login blocked by user-provided method: {$originalMessage}\",\n        [\"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */ ]: \"An Android Package Name must be provided if the Android App is required to be installed.\",\n        [\"auth-domain-config-required\" /* AuthErrorCode.MISSING_AUTH_DOMAIN */ ]: \"Be sure to include authDomain when calling firebase.initializeApp(), \" + \"by following the instructions in the Firebase console.\",\n        [\"missing-app-credential\" /* AuthErrorCode.MISSING_APP_CREDENTIAL */ ]: \"The phone verification request is missing an application verifier \" + \"assertion. A reCAPTCHA response token needs to be provided.\",\n        [\"missing-verification-code\" /* AuthErrorCode.MISSING_CODE */ ]: \"The phone auth credential was created with an empty SMS verification code.\",\n        [\"missing-continue-uri\" /* AuthErrorCode.MISSING_CONTINUE_URI */ ]: \"A continue URL must be provided in the request.\",\n        [\"missing-iframe-start\" /* AuthErrorCode.MISSING_IFRAME_START */ ]: \"An internal AuthError has occurred.\",\n        [\"missing-ios-bundle-id\" /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */ ]: \"An iOS Bundle ID must be provided if an App Store ID is provided.\",\n        [\"missing-or-invalid-nonce\" /* AuthErrorCode.MISSING_OR_INVALID_NONCE */ ]: \"The request does not contain a valid nonce. This can occur if the \" + \"SHA-256 hash of the provided raw nonce does not match the hashed nonce \" + \"in the ID token payload.\",\n        [\"missing-password\" /* AuthErrorCode.MISSING_PASSWORD */ ]: \"A non-empty password must be provided\",\n        [\"missing-multi-factor-info\" /* AuthErrorCode.MISSING_MFA_INFO */ ]: \"No second factor identifier is provided.\",\n        [\"missing-multi-factor-session\" /* AuthErrorCode.MISSING_MFA_SESSION */ ]: \"The request is missing proof of first factor successful sign-in.\",\n        [\"missing-phone-number\" /* AuthErrorCode.MISSING_PHONE_NUMBER */ ]: \"To send verification codes, provide a phone number for the recipient.\",\n        [\"missing-verification-id\" /* AuthErrorCode.MISSING_SESSION_INFO */ ]: \"The phone auth credential was created with an empty verification ID.\",\n        [\"app-deleted\" /* AuthErrorCode.MODULE_DESTROYED */ ]: \"This instance of FirebaseApp has been deleted.\",\n        [\"multi-factor-info-not-found\" /* AuthErrorCode.MFA_INFO_NOT_FOUND */ ]: \"The user does not have a second factor matching the identifier provided.\",\n        [\"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */ ]: \"Proof of ownership of a second factor is required to complete sign-in.\",\n        [\"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */ ]: \"An account already exists with the same email address but different \" + \"sign-in credentials. Sign in using a provider associated with this \" + \"email address.\",\n        [\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */ ]: \"A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.\",\n        [\"no-auth-event\" /* AuthErrorCode.NO_AUTH_EVENT */ ]: \"An internal AuthError has occurred.\",\n        [\"no-such-provider\" /* AuthErrorCode.NO_SUCH_PROVIDER */ ]: \"User was not linked to an account with the given provider.\",\n        [\"null-user\" /* AuthErrorCode.NULL_USER */ ]: \"A null user object was provided as the argument for an operation which \" + \"requires a non-null user object.\",\n        [\"operation-not-allowed\" /* AuthErrorCode.OPERATION_NOT_ALLOWED */ ]: \"The given sign-in provider is disabled for this Firebase project. \" + \"Enable it in the Firebase console, under the sign-in method tab of the \" + \"Auth section.\",\n        [\"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */ ]: \"This operation is not supported in the environment this application is \" + 'running on. \"location.protocol\" must be http, https or chrome-extension' + \" and web storage must be enabled.\",\n        [\"popup-blocked\" /* AuthErrorCode.POPUP_BLOCKED */ ]: \"Unable to establish a connection with the popup. It may have been blocked by the browser.\",\n        [\"popup-closed-by-user\" /* AuthErrorCode.POPUP_CLOSED_BY_USER */ ]: \"The popup has been closed by the user before finalizing the operation.\",\n        [\"provider-already-linked\" /* AuthErrorCode.PROVIDER_ALREADY_LINKED */ ]: \"User can only be linked to one identity for the given provider.\",\n        [\"quota-exceeded\" /* AuthErrorCode.QUOTA_EXCEEDED */ ]: \"The project's quota for this operation has been exceeded.\",\n        [\"redirect-cancelled-by-user\" /* AuthErrorCode.REDIRECT_CANCELLED_BY_USER */ ]: \"The redirect operation has been cancelled by the user before finalizing.\",\n        [\"redirect-operation-pending\" /* AuthErrorCode.REDIRECT_OPERATION_PENDING */ ]: \"A redirect sign-in operation is already pending.\",\n        [\"rejected-credential\" /* AuthErrorCode.REJECTED_CREDENTIAL */ ]: \"The request contains malformed or mismatching credentials.\",\n        [\"second-factor-already-in-use\" /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */ ]: \"The second factor is already enrolled on this account.\",\n        [\"maximum-second-factor-count-exceeded\" /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */ ]: \"The maximum allowed number of second factors on a user has been exceeded.\",\n        [\"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */ ]: \"The provided tenant ID does not match the Auth instance's tenant ID\",\n        [\"timeout\" /* AuthErrorCode.TIMEOUT */ ]: \"The operation has timed out.\",\n        [\"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */ ]: \"The user's credential is no longer valid. The user must sign in again.\",\n        [\"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */ ]: \"We have blocked all requests from this device due to unusual activity. \" + \"Try again later.\",\n        [\"unauthorized-continue-uri\" /* AuthErrorCode.UNAUTHORIZED_DOMAIN */ ]: \"The domain of the continue URL is not whitelisted.  Please whitelist \" + \"the domain in the Firebase console.\",\n        [\"unsupported-first-factor\" /* AuthErrorCode.UNSUPPORTED_FIRST_FACTOR */ ]: \"Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.\",\n        [\"unsupported-persistence-type\" /* AuthErrorCode.UNSUPPORTED_PERSISTENCE */ ]: \"The current environment does not support the specified persistence type.\",\n        [\"unsupported-tenant-operation\" /* AuthErrorCode.UNSUPPORTED_TENANT_OPERATION */ ]: \"This operation is not supported in a multi-tenant context.\",\n        [\"unverified-email\" /* AuthErrorCode.UNVERIFIED_EMAIL */ ]: \"The operation requires a verified email.\",\n        [\"user-cancelled\" /* AuthErrorCode.USER_CANCELLED */ ]: \"The user did not grant your application the permissions it requested.\",\n        [\"user-not-found\" /* AuthErrorCode.USER_DELETED */ ]: \"There is no user record corresponding to this identifier. The user may \" + \"have been deleted.\",\n        [\"user-disabled\" /* AuthErrorCode.USER_DISABLED */ ]: \"The user account has been disabled by an administrator.\",\n        [\"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */ ]: \"The supplied credentials do not correspond to the previously signed in user.\",\n        [\"user-signed-out\" /* AuthErrorCode.USER_SIGNED_OUT */ ]: \"\",\n        [\"weak-password\" /* AuthErrorCode.WEAK_PASSWORD */ ]: \"The password must be 6 characters long or more.\",\n        [\"web-storage-unsupported\" /* AuthErrorCode.WEB_STORAGE_UNSUPPORTED */ ]: \"This browser is not supported or 3rd party cookies and data may be disabled.\",\n        [\"already-initialized\" /* AuthErrorCode.ALREADY_INITIALIZED */ ]: \"initializeAuth() has already been called with \" + \"different options. To avoid this error, call initializeAuth() with the \" + \"same options as when it was originally called, or call getAuth() to return the\" + \" already initialized instance.\",\n        [\"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */ ]: \"The reCAPTCHA token is missing when sending request to the backend.\",\n        [\"invalid-recaptcha-token\" /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */ ]: \"The reCAPTCHA token is invalid when sending request to the backend.\",\n        [\"invalid-recaptcha-action\" /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */ ]: \"The reCAPTCHA action is invalid when sending request to the backend.\",\n        [\"recaptcha-not-enabled\" /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */ ]: \"reCAPTCHA Enterprise integration is not enabled for this project.\",\n        [\"missing-client-type\" /* AuthErrorCode.MISSING_CLIENT_TYPE */ ]: \"The reCAPTCHA client type is missing when sending request to the backend.\",\n        [\"missing-recaptcha-version\" /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */ ]: \"The reCAPTCHA version is missing when sending request to the backend.\",\n        [\"invalid-req-type\" /* AuthErrorCode.INVALID_REQ_TYPE */ ]: \"Invalid request parameters.\",\n        [\"invalid-recaptcha-version\" /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */ ]: \"The reCAPTCHA version is invalid when sending request to the backend.\",\n        [\"unsupported-password-policy-schema-version\" /* AuthErrorCode.UNSUPPORTED_PASSWORD_POLICY_SCHEMA_VERSION */ ]: \"The password policy received from the backend uses a schema version that is not supported by this version of the Firebase SDK.\",\n        [\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */ ]: \"The password does not meet the requirements.\"\n    };\n}\nfunction _prodErrorMap() {\n    // We will include this one message in the prod error map since by the very\n    // nature of this error, developers will never be able to see the message\n    // using the debugErrorMap (which is installed during auth initialization).\n    return {\n        [\"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */ ]: \"Another Firebase SDK was initialized and is trying to use Auth before Auth is \" + \"initialized. Please be sure to call `initializeAuth` or `getAuth` before \" + \"starting any other Firebase SDK.\"\n    };\n}\n/**\r\n * A verbose error map with detailed descriptions for most error codes.\r\n *\r\n * See discussion at {@link AuthErrorMap}\r\n *\r\n * @public\r\n */ const debugErrorMap = _debugErrorMap;\n/**\r\n * A minimal error map with all verbose error messages stripped.\r\n *\r\n * See discussion at {@link AuthErrorMap}\r\n *\r\n * @public\r\n */ const prodErrorMap = _prodErrorMap;\nconst _DEFAULT_AUTH_ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory(\"auth\", \"Firebase\", _prodErrorMap());\n/**\r\n * A map of potential `Auth` error codes, for easier comparison with errors\r\n * thrown by the SDK.\r\n *\r\n * @remarks\r\n * Note that you can't tree-shake individual keys\r\n * in the map, so by using the map you might substantially increase your\r\n * bundle size.\r\n *\r\n * @public\r\n */ const AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY = {\n    ADMIN_ONLY_OPERATION: \"auth/admin-restricted-operation\",\n    ARGUMENT_ERROR: \"auth/argument-error\",\n    APP_NOT_AUTHORIZED: \"auth/app-not-authorized\",\n    APP_NOT_INSTALLED: \"auth/app-not-installed\",\n    CAPTCHA_CHECK_FAILED: \"auth/captcha-check-failed\",\n    CODE_EXPIRED: \"auth/code-expired\",\n    CORDOVA_NOT_READY: \"auth/cordova-not-ready\",\n    CORS_UNSUPPORTED: \"auth/cors-unsupported\",\n    CREDENTIAL_ALREADY_IN_USE: \"auth/credential-already-in-use\",\n    CREDENTIAL_MISMATCH: \"auth/custom-token-mismatch\",\n    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: \"auth/requires-recent-login\",\n    DEPENDENT_SDK_INIT_BEFORE_AUTH: \"auth/dependent-sdk-initialized-before-auth\",\n    DYNAMIC_LINK_NOT_ACTIVATED: \"auth/dynamic-link-not-activated\",\n    EMAIL_CHANGE_NEEDS_VERIFICATION: \"auth/email-change-needs-verification\",\n    EMAIL_EXISTS: \"auth/email-already-in-use\",\n    EMULATOR_CONFIG_FAILED: \"auth/emulator-config-failed\",\n    EXPIRED_OOB_CODE: \"auth/expired-action-code\",\n    EXPIRED_POPUP_REQUEST: \"auth/cancelled-popup-request\",\n    INTERNAL_ERROR: \"auth/internal-error\",\n    INVALID_API_KEY: \"auth/invalid-api-key\",\n    INVALID_APP_CREDENTIAL: \"auth/invalid-app-credential\",\n    INVALID_APP_ID: \"auth/invalid-app-id\",\n    INVALID_AUTH: \"auth/invalid-user-token\",\n    INVALID_AUTH_EVENT: \"auth/invalid-auth-event\",\n    INVALID_CERT_HASH: \"auth/invalid-cert-hash\",\n    INVALID_CODE: \"auth/invalid-verification-code\",\n    INVALID_CONTINUE_URI: \"auth/invalid-continue-uri\",\n    INVALID_CORDOVA_CONFIGURATION: \"auth/invalid-cordova-configuration\",\n    INVALID_CUSTOM_TOKEN: \"auth/invalid-custom-token\",\n    INVALID_DYNAMIC_LINK_DOMAIN: \"auth/invalid-dynamic-link-domain\",\n    INVALID_EMAIL: \"auth/invalid-email\",\n    INVALID_EMULATOR_SCHEME: \"auth/invalid-emulator-scheme\",\n    INVALID_IDP_RESPONSE: \"auth/invalid-credential\",\n    INVALID_LOGIN_CREDENTIALS: \"auth/invalid-credential\",\n    INVALID_MESSAGE_PAYLOAD: \"auth/invalid-message-payload\",\n    INVALID_MFA_SESSION: \"auth/invalid-multi-factor-session\",\n    INVALID_OAUTH_CLIENT_ID: \"auth/invalid-oauth-client-id\",\n    INVALID_OAUTH_PROVIDER: \"auth/invalid-oauth-provider\",\n    INVALID_OOB_CODE: \"auth/invalid-action-code\",\n    INVALID_ORIGIN: \"auth/unauthorized-domain\",\n    INVALID_PASSWORD: \"auth/wrong-password\",\n    INVALID_PERSISTENCE: \"auth/invalid-persistence-type\",\n    INVALID_PHONE_NUMBER: \"auth/invalid-phone-number\",\n    INVALID_PROVIDER_ID: \"auth/invalid-provider-id\",\n    INVALID_RECIPIENT_EMAIL: \"auth/invalid-recipient-email\",\n    INVALID_SENDER: \"auth/invalid-sender\",\n    INVALID_SESSION_INFO: \"auth/invalid-verification-id\",\n    INVALID_TENANT_ID: \"auth/invalid-tenant-id\",\n    MFA_INFO_NOT_FOUND: \"auth/multi-factor-info-not-found\",\n    MFA_REQUIRED: \"auth/multi-factor-auth-required\",\n    MISSING_ANDROID_PACKAGE_NAME: \"auth/missing-android-pkg-name\",\n    MISSING_APP_CREDENTIAL: \"auth/missing-app-credential\",\n    MISSING_AUTH_DOMAIN: \"auth/auth-domain-config-required\",\n    MISSING_CODE: \"auth/missing-verification-code\",\n    MISSING_CONTINUE_URI: \"auth/missing-continue-uri\",\n    MISSING_IFRAME_START: \"auth/missing-iframe-start\",\n    MISSING_IOS_BUNDLE_ID: \"auth/missing-ios-bundle-id\",\n    MISSING_OR_INVALID_NONCE: \"auth/missing-or-invalid-nonce\",\n    MISSING_MFA_INFO: \"auth/missing-multi-factor-info\",\n    MISSING_MFA_SESSION: \"auth/missing-multi-factor-session\",\n    MISSING_PHONE_NUMBER: \"auth/missing-phone-number\",\n    MISSING_SESSION_INFO: \"auth/missing-verification-id\",\n    MODULE_DESTROYED: \"auth/app-deleted\",\n    NEED_CONFIRMATION: \"auth/account-exists-with-different-credential\",\n    NETWORK_REQUEST_FAILED: \"auth/network-request-failed\",\n    NULL_USER: \"auth/null-user\",\n    NO_AUTH_EVENT: \"auth/no-auth-event\",\n    NO_SUCH_PROVIDER: \"auth/no-such-provider\",\n    OPERATION_NOT_ALLOWED: \"auth/operation-not-allowed\",\n    OPERATION_NOT_SUPPORTED: \"auth/operation-not-supported-in-this-environment\",\n    POPUP_BLOCKED: \"auth/popup-blocked\",\n    POPUP_CLOSED_BY_USER: \"auth/popup-closed-by-user\",\n    PROVIDER_ALREADY_LINKED: \"auth/provider-already-linked\",\n    QUOTA_EXCEEDED: \"auth/quota-exceeded\",\n    REDIRECT_CANCELLED_BY_USER: \"auth/redirect-cancelled-by-user\",\n    REDIRECT_OPERATION_PENDING: \"auth/redirect-operation-pending\",\n    REJECTED_CREDENTIAL: \"auth/rejected-credential\",\n    SECOND_FACTOR_ALREADY_ENROLLED: \"auth/second-factor-already-in-use\",\n    SECOND_FACTOR_LIMIT_EXCEEDED: \"auth/maximum-second-factor-count-exceeded\",\n    TENANT_ID_MISMATCH: \"auth/tenant-id-mismatch\",\n    TIMEOUT: \"auth/timeout\",\n    TOKEN_EXPIRED: \"auth/user-token-expired\",\n    TOO_MANY_ATTEMPTS_TRY_LATER: \"auth/too-many-requests\",\n    UNAUTHORIZED_DOMAIN: \"auth/unauthorized-continue-uri\",\n    UNSUPPORTED_FIRST_FACTOR: \"auth/unsupported-first-factor\",\n    UNSUPPORTED_PERSISTENCE: \"auth/unsupported-persistence-type\",\n    UNSUPPORTED_TENANT_OPERATION: \"auth/unsupported-tenant-operation\",\n    UNVERIFIED_EMAIL: \"auth/unverified-email\",\n    USER_CANCELLED: \"auth/user-cancelled\",\n    USER_DELETED: \"auth/user-not-found\",\n    USER_DISABLED: \"auth/user-disabled\",\n    USER_MISMATCH: \"auth/user-mismatch\",\n    USER_SIGNED_OUT: \"auth/user-signed-out\",\n    WEAK_PASSWORD: \"auth/weak-password\",\n    WEB_STORAGE_UNSUPPORTED: \"auth/web-storage-unsupported\",\n    ALREADY_INITIALIZED: \"auth/already-initialized\",\n    RECAPTCHA_NOT_ENABLED: \"auth/recaptcha-not-enabled\",\n    MISSING_RECAPTCHA_TOKEN: \"auth/missing-recaptcha-token\",\n    INVALID_RECAPTCHA_TOKEN: \"auth/invalid-recaptcha-token\",\n    INVALID_RECAPTCHA_ACTION: \"auth/invalid-recaptcha-action\",\n    MISSING_CLIENT_TYPE: \"auth/missing-client-type\",\n    MISSING_RECAPTCHA_VERSION: \"auth/missing-recaptcha-version\",\n    INVALID_RECAPTCHA_VERSION: \"auth/invalid-recaptcha-version\",\n    INVALID_REQ_TYPE: \"auth/invalid-req-type\"\n};\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_4__.Logger(\"@firebase/auth\");\nfunction _logWarn(msg, ...args) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.WARN) {\n        logClient.warn(`Auth (${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}): ${msg}`, ...args);\n    }\n}\nfunction _logError(msg, ...args) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_4__.LogLevel.ERROR) {\n        logClient.error(`Auth (${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}): ${msg}`, ...args);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function _fail(authOrCode, ...rest) {\n    throw createErrorInternal(authOrCode, ...rest);\n}\nfunction _createError(authOrCode, ...rest) {\n    return createErrorInternal(authOrCode, ...rest);\n}\nfunction _errorWithCustomMessage(auth, code, message) {\n    const errorMap = Object.assign(Object.assign({}, prodErrorMap()), {\n        [code]: message\n    });\n    const factory = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory(\"auth\", \"Firebase\", errorMap);\n    return factory.create(code, {\n        appName: auth.name\n    });\n}\nfunction _serverAppCurrentUserOperationNotSupportedError(auth) {\n    return _errorWithCustomMessage(auth, \"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */ , \"Operations that alter the current user are not supported in conjunction with FirebaseServerApp\");\n}\nfunction createErrorInternal(authOrCode, ...rest) {\n    if (typeof authOrCode !== \"string\") {\n        const code = rest[0];\n        const fullParams = [\n            ...rest.slice(1)\n        ];\n        if (fullParams[0]) {\n            fullParams[0].appName = authOrCode.name;\n        }\n        return authOrCode._errorFactory.create(code, ...fullParams);\n    }\n    return _DEFAULT_AUTH_ERROR_FACTORY.create(authOrCode, ...rest);\n}\nfunction _assert(assertion, authOrCode, ...rest) {\n    if (!assertion) {\n        throw createErrorInternal(authOrCode, ...rest);\n    }\n}\n/**\r\n * Unconditionally fails, throwing an internal error with the given message.\r\n *\r\n * @param failure type of failure encountered\r\n * @throws Error\r\n */ function debugFail(failure) {\n    // Log the failure in addition to throw an exception, just in case the\n    // exception is swallowed.\n    const message = `INTERNAL ASSERTION FAILED: ` + failure;\n    _logError(message);\n    // NOTE: We don't use FirebaseError here because these are internal failures\n    // that cannot be handled by the user. (Also it would create a circular\n    // dependency between the error and assert modules which doesn't work.)\n    throw new Error(message);\n}\n/**\r\n * Fails if the given assertion condition is false, throwing an Error with the\r\n * given message if it did.\r\n *\r\n * @param assertion\r\n * @param message\r\n */ function debugAssert(assertion, message) {\n    if (!assertion) {\n        debugFail(message);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function _getCurrentUrl() {\n    var _a;\n    return typeof self !== \"undefined\" && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.href) || \"\";\n}\nfunction _isHttpOrHttps() {\n    return _getCurrentScheme() === \"http:\" || _getCurrentScheme() === \"https:\";\n}\nfunction _getCurrentScheme() {\n    var _a;\n    return typeof self !== \"undefined\" && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.protocol) || null;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Determine whether the browser is working online\r\n */ function _isOnline() {\n    if (typeof navigator !== \"undefined\" && navigator && \"onLine\" in navigator && typeof navigator.onLine === \"boolean\" && // Apply only for traditional web apps and Chrome extensions.\n    // This is especially true for Cordova apps which have unreliable\n    // navigator.onLine behavior unless cordova-plugin-network-information is\n    // installed which overwrites the native navigator.onLine value and\n    // defines navigator.connection.\n    (_isHttpOrHttps() || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isBrowserExtension)() || \"connection\" in navigator)) {\n        return navigator.onLine;\n    }\n    // If we can't determine the state, assume it is online.\n    return true;\n}\nfunction _getUserLanguage() {\n    if (typeof navigator === \"undefined\") {\n        return null;\n    }\n    const navigatorLanguage = navigator;\n    return(// Most reliable, but only supported in Chrome/Firefox.\n    navigatorLanguage.languages && navigatorLanguage.languages[0] || // Supported in most browsers, but returns the language of the browser\n    // UI, not the language set in browser settings.\n    navigatorLanguage.language || // Couldn't determine language.\n    null);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A structure to help pick between a range of long and short delay durations\r\n * depending on the current environment. In general, the long delay is used for\r\n * mobile environments whereas short delays are used for desktop environments.\r\n */ class Delay {\n    constructor(shortDelay, longDelay){\n        this.shortDelay = shortDelay;\n        this.longDelay = longDelay;\n        // Internal error when improperly initialized.\n        debugAssert(longDelay > shortDelay, \"Short delay should be less than long delay!\");\n        this.isMobile = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isMobileCordova)() || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isReactNative)();\n    }\n    get() {\n        if (!_isOnline()) {\n            // Pick the shorter timeout.\n            return Math.min(5000 /* DelayMin.OFFLINE */ , this.shortDelay);\n        }\n        // If running in a mobile environment, return the long delay, otherwise\n        // return the short delay.\n        // This could be improved in the future to dynamically change based on other\n        // variables instead of just reading the current environment.\n        return this.isMobile ? this.longDelay : this.shortDelay;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function _emulatorUrl(config, path) {\n    debugAssert(config.emulator, \"Emulator should always be set here\");\n    const { url } = config.emulator;\n    if (!path) {\n        return url;\n    }\n    return `${url}${path.startsWith(\"/\") ? path.slice(1) : path}`;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class FetchProvider {\n    static initialize(fetchImpl, headersImpl, responseImpl) {\n        this.fetchImpl = fetchImpl;\n        if (headersImpl) {\n            this.headersImpl = headersImpl;\n        }\n        if (responseImpl) {\n            this.responseImpl = responseImpl;\n        }\n    }\n    static fetch() {\n        if (this.fetchImpl) {\n            return this.fetchImpl;\n        }\n        if (typeof self !== \"undefined\" && \"fetch\" in self) {\n            return self.fetch;\n        }\n        if (typeof globalThis !== \"undefined\" && globalThis.fetch) {\n            return globalThis.fetch;\n        }\n        if (typeof fetch !== \"undefined\") {\n            return fetch;\n        }\n        debugFail(\"Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill\");\n    }\n    static headers() {\n        if (this.headersImpl) {\n            return this.headersImpl;\n        }\n        if (typeof self !== \"undefined\" && \"Headers\" in self) {\n            return self.Headers;\n        }\n        if (typeof globalThis !== \"undefined\" && globalThis.Headers) {\n            return globalThis.Headers;\n        }\n        if (typeof Headers !== \"undefined\") {\n            return Headers;\n        }\n        debugFail(\"Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill\");\n    }\n    static response() {\n        if (this.responseImpl) {\n            return this.responseImpl;\n        }\n        if (typeof self !== \"undefined\" && \"Response\" in self) {\n            return self.Response;\n        }\n        if (typeof globalThis !== \"undefined\" && globalThis.Response) {\n            return globalThis.Response;\n        }\n        if (typeof Response !== \"undefined\") {\n            return Response;\n        }\n        debugFail(\"Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Map from errors returned by the server to errors to developer visible errors\r\n */ const SERVER_ERROR_MAP = {\n    // Custom token errors.\n    [\"CREDENTIAL_MISMATCH\" /* ServerError.CREDENTIAL_MISMATCH */ ]: \"custom-token-mismatch\" /* AuthErrorCode.CREDENTIAL_MISMATCH */ ,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_CUSTOM_TOKEN\" /* ServerError.MISSING_CUSTOM_TOKEN */ ]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ ,\n    // Create Auth URI errors.\n    [\"INVALID_IDENTIFIER\" /* ServerError.INVALID_IDENTIFIER */ ]: \"invalid-email\" /* AuthErrorCode.INVALID_EMAIL */ ,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_CONTINUE_URI\" /* ServerError.MISSING_CONTINUE_URI */ ]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ ,\n    // Sign in with email and password errors (some apply to sign up too).\n    [\"INVALID_PASSWORD\" /* ServerError.INVALID_PASSWORD */ ]: \"wrong-password\" /* AuthErrorCode.INVALID_PASSWORD */ ,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_PASSWORD\" /* ServerError.MISSING_PASSWORD */ ]: \"missing-password\" /* AuthErrorCode.MISSING_PASSWORD */ ,\n    // Thrown if Email Enumeration Protection is enabled in the project and the email or password is\n    // invalid.\n    [\"INVALID_LOGIN_CREDENTIALS\" /* ServerError.INVALID_LOGIN_CREDENTIALS */ ]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */ ,\n    // Sign up with email and password errors.\n    [\"EMAIL_EXISTS\" /* ServerError.EMAIL_EXISTS */ ]: \"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */ ,\n    [\"PASSWORD_LOGIN_DISABLED\" /* ServerError.PASSWORD_LOGIN_DISABLED */ ]: \"operation-not-allowed\" /* AuthErrorCode.OPERATION_NOT_ALLOWED */ ,\n    // Verify assertion for sign in with credential errors:\n    [\"INVALID_IDP_RESPONSE\" /* ServerError.INVALID_IDP_RESPONSE */ ]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */ ,\n    [\"INVALID_PENDING_TOKEN\" /* ServerError.INVALID_PENDING_TOKEN */ ]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */ ,\n    [\"FEDERATED_USER_ID_ALREADY_LINKED\" /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */ ]: \"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */ ,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_REQ_TYPE\" /* ServerError.MISSING_REQ_TYPE */ ]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ ,\n    // Send Password reset email errors:\n    [\"EMAIL_NOT_FOUND\" /* ServerError.EMAIL_NOT_FOUND */ ]: \"user-not-found\" /* AuthErrorCode.USER_DELETED */ ,\n    [\"RESET_PASSWORD_EXCEED_LIMIT\" /* ServerError.RESET_PASSWORD_EXCEED_LIMIT */ ]: \"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */ ,\n    [\"EXPIRED_OOB_CODE\" /* ServerError.EXPIRED_OOB_CODE */ ]: \"expired-action-code\" /* AuthErrorCode.EXPIRED_OOB_CODE */ ,\n    [\"INVALID_OOB_CODE\" /* ServerError.INVALID_OOB_CODE */ ]: \"invalid-action-code\" /* AuthErrorCode.INVALID_OOB_CODE */ ,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_OOB_CODE\" /* ServerError.MISSING_OOB_CODE */ ]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ ,\n    // Operations that require ID token in request:\n    [\"CREDENTIAL_TOO_OLD_LOGIN_AGAIN\" /* ServerError.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */ ]: \"requires-recent-login\" /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */ ,\n    [\"INVALID_ID_TOKEN\" /* ServerError.INVALID_ID_TOKEN */ ]: \"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */ ,\n    [\"TOKEN_EXPIRED\" /* ServerError.TOKEN_EXPIRED */ ]: \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */ ,\n    [\"USER_NOT_FOUND\" /* ServerError.USER_NOT_FOUND */ ]: \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */ ,\n    // Other errors.\n    [\"TOO_MANY_ATTEMPTS_TRY_LATER\" /* ServerError.TOO_MANY_ATTEMPTS_TRY_LATER */ ]: \"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */ ,\n    [\"PASSWORD_DOES_NOT_MEET_REQUIREMENTS\" /* ServerError.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */ ]: \"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */ ,\n    // Phone Auth related errors.\n    [\"INVALID_CODE\" /* ServerError.INVALID_CODE */ ]: \"invalid-verification-code\" /* AuthErrorCode.INVALID_CODE */ ,\n    [\"INVALID_SESSION_INFO\" /* ServerError.INVALID_SESSION_INFO */ ]: \"invalid-verification-id\" /* AuthErrorCode.INVALID_SESSION_INFO */ ,\n    [\"INVALID_TEMPORARY_PROOF\" /* ServerError.INVALID_TEMPORARY_PROOF */ ]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */ ,\n    [\"MISSING_SESSION_INFO\" /* ServerError.MISSING_SESSION_INFO */ ]: \"missing-verification-id\" /* AuthErrorCode.MISSING_SESSION_INFO */ ,\n    [\"SESSION_EXPIRED\" /* ServerError.SESSION_EXPIRED */ ]: \"code-expired\" /* AuthErrorCode.CODE_EXPIRED */ ,\n    // Other action code errors when additional settings passed.\n    // MISSING_CONTINUE_URI is getting mapped to INTERNAL_ERROR above.\n    // This is OK as this error will be caught by client side validation.\n    [\"MISSING_ANDROID_PACKAGE_NAME\" /* ServerError.MISSING_ANDROID_PACKAGE_NAME */ ]: \"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */ ,\n    [\"UNAUTHORIZED_DOMAIN\" /* ServerError.UNAUTHORIZED_DOMAIN */ ]: \"unauthorized-continue-uri\" /* AuthErrorCode.UNAUTHORIZED_DOMAIN */ ,\n    // getProjectConfig errors when clientId is passed.\n    [\"INVALID_OAUTH_CLIENT_ID\" /* ServerError.INVALID_OAUTH_CLIENT_ID */ ]: \"invalid-oauth-client-id\" /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */ ,\n    // User actions (sign-up or deletion) disabled errors.\n    [\"ADMIN_ONLY_OPERATION\" /* ServerError.ADMIN_ONLY_OPERATION */ ]: \"admin-restricted-operation\" /* AuthErrorCode.ADMIN_ONLY_OPERATION */ ,\n    // Multi factor related errors.\n    [\"INVALID_MFA_PENDING_CREDENTIAL\" /* ServerError.INVALID_MFA_PENDING_CREDENTIAL */ ]: \"invalid-multi-factor-session\" /* AuthErrorCode.INVALID_MFA_SESSION */ ,\n    [\"MFA_ENROLLMENT_NOT_FOUND\" /* ServerError.MFA_ENROLLMENT_NOT_FOUND */ ]: \"multi-factor-info-not-found\" /* AuthErrorCode.MFA_INFO_NOT_FOUND */ ,\n    [\"MISSING_MFA_ENROLLMENT_ID\" /* ServerError.MISSING_MFA_ENROLLMENT_ID */ ]: \"missing-multi-factor-info\" /* AuthErrorCode.MISSING_MFA_INFO */ ,\n    [\"MISSING_MFA_PENDING_CREDENTIAL\" /* ServerError.MISSING_MFA_PENDING_CREDENTIAL */ ]: \"missing-multi-factor-session\" /* AuthErrorCode.MISSING_MFA_SESSION */ ,\n    [\"SECOND_FACTOR_EXISTS\" /* ServerError.SECOND_FACTOR_EXISTS */ ]: \"second-factor-already-in-use\" /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */ ,\n    [\"SECOND_FACTOR_LIMIT_EXCEEDED\" /* ServerError.SECOND_FACTOR_LIMIT_EXCEEDED */ ]: \"maximum-second-factor-count-exceeded\" /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */ ,\n    // Blocking functions related errors.\n    [\"BLOCKING_FUNCTION_ERROR_RESPONSE\" /* ServerError.BLOCKING_FUNCTION_ERROR_RESPONSE */ ]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ ,\n    // Recaptcha related errors.\n    [\"RECAPTCHA_NOT_ENABLED\" /* ServerError.RECAPTCHA_NOT_ENABLED */ ]: \"recaptcha-not-enabled\" /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */ ,\n    [\"MISSING_RECAPTCHA_TOKEN\" /* ServerError.MISSING_RECAPTCHA_TOKEN */ ]: \"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */ ,\n    [\"INVALID_RECAPTCHA_TOKEN\" /* ServerError.INVALID_RECAPTCHA_TOKEN */ ]: \"invalid-recaptcha-token\" /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */ ,\n    [\"INVALID_RECAPTCHA_ACTION\" /* ServerError.INVALID_RECAPTCHA_ACTION */ ]: \"invalid-recaptcha-action\" /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */ ,\n    [\"MISSING_CLIENT_TYPE\" /* ServerError.MISSING_CLIENT_TYPE */ ]: \"missing-client-type\" /* AuthErrorCode.MISSING_CLIENT_TYPE */ ,\n    [\"MISSING_RECAPTCHA_VERSION\" /* ServerError.MISSING_RECAPTCHA_VERSION */ ]: \"missing-recaptcha-version\" /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */ ,\n    [\"INVALID_RECAPTCHA_VERSION\" /* ServerError.INVALID_RECAPTCHA_VERSION */ ]: \"invalid-recaptcha-version\" /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */ ,\n    [\"INVALID_REQ_TYPE\" /* ServerError.INVALID_REQ_TYPE */ ]: \"invalid-req-type\" /* AuthErrorCode.INVALID_REQ_TYPE */ \n};\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const DEFAULT_API_TIMEOUT_MS = new Delay(30000, 60000);\nfunction _addTidIfNecessary(auth, request) {\n    if (auth.tenantId && !request.tenantId) {\n        return Object.assign(Object.assign({}, request), {\n            tenantId: auth.tenantId\n        });\n    }\n    return request;\n}\nasync function _performApiRequest(auth, method, path, request, customErrorMap = {}) {\n    return _performFetchWithErrorHandling(auth, customErrorMap, async ()=>{\n        let body = {};\n        let params = {};\n        if (request) {\n            if (method === \"GET\" /* HttpMethod.GET */ ) {\n                params = request;\n            } else {\n                body = {\n                    body: JSON.stringify(request)\n                };\n            }\n        }\n        const query = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)(Object.assign({\n            key: auth.config.apiKey\n        }, params)).slice(1);\n        const headers = await auth._getAdditionalHeaders();\n        headers[\"Content-Type\" /* HttpHeader.CONTENT_TYPE */ ] = \"application/json\";\n        if (auth.languageCode) {\n            headers[\"X-Firebase-Locale\" /* HttpHeader.X_FIREBASE_LOCALE */ ] = auth.languageCode;\n        }\n        return FetchProvider.fetch()(_getFinalTarget(auth, auth.config.apiHost, path, query), Object.assign({\n            method,\n            headers,\n            referrerPolicy: \"no-referrer\"\n        }, body));\n    });\n}\nasync function _performFetchWithErrorHandling(auth, customErrorMap, fetchFn) {\n    auth._canInitEmulator = false;\n    const errorMap = Object.assign(Object.assign({}, SERVER_ERROR_MAP), customErrorMap);\n    try {\n        const networkTimeout = new NetworkTimeout(auth);\n        const response = await Promise.race([\n            fetchFn(),\n            networkTimeout.promise\n        ]);\n        // If we've reached this point, the fetch succeeded and the networkTimeout\n        // didn't throw; clear the network timeout delay so that Node won't hang\n        networkTimeout.clearNetworkTimeout();\n        const json = await response.json();\n        if (\"needConfirmation\" in json) {\n            throw _makeTaggedError(auth, \"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */ , json);\n        }\n        if (response.ok && !(\"errorMessage\" in json)) {\n            return json;\n        } else {\n            const errorMessage = response.ok ? json.errorMessage : json.error.message;\n            const [serverErrorCode, serverErrorMessage] = errorMessage.split(\" : \");\n            if (serverErrorCode === \"FEDERATED_USER_ID_ALREADY_LINKED\" /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */ ) {\n                throw _makeTaggedError(auth, \"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */ , json);\n            } else if (serverErrorCode === \"EMAIL_EXISTS\" /* ServerError.EMAIL_EXISTS */ ) {\n                throw _makeTaggedError(auth, \"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */ , json);\n            } else if (serverErrorCode === \"USER_DISABLED\" /* ServerError.USER_DISABLED */ ) {\n                throw _makeTaggedError(auth, \"user-disabled\" /* AuthErrorCode.USER_DISABLED */ , json);\n            }\n            const authError = errorMap[serverErrorCode] || serverErrorCode.toLowerCase().replace(/[_\\s]+/g, \"-\");\n            if (serverErrorMessage) {\n                throw _errorWithCustomMessage(auth, authError, serverErrorMessage);\n            } else {\n                _fail(auth, authError);\n            }\n        }\n    } catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError) {\n            throw e;\n        }\n        // Changing this to a different error code will log user out when there is a network error\n        // because we treat any error other than NETWORK_REQUEST_FAILED as token is invalid.\n        // https://github.com/firebase/firebase-js-sdk/blob/4fbc73610d70be4e0852e7de63a39cb7897e8546/packages/auth/src/core/auth/auth_impl.ts#L309-L316\n        _fail(auth, \"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */ , {\n            \"message\": String(e)\n        });\n    }\n}\nasync function _performSignInRequest(auth, method, path, request, customErrorMap = {}) {\n    const serverResponse = await _performApiRequest(auth, method, path, request, customErrorMap);\n    if (\"mfaPendingCredential\" in serverResponse) {\n        _fail(auth, \"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */ , {\n            _serverResponse: serverResponse\n        });\n    }\n    return serverResponse;\n}\nfunction _getFinalTarget(auth, host, path, query) {\n    const base = `${host}${path}?${query}`;\n    if (!auth.config.emulator) {\n        return `${auth.config.apiScheme}://${base}`;\n    }\n    return _emulatorUrl(auth.config, base);\n}\nfunction _parseEnforcementState(enforcementStateStr) {\n    switch(enforcementStateStr){\n        case \"ENFORCE\":\n            return \"ENFORCE\" /* EnforcementState.ENFORCE */ ;\n        case \"AUDIT\":\n            return \"AUDIT\" /* EnforcementState.AUDIT */ ;\n        case \"OFF\":\n            return \"OFF\" /* EnforcementState.OFF */ ;\n        default:\n            return \"ENFORCEMENT_STATE_UNSPECIFIED\" /* EnforcementState.ENFORCEMENT_STATE_UNSPECIFIED */ ;\n    }\n}\nclass NetworkTimeout {\n    constructor(auth){\n        this.auth = auth;\n        // Node timers and browser timers are fundamentally incompatible, but we\n        // don't care about the value here\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.timer = null;\n        this.promise = new Promise((_, reject)=>{\n            this.timer = setTimeout(()=>{\n                return reject(_createError(this.auth, \"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */ ));\n            }, DEFAULT_API_TIMEOUT_MS.get());\n        });\n    }\n    clearNetworkTimeout() {\n        clearTimeout(this.timer);\n    }\n}\nfunction _makeTaggedError(auth, code, response) {\n    const errorParams = {\n        appName: auth.name\n    };\n    if (response.email) {\n        errorParams.email = response.email;\n    }\n    if (response.phoneNumber) {\n        errorParams.phoneNumber = response.phoneNumber;\n    }\n    const error = _createError(auth, code, errorParams);\n    // We know customData is defined on error because errorParams is defined\n    error.customData._tokenResponse = response;\n    return error;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function isEnterprise(grecaptcha) {\n    return grecaptcha !== undefined && grecaptcha.enterprise !== undefined;\n}\nclass RecaptchaConfig {\n    constructor(response){\n        /**\r\n         * The reCAPTCHA site key.\r\n         */ this.siteKey = \"\";\n        /**\r\n         * The list of providers and their enablement status for reCAPTCHA Enterprise.\r\n         */ this.recaptchaEnforcementState = [];\n        if (response.recaptchaKey === undefined) {\n            throw new Error(\"recaptchaKey undefined\");\n        }\n        // Example response.recaptchaKey: \"projects/proj123/keys/sitekey123\"\n        this.siteKey = response.recaptchaKey.split(\"/\")[3];\n        this.recaptchaEnforcementState = response.recaptchaEnforcementState;\n    }\n    /**\r\n     * Returns the reCAPTCHA Enterprise enforcement state for the given provider.\r\n     *\r\n     * @param providerStr - The provider whose enforcement state is to be returned.\r\n     * @returns The reCAPTCHA Enterprise enforcement state for the given provider.\r\n     */ getProviderEnforcementState(providerStr) {\n        if (!this.recaptchaEnforcementState || this.recaptchaEnforcementState.length === 0) {\n            return null;\n        }\n        for (const recaptchaEnforcementState of this.recaptchaEnforcementState){\n            if (recaptchaEnforcementState.provider && recaptchaEnforcementState.provider === providerStr) {\n                return _parseEnforcementState(recaptchaEnforcementState.enforcementState);\n            }\n        }\n        return null;\n    }\n    /**\r\n     * Returns true if the reCAPTCHA Enterprise enforcement state for the provider is set to ENFORCE or AUDIT.\r\n     *\r\n     * @param providerStr - The provider whose enablement state is to be returned.\r\n     * @returns Whether or not reCAPTCHA Enterprise protection is enabled for the given provider.\r\n     */ isProviderEnabled(providerStr) {\n        return this.getProviderEnforcementState(providerStr) === \"ENFORCE\" /* EnforcementState.ENFORCE */  || this.getProviderEnforcementState(providerStr) === \"AUDIT\" /* EnforcementState.AUDIT */ ;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function getRecaptchaConfig(auth, request) {\n    return _performApiRequest(auth, \"GET\" /* HttpMethod.GET */ , \"/v2/recaptchaConfig\" /* Endpoint.GET_RECAPTCHA_CONFIG */ , _addTidIfNecessary(auth, request));\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function deleteAccount(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:delete\" /* Endpoint.DELETE_ACCOUNT */ , request);\n}\nasync function deleteLinkedAccounts(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */ , request);\n}\nasync function getAccountInfo(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:lookup\" /* Endpoint.GET_ACCOUNT_INFO */ , request);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function utcTimestampToDateString(utcTimestamp) {\n    if (!utcTimestamp) {\n        return undefined;\n    }\n    try {\n        // Convert to date object.\n        const date = new Date(Number(utcTimestamp));\n        // Test date is valid.\n        if (!isNaN(date.getTime())) {\n            // Convert to UTC date string.\n            return date.toUTCString();\n        }\n    } catch (e) {\n    // Do nothing. undefined will be returned.\n    }\n    return undefined;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns a JSON Web Token (JWT) used to identify the user to a Firebase service.\r\n *\r\n * @remarks\r\n * Returns the current token if it has not expired or if it will not expire in the next five\r\n * minutes. Otherwise, this will refresh the token and return a new one.\r\n *\r\n * @param user - The user.\r\n * @param forceRefresh - Force refresh regardless of token expiration.\r\n *\r\n * @public\r\n */ function getIdToken(user, forceRefresh = false) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user).getIdToken(forceRefresh);\n}\n/**\r\n * Returns a deserialized JSON Web Token (JWT) used to identify the user to a Firebase service.\r\n *\r\n * @remarks\r\n * Returns the current token if it has not expired or if it will not expire in the next five\r\n * minutes. Otherwise, this will refresh the token and return a new one.\r\n *\r\n * @param user - The user.\r\n * @param forceRefresh - Force refresh regardless of token expiration.\r\n *\r\n * @public\r\n */ async function getIdTokenResult(user, forceRefresh = false) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const token = await userInternal.getIdToken(forceRefresh);\n    const claims = _parseToken(token);\n    _assert(claims && claims.exp && claims.auth_time && claims.iat, userInternal.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n    const firebase = typeof claims.firebase === \"object\" ? claims.firebase : undefined;\n    const signInProvider = firebase === null || firebase === void 0 ? void 0 : firebase[\"sign_in_provider\"];\n    return {\n        claims,\n        token,\n        authTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.auth_time)),\n        issuedAtTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.iat)),\n        expirationTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.exp)),\n        signInProvider: signInProvider || null,\n        signInSecondFactor: (firebase === null || firebase === void 0 ? void 0 : firebase[\"sign_in_second_factor\"]) || null\n    };\n}\nfunction secondsStringToMilliseconds(seconds) {\n    return Number(seconds) * 1000;\n}\nfunction _parseToken(token) {\n    const [algorithm, payload, signature] = token.split(\".\");\n    if (algorithm === undefined || payload === undefined || signature === undefined) {\n        _logError(\"JWT malformed, contained fewer than 3 sections\");\n        return null;\n    }\n    try {\n        const decoded = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.base64Decode)(payload);\n        if (!decoded) {\n            _logError(\"Failed to decode base64 JWT payload\");\n            return null;\n        }\n        return JSON.parse(decoded);\n    } catch (e) {\n        _logError(\"Caught error parsing JWT payload as JSON\", e === null || e === void 0 ? void 0 : e.toString());\n        return null;\n    }\n}\n/**\r\n * Extract expiresIn TTL from a token by subtracting the expiration from the issuance.\r\n */ function _tokenExpiresIn(token) {\n    const parsedToken = _parseToken(token);\n    _assert(parsedToken, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n    _assert(typeof parsedToken.exp !== \"undefined\", \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n    _assert(typeof parsedToken.iat !== \"undefined\", \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n    return Number(parsedToken.exp) - Number(parsedToken.iat);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function _logoutIfInvalidated(user, promise, bypassAuthState = false) {\n    if (bypassAuthState) {\n        return promise;\n    }\n    try {\n        return await promise;\n    } catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError && isUserInvalidated(e)) {\n            if (user.auth.currentUser === user) {\n                await user.auth.signOut();\n            }\n        }\n        throw e;\n    }\n}\nfunction isUserInvalidated({ code }) {\n    return code === `auth/${\"user-disabled\" /* AuthErrorCode.USER_DISABLED */ }` || code === `auth/${\"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */ }`;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class ProactiveRefresh {\n    constructor(user){\n        this.user = user;\n        this.isRunning = false;\n        // Node timers and browser timers return fundamentally different types.\n        // We don't actually care what the value is but TS won't accept unknown and\n        // we can't cast properly in both environments.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.timerId = null;\n        this.errorBackoff = 30000 /* Duration.RETRY_BACKOFF_MIN */ ;\n    }\n    _start() {\n        if (this.isRunning) {\n            return;\n        }\n        this.isRunning = true;\n        this.schedule();\n    }\n    _stop() {\n        if (!this.isRunning) {\n            return;\n        }\n        this.isRunning = false;\n        if (this.timerId !== null) {\n            clearTimeout(this.timerId);\n        }\n    }\n    getInterval(wasError) {\n        var _a;\n        if (wasError) {\n            const interval = this.errorBackoff;\n            this.errorBackoff = Math.min(this.errorBackoff * 2, 960000 /* Duration.RETRY_BACKOFF_MAX */ );\n            return interval;\n        } else {\n            // Reset the error backoff\n            this.errorBackoff = 30000 /* Duration.RETRY_BACKOFF_MIN */ ;\n            const expTime = (_a = this.user.stsTokenManager.expirationTime) !== null && _a !== void 0 ? _a : 0;\n            const interval = expTime - Date.now() - 300000 /* Duration.OFFSET */ ;\n            return Math.max(0, interval);\n        }\n    }\n    schedule(wasError = false) {\n        if (!this.isRunning) {\n            // Just in case...\n            return;\n        }\n        const interval = this.getInterval(wasError);\n        this.timerId = setTimeout(async ()=>{\n            await this.iteration();\n        }, interval);\n    }\n    async iteration() {\n        try {\n            await this.user.getIdToken(true);\n        } catch (e) {\n            // Only retry on network errors\n            if ((e === null || e === void 0 ? void 0 : e.code) === `auth/${\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */ }`) {\n                this.schedule(/* wasError */ true);\n            }\n            return;\n        }\n        this.schedule();\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class UserMetadata {\n    constructor(createdAt, lastLoginAt){\n        this.createdAt = createdAt;\n        this.lastLoginAt = lastLoginAt;\n        this._initializeTime();\n    }\n    _initializeTime() {\n        this.lastSignInTime = utcTimestampToDateString(this.lastLoginAt);\n        this.creationTime = utcTimestampToDateString(this.createdAt);\n    }\n    _copy(metadata) {\n        this.createdAt = metadata.createdAt;\n        this.lastLoginAt = metadata.lastLoginAt;\n        this._initializeTime();\n    }\n    toJSON() {\n        return {\n            createdAt: this.createdAt,\n            lastLoginAt: this.lastLoginAt\n        };\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function _reloadWithoutSaving(user) {\n    var _a;\n    const auth = user.auth;\n    const idToken = await user.getIdToken();\n    const response = await _logoutIfInvalidated(user, getAccountInfo(auth, {\n        idToken\n    }));\n    _assert(response === null || response === void 0 ? void 0 : response.users.length, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n    const coreAccount = response.users[0];\n    user._notifyReloadListener(coreAccount);\n    const newProviderData = ((_a = coreAccount.providerUserInfo) === null || _a === void 0 ? void 0 : _a.length) ? extractProviderData(coreAccount.providerUserInfo) : [];\n    const providerData = mergeProviderData(user.providerData, newProviderData);\n    // Preserves the non-nonymous status of the stored user, even if no more\n    // credentials (federated or email/password) are linked to the user. If\n    // the user was previously anonymous, then use provider data to update.\n    // On the other hand, if it was not anonymous before, it should never be\n    // considered anonymous now.\n    const oldIsAnonymous = user.isAnonymous;\n    const newIsAnonymous = !(user.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);\n    const isAnonymous = !oldIsAnonymous ? false : newIsAnonymous;\n    const updates = {\n        uid: coreAccount.localId,\n        displayName: coreAccount.displayName || null,\n        photoURL: coreAccount.photoUrl || null,\n        email: coreAccount.email || null,\n        emailVerified: coreAccount.emailVerified || false,\n        phoneNumber: coreAccount.phoneNumber || null,\n        tenantId: coreAccount.tenantId || null,\n        providerData,\n        metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),\n        isAnonymous\n    };\n    Object.assign(user, updates);\n}\n/**\r\n * Reloads user account data, if signed in.\r\n *\r\n * @param user - The user.\r\n *\r\n * @public\r\n */ async function reload(user) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    await _reloadWithoutSaving(userInternal);\n    // Even though the current user hasn't changed, update\n    // current user will trigger a persistence update w/ the\n    // new info.\n    await userInternal.auth._persistUserIfCurrent(userInternal);\n    userInternal.auth._notifyListenersIfCurrent(userInternal);\n}\nfunction mergeProviderData(original, newData) {\n    const deduped = original.filter((o)=>!newData.some((n)=>n.providerId === o.providerId));\n    return [\n        ...deduped,\n        ...newData\n    ];\n}\nfunction extractProviderData(providers) {\n    return providers.map((_a)=>{\n        var { providerId } = _a, provider = (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__rest)(_a, [\n            \"providerId\"\n        ]);\n        return {\n            providerId,\n            uid: provider.rawId || \"\",\n            displayName: provider.displayName || null,\n            email: provider.email || null,\n            phoneNumber: provider.phoneNumber || null,\n            photoURL: provider.photoUrl || null\n        };\n    });\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function requestStsToken(auth, refreshToken) {\n    const response = await _performFetchWithErrorHandling(auth, {}, async ()=>{\n        const body = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)({\n            \"grant_type\": \"refresh_token\",\n            \"refresh_token\": refreshToken\n        }).slice(1);\n        const { tokenApiHost, apiKey } = auth.config;\n        const url = _getFinalTarget(auth, tokenApiHost, \"/v1/token\" /* Endpoint.TOKEN */ , `key=${apiKey}`);\n        const headers = await auth._getAdditionalHeaders();\n        headers[\"Content-Type\" /* HttpHeader.CONTENT_TYPE */ ] = \"application/x-www-form-urlencoded\";\n        return FetchProvider.fetch()(url, {\n            method: \"POST\" /* HttpMethod.POST */ ,\n            headers,\n            body\n        });\n    });\n    // The response comes back in snake_case. Convert to camel:\n    return {\n        accessToken: response.access_token,\n        expiresIn: response.expires_in,\n        refreshToken: response.refresh_token\n    };\n}\nasync function revokeToken(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v2/accounts:revokeToken\" /* Endpoint.REVOKE_TOKEN */ , _addTidIfNecessary(auth, request));\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * We need to mark this class as internal explicitly to exclude it in the public typings, because\r\n * it references AuthInternal which has a circular dependency with UserInternal.\r\n *\r\n * @internal\r\n */ class StsTokenManager {\n    constructor(){\n        this.refreshToken = null;\n        this.accessToken = null;\n        this.expirationTime = null;\n    }\n    get isExpired() {\n        return !this.expirationTime || Date.now() > this.expirationTime - 30000 /* Buffer.TOKEN_REFRESH */ ;\n    }\n    updateFromServerResponse(response) {\n        _assert(response.idToken, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        _assert(typeof response.idToken !== \"undefined\", \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        _assert(typeof response.refreshToken !== \"undefined\", \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        const expiresIn = \"expiresIn\" in response && typeof response.expiresIn !== \"undefined\" ? Number(response.expiresIn) : _tokenExpiresIn(response.idToken);\n        this.updateTokensAndExpiration(response.idToken, response.refreshToken, expiresIn);\n    }\n    updateFromIdToken(idToken) {\n        _assert(idToken.length !== 0, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        const expiresIn = _tokenExpiresIn(idToken);\n        this.updateTokensAndExpiration(idToken, null, expiresIn);\n    }\n    async getToken(auth, forceRefresh = false) {\n        if (!forceRefresh && this.accessToken && !this.isExpired) {\n            return this.accessToken;\n        }\n        _assert(this.refreshToken, auth, \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */ );\n        if (this.refreshToken) {\n            await this.refresh(auth, this.refreshToken);\n            return this.accessToken;\n        }\n        return null;\n    }\n    clearRefreshToken() {\n        this.refreshToken = null;\n    }\n    async refresh(auth, oldToken) {\n        const { accessToken, refreshToken, expiresIn } = await requestStsToken(auth, oldToken);\n        this.updateTokensAndExpiration(accessToken, refreshToken, Number(expiresIn));\n    }\n    updateTokensAndExpiration(accessToken, refreshToken, expiresInSec) {\n        this.refreshToken = refreshToken || null;\n        this.accessToken = accessToken || null;\n        this.expirationTime = Date.now() + expiresInSec * 1000;\n    }\n    static fromJSON(appName, object) {\n        const { refreshToken, accessToken, expirationTime } = object;\n        const manager = new StsTokenManager();\n        if (refreshToken) {\n            _assert(typeof refreshToken === \"string\", \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ , {\n                appName\n            });\n            manager.refreshToken = refreshToken;\n        }\n        if (accessToken) {\n            _assert(typeof accessToken === \"string\", \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ , {\n                appName\n            });\n            manager.accessToken = accessToken;\n        }\n        if (expirationTime) {\n            _assert(typeof expirationTime === \"number\", \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ , {\n                appName\n            });\n            manager.expirationTime = expirationTime;\n        }\n        return manager;\n    }\n    toJSON() {\n        return {\n            refreshToken: this.refreshToken,\n            accessToken: this.accessToken,\n            expirationTime: this.expirationTime\n        };\n    }\n    _assign(stsTokenManager) {\n        this.accessToken = stsTokenManager.accessToken;\n        this.refreshToken = stsTokenManager.refreshToken;\n        this.expirationTime = stsTokenManager.expirationTime;\n    }\n    _clone() {\n        return Object.assign(new StsTokenManager(), this.toJSON());\n    }\n    _performRefresh() {\n        return debugFail(\"not implemented\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function assertStringOrUndefined(assertion, appName) {\n    _assert(typeof assertion === \"string\" || typeof assertion === \"undefined\", \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ , {\n        appName\n    });\n}\nclass UserImpl {\n    constructor(_a){\n        var { uid, auth, stsTokenManager } = _a, opt = (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__rest)(_a, [\n            \"uid\",\n            \"auth\",\n            \"stsTokenManager\"\n        ]);\n        // For the user object, provider is always Firebase.\n        this.providerId = \"firebase\" /* ProviderId.FIREBASE */ ;\n        this.proactiveRefresh = new ProactiveRefresh(this);\n        this.reloadUserInfo = null;\n        this.reloadListener = null;\n        this.uid = uid;\n        this.auth = auth;\n        this.stsTokenManager = stsTokenManager;\n        this.accessToken = stsTokenManager.accessToken;\n        this.displayName = opt.displayName || null;\n        this.email = opt.email || null;\n        this.emailVerified = opt.emailVerified || false;\n        this.phoneNumber = opt.phoneNumber || null;\n        this.photoURL = opt.photoURL || null;\n        this.isAnonymous = opt.isAnonymous || false;\n        this.tenantId = opt.tenantId || null;\n        this.providerData = opt.providerData ? [\n            ...opt.providerData\n        ] : [];\n        this.metadata = new UserMetadata(opt.createdAt || undefined, opt.lastLoginAt || undefined);\n    }\n    async getIdToken(forceRefresh) {\n        const accessToken = await _logoutIfInvalidated(this, this.stsTokenManager.getToken(this.auth, forceRefresh));\n        _assert(accessToken, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        if (this.accessToken !== accessToken) {\n            this.accessToken = accessToken;\n            await this.auth._persistUserIfCurrent(this);\n            this.auth._notifyListenersIfCurrent(this);\n        }\n        return accessToken;\n    }\n    getIdTokenResult(forceRefresh) {\n        return getIdTokenResult(this, forceRefresh);\n    }\n    reload() {\n        return reload(this);\n    }\n    _assign(user) {\n        if (this === user) {\n            return;\n        }\n        _assert(this.uid === user.uid, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        this.displayName = user.displayName;\n        this.photoURL = user.photoURL;\n        this.email = user.email;\n        this.emailVerified = user.emailVerified;\n        this.phoneNumber = user.phoneNumber;\n        this.isAnonymous = user.isAnonymous;\n        this.tenantId = user.tenantId;\n        this.providerData = user.providerData.map((userInfo)=>Object.assign({}, userInfo));\n        this.metadata._copy(user.metadata);\n        this.stsTokenManager._assign(user.stsTokenManager);\n    }\n    _clone(auth) {\n        const newUser = new UserImpl(Object.assign(Object.assign({}, this), {\n            auth,\n            stsTokenManager: this.stsTokenManager._clone()\n        }));\n        newUser.metadata._copy(this.metadata);\n        return newUser;\n    }\n    _onReload(callback) {\n        // There should only ever be one listener, and that is a single instance of MultiFactorUser\n        _assert(!this.reloadListener, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        this.reloadListener = callback;\n        if (this.reloadUserInfo) {\n            this._notifyReloadListener(this.reloadUserInfo);\n            this.reloadUserInfo = null;\n        }\n    }\n    _notifyReloadListener(userInfo) {\n        if (this.reloadListener) {\n            this.reloadListener(userInfo);\n        } else {\n            // If no listener is subscribed yet, save the result so it's available when they do subscribe\n            this.reloadUserInfo = userInfo;\n        }\n    }\n    _startProactiveRefresh() {\n        this.proactiveRefresh._start();\n    }\n    _stopProactiveRefresh() {\n        this.proactiveRefresh._stop();\n    }\n    async _updateTokensIfNecessary(response, reload = false) {\n        let tokensRefreshed = false;\n        if (response.idToken && response.idToken !== this.stsTokenManager.accessToken) {\n            this.stsTokenManager.updateFromServerResponse(response);\n            tokensRefreshed = true;\n        }\n        if (reload) {\n            await _reloadWithoutSaving(this);\n        }\n        await this.auth._persistUserIfCurrent(this);\n        if (tokensRefreshed) {\n            this.auth._notifyListenersIfCurrent(this);\n        }\n    }\n    async delete() {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.auth.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this.auth));\n        }\n        const idToken = await this.getIdToken();\n        await _logoutIfInvalidated(this, deleteAccount(this.auth, {\n            idToken\n        }));\n        this.stsTokenManager.clearRefreshToken();\n        // TODO: Determine if cancellable-promises are necessary to use in this class so that delete()\n        //       cancels pending actions...\n        return this.auth.signOut();\n    }\n    toJSON() {\n        return Object.assign(Object.assign({\n            uid: this.uid,\n            email: this.email || undefined,\n            emailVerified: this.emailVerified,\n            displayName: this.displayName || undefined,\n            isAnonymous: this.isAnonymous,\n            photoURL: this.photoURL || undefined,\n            phoneNumber: this.phoneNumber || undefined,\n            tenantId: this.tenantId || undefined,\n            providerData: this.providerData.map((userInfo)=>Object.assign({}, userInfo)),\n            stsTokenManager: this.stsTokenManager.toJSON(),\n            // Redirect event ID must be maintained in case there is a pending\n            // redirect event.\n            _redirectEventId: this._redirectEventId\n        }, this.metadata.toJSON()), {\n            // Required for compatibility with the legacy SDK (go/firebase-auth-sdk-persistence-parsing):\n            apiKey: this.auth.config.apiKey,\n            appName: this.auth.name\n        });\n    }\n    get refreshToken() {\n        return this.stsTokenManager.refreshToken || \"\";\n    }\n    static _fromJSON(auth, object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        const displayName = (_a = object.displayName) !== null && _a !== void 0 ? _a : undefined;\n        const email = (_b = object.email) !== null && _b !== void 0 ? _b : undefined;\n        const phoneNumber = (_c = object.phoneNumber) !== null && _c !== void 0 ? _c : undefined;\n        const photoURL = (_d = object.photoURL) !== null && _d !== void 0 ? _d : undefined;\n        const tenantId = (_e = object.tenantId) !== null && _e !== void 0 ? _e : undefined;\n        const _redirectEventId = (_f = object._redirectEventId) !== null && _f !== void 0 ? _f : undefined;\n        const createdAt = (_g = object.createdAt) !== null && _g !== void 0 ? _g : undefined;\n        const lastLoginAt = (_h = object.lastLoginAt) !== null && _h !== void 0 ? _h : undefined;\n        const { uid, emailVerified, isAnonymous, providerData, stsTokenManager: plainObjectTokenManager } = object;\n        _assert(uid && plainObjectTokenManager, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        const stsTokenManager = StsTokenManager.fromJSON(this.name, plainObjectTokenManager);\n        _assert(typeof uid === \"string\", auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        assertStringOrUndefined(displayName, auth.name);\n        assertStringOrUndefined(email, auth.name);\n        _assert(typeof emailVerified === \"boolean\", auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        _assert(typeof isAnonymous === \"boolean\", auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        assertStringOrUndefined(phoneNumber, auth.name);\n        assertStringOrUndefined(photoURL, auth.name);\n        assertStringOrUndefined(tenantId, auth.name);\n        assertStringOrUndefined(_redirectEventId, auth.name);\n        assertStringOrUndefined(createdAt, auth.name);\n        assertStringOrUndefined(lastLoginAt, auth.name);\n        const user = new UserImpl({\n            uid,\n            auth,\n            email,\n            emailVerified,\n            displayName,\n            isAnonymous,\n            photoURL,\n            phoneNumber,\n            tenantId,\n            stsTokenManager,\n            createdAt,\n            lastLoginAt\n        });\n        if (providerData && Array.isArray(providerData)) {\n            user.providerData = providerData.map((userInfo)=>Object.assign({}, userInfo));\n        }\n        if (_redirectEventId) {\n            user._redirectEventId = _redirectEventId;\n        }\n        return user;\n    }\n    /**\r\n     * Initialize a User from an idToken server response\r\n     * @param auth\r\n     * @param idTokenResponse\r\n     */ static async _fromIdTokenResponse(auth, idTokenResponse, isAnonymous = false) {\n        const stsTokenManager = new StsTokenManager();\n        stsTokenManager.updateFromServerResponse(idTokenResponse);\n        // Initialize the Firebase Auth user.\n        const user = new UserImpl({\n            uid: idTokenResponse.localId,\n            auth,\n            stsTokenManager,\n            isAnonymous\n        });\n        // Updates the user info and data and resolves with a user instance.\n        await _reloadWithoutSaving(user);\n        return user;\n    }\n    /**\r\n     * Initialize a User from an idToken server response\r\n     * @param auth\r\n     * @param idTokenResponse\r\n     */ static async _fromGetAccountInfoResponse(auth, response, idToken) {\n        const coreAccount = response.users[0];\n        _assert(coreAccount.localId !== undefined, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        const providerData = coreAccount.providerUserInfo !== undefined ? extractProviderData(coreAccount.providerUserInfo) : [];\n        const isAnonymous = !(coreAccount.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);\n        const stsTokenManager = new StsTokenManager();\n        stsTokenManager.updateFromIdToken(idToken);\n        // Initialize the Firebase Auth user.\n        const user = new UserImpl({\n            uid: coreAccount.localId,\n            auth,\n            stsTokenManager,\n            isAnonymous\n        });\n        // update the user with data from the GetAccountInfo response.\n        const updates = {\n            uid: coreAccount.localId,\n            displayName: coreAccount.displayName || null,\n            photoURL: coreAccount.photoUrl || null,\n            email: coreAccount.email || null,\n            emailVerified: coreAccount.emailVerified || false,\n            phoneNumber: coreAccount.phoneNumber || null,\n            tenantId: coreAccount.tenantId || null,\n            providerData,\n            metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),\n            isAnonymous: !(coreAccount.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length)\n        };\n        Object.assign(user, updates);\n        return user;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const instanceCache = new Map();\nfunction _getInstance(cls) {\n    debugAssert(cls instanceof Function, \"Expected a class definition\");\n    let instance = instanceCache.get(cls);\n    if (instance) {\n        debugAssert(instance instanceof cls, \"Instance stored in cache mismatched with class\");\n        return instance;\n    }\n    instance = new cls();\n    instanceCache.set(cls, instance);\n    return instance;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class InMemoryPersistence {\n    constructor(){\n        this.type = \"NONE\" /* PersistenceType.NONE */ ;\n        this.storage = {};\n    }\n    async _isAvailable() {\n        return true;\n    }\n    async _set(key, value) {\n        this.storage[key] = value;\n    }\n    async _get(key) {\n        const value = this.storage[key];\n        return value === undefined ? null : value;\n    }\n    async _remove(key) {\n        delete this.storage[key];\n    }\n    _addListener(_key, _listener) {\n        // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers\n        return;\n    }\n    _removeListener(_key, _listener) {\n        // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers\n        return;\n    }\n}\nInMemoryPersistence.type = \"NONE\";\n/**\r\n * An implementation of {@link Persistence} of type 'NONE'.\r\n *\r\n * @public\r\n */ const inMemoryPersistence = InMemoryPersistence;\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function _persistenceKeyName(key, apiKey, appName) {\n    return `${\"firebase\" /* Namespace.PERSISTENCE */ }:${key}:${apiKey}:${appName}`;\n}\nclass PersistenceUserManager {\n    constructor(persistence, auth, userKey){\n        this.persistence = persistence;\n        this.auth = auth;\n        this.userKey = userKey;\n        const { config, name } = this.auth;\n        this.fullUserKey = _persistenceKeyName(this.userKey, config.apiKey, name);\n        this.fullPersistenceKey = _persistenceKeyName(\"persistence\" /* KeyName.PERSISTENCE_USER */ , config.apiKey, name);\n        this.boundEventHandler = auth._onStorageEvent.bind(auth);\n        this.persistence._addListener(this.fullUserKey, this.boundEventHandler);\n    }\n    setCurrentUser(user) {\n        return this.persistence._set(this.fullUserKey, user.toJSON());\n    }\n    async getCurrentUser() {\n        const blob = await this.persistence._get(this.fullUserKey);\n        return blob ? UserImpl._fromJSON(this.auth, blob) : null;\n    }\n    removeCurrentUser() {\n        return this.persistence._remove(this.fullUserKey);\n    }\n    savePersistenceForRedirect() {\n        return this.persistence._set(this.fullPersistenceKey, this.persistence.type);\n    }\n    async setPersistence(newPersistence) {\n        if (this.persistence === newPersistence) {\n            return;\n        }\n        const currentUser = await this.getCurrentUser();\n        await this.removeCurrentUser();\n        this.persistence = newPersistence;\n        if (currentUser) {\n            return this.setCurrentUser(currentUser);\n        }\n    }\n    delete() {\n        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);\n    }\n    static async create(auth, persistenceHierarchy, userKey = \"authUser\" /* KeyName.AUTH_USER */ ) {\n        if (!persistenceHierarchy.length) {\n            return new PersistenceUserManager(_getInstance(inMemoryPersistence), auth, userKey);\n        }\n        // Eliminate any persistences that are not available\n        const availablePersistences = (await Promise.all(persistenceHierarchy.map(async (persistence)=>{\n            if (await persistence._isAvailable()) {\n                return persistence;\n            }\n            return undefined;\n        }))).filter((persistence)=>persistence);\n        // Fall back to the first persistence listed, or in memory if none available\n        let selectedPersistence = availablePersistences[0] || _getInstance(inMemoryPersistence);\n        const key = _persistenceKeyName(userKey, auth.config.apiKey, auth.name);\n        // Pull out the existing user, setting the chosen persistence to that\n        // persistence if the user exists.\n        let userToMigrate = null;\n        // Note, here we check for a user in _all_ persistences, not just the\n        // ones deemed available. If we can migrate a user out of a broken\n        // persistence, we will (but only if that persistence supports migration).\n        for (const persistence of persistenceHierarchy){\n            try {\n                const blob = await persistence._get(key);\n                if (blob) {\n                    const user = UserImpl._fromJSON(auth, blob); // throws for unparsable blob (wrong format)\n                    if (persistence !== selectedPersistence) {\n                        userToMigrate = user;\n                    }\n                    selectedPersistence = persistence;\n                    break;\n                }\n            } catch (_a) {}\n        }\n        // If we find the user in a persistence that does support migration, use\n        // that migration path (of only persistences that support migration)\n        const migrationHierarchy = availablePersistences.filter((p)=>p._shouldAllowMigration);\n        // If the persistence does _not_ allow migration, just finish off here\n        if (!selectedPersistence._shouldAllowMigration || !migrationHierarchy.length) {\n            return new PersistenceUserManager(selectedPersistence, auth, userKey);\n        }\n        selectedPersistence = migrationHierarchy[0];\n        if (userToMigrate) {\n            // This normally shouldn't throw since chosenPersistence.isAvailable() is true, but if it does\n            // we'll just let it bubble to surface the error.\n            await selectedPersistence._set(key, userToMigrate.toJSON());\n        }\n        // Attempt to clear the key in other persistences but ignore errors. This helps prevent issues\n        // such as users getting stuck with a previous account after signing out and refreshing the tab.\n        await Promise.all(persistenceHierarchy.map(async (persistence)=>{\n            if (persistence !== selectedPersistence) {\n                try {\n                    await persistence._remove(key);\n                } catch (_a) {}\n            }\n        }));\n        return new PersistenceUserManager(selectedPersistence, auth, userKey);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Determine the browser for the purposes of reporting usage to the API\r\n */ function _getBrowserName(userAgent) {\n    const ua = userAgent.toLowerCase();\n    if (ua.includes(\"opera/\") || ua.includes(\"opr/\") || ua.includes(\"opios/\")) {\n        return \"Opera\" /* BrowserName.OPERA */ ;\n    } else if (_isIEMobile(ua)) {\n        // Windows phone IEMobile browser.\n        return \"IEMobile\" /* BrowserName.IEMOBILE */ ;\n    } else if (ua.includes(\"msie\") || ua.includes(\"trident/\")) {\n        return \"IE\" /* BrowserName.IE */ ;\n    } else if (ua.includes(\"edge/\")) {\n        return \"Edge\" /* BrowserName.EDGE */ ;\n    } else if (_isFirefox(ua)) {\n        return \"Firefox\" /* BrowserName.FIREFOX */ ;\n    } else if (ua.includes(\"silk/\")) {\n        return \"Silk\" /* BrowserName.SILK */ ;\n    } else if (_isBlackBerry(ua)) {\n        // Blackberry browser.\n        return \"Blackberry\" /* BrowserName.BLACKBERRY */ ;\n    } else if (_isWebOS(ua)) {\n        // WebOS default browser.\n        return \"Webos\" /* BrowserName.WEBOS */ ;\n    } else if (_isSafari(ua)) {\n        return \"Safari\" /* BrowserName.SAFARI */ ;\n    } else if ((ua.includes(\"chrome/\") || _isChromeIOS(ua)) && !ua.includes(\"edge/\")) {\n        return \"Chrome\" /* BrowserName.CHROME */ ;\n    } else if (_isAndroid(ua)) {\n        // Android stock browser.\n        return \"Android\" /* BrowserName.ANDROID */ ;\n    } else {\n        // Most modern browsers have name/version at end of user agent string.\n        const re = /([a-zA-Z\\d\\.]+)\\/[a-zA-Z\\d\\.]*$/;\n        const matches = userAgent.match(re);\n        if ((matches === null || matches === void 0 ? void 0 : matches.length) === 2) {\n            return matches[1];\n        }\n    }\n    return \"Other\" /* BrowserName.OTHER */ ;\n}\nfunction _isFirefox(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /firefox\\//i.test(ua);\n}\nfunction _isSafari(userAgent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    const ua = userAgent.toLowerCase();\n    return ua.includes(\"safari/\") && !ua.includes(\"chrome/\") && !ua.includes(\"crios/\") && !ua.includes(\"android\");\n}\nfunction _isChromeIOS(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /crios\\//i.test(ua);\n}\nfunction _isIEMobile(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /iemobile/i.test(ua);\n}\nfunction _isAndroid(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /android/i.test(ua);\n}\nfunction _isBlackBerry(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /blackberry/i.test(ua);\n}\nfunction _isWebOS(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /webos/i.test(ua);\n}\nfunction _isIOS(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /iphone|ipad|ipod/i.test(ua) || /macintosh/i.test(ua) && /mobile/i.test(ua);\n}\nfunction _isIOS7Or8(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /(iPad|iPhone|iPod).*OS 7_\\d/i.test(ua) || /(iPad|iPhone|iPod).*OS 8_\\d/i.test(ua);\n}\nfunction _isIE10() {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isIE)() && document.documentMode === 10;\n}\nfunction _isMobileBrowser(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    // TODO: implement getBrowserName equivalent for OS.\n    return _isIOS(ua) || _isAndroid(ua) || _isWebOS(ua) || _isBlackBerry(ua) || /windows phone/i.test(ua) || _isIEMobile(ua);\n}\nfunction _isIframe() {\n    try {\n        // Check that the current window is not the top window.\n        // If so, return true.\n        return !!(window && window !== window.top);\n    } catch (e) {\n        return false;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /*\r\n * Determine the SDK version string\r\n */ function _getClientVersion(clientPlatform, frameworks = []) {\n    let reportedPlatform;\n    switch(clientPlatform){\n        case \"Browser\" /* ClientPlatform.BROWSER */ :\n            // In a browser environment, report the browser name.\n            reportedPlatform = _getBrowserName((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)());\n            break;\n        case \"Worker\" /* ClientPlatform.WORKER */ :\n            // Technically a worker runs from a browser but we need to differentiate a\n            // worker from a browser.\n            // For example: Chrome-Worker/JsCore/4.9.1/FirebaseCore-web.\n            reportedPlatform = `${_getBrowserName((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)())}-${clientPlatform}`;\n            break;\n        default:\n            reportedPlatform = clientPlatform;\n    }\n    const reportedFrameworks = frameworks.length ? frameworks.join(\",\") : \"FirebaseCore-web\"; /* default value if no other framework is used */ \n    return `${reportedPlatform}/${\"JsCore\" /* ClientImplementation.CORE */ }/${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}/${reportedFrameworks}`;\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class AuthMiddlewareQueue {\n    constructor(auth){\n        this.auth = auth;\n        this.queue = [];\n    }\n    pushCallback(callback, onAbort) {\n        // The callback could be sync or async. Wrap it into a\n        // function that is always async.\n        const wrappedCallback = (user)=>new Promise((resolve, reject)=>{\n                try {\n                    const result = callback(user);\n                    // Either resolve with existing promise or wrap a non-promise\n                    // return value into a promise.\n                    resolve(result);\n                } catch (e) {\n                    // Sync callback throws.\n                    reject(e);\n                }\n            });\n        // Attach the onAbort if present\n        wrappedCallback.onAbort = onAbort;\n        this.queue.push(wrappedCallback);\n        const index = this.queue.length - 1;\n        return ()=>{\n            // Unsubscribe. Replace with no-op. Do not remove from array, or it will disturb\n            // indexing of other elements.\n            this.queue[index] = ()=>Promise.resolve();\n        };\n    }\n    async runMiddleware(nextUser) {\n        if (this.auth.currentUser === nextUser) {\n            return;\n        }\n        // While running the middleware, build a temporary stack of onAbort\n        // callbacks to call if one middleware callback rejects.\n        const onAbortStack = [];\n        try {\n            for (const beforeStateCallback of this.queue){\n                await beforeStateCallback(nextUser);\n                // Only push the onAbort if the callback succeeds\n                if (beforeStateCallback.onAbort) {\n                    onAbortStack.push(beforeStateCallback.onAbort);\n                }\n            }\n        } catch (e) {\n            // Run all onAbort, with separate try/catch to ignore any errors and\n            // continue\n            onAbortStack.reverse();\n            for (const onAbort of onAbortStack){\n                try {\n                    onAbort();\n                } catch (_) {\n                /* swallow error */ }\n            }\n            throw this.auth._errorFactory.create(\"login-blocked\" /* AuthErrorCode.LOGIN_BLOCKED */ , {\n                originalMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Fetches the password policy for the currently set tenant or the project if no tenant is set.\r\n *\r\n * @param auth Auth object.\r\n * @param request Password policy request.\r\n * @returns Password policy response.\r\n */ async function _getPasswordPolicy(auth, request = {}) {\n    return _performApiRequest(auth, \"GET\" /* HttpMethod.GET */ , \"/v2/passwordPolicy\" /* Endpoint.GET_PASSWORD_POLICY */ , _addTidIfNecessary(auth, request));\n}\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Minimum min password length enforced by the backend, even if no minimum length is set.\nconst MINIMUM_MIN_PASSWORD_LENGTH = 6;\n/**\r\n * Stores password policy requirements and provides password validation against the policy.\r\n *\r\n * @internal\r\n */ class PasswordPolicyImpl {\n    constructor(response){\n        var _a, _b, _c, _d;\n        // Only include custom strength options defined in the response.\n        const responseOptions = response.customStrengthOptions;\n        this.customStrengthOptions = {};\n        // TODO: Remove once the backend is updated to include the minimum min password length instead of undefined when there is no minimum length set.\n        this.customStrengthOptions.minPasswordLength = (_a = responseOptions.minPasswordLength) !== null && _a !== void 0 ? _a : MINIMUM_MIN_PASSWORD_LENGTH;\n        if (responseOptions.maxPasswordLength) {\n            this.customStrengthOptions.maxPasswordLength = responseOptions.maxPasswordLength;\n        }\n        if (responseOptions.containsLowercaseCharacter !== undefined) {\n            this.customStrengthOptions.containsLowercaseLetter = responseOptions.containsLowercaseCharacter;\n        }\n        if (responseOptions.containsUppercaseCharacter !== undefined) {\n            this.customStrengthOptions.containsUppercaseLetter = responseOptions.containsUppercaseCharacter;\n        }\n        if (responseOptions.containsNumericCharacter !== undefined) {\n            this.customStrengthOptions.containsNumericCharacter = responseOptions.containsNumericCharacter;\n        }\n        if (responseOptions.containsNonAlphanumericCharacter !== undefined) {\n            this.customStrengthOptions.containsNonAlphanumericCharacter = responseOptions.containsNonAlphanumericCharacter;\n        }\n        this.enforcementState = response.enforcementState;\n        if (this.enforcementState === \"ENFORCEMENT_STATE_UNSPECIFIED\") {\n            this.enforcementState = \"OFF\";\n        }\n        // Use an empty string if no non-alphanumeric characters are specified in the response.\n        this.allowedNonAlphanumericCharacters = (_c = (_b = response.allowedNonAlphanumericCharacters) === null || _b === void 0 ? void 0 : _b.join(\"\")) !== null && _c !== void 0 ? _c : \"\";\n        this.forceUpgradeOnSignin = (_d = response.forceUpgradeOnSignin) !== null && _d !== void 0 ? _d : false;\n        this.schemaVersion = response.schemaVersion;\n    }\n    validatePassword(password) {\n        var _a, _b, _c, _d, _e, _f;\n        const status = {\n            isValid: true,\n            passwordPolicy: this\n        };\n        // Check the password length and character options.\n        this.validatePasswordLengthOptions(password, status);\n        this.validatePasswordCharacterOptions(password, status);\n        // Combine the status into single isValid property.\n        status.isValid && (status.isValid = (_a = status.meetsMinPasswordLength) !== null && _a !== void 0 ? _a : true);\n        status.isValid && (status.isValid = (_b = status.meetsMaxPasswordLength) !== null && _b !== void 0 ? _b : true);\n        status.isValid && (status.isValid = (_c = status.containsLowercaseLetter) !== null && _c !== void 0 ? _c : true);\n        status.isValid && (status.isValid = (_d = status.containsUppercaseLetter) !== null && _d !== void 0 ? _d : true);\n        status.isValid && (status.isValid = (_e = status.containsNumericCharacter) !== null && _e !== void 0 ? _e : true);\n        status.isValid && (status.isValid = (_f = status.containsNonAlphanumericCharacter) !== null && _f !== void 0 ? _f : true);\n        return status;\n    }\n    /**\r\n     * Validates that the password meets the length options for the policy.\r\n     *\r\n     * @param password Password to validate.\r\n     * @param status Validation status.\r\n     */ validatePasswordLengthOptions(password, status) {\n        const minPasswordLength = this.customStrengthOptions.minPasswordLength;\n        const maxPasswordLength = this.customStrengthOptions.maxPasswordLength;\n        if (minPasswordLength) {\n            status.meetsMinPasswordLength = password.length >= minPasswordLength;\n        }\n        if (maxPasswordLength) {\n            status.meetsMaxPasswordLength = password.length <= maxPasswordLength;\n        }\n    }\n    /**\r\n     * Validates that the password meets the character options for the policy.\r\n     *\r\n     * @param password Password to validate.\r\n     * @param status Validation status.\r\n     */ validatePasswordCharacterOptions(password, status) {\n        // Assign statuses for requirements even if the password is an empty string.\n        this.updatePasswordCharacterOptionsStatuses(status, /* containsLowercaseCharacter= */ false, /* containsUppercaseCharacter= */ false, /* containsNumericCharacter= */ false, /* containsNonAlphanumericCharacter= */ false);\n        let passwordChar;\n        for(let i = 0; i < password.length; i++){\n            passwordChar = password.charAt(i);\n            this.updatePasswordCharacterOptionsStatuses(status, /* containsLowercaseCharacter= */ passwordChar >= \"a\" && passwordChar <= \"z\", /* containsUppercaseCharacter= */ passwordChar >= \"A\" && passwordChar <= \"Z\", /* containsNumericCharacter= */ passwordChar >= \"0\" && passwordChar <= \"9\", /* containsNonAlphanumericCharacter= */ this.allowedNonAlphanumericCharacters.includes(passwordChar));\n        }\n    }\n    /**\r\n     * Updates the running validation status with the statuses for the character options.\r\n     * Expected to be called each time a character is processed to update each option status\r\n     * based on the current character.\r\n     *\r\n     * @param status Validation status.\r\n     * @param containsLowercaseCharacter Whether the character is a lowercase letter.\r\n     * @param containsUppercaseCharacter Whether the character is an uppercase letter.\r\n     * @param containsNumericCharacter Whether the character is a numeric character.\r\n     * @param containsNonAlphanumericCharacter Whether the character is a non-alphanumeric character.\r\n     */ updatePasswordCharacterOptionsStatuses(status, containsLowercaseCharacter, containsUppercaseCharacter, containsNumericCharacter, containsNonAlphanumericCharacter) {\n        if (this.customStrengthOptions.containsLowercaseLetter) {\n            status.containsLowercaseLetter || (status.containsLowercaseLetter = containsLowercaseCharacter);\n        }\n        if (this.customStrengthOptions.containsUppercaseLetter) {\n            status.containsUppercaseLetter || (status.containsUppercaseLetter = containsUppercaseCharacter);\n        }\n        if (this.customStrengthOptions.containsNumericCharacter) {\n            status.containsNumericCharacter || (status.containsNumericCharacter = containsNumericCharacter);\n        }\n        if (this.customStrengthOptions.containsNonAlphanumericCharacter) {\n            status.containsNonAlphanumericCharacter || (status.containsNonAlphanumericCharacter = containsNonAlphanumericCharacter);\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class AuthImpl {\n    constructor(app, heartbeatServiceProvider, appCheckServiceProvider, config){\n        this.app = app;\n        this.heartbeatServiceProvider = heartbeatServiceProvider;\n        this.appCheckServiceProvider = appCheckServiceProvider;\n        this.config = config;\n        this.currentUser = null;\n        this.emulatorConfig = null;\n        this.operations = Promise.resolve();\n        this.authStateSubscription = new Subscription(this);\n        this.idTokenSubscription = new Subscription(this);\n        this.beforeStateQueue = new AuthMiddlewareQueue(this);\n        this.redirectUser = null;\n        this.isProactiveRefreshEnabled = false;\n        this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1;\n        // Any network calls will set this to true and prevent subsequent emulator\n        // initialization\n        this._canInitEmulator = true;\n        this._isInitialized = false;\n        this._deleted = false;\n        this._initializationPromise = null;\n        this._popupRedirectResolver = null;\n        this._errorFactory = _DEFAULT_AUTH_ERROR_FACTORY;\n        this._agentRecaptchaConfig = null;\n        this._tenantRecaptchaConfigs = {};\n        this._projectPasswordPolicy = null;\n        this._tenantPasswordPolicies = {};\n        // Tracks the last notified UID for state change listeners to prevent\n        // repeated calls to the callbacks. Undefined means it's never been\n        // called, whereas null means it's been called with a signed out user\n        this.lastNotifiedUid = undefined;\n        this.languageCode = null;\n        this.tenantId = null;\n        this.settings = {\n            appVerificationDisabledForTesting: false\n        };\n        this.frameworks = [];\n        this.name = app.name;\n        this.clientVersion = config.sdkClientVersion;\n    }\n    _initializeWithPersistence(persistenceHierarchy, popupRedirectResolver) {\n        if (popupRedirectResolver) {\n            this._popupRedirectResolver = _getInstance(popupRedirectResolver);\n        }\n        // Have to check for app deletion throughout initialization (after each\n        // promise resolution)\n        this._initializationPromise = this.queue(async ()=>{\n            var _a, _b;\n            if (this._deleted) {\n                return;\n            }\n            this.persistenceManager = await PersistenceUserManager.create(this, persistenceHierarchy);\n            if (this._deleted) {\n                return;\n            }\n            // Initialize the resolver early if necessary (only applicable to web:\n            // this will cause the iframe to load immediately in certain cases)\n            if ((_a = this._popupRedirectResolver) === null || _a === void 0 ? void 0 : _a._shouldInitProactively) {\n                // If this fails, don't halt auth loading\n                try {\n                    await this._popupRedirectResolver._initialize(this);\n                } catch (e) {\n                /* Ignore the error */ }\n            }\n            await this.initializeCurrentUser(popupRedirectResolver);\n            this.lastNotifiedUid = ((_b = this.currentUser) === null || _b === void 0 ? void 0 : _b.uid) || null;\n            if (this._deleted) {\n                return;\n            }\n            this._isInitialized = true;\n        });\n        return this._initializationPromise;\n    }\n    /**\r\n     * If the persistence is changed in another window, the user manager will let us know\r\n     */ async _onStorageEvent() {\n        if (this._deleted) {\n            return;\n        }\n        const user = await this.assertedPersistence.getCurrentUser();\n        if (!this.currentUser && !user) {\n            // No change, do nothing (was signed out and remained signed out).\n            return;\n        }\n        // If the same user is to be synchronized.\n        if (this.currentUser && user && this.currentUser.uid === user.uid) {\n            // Data update, simply copy data changes.\n            this._currentUser._assign(user);\n            // If tokens changed from previous user tokens, this will trigger\n            // notifyAuthListeners_.\n            await this.currentUser.getIdToken();\n            return;\n        }\n        // Update current Auth state. Either a new login or logout.\n        // Skip blocking callbacks, they should not apply to a change in another tab.\n        await this._updateCurrentUser(user, /* skipBeforeStateCallbacks */ true);\n    }\n    async initializeCurrentUserFromIdToken(idToken) {\n        try {\n            const response = await getAccountInfo(this, {\n                idToken\n            });\n            const user = await UserImpl._fromGetAccountInfoResponse(this, response, idToken);\n            await this.directlySetCurrentUser(user);\n        } catch (err) {\n            console.warn(\"FirebaseServerApp could not login user with provided authIdToken: \", err);\n            await this.directlySetCurrentUser(null);\n        }\n    }\n    async initializeCurrentUser(popupRedirectResolver) {\n        var _a;\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            const idToken = this.app.settings.authIdToken;\n            if (idToken) {\n                // Start the auth operation in the next tick to allow a moment for the customer's app to\n                // attach an emulator, if desired.\n                return new Promise((resolve)=>{\n                    setTimeout(()=>this.initializeCurrentUserFromIdToken(idToken).then(resolve, resolve));\n                });\n            } else {\n                return this.directlySetCurrentUser(null);\n            }\n        }\n        // First check to see if we have a pending redirect event.\n        const previouslyStoredUser = await this.assertedPersistence.getCurrentUser();\n        let futureCurrentUser = previouslyStoredUser;\n        let needsTocheckMiddleware = false;\n        if (popupRedirectResolver && this.config.authDomain) {\n            await this.getOrInitRedirectPersistenceManager();\n            const redirectUserEventId = (_a = this.redirectUser) === null || _a === void 0 ? void 0 : _a._redirectEventId;\n            const storedUserEventId = futureCurrentUser === null || futureCurrentUser === void 0 ? void 0 : futureCurrentUser._redirectEventId;\n            const result = await this.tryRedirectSignIn(popupRedirectResolver);\n            // If the stored user (i.e. the old \"currentUser\") has a redirectId that\n            // matches the redirect user, then we want to initially sign in with the\n            // new user object from result.\n            // TODO(samgho): More thoroughly test all of this\n            if ((!redirectUserEventId || redirectUserEventId === storedUserEventId) && (result === null || result === void 0 ? void 0 : result.user)) {\n                futureCurrentUser = result.user;\n                needsTocheckMiddleware = true;\n            }\n        }\n        // If no user in persistence, there is no current user. Set to null.\n        if (!futureCurrentUser) {\n            return this.directlySetCurrentUser(null);\n        }\n        if (!futureCurrentUser._redirectEventId) {\n            // This isn't a redirect link operation, we can reload and bail.\n            // First though, ensure that we check the middleware is happy.\n            if (needsTocheckMiddleware) {\n                try {\n                    await this.beforeStateQueue.runMiddleware(futureCurrentUser);\n                } catch (e) {\n                    futureCurrentUser = previouslyStoredUser;\n                    // We know this is available since the bit is only set when the\n                    // resolver is available\n                    this._popupRedirectResolver._overrideRedirectResult(this, ()=>Promise.reject(e));\n                }\n            }\n            if (futureCurrentUser) {\n                return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);\n            } else {\n                return this.directlySetCurrentUser(null);\n            }\n        }\n        _assert(this._popupRedirectResolver, this, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        await this.getOrInitRedirectPersistenceManager();\n        // If the redirect user's event ID matches the current user's event ID,\n        // DO NOT reload the current user, otherwise they'll be cleared from storage.\n        // This is important for the reauthenticateWithRedirect() flow.\n        if (this.redirectUser && this.redirectUser._redirectEventId === futureCurrentUser._redirectEventId) {\n            return this.directlySetCurrentUser(futureCurrentUser);\n        }\n        return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);\n    }\n    async tryRedirectSignIn(redirectResolver) {\n        // The redirect user needs to be checked (and signed in if available)\n        // during auth initialization. All of the normal sign in and link/reauth\n        // flows call back into auth and push things onto the promise queue. We\n        // need to await the result of the redirect sign in *inside the promise\n        // queue*. This presents a problem: we run into deadlock. See:\n        //    > [Initialization] \n        //    > [<other queue tasks>] \n        //     [getRedirectResult] <\n        //    where [] are tasks on the queue and arrows denote awaits\n        // Initialization will never complete because it's waiting on something\n        // that's waiting for initialization to complete!\n        //\n        // Instead, this method calls getRedirectResult() (stored in\n        // _completeRedirectFn) with an optional parameter that instructs all of\n        // the underlying auth operations to skip anything that mutates auth state.\n        let result = null;\n        try {\n            // We know this._popupRedirectResolver is set since redirectResolver\n            // is passed in. The _completeRedirectFn expects the unwrapped extern.\n            result = await this._popupRedirectResolver._completeRedirectFn(this, redirectResolver, true);\n        } catch (e) {\n            // Swallow any errors here; the code can retrieve them in\n            // getRedirectResult().\n            await this._setRedirectUser(null);\n        }\n        return result;\n    }\n    async reloadAndSetCurrentUserOrClear(user) {\n        try {\n            await _reloadWithoutSaving(user);\n        } catch (e) {\n            if ((e === null || e === void 0 ? void 0 : e.code) !== `auth/${\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */ }`) {\n                // Something's wrong with the user's token. Log them out and remove\n                // them from storage\n                return this.directlySetCurrentUser(null);\n            }\n        }\n        return this.directlySetCurrentUser(user);\n    }\n    useDeviceLanguage() {\n        this.languageCode = _getUserLanguage();\n    }\n    async _delete() {\n        this._deleted = true;\n    }\n    async updateCurrentUser(userExtern) {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\n        }\n        // The public updateCurrentUser method needs to make a copy of the user,\n        // and also check that the project matches\n        const user = userExtern ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(userExtern) : null;\n        if (user) {\n            _assert(user.auth.config.apiKey === this.config.apiKey, this, \"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */ );\n        }\n        return this._updateCurrentUser(user && user._clone(this));\n    }\n    async _updateCurrentUser(user, skipBeforeStateCallbacks = false) {\n        if (this._deleted) {\n            return;\n        }\n        if (user) {\n            _assert(this.tenantId === user.tenantId, this, \"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */ );\n        }\n        if (!skipBeforeStateCallbacks) {\n            await this.beforeStateQueue.runMiddleware(user);\n        }\n        return this.queue(async ()=>{\n            await this.directlySetCurrentUser(user);\n            this.notifyAuthListeners();\n        });\n    }\n    async signOut() {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\n        }\n        // Run first, to block _setRedirectUser() if any callbacks fail.\n        await this.beforeStateQueue.runMiddleware(null);\n        // Clear the redirect user when signOut is called\n        if (this.redirectPersistenceManager || this._popupRedirectResolver) {\n            await this._setRedirectUser(null);\n        }\n        // Prevent callbacks from being called again in _updateCurrentUser, as\n        // they were already called in the first line.\n        return this._updateCurrentUser(null, /* skipBeforeStateCallbacks */ true);\n    }\n    setPersistence(persistence) {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\n        }\n        return this.queue(async ()=>{\n            await this.assertedPersistence.setPersistence(_getInstance(persistence));\n        });\n    }\n    _getRecaptchaConfig() {\n        if (this.tenantId == null) {\n            return this._agentRecaptchaConfig;\n        } else {\n            return this._tenantRecaptchaConfigs[this.tenantId];\n        }\n    }\n    async validatePassword(password) {\n        if (!this._getPasswordPolicyInternal()) {\n            await this._updatePasswordPolicy();\n        }\n        // Password policy will be defined after fetching.\n        const passwordPolicy = this._getPasswordPolicyInternal();\n        // Check that the policy schema version is supported by the SDK.\n        // TODO: Update this logic to use a max supported policy schema version once we have multiple schema versions.\n        if (passwordPolicy.schemaVersion !== this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION) {\n            return Promise.reject(this._errorFactory.create(\"unsupported-password-policy-schema-version\" /* AuthErrorCode.UNSUPPORTED_PASSWORD_POLICY_SCHEMA_VERSION */ , {}));\n        }\n        return passwordPolicy.validatePassword(password);\n    }\n    _getPasswordPolicyInternal() {\n        if (this.tenantId === null) {\n            return this._projectPasswordPolicy;\n        } else {\n            return this._tenantPasswordPolicies[this.tenantId];\n        }\n    }\n    async _updatePasswordPolicy() {\n        const response = await _getPasswordPolicy(this);\n        const passwordPolicy = new PasswordPolicyImpl(response);\n        if (this.tenantId === null) {\n            this._projectPasswordPolicy = passwordPolicy;\n        } else {\n            this._tenantPasswordPolicies[this.tenantId] = passwordPolicy;\n        }\n    }\n    _getPersistence() {\n        return this.assertedPersistence.persistence.type;\n    }\n    _updateErrorMap(errorMap) {\n        this._errorFactory = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory(\"auth\", \"Firebase\", errorMap());\n    }\n    onAuthStateChanged(nextOrObserver, error, completed) {\n        return this.registerStateListener(this.authStateSubscription, nextOrObserver, error, completed);\n    }\n    beforeAuthStateChanged(callback, onAbort) {\n        return this.beforeStateQueue.pushCallback(callback, onAbort);\n    }\n    onIdTokenChanged(nextOrObserver, error, completed) {\n        return this.registerStateListener(this.idTokenSubscription, nextOrObserver, error, completed);\n    }\n    authStateReady() {\n        return new Promise((resolve, reject)=>{\n            if (this.currentUser) {\n                resolve();\n            } else {\n                const unsubscribe = this.onAuthStateChanged(()=>{\n                    unsubscribe();\n                    resolve();\n                }, reject);\n            }\n        });\n    }\n    /**\r\n     * Revokes the given access token. Currently only supports Apple OAuth access tokens.\r\n     */ async revokeAccessToken(token) {\n        if (this.currentUser) {\n            const idToken = await this.currentUser.getIdToken();\n            // Generalize this to accept other providers once supported.\n            const request = {\n                providerId: \"apple.com\",\n                tokenType: \"ACCESS_TOKEN\" /* TokenType.ACCESS_TOKEN */ ,\n                token,\n                idToken\n            };\n            if (this.tenantId != null) {\n                request.tenantId = this.tenantId;\n            }\n            await revokeToken(this, request);\n        }\n    }\n    toJSON() {\n        var _a;\n        return {\n            apiKey: this.config.apiKey,\n            authDomain: this.config.authDomain,\n            appName: this.name,\n            currentUser: (_a = this._currentUser) === null || _a === void 0 ? void 0 : _a.toJSON()\n        };\n    }\n    async _setRedirectUser(user, popupRedirectResolver) {\n        const redirectManager = await this.getOrInitRedirectPersistenceManager(popupRedirectResolver);\n        return user === null ? redirectManager.removeCurrentUser() : redirectManager.setCurrentUser(user);\n    }\n    async getOrInitRedirectPersistenceManager(popupRedirectResolver) {\n        if (!this.redirectPersistenceManager) {\n            const resolver = popupRedirectResolver && _getInstance(popupRedirectResolver) || this._popupRedirectResolver;\n            _assert(resolver, this, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n            this.redirectPersistenceManager = await PersistenceUserManager.create(this, [\n                _getInstance(resolver._redirectPersistence)\n            ], \"redirectUser\" /* KeyName.REDIRECT_USER */ );\n            this.redirectUser = await this.redirectPersistenceManager.getCurrentUser();\n        }\n        return this.redirectPersistenceManager;\n    }\n    async _redirectUserForId(id) {\n        var _a, _b;\n        // Make sure we've cleared any pending persistence actions if we're not in\n        // the initializer\n        if (this._isInitialized) {\n            await this.queue(async ()=>{});\n        }\n        if (((_a = this._currentUser) === null || _a === void 0 ? void 0 : _a._redirectEventId) === id) {\n            return this._currentUser;\n        }\n        if (((_b = this.redirectUser) === null || _b === void 0 ? void 0 : _b._redirectEventId) === id) {\n            return this.redirectUser;\n        }\n        return null;\n    }\n    async _persistUserIfCurrent(user) {\n        if (user === this.currentUser) {\n            return this.queue(async ()=>this.directlySetCurrentUser(user));\n        }\n    }\n    /** Notifies listeners only if the user is current */ _notifyListenersIfCurrent(user) {\n        if (user === this.currentUser) {\n            this.notifyAuthListeners();\n        }\n    }\n    _key() {\n        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;\n    }\n    _startProactiveRefresh() {\n        this.isProactiveRefreshEnabled = true;\n        if (this.currentUser) {\n            this._currentUser._startProactiveRefresh();\n        }\n    }\n    _stopProactiveRefresh() {\n        this.isProactiveRefreshEnabled = false;\n        if (this.currentUser) {\n            this._currentUser._stopProactiveRefresh();\n        }\n    }\n    /** Returns the current user cast as the internal type */ get _currentUser() {\n        return this.currentUser;\n    }\n    notifyAuthListeners() {\n        var _a, _b;\n        if (!this._isInitialized) {\n            return;\n        }\n        this.idTokenSubscription.next(this.currentUser);\n        const currentUid = (_b = (_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.uid) !== null && _b !== void 0 ? _b : null;\n        if (this.lastNotifiedUid !== currentUid) {\n            this.lastNotifiedUid = currentUid;\n            this.authStateSubscription.next(this.currentUser);\n        }\n    }\n    registerStateListener(subscription, nextOrObserver, error, completed) {\n        if (this._deleted) {\n            return ()=>{};\n        }\n        const cb = typeof nextOrObserver === \"function\" ? nextOrObserver : nextOrObserver.next.bind(nextOrObserver);\n        let isUnsubscribed = false;\n        const promise = this._isInitialized ? Promise.resolve() : this._initializationPromise;\n        _assert(promise, this, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        // The callback needs to be called asynchronously per the spec.\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        promise.then(()=>{\n            if (isUnsubscribed) {\n                return;\n            }\n            cb(this.currentUser);\n        });\n        if (typeof nextOrObserver === \"function\") {\n            const unsubscribe = subscription.addObserver(nextOrObserver, error, completed);\n            return ()=>{\n                isUnsubscribed = true;\n                unsubscribe();\n            };\n        } else {\n            const unsubscribe = subscription.addObserver(nextOrObserver);\n            return ()=>{\n                isUnsubscribed = true;\n                unsubscribe();\n            };\n        }\n    }\n    /**\r\n     * Unprotected (from race conditions) method to set the current user. This\r\n     * should only be called from within a queued callback. This is necessary\r\n     * because the queue shouldn't rely on another queued callback.\r\n     */ async directlySetCurrentUser(user) {\n        if (this.currentUser && this.currentUser !== user) {\n            this._currentUser._stopProactiveRefresh();\n        }\n        if (user && this.isProactiveRefreshEnabled) {\n            user._startProactiveRefresh();\n        }\n        this.currentUser = user;\n        if (user) {\n            await this.assertedPersistence.setCurrentUser(user);\n        } else {\n            await this.assertedPersistence.removeCurrentUser();\n        }\n    }\n    queue(action) {\n        // In case something errors, the callback still should be called in order\n        // to keep the promise chain alive\n        this.operations = this.operations.then(action, action);\n        return this.operations;\n    }\n    get assertedPersistence() {\n        _assert(this.persistenceManager, this, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        return this.persistenceManager;\n    }\n    _logFramework(framework) {\n        if (!framework || this.frameworks.includes(framework)) {\n            return;\n        }\n        this.frameworks.push(framework);\n        // Sort alphabetically so that \"FirebaseCore-web,FirebaseUI-web\" and\n        // \"FirebaseUI-web,FirebaseCore-web\" aren't viewed as different.\n        this.frameworks.sort();\n        this.clientVersion = _getClientVersion(this.config.clientPlatform, this._getFrameworks());\n    }\n    _getFrameworks() {\n        return this.frameworks;\n    }\n    async _getAdditionalHeaders() {\n        var _a;\n        // Additional headers on every request\n        const headers = {\n            [\"X-Client-Version\" /* HttpHeader.X_CLIENT_VERSION */ ]: this.clientVersion\n        };\n        if (this.app.options.appId) {\n            headers[\"X-Firebase-gmpid\" /* HttpHeader.X_FIREBASE_GMPID */ ] = this.app.options.appId;\n        }\n        // If the heartbeat service exists, add the heartbeat string\n        const heartbeatsHeader = await ((_a = this.heartbeatServiceProvider.getImmediate({\n            optional: true\n        })) === null || _a === void 0 ? void 0 : _a.getHeartbeatsHeader());\n        if (heartbeatsHeader) {\n            headers[\"X-Firebase-Client\" /* HttpHeader.X_FIREBASE_CLIENT */ ] = heartbeatsHeader;\n        }\n        // If the App Check service exists, add the App Check token in the headers\n        const appCheckToken = await this._getAppCheckToken();\n        if (appCheckToken) {\n            headers[\"X-Firebase-AppCheck\" /* HttpHeader.X_FIREBASE_APP_CHECK */ ] = appCheckToken;\n        }\n        return headers;\n    }\n    async _getAppCheckToken() {\n        var _a;\n        const appCheckTokenResult = await ((_a = this.appCheckServiceProvider.getImmediate({\n            optional: true\n        })) === null || _a === void 0 ? void 0 : _a.getToken());\n        if (appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.error) {\n            // Context: appCheck.getToken() will never throw even if an error happened.\n            // In the error case, a dummy token will be returned along with an error field describing\n            // the error. In general, we shouldn't care about the error condition and just use\n            // the token (actual or dummy) to send requests.\n            _logWarn(`Error while retrieving App Check token: ${appCheckTokenResult.error}`);\n        }\n        return appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.token;\n    }\n}\n/**\r\n * Method to be used to cast down to our private implmentation of Auth.\r\n * It will also handle unwrapping from the compat type if necessary\r\n *\r\n * @param auth Auth object passed in from developer\r\n */ function _castAuth(auth) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n}\n/** Helper class to wrap subscriber logic */ class Subscription {\n    constructor(auth){\n        this.auth = auth;\n        this.observer = null;\n        this.addObserver = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.createSubscribe)((observer)=>this.observer = observer);\n    }\n    get next() {\n        _assert(this.observer, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        return this.observer.next.bind(this.observer);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let externalJSProvider = {\n    async loadJS () {\n        throw new Error(\"Unable to load external scripts\");\n    },\n    recaptchaV2Script: \"\",\n    recaptchaEnterpriseScript: \"\",\n    gapiScript: \"\"\n};\nfunction _loadJS(url) {\n    return externalJSProvider.loadJS(url);\n}\nfunction _recaptchaEnterpriseScriptUrl() {\n    return externalJSProvider.recaptchaEnterpriseScript;\n}\n/* eslint-disable @typescript-eslint/no-require-imports */ const RECAPTCHA_ENTERPRISE_VERIFIER_TYPE = \"recaptcha-enterprise\";\nconst FAKE_TOKEN = \"NO_RECAPTCHA\";\nclass RecaptchaEnterpriseVerifier {\n    /**\r\n     *\r\n     * @param authExtern - The corresponding Firebase {@link Auth} instance.\r\n     *\r\n     */ constructor(authExtern){\n        /**\r\n         * Identifies the type of application verifier (e.g. \"recaptcha-enterprise\").\r\n         */ this.type = RECAPTCHA_ENTERPRISE_VERIFIER_TYPE;\n        this.auth = _castAuth(authExtern);\n    }\n    /**\r\n     * Executes the verification process.\r\n     *\r\n     * @returns A Promise for a token that can be used to assert the validity of a request.\r\n     */ async verify(action = \"verify\", forceRefresh = false) {\n        async function retrieveSiteKey(auth) {\n            if (!forceRefresh) {\n                if (auth.tenantId == null && auth._agentRecaptchaConfig != null) {\n                    return auth._agentRecaptchaConfig.siteKey;\n                }\n                if (auth.tenantId != null && auth._tenantRecaptchaConfigs[auth.tenantId] !== undefined) {\n                    return auth._tenantRecaptchaConfigs[auth.tenantId].siteKey;\n                }\n            }\n            return new Promise(async (resolve, reject)=>{\n                getRecaptchaConfig(auth, {\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ ,\n                    version: \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */ \n                }).then((response)=>{\n                    if (response.recaptchaKey === undefined) {\n                        reject(new Error(\"recaptcha Enterprise site key undefined\"));\n                    } else {\n                        const config = new RecaptchaConfig(response);\n                        if (auth.tenantId == null) {\n                            auth._agentRecaptchaConfig = config;\n                        } else {\n                            auth._tenantRecaptchaConfigs[auth.tenantId] = config;\n                        }\n                        return resolve(config.siteKey);\n                    }\n                }).catch((error)=>{\n                    reject(error);\n                });\n            });\n        }\n        function retrieveRecaptchaToken(siteKey, resolve, reject) {\n            const grecaptcha = window.grecaptcha;\n            if (isEnterprise(grecaptcha)) {\n                grecaptcha.enterprise.ready(()=>{\n                    grecaptcha.enterprise.execute(siteKey, {\n                        action\n                    }).then((token)=>{\n                        resolve(token);\n                    }).catch(()=>{\n                        resolve(FAKE_TOKEN);\n                    });\n                });\n            } else {\n                reject(Error(\"No reCAPTCHA enterprise script loaded.\"));\n            }\n        }\n        return new Promise((resolve, reject)=>{\n            retrieveSiteKey(this.auth).then((siteKey)=>{\n                if (!forceRefresh && isEnterprise(window.grecaptcha)) {\n                    retrieveRecaptchaToken(siteKey, resolve, reject);\n                } else {\n                    if (true) {\n                        reject(new Error(\"RecaptchaVerifier is only supported in browser\"));\n                        return;\n                    }\n                    let url = _recaptchaEnterpriseScriptUrl();\n                    if (url.length !== 0) {\n                        url += siteKey;\n                    }\n                    _loadJS(url).then(()=>{\n                        retrieveRecaptchaToken(siteKey, resolve, reject);\n                    }).catch((error)=>{\n                        reject(error);\n                    });\n                }\n            }).catch((error)=>{\n                reject(error);\n            });\n        });\n    }\n}\nasync function injectRecaptchaFields(auth, request, action, captchaResp = false) {\n    const verifier = new RecaptchaEnterpriseVerifier(auth);\n    let captchaResponse;\n    try {\n        captchaResponse = await verifier.verify(action);\n    } catch (error) {\n        captchaResponse = await verifier.verify(action, true);\n    }\n    const newRequest = Object.assign({}, request);\n    if (!captchaResp) {\n        Object.assign(newRequest, {\n            captchaResponse\n        });\n    } else {\n        Object.assign(newRequest, {\n            \"captchaResp\": captchaResponse\n        });\n    }\n    Object.assign(newRequest, {\n        \"clientType\": \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ \n    });\n    Object.assign(newRequest, {\n        \"recaptchaVersion\": \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */ \n    });\n    return newRequest;\n}\nasync function handleRecaptchaFlow(authInstance, request, actionName, actionMethod) {\n    var _a;\n    if ((_a = authInstance._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.isProviderEnabled(\"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaProvider.EMAIL_PASSWORD_PROVIDER */ )) {\n        const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName, actionName === \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */ );\n        return actionMethod(authInstance, requestWithRecaptcha);\n    } else {\n        return actionMethod(authInstance, request).catch(async (error)=>{\n            if (error.code === `auth/${\"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */ }`) {\n                console.log(`${actionName} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`);\n                const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName, actionName === \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */ );\n                return actionMethod(authInstance, requestWithRecaptcha);\n            } else {\n                return Promise.reject(error);\n            }\n        });\n    }\n}\nasync function _initializeRecaptchaConfig(auth) {\n    const authInternal = _castAuth(auth);\n    const response = await getRecaptchaConfig(authInternal, {\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ ,\n        version: \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */ \n    });\n    const config = new RecaptchaConfig(response);\n    if (authInternal.tenantId == null) {\n        authInternal._agentRecaptchaConfig = config;\n    } else {\n        authInternal._tenantRecaptchaConfigs[authInternal.tenantId] = config;\n    }\n    if (config.isProviderEnabled(\"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaProvider.EMAIL_PASSWORD_PROVIDER */ )) {\n        const verifier = new RecaptchaEnterpriseVerifier(authInternal);\n        void verifier.verify();\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Initializes an {@link Auth} instance with fine-grained control over\r\n * {@link Dependencies}.\r\n *\r\n * @remarks\r\n *\r\n * This function allows more control over the {@link Auth} instance than\r\n * {@link getAuth}. `getAuth` uses platform-specific defaults to supply\r\n * the {@link Dependencies}. In general, `getAuth` is the easiest way to\r\n * initialize Auth and works for most use cases. Use `initializeAuth` if you\r\n * need control over which persistence layer is used, or to minimize bundle\r\n * size if you're not using either `signInWithPopup` or `signInWithRedirect`.\r\n *\r\n * For example, if your app only uses anonymous accounts and you only want\r\n * accounts saved for the current session, initialize `Auth` with:\r\n *\r\n * ```js\r\n * const auth = initializeAuth(app, {\r\n *   persistence: browserSessionPersistence,\r\n *   popupRedirectResolver: undefined,\r\n * });\r\n * ```\r\n *\r\n * @public\r\n */ function initializeAuth(app, deps) {\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, \"auth\");\n    if (provider.isInitialized()) {\n        const auth = provider.getImmediate();\n        const initialOptions = provider.getOptions();\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepEqual)(initialOptions, deps !== null && deps !== void 0 ? deps : {})) {\n            return auth;\n        } else {\n            _fail(auth, \"already-initialized\" /* AuthErrorCode.ALREADY_INITIALIZED */ );\n        }\n    }\n    const auth = provider.initialize({\n        options: deps\n    });\n    return auth;\n}\nfunction _initializeAuthInstance(auth, deps) {\n    const persistence = (deps === null || deps === void 0 ? void 0 : deps.persistence) || [];\n    const hierarchy = (Array.isArray(persistence) ? persistence : [\n        persistence\n    ]).map(_getInstance);\n    if (deps === null || deps === void 0 ? void 0 : deps.errorMap) {\n        auth._updateErrorMap(deps.errorMap);\n    }\n    // This promise is intended to float; auth initialization happens in the\n    // background, meanwhile the auth object may be used by the app.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    auth._initializeWithPersistence(hierarchy, deps === null || deps === void 0 ? void 0 : deps.popupRedirectResolver);\n}\n/**\r\n * Changes the {@link Auth} instance to communicate with the Firebase Auth Emulator, instead of production\r\n * Firebase Auth services.\r\n *\r\n * @remarks\r\n * This must be called synchronously immediately following the first call to\r\n * {@link initializeAuth}.  Do not use with production credentials as emulator\r\n * traffic is not encrypted.\r\n *\r\n *\r\n * @example\r\n * ```javascript\r\n * connectAuthEmulator(auth, 'http://127.0.0.1:9099', { disableWarnings: true });\r\n * ```\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param url - The URL at which the emulator is running (eg, 'http://localhost:9099').\r\n * @param options - Optional. `options.disableWarnings` defaults to `false`. Set it to\r\n * `true` to disable the warning banner attached to the DOM.\r\n *\r\n * @public\r\n */ function connectAuthEmulator(auth, url, options) {\n    const authInternal = _castAuth(auth);\n    _assert(authInternal._canInitEmulator, authInternal, \"emulator-config-failed\" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */ );\n    _assert(/^https?:\\/\\//.test(url), authInternal, \"invalid-emulator-scheme\" /* AuthErrorCode.INVALID_EMULATOR_SCHEME */ );\n    const disableWarnings = !!(options === null || options === void 0 ? void 0 : options.disableWarnings);\n    const protocol = extractProtocol(url);\n    const { host, port } = extractHostAndPort(url);\n    const portStr = port === null ? \"\" : `:${port}`;\n    // Always replace path with \"/\" (even if input url had no path at all, or had a different one).\n    authInternal.config.emulator = {\n        url: `${protocol}//${host}${portStr}/`\n    };\n    authInternal.settings.appVerificationDisabledForTesting = true;\n    authInternal.emulatorConfig = Object.freeze({\n        host,\n        port,\n        protocol: protocol.replace(\":\", \"\"),\n        options: Object.freeze({\n            disableWarnings\n        })\n    });\n    if (!disableWarnings) {\n        emitEmulatorWarning();\n    }\n}\nfunction extractProtocol(url) {\n    const protocolEnd = url.indexOf(\":\");\n    return protocolEnd < 0 ? \"\" : url.substr(0, protocolEnd + 1);\n}\nfunction extractHostAndPort(url) {\n    const protocol = extractProtocol(url);\n    const authority = /(\\/\\/)?([^?#/]+)/.exec(url.substr(protocol.length)); // Between // and /, ? or #.\n    if (!authority) {\n        return {\n            host: \"\",\n            port: null\n        };\n    }\n    const hostAndPort = authority[2].split(\"@\").pop() || \"\"; // Strip out \"username:password@\".\n    const bracketedIPv6 = /^(\\[[^\\]]+\\])(:|$)/.exec(hostAndPort);\n    if (bracketedIPv6) {\n        const host = bracketedIPv6[1];\n        return {\n            host,\n            port: parsePort(hostAndPort.substr(host.length + 1))\n        };\n    } else {\n        const [host, port] = hostAndPort.split(\":\");\n        return {\n            host,\n            port: parsePort(port)\n        };\n    }\n}\nfunction parsePort(portStr) {\n    if (!portStr) {\n        return null;\n    }\n    const port = Number(portStr);\n    if (isNaN(port)) {\n        return null;\n    }\n    return port;\n}\nfunction emitEmulatorWarning() {\n    function attachBanner() {\n        const el = document.createElement(\"p\");\n        const sty = el.style;\n        el.innerText = \"Running in emulator mode. Do not use with production credentials.\";\n        sty.position = \"fixed\";\n        sty.width = \"100%\";\n        sty.backgroundColor = \"#ffffff\";\n        sty.border = \".1em solid #000000\";\n        sty.color = \"#b50000\";\n        sty.bottom = \"0px\";\n        sty.left = \"0px\";\n        sty.margin = \"0px\";\n        sty.zIndex = \"10000\";\n        sty.textAlign = \"center\";\n        el.classList.add(\"firebase-emulator-warning\");\n        document.body.appendChild(el);\n    }\n    if (typeof console !== \"undefined\" && typeof console.info === \"function\") {\n        console.info(\"WARNING: You are using the Auth Emulator,\" + \" which is intended for local testing only.  Do not use with\" + \" production credentials.\");\n    }\n    if (false) {}\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Interface that represents the credentials returned by an {@link AuthProvider}.\r\n *\r\n * @remarks\r\n * Implementations specify the details about each auth provider's credential requirements.\r\n *\r\n * @public\r\n */ class AuthCredential {\n    /** @internal */ constructor(/**\r\n     * The authentication provider ID for the credential.\r\n     *\r\n     * @remarks\r\n     * For example, 'facebook.com', or 'google.com'.\r\n     */ providerId, /**\r\n     * The authentication sign in method for the credential.\r\n     *\r\n     * @remarks\r\n     * For example, {@link SignInMethod}.EMAIL_PASSWORD, or\r\n     * {@link SignInMethod}.EMAIL_LINK. This corresponds to the sign-in method\r\n     * identifier as returned in {@link fetchSignInMethodsForEmail}.\r\n     */ signInMethod){\n        this.providerId = providerId;\n        this.signInMethod = signInMethod;\n    }\n    /**\r\n     * Returns a JSON-serializable representation of this object.\r\n     *\r\n     * @returns a JSON-serializable representation of this object.\r\n     */ toJSON() {\n        return debugFail(\"not implemented\");\n    }\n    /** @internal */ _getIdTokenResponse(_auth) {\n        return debugFail(\"not implemented\");\n    }\n    /** @internal */ _linkToIdToken(_auth, _idToken) {\n        return debugFail(\"not implemented\");\n    }\n    /** @internal */ _getReauthenticationResolver(_auth) {\n        return debugFail(\"not implemented\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function resetPassword(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:resetPassword\" /* Endpoint.RESET_PASSWORD */ , _addTidIfNecessary(auth, request));\n}\nasync function updateEmailPassword(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */ , request);\n}\n// Used for linking an email/password account to an existing idToken. Uses the same request/response\n// format as updateEmailPassword.\nasync function linkEmailPassword(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signUp\" /* Endpoint.SIGN_UP */ , request);\n}\nasync function applyActionCode$1(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */ , _addTidIfNecessary(auth, request));\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function signInWithPassword(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signInWithPassword\" /* Endpoint.SIGN_IN_WITH_PASSWORD */ , _addTidIfNecessary(auth, request));\n}\nasync function sendOobCode(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:sendOobCode\" /* Endpoint.SEND_OOB_CODE */ , _addTidIfNecessary(auth, request));\n}\nasync function sendEmailVerification$1(auth, request) {\n    return sendOobCode(auth, request);\n}\nasync function sendPasswordResetEmail$1(auth, request) {\n    return sendOobCode(auth, request);\n}\nasync function sendSignInLinkToEmail$1(auth, request) {\n    return sendOobCode(auth, request);\n}\nasync function verifyAndChangeEmail(auth, request) {\n    return sendOobCode(auth, request);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function signInWithEmailLink$1(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signInWithEmailLink\" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */ , _addTidIfNecessary(auth, request));\n}\nasync function signInWithEmailLinkForLinking(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signInWithEmailLink\" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */ , _addTidIfNecessary(auth, request));\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Interface that represents the credentials returned by {@link EmailAuthProvider} for\r\n * {@link ProviderId}.PASSWORD\r\n *\r\n * @remarks\r\n * Covers both {@link SignInMethod}.EMAIL_PASSWORD and\r\n * {@link SignInMethod}.EMAIL_LINK.\r\n *\r\n * @public\r\n */ class EmailAuthCredential extends AuthCredential {\n    /** @internal */ constructor(/** @internal */ _email, /** @internal */ _password, signInMethod, /** @internal */ _tenantId = null){\n        super(\"password\" /* ProviderId.PASSWORD */ , signInMethod);\n        this._email = _email;\n        this._password = _password;\n        this._tenantId = _tenantId;\n    }\n    /** @internal */ static _fromEmailAndPassword(email, password) {\n        return new EmailAuthCredential(email, password, \"password\" /* SignInMethod.EMAIL_PASSWORD */ );\n    }\n    /** @internal */ static _fromEmailAndCode(email, oobCode, tenantId = null) {\n        return new EmailAuthCredential(email, oobCode, \"emailLink\" /* SignInMethod.EMAIL_LINK */ , tenantId);\n    }\n    /** {@inheritdoc AuthCredential.toJSON} */ toJSON() {\n        return {\n            email: this._email,\n            password: this._password,\n            signInMethod: this.signInMethod,\n            tenantId: this._tenantId\n        };\n    }\n    /**\r\n     * Static method to deserialize a JSON representation of an object into an {@link  AuthCredential}.\r\n     *\r\n     * @param json - Either `object` or the stringified representation of the object. When string is\r\n     * provided, `JSON.parse` would be called first.\r\n     *\r\n     * @returns If the JSON input does not represent an {@link AuthCredential}, null is returned.\r\n     */ static fromJSON(json) {\n        const obj = typeof json === \"string\" ? JSON.parse(json) : json;\n        if ((obj === null || obj === void 0 ? void 0 : obj.email) && (obj === null || obj === void 0 ? void 0 : obj.password)) {\n            if (obj.signInMethod === \"password\" /* SignInMethod.EMAIL_PASSWORD */ ) {\n                return this._fromEmailAndPassword(obj.email, obj.password);\n            } else if (obj.signInMethod === \"emailLink\" /* SignInMethod.EMAIL_LINK */ ) {\n                return this._fromEmailAndCode(obj.email, obj.password, obj.tenantId);\n            }\n        }\n        return null;\n    }\n    /** @internal */ async _getIdTokenResponse(auth) {\n        switch(this.signInMethod){\n            case \"password\" /* SignInMethod.EMAIL_PASSWORD */ :\n                const request = {\n                    returnSecureToken: true,\n                    email: this._email,\n                    password: this._password,\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ \n                };\n                return handleRecaptchaFlow(auth, request, \"signInWithPassword\" /* RecaptchaActionName.SIGN_IN_WITH_PASSWORD */ , signInWithPassword);\n            case \"emailLink\" /* SignInMethod.EMAIL_LINK */ :\n                return signInWithEmailLink$1(auth, {\n                    email: this._email,\n                    oobCode: this._password\n                });\n            default:\n                _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        }\n    }\n    /** @internal */ async _linkToIdToken(auth, idToken) {\n        switch(this.signInMethod){\n            case \"password\" /* SignInMethod.EMAIL_PASSWORD */ :\n                const request = {\n                    idToken,\n                    returnSecureToken: true,\n                    email: this._email,\n                    password: this._password,\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ \n                };\n                return handleRecaptchaFlow(auth, request, \"signUpPassword\" /* RecaptchaActionName.SIGN_UP_PASSWORD */ , linkEmailPassword);\n            case \"emailLink\" /* SignInMethod.EMAIL_LINK */ :\n                return signInWithEmailLinkForLinking(auth, {\n                    idToken,\n                    email: this._email,\n                    oobCode: this._password\n                });\n            default:\n                _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        }\n    }\n    /** @internal */ _getReauthenticationResolver(auth) {\n        return this._getIdTokenResponse(auth);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function signInWithIdp(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signInWithIdp\" /* Endpoint.SIGN_IN_WITH_IDP */ , _addTidIfNecessary(auth, request));\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const IDP_REQUEST_URI$1 = \"http://localhost\";\n/**\r\n * Represents the OAuth credentials returned by an {@link OAuthProvider}.\r\n *\r\n * @remarks\r\n * Implementations specify the details about each auth provider's credential requirements.\r\n *\r\n * @public\r\n */ class OAuthCredential extends AuthCredential {\n    constructor(){\n        super(...arguments);\n        this.pendingToken = null;\n    }\n    /** @internal */ static _fromParams(params) {\n        const cred = new OAuthCredential(params.providerId, params.signInMethod);\n        if (params.idToken || params.accessToken) {\n            // OAuth 2 and either ID token or access token.\n            if (params.idToken) {\n                cred.idToken = params.idToken;\n            }\n            if (params.accessToken) {\n                cred.accessToken = params.accessToken;\n            }\n            // Add nonce if available and no pendingToken is present.\n            if (params.nonce && !params.pendingToken) {\n                cred.nonce = params.nonce;\n            }\n            if (params.pendingToken) {\n                cred.pendingToken = params.pendingToken;\n            }\n        } else if (params.oauthToken && params.oauthTokenSecret) {\n            // OAuth 1 and OAuth token with token secret\n            cred.accessToken = params.oauthToken;\n            cred.secret = params.oauthTokenSecret;\n        } else {\n            _fail(\"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        }\n        return cred;\n    }\n    /** {@inheritdoc AuthCredential.toJSON}  */ toJSON() {\n        return {\n            idToken: this.idToken,\n            accessToken: this.accessToken,\n            secret: this.secret,\n            nonce: this.nonce,\n            pendingToken: this.pendingToken,\n            providerId: this.providerId,\n            signInMethod: this.signInMethod\n        };\n    }\n    /**\r\n     * Static method to deserialize a JSON representation of an object into an\r\n     * {@link  AuthCredential}.\r\n     *\r\n     * @param json - Input can be either Object or the stringified representation of the object.\r\n     * When string is provided, JSON.parse would be called first.\r\n     *\r\n     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.\r\n     */ static fromJSON(json) {\n        const obj = typeof json === \"string\" ? JSON.parse(json) : json;\n        const { providerId, signInMethod } = obj, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__rest)(obj, [\n            \"providerId\",\n            \"signInMethod\"\n        ]);\n        if (!providerId || !signInMethod) {\n            return null;\n        }\n        const cred = new OAuthCredential(providerId, signInMethod);\n        cred.idToken = rest.idToken || undefined;\n        cred.accessToken = rest.accessToken || undefined;\n        cred.secret = rest.secret;\n        cred.nonce = rest.nonce;\n        cred.pendingToken = rest.pendingToken || null;\n        return cred;\n    }\n    /** @internal */ _getIdTokenResponse(auth) {\n        const request = this.buildRequest();\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */ _linkToIdToken(auth, idToken) {\n        const request = this.buildRequest();\n        request.idToken = idToken;\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */ _getReauthenticationResolver(auth) {\n        const request = this.buildRequest();\n        request.autoCreate = false;\n        return signInWithIdp(auth, request);\n    }\n    buildRequest() {\n        const request = {\n            requestUri: IDP_REQUEST_URI$1,\n            returnSecureToken: true\n        };\n        if (this.pendingToken) {\n            request.pendingToken = this.pendingToken;\n        } else {\n            const postBody = {};\n            if (this.idToken) {\n                postBody[\"id_token\"] = this.idToken;\n            }\n            if (this.accessToken) {\n                postBody[\"access_token\"] = this.accessToken;\n            }\n            if (this.secret) {\n                postBody[\"oauth_token_secret\"] = this.secret;\n            }\n            postBody[\"providerId\"] = this.providerId;\n            if (this.nonce && !this.pendingToken) {\n                postBody[\"nonce\"] = this.nonce;\n            }\n            request.postBody = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)(postBody);\n        }\n        return request;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function signInWithPhoneNumber$1(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */ , _addTidIfNecessary(auth, request));\n}\nasync function linkWithPhoneNumber$1(auth, request) {\n    const response = await _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */ , _addTidIfNecessary(auth, request));\n    if (response.temporaryProof) {\n        throw _makeTaggedError(auth, \"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */ , response);\n    }\n    return response;\n}\nconst VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_ = {\n    [\"USER_NOT_FOUND\" /* ServerError.USER_NOT_FOUND */ ]: \"user-not-found\" /* AuthErrorCode.USER_DELETED */ \n};\nasync function verifyPhoneNumberForExisting(auth, request) {\n    const apiRequest = Object.assign(Object.assign({}, request), {\n        operation: \"REAUTH\"\n    });\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */ , _addTidIfNecessary(auth, apiRequest), VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Represents the credentials returned by {@link PhoneAuthProvider}.\r\n *\r\n * @public\r\n */ class PhoneAuthCredential extends AuthCredential {\n    constructor(params){\n        super(\"phone\" /* ProviderId.PHONE */ , \"phone\" /* SignInMethod.PHONE */ );\n        this.params = params;\n    }\n    /** @internal */ static _fromVerification(verificationId, verificationCode) {\n        return new PhoneAuthCredential({\n            verificationId,\n            verificationCode\n        });\n    }\n    /** @internal */ static _fromTokenResponse(phoneNumber, temporaryProof) {\n        return new PhoneAuthCredential({\n            phoneNumber,\n            temporaryProof\n        });\n    }\n    /** @internal */ _getIdTokenResponse(auth) {\n        return signInWithPhoneNumber$1(auth, this._makeVerificationRequest());\n    }\n    /** @internal */ _linkToIdToken(auth, idToken) {\n        return linkWithPhoneNumber$1(auth, Object.assign({\n            idToken\n        }, this._makeVerificationRequest()));\n    }\n    /** @internal */ _getReauthenticationResolver(auth) {\n        return verifyPhoneNumberForExisting(auth, this._makeVerificationRequest());\n    }\n    /** @internal */ _makeVerificationRequest() {\n        const { temporaryProof, phoneNumber, verificationId, verificationCode } = this.params;\n        if (temporaryProof && phoneNumber) {\n            return {\n                temporaryProof,\n                phoneNumber\n            };\n        }\n        return {\n            sessionInfo: verificationId,\n            code: verificationCode\n        };\n    }\n    /** {@inheritdoc AuthCredential.toJSON} */ toJSON() {\n        const obj = {\n            providerId: this.providerId\n        };\n        if (this.params.phoneNumber) {\n            obj.phoneNumber = this.params.phoneNumber;\n        }\n        if (this.params.temporaryProof) {\n            obj.temporaryProof = this.params.temporaryProof;\n        }\n        if (this.params.verificationCode) {\n            obj.verificationCode = this.params.verificationCode;\n        }\n        if (this.params.verificationId) {\n            obj.verificationId = this.params.verificationId;\n        }\n        return obj;\n    }\n    /** Generates a phone credential based on a plain object or a JSON string. */ static fromJSON(json) {\n        if (typeof json === \"string\") {\n            json = JSON.parse(json);\n        }\n        const { verificationId, verificationCode, phoneNumber, temporaryProof } = json;\n        if (!verificationCode && !verificationId && !phoneNumber && !temporaryProof) {\n            return null;\n        }\n        return new PhoneAuthCredential({\n            verificationId,\n            verificationCode,\n            phoneNumber,\n            temporaryProof\n        });\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Maps the mode string in action code URL to Action Code Info operation.\r\n *\r\n * @param mode\r\n */ function parseMode(mode) {\n    switch(mode){\n        case \"recoverEmail\":\n            return \"RECOVER_EMAIL\" /* ActionCodeOperation.RECOVER_EMAIL */ ;\n        case \"resetPassword\":\n            return \"PASSWORD_RESET\" /* ActionCodeOperation.PASSWORD_RESET */ ;\n        case \"signIn\":\n            return \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */ ;\n        case \"verifyEmail\":\n            return \"VERIFY_EMAIL\" /* ActionCodeOperation.VERIFY_EMAIL */ ;\n        case \"verifyAndChangeEmail\":\n            return \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */ ;\n        case \"revertSecondFactorAddition\":\n            return \"REVERT_SECOND_FACTOR_ADDITION\" /* ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION */ ;\n        default:\n            return null;\n    }\n}\n/**\r\n * Helper to parse FDL links\r\n *\r\n * @param url\r\n */ function parseDeepLink(url) {\n    const link = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(url))[\"link\"];\n    // Double link case (automatic redirect).\n    const doubleDeepLink = link ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(link))[\"deep_link_id\"] : null;\n    // iOS custom scheme links.\n    const iOSDeepLink = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(url))[\"deep_link_id\"];\n    const iOSDoubleDeepLink = iOSDeepLink ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(iOSDeepLink))[\"link\"] : null;\n    return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;\n}\n/**\r\n * A utility class to parse email action URLs such as password reset, email verification,\r\n * email link sign in, etc.\r\n *\r\n * @public\r\n */ class ActionCodeURL {\n    /**\r\n     * @param actionLink - The link from which to extract the URL.\r\n     * @returns The {@link ActionCodeURL} object, or null if the link is invalid.\r\n     *\r\n     * @internal\r\n     */ constructor(actionLink){\n        var _a, _b, _c, _d, _e, _f;\n        const searchParams = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(actionLink));\n        const apiKey = (_a = searchParams[\"apiKey\" /* QueryField.API_KEY */ ]) !== null && _a !== void 0 ? _a : null;\n        const code = (_b = searchParams[\"oobCode\" /* QueryField.CODE */ ]) !== null && _b !== void 0 ? _b : null;\n        const operation = parseMode((_c = searchParams[\"mode\" /* QueryField.MODE */ ]) !== null && _c !== void 0 ? _c : null);\n        // Validate API key, code and mode.\n        _assert(apiKey && code && operation, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        this.apiKey = apiKey;\n        this.operation = operation;\n        this.code = code;\n        this.continueUrl = (_d = searchParams[\"continueUrl\" /* QueryField.CONTINUE_URL */ ]) !== null && _d !== void 0 ? _d : null;\n        this.languageCode = (_e = searchParams[\"languageCode\" /* QueryField.LANGUAGE_CODE */ ]) !== null && _e !== void 0 ? _e : null;\n        this.tenantId = (_f = searchParams[\"tenantId\" /* QueryField.TENANT_ID */ ]) !== null && _f !== void 0 ? _f : null;\n    }\n    /**\r\n     * Parses the email action link string and returns an {@link ActionCodeURL} if the link is valid,\r\n     * otherwise returns null.\r\n     *\r\n     * @param link  - The email action link string.\r\n     * @returns The {@link ActionCodeURL} object, or null if the link is invalid.\r\n     *\r\n     * @public\r\n     */ static parseLink(link) {\n        const actionLink = parseDeepLink(link);\n        try {\n            return new ActionCodeURL(actionLink);\n        } catch (_a) {\n            return null;\n        }\n    }\n}\n/**\r\n * Parses the email action link string and returns an {@link ActionCodeURL} if\r\n * the link is valid, otherwise returns null.\r\n *\r\n * @public\r\n */ function parseActionCodeURL(link) {\n    return ActionCodeURL.parseLink(link);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provider for generating {@link EmailAuthCredential}.\r\n *\r\n * @public\r\n */ class EmailAuthProvider {\n    constructor(){\n        /**\r\n         * Always set to {@link ProviderId}.PASSWORD, even for email link.\r\n         */ this.providerId = EmailAuthProvider.PROVIDER_ID;\n    }\n    /**\r\n     * Initialize an {@link AuthCredential} using an email and password.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const authCredential = EmailAuthProvider.credential(email, password);\r\n     * const userCredential = await signInWithCredential(auth, authCredential);\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const userCredential = await signInWithEmailAndPassword(auth, email, password);\r\n     * ```\r\n     *\r\n     * @param email - Email address.\r\n     * @param password - User account password.\r\n     * @returns The auth provider credential.\r\n     */ static credential(email, password) {\n        return EmailAuthCredential._fromEmailAndPassword(email, password);\n    }\n    /**\r\n     * Initialize an {@link AuthCredential} using an email and an email link after a sign in with\r\n     * email link operation.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const authCredential = EmailAuthProvider.credentialWithLink(auth, email, emailLink);\r\n     * const userCredential = await signInWithCredential(auth, authCredential);\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * await sendSignInLinkToEmail(auth, email);\r\n     * // Obtain emailLink from user.\r\n     * const userCredential = await signInWithEmailLink(auth, email, emailLink);\r\n     * ```\r\n     *\r\n     * @param auth - The {@link Auth} instance used to verify the link.\r\n     * @param email - Email address.\r\n     * @param emailLink - Sign-in email link.\r\n     * @returns - The auth provider credential.\r\n     */ static credentialWithLink(email, emailLink) {\n        const actionCodeUrl = ActionCodeURL.parseLink(emailLink);\n        _assert(actionCodeUrl, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        return EmailAuthCredential._fromEmailAndCode(email, actionCodeUrl.code, actionCodeUrl.tenantId);\n    }\n}\n/**\r\n * Always set to {@link ProviderId}.PASSWORD, even for email link.\r\n */ EmailAuthProvider.PROVIDER_ID = \"password\" /* ProviderId.PASSWORD */ ;\n/**\r\n * Always set to {@link SignInMethod}.EMAIL_PASSWORD.\r\n */ EmailAuthProvider.EMAIL_PASSWORD_SIGN_IN_METHOD = \"password\" /* SignInMethod.EMAIL_PASSWORD */ ;\n/**\r\n * Always set to {@link SignInMethod}.EMAIL_LINK.\r\n */ EmailAuthProvider.EMAIL_LINK_SIGN_IN_METHOD = \"emailLink\" /* SignInMethod.EMAIL_LINK */ ;\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The base class for all Federated providers (OAuth (including OIDC), SAML).\r\n *\r\n * This class is not meant to be instantiated directly.\r\n *\r\n * @public\r\n */ class FederatedAuthProvider {\n    /**\r\n     * Constructor for generic OAuth providers.\r\n     *\r\n     * @param providerId - Provider for which credentials should be generated.\r\n     */ constructor(providerId){\n        this.providerId = providerId;\n        /** @internal */ this.defaultLanguageCode = null;\n        /** @internal */ this.customParameters = {};\n    }\n    /**\r\n     * Set the language gode.\r\n     *\r\n     * @param languageCode - language code\r\n     */ setDefaultLanguage(languageCode) {\n        this.defaultLanguageCode = languageCode;\n    }\n    /**\r\n     * Sets the OAuth custom parameters to pass in an OAuth request for popup and redirect sign-in\r\n     * operations.\r\n     *\r\n     * @remarks\r\n     * For a detailed list, check the reserved required OAuth 2.0 parameters such as `client_id`,\r\n     * `redirect_uri`, `scope`, `response_type`, and `state` are not allowed and will be ignored.\r\n     *\r\n     * @param customOAuthParameters - The custom OAuth parameters to pass in the OAuth request.\r\n     */ setCustomParameters(customOAuthParameters) {\n        this.customParameters = customOAuthParameters;\n        return this;\n    }\n    /**\r\n     * Retrieve the current list of {@link CustomParameters}.\r\n     */ getCustomParameters() {\n        return this.customParameters;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Common code to all OAuth providers. This is separate from the\r\n * {@link OAuthProvider} so that child providers (like\r\n * {@link GoogleAuthProvider}) don't inherit the `credential` instance method.\r\n * Instead, they rely on a static `credential` method.\r\n */ class BaseOAuthProvider extends FederatedAuthProvider {\n    constructor(){\n        super(...arguments);\n        /** @internal */ this.scopes = [];\n    }\n    /**\r\n     * Add an OAuth scope to the credential.\r\n     *\r\n     * @param scope - Provider OAuth scope to add.\r\n     */ addScope(scope) {\n        // If not already added, add scope to list.\n        if (!this.scopes.includes(scope)) {\n            this.scopes.push(scope);\n        }\n        return this;\n    }\n    /**\r\n     * Retrieve the current list of OAuth scopes.\r\n     */ getScopes() {\n        return [\n            ...this.scopes\n        ];\n    }\n}\n/**\r\n * Provider for generating generic {@link OAuthCredential}.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new OAuthProvider('google.com');\r\n * // Start a sign in process for an unauthenticated user.\r\n * provider.addScope('profile');\r\n * provider.addScope('email');\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a OAuth Access Token for the provider.\r\n *   const credential = provider.credentialFromResult(auth, result);\r\n *   const token = credential.accessToken;\r\n * }\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a popup.\r\n * const provider = new OAuthProvider('google.com');\r\n * provider.addScope('profile');\r\n * provider.addScope('email');\r\n * const result = await signInWithPopup(auth, provider);\r\n *\r\n * // The signed-in user info.\r\n * const user = result.user;\r\n * // This gives you a OAuth Access Token for the provider.\r\n * const credential = provider.credentialFromResult(auth, result);\r\n * const token = credential.accessToken;\r\n * ```\r\n * @public\r\n */ class OAuthProvider extends BaseOAuthProvider {\n    /**\r\n     * Creates an {@link OAuthCredential} from a JSON string or a plain object.\r\n     * @param json - A plain object or a JSON string\r\n     */ static credentialFromJSON(json) {\n        const obj = typeof json === \"string\" ? JSON.parse(json) : json;\n        _assert(\"providerId\" in obj && \"signInMethod\" in obj, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        return OAuthCredential._fromParams(obj);\n    }\n    /**\r\n     * Creates a {@link OAuthCredential} from a generic OAuth provider's access token or ID token.\r\n     *\r\n     * @remarks\r\n     * The raw nonce is required when an ID token with a nonce field is provided. The SHA-256 hash of\r\n     * the raw nonce must match the nonce field in the ID token.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // `googleUser` from the onsuccess Google Sign In callback.\r\n     * // Initialize a generate OAuth provider with a `google.com` providerId.\r\n     * const provider = new OAuthProvider('google.com');\r\n     * const credential = provider.credential({\r\n     *   idToken: googleUser.getAuthResponse().id_token,\r\n     * });\r\n     * const result = await signInWithCredential(credential);\r\n     * ```\r\n     *\r\n     * @param params - Either the options object containing the ID token, access token and raw nonce\r\n     * or the ID token string.\r\n     */ credential(params) {\n        return this._credential(Object.assign(Object.assign({}, params), {\n            nonce: params.rawNonce\n        }));\n    }\n    /** An internal credential method that accepts more permissive options */ _credential(params) {\n        _assert(params.idToken || params.accessToken, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        // For OAuthCredential, sign in method is same as providerId.\n        return OAuthCredential._fromParams(Object.assign(Object.assign({}, params), {\n            providerId: this.providerId,\n            signInMethod: this.providerId\n        }));\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromResult(userCredential) {\n        return OAuthProvider.oauthCredentialFromTaggedObject(userCredential);\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\r\n     * thrown during a sign-in, link, or reauthenticate operation.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromError(error) {\n        return OAuthProvider.oauthCredentialFromTaggedObject(error.customData || {});\n    }\n    static oauthCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { oauthIdToken, oauthAccessToken, oauthTokenSecret, pendingToken, nonce, providerId } = tokenResponse;\n        if (!oauthAccessToken && !oauthTokenSecret && !oauthIdToken && !pendingToken) {\n            return null;\n        }\n        if (!providerId) {\n            return null;\n        }\n        try {\n            return new OAuthProvider(providerId)._credential({\n                idToken: oauthIdToken,\n                accessToken: oauthAccessToken,\n                nonce,\n                pendingToken\n            });\n        } catch (e) {\n            return null;\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.FACEBOOK.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new FacebookAuthProvider();\r\n * // Start a sign in process for an unauthenticated user.\r\n * provider.addScope('user_birthday');\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a Facebook Access Token.\r\n *   const credential = FacebookAuthProvider.credentialFromResult(result);\r\n *   const token = credential.accessToken;\r\n * }\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a popup.\r\n * const provider = new FacebookAuthProvider();\r\n * provider.addScope('user_birthday');\r\n * const result = await signInWithPopup(auth, provider);\r\n *\r\n * // The signed-in user info.\r\n * const user = result.user;\r\n * // This gives you a Facebook Access Token.\r\n * const credential = FacebookAuthProvider.credentialFromResult(result);\r\n * const token = credential.accessToken;\r\n * ```\r\n *\r\n * @public\r\n */ class FacebookAuthProvider extends BaseOAuthProvider {\n    constructor(){\n        super(\"facebook.com\" /* ProviderId.FACEBOOK */ );\n    }\n    /**\r\n     * Creates a credential for Facebook.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // `event` from the Facebook auth.authResponseChange callback.\r\n     * const credential = FacebookAuthProvider.credential(event.authResponse.accessToken);\r\n     * const result = await signInWithCredential(credential);\r\n     * ```\r\n     *\r\n     * @param accessToken - Facebook access token.\r\n     */ static credential(accessToken) {\n        return OAuthCredential._fromParams({\n            providerId: FacebookAuthProvider.PROVIDER_ID,\n            signInMethod: FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,\n            accessToken\n        });\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromResult(userCredential) {\n        return FacebookAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\r\n     * thrown during a sign-in, link, or reauthenticate operation.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromError(error) {\n        return FacebookAuthProvider.credentialFromTaggedObject(error.customData || {});\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse || !(\"oauthAccessToken\" in tokenResponse)) {\n            return null;\n        }\n        if (!tokenResponse.oauthAccessToken) {\n            return null;\n        }\n        try {\n            return FacebookAuthProvider.credential(tokenResponse.oauthAccessToken);\n        } catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.FACEBOOK. */ FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD = \"facebook.com\" /* SignInMethod.FACEBOOK */ ;\n/** Always set to {@link ProviderId}.FACEBOOK. */ FacebookAuthProvider.PROVIDER_ID = \"facebook.com\" /* ProviderId.FACEBOOK */ ;\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.GOOGLE.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new GoogleAuthProvider();\r\n * // Start a sign in process for an unauthenticated user.\r\n * provider.addScope('profile');\r\n * provider.addScope('email');\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a Google Access Token.\r\n *   const credential = GoogleAuthProvider.credentialFromResult(result);\r\n *   const token = credential.accessToken;\r\n * }\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a popup.\r\n * const provider = new GoogleAuthProvider();\r\n * provider.addScope('profile');\r\n * provider.addScope('email');\r\n * const result = await signInWithPopup(auth, provider);\r\n *\r\n * // The signed-in user info.\r\n * const user = result.user;\r\n * // This gives you a Google Access Token.\r\n * const credential = GoogleAuthProvider.credentialFromResult(result);\r\n * const token = credential.accessToken;\r\n * ```\r\n *\r\n * @public\r\n */ class GoogleAuthProvider extends BaseOAuthProvider {\n    constructor(){\n        super(\"google.com\" /* ProviderId.GOOGLE */ );\n        this.addScope(\"profile\");\n    }\n    /**\r\n     * Creates a credential for Google. At least one of ID token and access token is required.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // \\`googleUser\\` from the onsuccess Google Sign In callback.\r\n     * const credential = GoogleAuthProvider.credential(googleUser.getAuthResponse().id_token);\r\n     * const result = await signInWithCredential(credential);\r\n     * ```\r\n     *\r\n     * @param idToken - Google ID token.\r\n     * @param accessToken - Google access token.\r\n     */ static credential(idToken, accessToken) {\n        return OAuthCredential._fromParams({\n            providerId: GoogleAuthProvider.PROVIDER_ID,\n            signInMethod: GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,\n            idToken,\n            accessToken\n        });\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromResult(userCredential) {\n        return GoogleAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\r\n     * thrown during a sign-in, link, or reauthenticate operation.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromError(error) {\n        return GoogleAuthProvider.credentialFromTaggedObject(error.customData || {});\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { oauthIdToken, oauthAccessToken } = tokenResponse;\n        if (!oauthIdToken && !oauthAccessToken) {\n            // This could be an oauth 1 credential or a phone credential\n            return null;\n        }\n        try {\n            return GoogleAuthProvider.credential(oauthIdToken, oauthAccessToken);\n        } catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.GOOGLE. */ GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD = \"google.com\" /* SignInMethod.GOOGLE */ ;\n/** Always set to {@link ProviderId}.GOOGLE. */ GoogleAuthProvider.PROVIDER_ID = \"google.com\" /* ProviderId.GOOGLE */ ;\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.GITHUB.\r\n *\r\n * @remarks\r\n * GitHub requires an OAuth 2.0 redirect, so you can either handle the redirect directly, or use\r\n * the {@link signInWithPopup} handler:\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new GithubAuthProvider();\r\n * // Start a sign in process for an unauthenticated user.\r\n * provider.addScope('repo');\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a Github Access Token.\r\n *   const credential = GithubAuthProvider.credentialFromResult(result);\r\n *   const token = credential.accessToken;\r\n * }\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a popup.\r\n * const provider = new GithubAuthProvider();\r\n * provider.addScope('repo');\r\n * const result = await signInWithPopup(auth, provider);\r\n *\r\n * // The signed-in user info.\r\n * const user = result.user;\r\n * // This gives you a Github Access Token.\r\n * const credential = GithubAuthProvider.credentialFromResult(result);\r\n * const token = credential.accessToken;\r\n * ```\r\n * @public\r\n */ class GithubAuthProvider extends BaseOAuthProvider {\n    constructor(){\n        super(\"github.com\" /* ProviderId.GITHUB */ );\n    }\n    /**\r\n     * Creates a credential for Github.\r\n     *\r\n     * @param accessToken - Github access token.\r\n     */ static credential(accessToken) {\n        return OAuthCredential._fromParams({\n            providerId: GithubAuthProvider.PROVIDER_ID,\n            signInMethod: GithubAuthProvider.GITHUB_SIGN_IN_METHOD,\n            accessToken\n        });\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromResult(userCredential) {\n        return GithubAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\r\n     * thrown during a sign-in, link, or reauthenticate operation.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromError(error) {\n        return GithubAuthProvider.credentialFromTaggedObject(error.customData || {});\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse || !(\"oauthAccessToken\" in tokenResponse)) {\n            return null;\n        }\n        if (!tokenResponse.oauthAccessToken) {\n            return null;\n        }\n        try {\n            return GithubAuthProvider.credential(tokenResponse.oauthAccessToken);\n        } catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.GITHUB. */ GithubAuthProvider.GITHUB_SIGN_IN_METHOD = \"github.com\" /* SignInMethod.GITHUB */ ;\n/** Always set to {@link ProviderId}.GITHUB. */ GithubAuthProvider.PROVIDER_ID = \"github.com\" /* ProviderId.GITHUB */ ;\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const IDP_REQUEST_URI = \"http://localhost\";\n/**\r\n * @public\r\n */ class SAMLAuthCredential extends AuthCredential {\n    /** @internal */ constructor(providerId, pendingToken){\n        super(providerId, providerId);\n        this.pendingToken = pendingToken;\n    }\n    /** @internal */ _getIdTokenResponse(auth) {\n        const request = this.buildRequest();\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */ _linkToIdToken(auth, idToken) {\n        const request = this.buildRequest();\n        request.idToken = idToken;\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */ _getReauthenticationResolver(auth) {\n        const request = this.buildRequest();\n        request.autoCreate = false;\n        return signInWithIdp(auth, request);\n    }\n    /** {@inheritdoc AuthCredential.toJSON}  */ toJSON() {\n        return {\n            signInMethod: this.signInMethod,\n            providerId: this.providerId,\n            pendingToken: this.pendingToken\n        };\n    }\n    /**\r\n     * Static method to deserialize a JSON representation of an object into an\r\n     * {@link  AuthCredential}.\r\n     *\r\n     * @param json - Input can be either Object or the stringified representation of the object.\r\n     * When string is provided, JSON.parse would be called first.\r\n     *\r\n     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.\r\n     */ static fromJSON(json) {\n        const obj = typeof json === \"string\" ? JSON.parse(json) : json;\n        const { providerId, signInMethod, pendingToken } = obj;\n        if (!providerId || !signInMethod || !pendingToken || providerId !== signInMethod) {\n            return null;\n        }\n        return new SAMLAuthCredential(providerId, pendingToken);\n    }\n    /**\r\n     * Helper static method to avoid exposing the constructor to end users.\r\n     *\r\n     * @internal\r\n     */ static _create(providerId, pendingToken) {\n        return new SAMLAuthCredential(providerId, pendingToken);\n    }\n    buildRequest() {\n        return {\n            requestUri: IDP_REQUEST_URI,\n            returnSecureToken: true,\n            pendingToken: this.pendingToken\n        };\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const SAML_PROVIDER_PREFIX = \"saml.\";\n/**\r\n * An {@link AuthProvider} for SAML.\r\n *\r\n * @public\r\n */ class SAMLAuthProvider extends FederatedAuthProvider {\n    /**\r\n     * Constructor. The providerId must start with \"saml.\"\r\n     * @param providerId - SAML provider ID.\r\n     */ constructor(providerId){\n        _assert(providerId.startsWith(SAML_PROVIDER_PREFIX), \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        super(providerId);\n    }\n    /**\r\n     * Generates an {@link AuthCredential} from a {@link UserCredential} after a\r\n     * successful SAML flow completes.\r\n     *\r\n     * @remarks\r\n     *\r\n     * For example, to get an {@link AuthCredential}, you could write the\r\n     * following code:\r\n     *\r\n     * ```js\r\n     * const userCredential = await signInWithPopup(auth, samlProvider);\r\n     * const credential = SAMLAuthProvider.credentialFromResult(userCredential);\r\n     * ```\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromResult(userCredential) {\n        return SAMLAuthProvider.samlCredentialFromTaggedObject(userCredential);\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\r\n     * thrown during a sign-in, link, or reauthenticate operation.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromError(error) {\n        return SAMLAuthProvider.samlCredentialFromTaggedObject(error.customData || {});\n    }\n    /**\r\n     * Creates an {@link AuthCredential} from a JSON string or a plain object.\r\n     * @param json - A plain object or a JSON string\r\n     */ static credentialFromJSON(json) {\n        const credential = SAMLAuthCredential.fromJSON(json);\n        _assert(credential, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        return credential;\n    }\n    static samlCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { pendingToken, providerId } = tokenResponse;\n        if (!pendingToken || !providerId) {\n            return null;\n        }\n        try {\n            return SAMLAuthCredential._create(providerId, pendingToken);\n        } catch (e) {\n            return null;\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.TWITTER.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a redirect.\r\n * const provider = new TwitterAuthProvider();\r\n * // Start a sign in process for an unauthenticated user.\r\n * await signInWithRedirect(auth, provider);\r\n * // This will trigger a full page redirect away from your app\r\n *\r\n * // After returning from the redirect when your app initializes you can obtain the result\r\n * const result = await getRedirectResult(auth);\r\n * if (result) {\r\n *   // This is the signed-in user\r\n *   const user = result.user;\r\n *   // This gives you a Twitter Access Token and Secret.\r\n *   const credential = TwitterAuthProvider.credentialFromResult(result);\r\n *   const token = credential.accessToken;\r\n *   const secret = credential.secret;\r\n * }\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Sign in using a popup.\r\n * const provider = new TwitterAuthProvider();\r\n * const result = await signInWithPopup(auth, provider);\r\n *\r\n * // The signed-in user info.\r\n * const user = result.user;\r\n * // This gives you a Twitter Access Token and Secret.\r\n * const credential = TwitterAuthProvider.credentialFromResult(result);\r\n * const token = credential.accessToken;\r\n * const secret = credential.secret;\r\n * ```\r\n *\r\n * @public\r\n */ class TwitterAuthProvider extends BaseOAuthProvider {\n    constructor(){\n        super(\"twitter.com\" /* ProviderId.TWITTER */ );\n    }\n    /**\r\n     * Creates a credential for Twitter.\r\n     *\r\n     * @param token - Twitter access token.\r\n     * @param secret - Twitter secret.\r\n     */ static credential(token, secret) {\n        return OAuthCredential._fromParams({\n            providerId: TwitterAuthProvider.PROVIDER_ID,\n            signInMethod: TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,\n            oauthToken: token,\n            oauthTokenSecret: secret\n        });\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromResult(userCredential) {\n        return TwitterAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\r\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\r\n     * thrown during a sign-in, link, or reauthenticate operation.\r\n     *\r\n     * @param userCredential - The user credential.\r\n     */ static credentialFromError(error) {\n        return TwitterAuthProvider.credentialFromTaggedObject(error.customData || {});\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { oauthAccessToken, oauthTokenSecret } = tokenResponse;\n        if (!oauthAccessToken || !oauthTokenSecret) {\n            return null;\n        }\n        try {\n            return TwitterAuthProvider.credential(oauthAccessToken, oauthTokenSecret);\n        } catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.TWITTER. */ TwitterAuthProvider.TWITTER_SIGN_IN_METHOD = \"twitter.com\" /* SignInMethod.TWITTER */ ;\n/** Always set to {@link ProviderId}.TWITTER. */ TwitterAuthProvider.PROVIDER_ID = \"twitter.com\" /* ProviderId.TWITTER */ ;\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function signUp(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signUp\" /* Endpoint.SIGN_UP */ , _addTidIfNecessary(auth, request));\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class UserCredentialImpl {\n    constructor(params){\n        this.user = params.user;\n        this.providerId = params.providerId;\n        this._tokenResponse = params._tokenResponse;\n        this.operationType = params.operationType;\n    }\n    static async _fromIdTokenResponse(auth, operationType, idTokenResponse, isAnonymous = false) {\n        const user = await UserImpl._fromIdTokenResponse(auth, idTokenResponse, isAnonymous);\n        const providerId = providerIdForResponse(idTokenResponse);\n        const userCred = new UserCredentialImpl({\n            user,\n            providerId,\n            _tokenResponse: idTokenResponse,\n            operationType\n        });\n        return userCred;\n    }\n    static async _forOperation(user, operationType, response) {\n        await user._updateTokensIfNecessary(response, /* reload */ true);\n        const providerId = providerIdForResponse(response);\n        return new UserCredentialImpl({\n            user,\n            providerId,\n            _tokenResponse: response,\n            operationType\n        });\n    }\n}\nfunction providerIdForResponse(response) {\n    if (response.providerId) {\n        return response.providerId;\n    }\n    if (\"phoneNumber\" in response) {\n        return \"phone\" /* ProviderId.PHONE */ ;\n    }\n    return null;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Asynchronously signs in as an anonymous user.\r\n *\r\n * @remarks\r\n * If there is already an anonymous user signed in, that user will be returned; otherwise, a\r\n * new anonymous user identity will be created and returned.\r\n *\r\n * This method is not supported by {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n *\r\n * @public\r\n */ async function signInAnonymously(auth) {\n    var _a;\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authInternal = _castAuth(auth);\n    await authInternal._initializationPromise;\n    if ((_a = authInternal.currentUser) === null || _a === void 0 ? void 0 : _a.isAnonymous) {\n        // If an anonymous user is already signed in, no need to sign them in again.\n        return new UserCredentialImpl({\n            user: authInternal.currentUser,\n            providerId: null,\n            operationType: \"signIn\" /* OperationType.SIGN_IN */ \n        });\n    }\n    const response = await signUp(authInternal, {\n        returnSecureToken: true\n    });\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */ , response, true);\n    await authInternal._updateCurrentUser(userCredential.user);\n    return userCredential;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class MultiFactorError extends _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError {\n    constructor(auth, error, operationType, user){\n        var _a;\n        super(error.code, error.message);\n        this.operationType = operationType;\n        this.user = user;\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, MultiFactorError.prototype);\n        this.customData = {\n            appName: auth.name,\n            tenantId: (_a = auth.tenantId) !== null && _a !== void 0 ? _a : undefined,\n            _serverResponse: error.customData._serverResponse,\n            operationType\n        };\n    }\n    static _fromErrorAndOperation(auth, error, operationType, user) {\n        return new MultiFactorError(auth, error, operationType, user);\n    }\n}\nfunction _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user) {\n    const idTokenProvider = operationType === \"reauthenticate\" /* OperationType.REAUTHENTICATE */  ? credential._getReauthenticationResolver(auth) : credential._getIdTokenResponse(auth);\n    return idTokenProvider.catch((error)=>{\n        if (error.code === `auth/${\"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */ }`) {\n            throw MultiFactorError._fromErrorAndOperation(auth, error, operationType, user);\n        }\n        throw error;\n    });\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Takes a set of UserInfo provider data and converts it to a set of names\r\n */ function providerDataAsNames(providerData) {\n    return new Set(providerData.map(({ providerId })=>providerId).filter((pid)=>!!pid));\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Unlinks a provider from a user account.\r\n *\r\n * @param user - The user.\r\n * @param providerId - The provider to unlink.\r\n *\r\n * @public\r\n */ async function unlink(user, providerId) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    await _assertLinkedStatus(true, userInternal, providerId);\n    const { providerUserInfo } = await deleteLinkedAccounts(userInternal.auth, {\n        idToken: await userInternal.getIdToken(),\n        deleteProvider: [\n            providerId\n        ]\n    });\n    const providersLeft = providerDataAsNames(providerUserInfo || []);\n    userInternal.providerData = userInternal.providerData.filter((pd)=>providersLeft.has(pd.providerId));\n    if (!providersLeft.has(\"phone\" /* ProviderId.PHONE */ )) {\n        userInternal.phoneNumber = null;\n    }\n    await userInternal.auth._persistUserIfCurrent(userInternal);\n    return userInternal;\n}\nasync function _link(user, credential, bypassAuthState = false) {\n    const response = await _logoutIfInvalidated(user, credential._linkToIdToken(user.auth, await user.getIdToken()), bypassAuthState);\n    return UserCredentialImpl._forOperation(user, \"link\" /* OperationType.LINK */ , response);\n}\nasync function _assertLinkedStatus(expected, user, provider) {\n    await _reloadWithoutSaving(user);\n    const providerIds = providerDataAsNames(user.providerData);\n    const code = expected === false ? \"provider-already-linked\" /* AuthErrorCode.PROVIDER_ALREADY_LINKED */  : \"no-such-provider\" /* AuthErrorCode.NO_SUCH_PROVIDER */ ;\n    _assert(providerIds.has(provider) === expected, user.auth, code);\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function _reauthenticate(user, credential, bypassAuthState = false) {\n    const { auth } = user;\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const operationType = \"reauthenticate\" /* OperationType.REAUTHENTICATE */ ;\n    try {\n        const response = await _logoutIfInvalidated(user, _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user), bypassAuthState);\n        _assert(response.idToken, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        const parsed = _parseToken(response.idToken);\n        _assert(parsed, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        const { sub: localId } = parsed;\n        _assert(user.uid === localId, auth, \"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */ );\n        return UserCredentialImpl._forOperation(user, operationType, response);\n    } catch (e) {\n        // Convert user deleted error into user mismatch\n        if ((e === null || e === void 0 ? void 0 : e.code) === `auth/${\"user-not-found\" /* AuthErrorCode.USER_DELETED */ }`) {\n            _fail(auth, \"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */ );\n        }\n        throw e;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function _signInWithCredential(auth, credential, bypassAuthState = false) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const operationType = \"signIn\" /* OperationType.SIGN_IN */ ;\n    const response = await _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential);\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, operationType, response);\n    if (!bypassAuthState) {\n        await auth._updateCurrentUser(userCredential.user);\n    }\n    return userCredential;\n}\n/**\r\n * Asynchronously signs in with the given credentials.\r\n *\r\n * @remarks\r\n * An {@link AuthProvider} can be used to generate the credential.\r\n *\r\n * This method is not supported by {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param credential - The auth credential.\r\n *\r\n * @public\r\n */ async function signInWithCredential(auth, credential) {\n    return _signInWithCredential(_castAuth(auth), credential);\n}\n/**\r\n * Links the user account with the given credentials.\r\n *\r\n * @remarks\r\n * An {@link AuthProvider} can be used to generate the credential.\r\n *\r\n * @param user - The user.\r\n * @param credential - The auth credential.\r\n *\r\n * @public\r\n */ async function linkWithCredential(user, credential) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    await _assertLinkedStatus(false, userInternal, credential.providerId);\n    return _link(userInternal, credential);\n}\n/**\r\n * Re-authenticates a user using a fresh credential.\r\n *\r\n * @remarks\r\n * Use before operations such as {@link updatePassword} that require tokens from recent sign-in\r\n * attempts. This method can be used to recover from a `CREDENTIAL_TOO_OLD_LOGIN_AGAIN` error\r\n * or a `TOKEN_EXPIRED` error.\r\n *\r\n * This method is not supported on any {@link User} signed in by {@link Auth} instances\r\n * created with a {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @param user - The user.\r\n * @param credential - The auth credential.\r\n *\r\n * @public\r\n */ async function reauthenticateWithCredential(user, credential) {\n    return _reauthenticate((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user), credential);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function signInWithCustomToken$1(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:signInWithCustomToken\" /* Endpoint.SIGN_IN_WITH_CUSTOM_TOKEN */ , _addTidIfNecessary(auth, request));\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Asynchronously signs in using a custom token.\r\n *\r\n * @remarks\r\n * Custom tokens are used to integrate Firebase Auth with existing auth systems, and must\r\n * be generated by an auth backend using the\r\n * {@link https://firebase.google.com/docs/reference/admin/node/admin.auth.Auth#createcustomtoken | createCustomToken}\r\n * method in the {@link https://firebase.google.com/docs/auth/admin | Admin SDK} .\r\n *\r\n * Fails with an error if the token is invalid, expired, or not accepted by the Firebase Auth service.\r\n *\r\n * This method is not supported by {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param customToken - The custom token to sign in with.\r\n *\r\n * @public\r\n */ async function signInWithCustomToken(auth, customToken) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authInternal = _castAuth(auth);\n    const response = await signInWithCustomToken$1(authInternal, {\n        token: customToken,\n        returnSecureToken: true\n    });\n    const cred = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */ , response);\n    await authInternal._updateCurrentUser(cred.user);\n    return cred;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class MultiFactorInfoImpl {\n    constructor(factorId, response){\n        this.factorId = factorId;\n        this.uid = response.mfaEnrollmentId;\n        this.enrollmentTime = new Date(response.enrolledAt).toUTCString();\n        this.displayName = response.displayName;\n    }\n    static _fromServerResponse(auth, enrollment) {\n        if (\"phoneInfo\" in enrollment) {\n            return PhoneMultiFactorInfoImpl._fromServerResponse(auth, enrollment);\n        } else if (\"totpInfo\" in enrollment) {\n            return TotpMultiFactorInfoImpl._fromServerResponse(auth, enrollment);\n        }\n        return _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n    }\n}\nclass PhoneMultiFactorInfoImpl extends MultiFactorInfoImpl {\n    constructor(response){\n        super(\"phone\" /* FactorId.PHONE */ , response);\n        this.phoneNumber = response.phoneInfo;\n    }\n    static _fromServerResponse(_auth, enrollment) {\n        return new PhoneMultiFactorInfoImpl(enrollment);\n    }\n}\nclass TotpMultiFactorInfoImpl extends MultiFactorInfoImpl {\n    constructor(response){\n        super(\"totp\" /* FactorId.TOTP */ , response);\n    }\n    static _fromServerResponse(_auth, enrollment) {\n        return new TotpMultiFactorInfoImpl(enrollment);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function _setActionCodeSettingsOnRequest(auth, request, actionCodeSettings) {\n    var _a;\n    _assert(((_a = actionCodeSettings.url) === null || _a === void 0 ? void 0 : _a.length) > 0, auth, \"invalid-continue-uri\" /* AuthErrorCode.INVALID_CONTINUE_URI */ );\n    _assert(typeof actionCodeSettings.dynamicLinkDomain === \"undefined\" || actionCodeSettings.dynamicLinkDomain.length > 0, auth, \"invalid-dynamic-link-domain\" /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */ );\n    request.continueUrl = actionCodeSettings.url;\n    request.dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;\n    request.canHandleCodeInApp = actionCodeSettings.handleCodeInApp;\n    if (actionCodeSettings.iOS) {\n        _assert(actionCodeSettings.iOS.bundleId.length > 0, auth, \"missing-ios-bundle-id\" /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */ );\n        request.iOSBundleId = actionCodeSettings.iOS.bundleId;\n    }\n    if (actionCodeSettings.android) {\n        _assert(actionCodeSettings.android.packageName.length > 0, auth, \"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */ );\n        request.androidInstallApp = actionCodeSettings.android.installApp;\n        request.androidMinimumVersionCode = actionCodeSettings.android.minimumVersion;\n        request.androidPackageName = actionCodeSettings.android.packageName;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Updates the password policy cached in the {@link Auth} instance if a policy is already\r\n * cached for the project or tenant.\r\n *\r\n * @remarks\r\n * We only fetch the password policy if the password did not meet policy requirements and\r\n * there is an existing policy cached. A developer must call validatePassword at least\r\n * once for the cache to be automatically updated.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n *\r\n * @private\r\n */ async function recachePasswordPolicy(auth) {\n    const authInternal = _castAuth(auth);\n    if (authInternal._getPasswordPolicyInternal()) {\n        await authInternal._updatePasswordPolicy();\n    }\n}\n/**\r\n * Sends a password reset email to the given email address. This method does not throw an error when\r\n * there's no user account with the given email address and\r\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\r\n * is enabled.\r\n *\r\n * @remarks\r\n * To complete the password reset, call {@link confirmPasswordReset} with the code supplied in\r\n * the email sent to the user, along with the new password specified by the user.\r\n *\r\n * @example\r\n * ```javascript\r\n * const actionCodeSettings = {\r\n *   url: 'https://www.example.com/?email=user@example.com',\r\n *   iOS: {\r\n *      bundleId: 'com.example.ios'\r\n *   },\r\n *   android: {\r\n *     packageName: 'com.example.android',\r\n *     installApp: true,\r\n *     minimumVersion: '12'\r\n *   },\r\n *   handleCodeInApp: true\r\n * };\r\n * await sendPasswordResetEmail(auth, 'user@example.com', actionCodeSettings);\r\n * // Obtain code from user.\r\n * await confirmPasswordReset('user@example.com', code);\r\n * ```\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param email - The user's email address.\r\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\r\n *\r\n * @public\r\n */ async function sendPasswordResetEmail(auth, email, actionCodeSettings) {\n    const authInternal = _castAuth(auth);\n    const request = {\n        requestType: \"PASSWORD_RESET\" /* ActionCodeOperation.PASSWORD_RESET */ ,\n        email,\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ \n    };\n    if (actionCodeSettings) {\n        _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);\n    }\n    await handleRecaptchaFlow(authInternal, request, \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */ , sendPasswordResetEmail$1);\n}\n/**\r\n * Completes the password reset process, given a confirmation code and new password.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param oobCode - A confirmation code sent to the user.\r\n * @param newPassword - The new password.\r\n *\r\n * @public\r\n */ async function confirmPasswordReset(auth, oobCode, newPassword) {\n    await resetPassword((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), {\n        oobCode,\n        newPassword\n    }).catch(async (error)=>{\n        if (error.code === `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */ }`) {\n            void recachePasswordPolicy(auth);\n        }\n        throw error;\n    });\n// Do not return the email.\n}\n/**\r\n * Applies a verification code sent to the user by email or other out-of-band mechanism.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param oobCode - A verification code sent to the user.\r\n *\r\n * @public\r\n */ async function applyActionCode(auth, oobCode) {\n    await applyActionCode$1((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), {\n        oobCode\n    });\n}\n/**\r\n * Checks a verification code sent to the user by email or other out-of-band mechanism.\r\n *\r\n * @returns metadata about the code.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param oobCode - A verification code sent to the user.\r\n *\r\n * @public\r\n */ async function checkActionCode(auth, oobCode) {\n    const authModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n    const response = await resetPassword(authModular, {\n        oobCode\n    });\n    // Email could be empty only if the request type is EMAIL_SIGNIN or\n    // VERIFY_AND_CHANGE_EMAIL.\n    // New email should not be empty if the request type is\n    // VERIFY_AND_CHANGE_EMAIL.\n    // Multi-factor info could not be empty if the request type is\n    // REVERT_SECOND_FACTOR_ADDITION.\n    const operation = response.requestType;\n    _assert(operation, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n    switch(operation){\n        case \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */ :\n            break;\n        case \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */ :\n            _assert(response.newEmail, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n            break;\n        case \"REVERT_SECOND_FACTOR_ADDITION\" /* ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION */ :\n            _assert(response.mfaInfo, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        // fall through\n        default:\n            _assert(response.email, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n    }\n    // The multi-factor info for revert second factor addition\n    let multiFactorInfo = null;\n    if (response.mfaInfo) {\n        multiFactorInfo = MultiFactorInfoImpl._fromServerResponse(_castAuth(authModular), response.mfaInfo);\n    }\n    return {\n        data: {\n            email: (response.requestType === \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */  ? response.newEmail : response.email) || null,\n            previousEmail: (response.requestType === \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */  ? response.email : response.newEmail) || null,\n            multiFactorInfo\n        },\n        operation\n    };\n}\n/**\r\n * Checks a password reset code sent to the user by email or other out-of-band mechanism.\r\n *\r\n * @returns the user's email address if valid.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param code - A verification code sent to the user.\r\n *\r\n * @public\r\n */ async function verifyPasswordResetCode(auth, code) {\n    const { data } = await checkActionCode((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), code);\n    // Email should always be present since a code was sent to it\n    return data.email;\n}\n/**\r\n * Creates a new user account associated with the specified email address and password.\r\n *\r\n * @remarks\r\n * On successful creation of the user account, this user will also be signed in to your application.\r\n *\r\n * User account creation can fail if the account already exists or the password is invalid.\r\n *\r\n * This method is not supported on {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * Note: The email address acts as a unique identifier for the user and enables an email-based\r\n * password reset. This function will create a new user account and set the initial user password.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param email - The user's email address.\r\n * @param password - The user's chosen password.\r\n *\r\n * @public\r\n */ async function createUserWithEmailAndPassword(auth, email, password) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authInternal = _castAuth(auth);\n    const request = {\n        returnSecureToken: true,\n        email,\n        password,\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ \n    };\n    const signUpResponse = handleRecaptchaFlow(authInternal, request, \"signUpPassword\" /* RecaptchaActionName.SIGN_UP_PASSWORD */ , signUp);\n    const response = await signUpResponse.catch((error)=>{\n        if (error.code === `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */ }`) {\n            void recachePasswordPolicy(auth);\n        }\n        throw error;\n    });\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */ , response);\n    await authInternal._updateCurrentUser(userCredential.user);\n    return userCredential;\n}\n/**\r\n * Asynchronously signs in using an email and password.\r\n *\r\n * @remarks\r\n * Fails with an error if the email address and password do not match. When\r\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\r\n * is enabled, this method fails with \"auth/invalid-credential\" in case of an invalid\r\n * email/password.\r\n *\r\n * This method is not supported on {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * Note: The user's password is NOT the password used to access the user's email account. The\r\n * email address serves as a unique identifier for the user, and the password is used to access\r\n * the user's account in your Firebase project. See also: {@link createUserWithEmailAndPassword}.\r\n *\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param email - The users email address.\r\n * @param password - The users password.\r\n *\r\n * @public\r\n */ function signInWithEmailAndPassword(auth, email, password) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    return signInWithCredential((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), EmailAuthProvider.credential(email, password)).catch(async (error)=>{\n        if (error.code === `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */ }`) {\n            void recachePasswordPolicy(auth);\n        }\n        throw error;\n    });\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Sends a sign-in email link to the user with the specified email.\r\n *\r\n * @remarks\r\n * The sign-in operation has to always be completed in the app unlike other out of band email\r\n * actions (password reset and email verifications). This is because, at the end of the flow,\r\n * the user is expected to be signed in and their Auth state persisted within the app.\r\n *\r\n * To complete sign in with the email link, call {@link signInWithEmailLink} with the email\r\n * address and the email link supplied in the email sent to the user.\r\n *\r\n * @example\r\n * ```javascript\r\n * const actionCodeSettings = {\r\n *   url: 'https://www.example.com/?email=user@example.com',\r\n *   iOS: {\r\n *      bundleId: 'com.example.ios'\r\n *   },\r\n *   android: {\r\n *     packageName: 'com.example.android',\r\n *     installApp: true,\r\n *     minimumVersion: '12'\r\n *   },\r\n *   handleCodeInApp: true\r\n * };\r\n * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);\r\n * // Obtain emailLink from the user.\r\n * if(isSignInWithEmailLink(auth, emailLink)) {\r\n *   await signInWithEmailLink(auth, 'user@example.com', emailLink);\r\n * }\r\n * ```\r\n *\r\n * @param authInternal - The {@link Auth} instance.\r\n * @param email - The user's email address.\r\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\r\n *\r\n * @public\r\n */ async function sendSignInLinkToEmail(auth, email, actionCodeSettings) {\n    const authInternal = _castAuth(auth);\n    const request = {\n        requestType: \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */ ,\n        email,\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ \n    };\n    function setActionCodeSettings(request, actionCodeSettings) {\n        _assert(actionCodeSettings.handleCodeInApp, authInternal, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        if (actionCodeSettings) {\n            _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);\n        }\n    }\n    setActionCodeSettings(request, actionCodeSettings);\n    await handleRecaptchaFlow(authInternal, request, \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */ , sendSignInLinkToEmail$1);\n}\n/**\r\n * Checks if an incoming link is a sign-in with email link suitable for {@link signInWithEmailLink}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param emailLink - The link sent to the user's email address.\r\n *\r\n * @public\r\n */ function isSignInWithEmailLink(auth, emailLink) {\n    const actionCodeUrl = ActionCodeURL.parseLink(emailLink);\n    return (actionCodeUrl === null || actionCodeUrl === void 0 ? void 0 : actionCodeUrl.operation) === \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */ ;\n}\n/**\r\n * Asynchronously signs in using an email and sign-in email link.\r\n *\r\n * @remarks\r\n * If no link is passed, the link is inferred from the current URL.\r\n *\r\n * Fails with an error if the email address is invalid or OTP in email link expires.\r\n *\r\n * This method is not supported by {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * Note: Confirm the link is a sign-in email link before calling this method firebase.auth.Auth.isSignInWithEmailLink.\r\n *\r\n * @example\r\n * ```javascript\r\n * const actionCodeSettings = {\r\n *   url: 'https://www.example.com/?email=user@example.com',\r\n *   iOS: {\r\n *      bundleId: 'com.example.ios'\r\n *   },\r\n *   android: {\r\n *     packageName: 'com.example.android',\r\n *     installApp: true,\r\n *     minimumVersion: '12'\r\n *   },\r\n *   handleCodeInApp: true\r\n * };\r\n * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);\r\n * // Obtain emailLink from the user.\r\n * if(isSignInWithEmailLink(auth, emailLink)) {\r\n *   await signInWithEmailLink(auth, 'user@example.com', emailLink);\r\n * }\r\n * ```\r\n *\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param email - The user's email address.\r\n * @param emailLink - The link sent to the user's email address.\r\n *\r\n * @public\r\n */ async function signInWithEmailLink(auth, email, emailLink) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n    const credential = EmailAuthProvider.credentialWithLink(email, emailLink || _getCurrentUrl());\n    // Check if the tenant ID in the email link matches the tenant ID on Auth\n    // instance.\n    _assert(credential._tenantId === (authModular.tenantId || null), authModular, \"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */ );\n    return signInWithCredential(authModular, credential);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function createAuthUri(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:createAuthUri\" /* Endpoint.CREATE_AUTH_URI */ , _addTidIfNecessary(auth, request));\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Gets the list of possible sign in methods for the given email address. This method returns an\r\n * empty list when\r\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\r\n * is enabled, irrespective of the number of authentication methods available for the given email.\r\n *\r\n * @remarks\r\n * This is useful to differentiate methods of sign-in for the same provider, eg.\r\n * {@link EmailAuthProvider} which has 2 methods of sign-in,\r\n * {@link SignInMethod}.EMAIL_PASSWORD and\r\n * {@link SignInMethod}.EMAIL_LINK.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param email - The user's email address.\r\n *\r\n * Deprecated. Migrating off of this method is recommended as a security best-practice.\r\n * Learn more in the Identity Platform documentation for\r\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}.\r\n * @public\r\n */ async function fetchSignInMethodsForEmail(auth, email) {\n    // createAuthUri returns an error if continue URI is not http or https.\n    // For environments like Cordova, Chrome extensions, native frameworks, file\n    // systems, etc, use http://localhost as continue URL.\n    const continueUri = _isHttpOrHttps() ? _getCurrentUrl() : \"http://localhost\";\n    const request = {\n        identifier: email,\n        continueUri\n    };\n    const { signinMethods } = await createAuthUri((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), request);\n    return signinMethods || [];\n}\n/**\r\n * Sends a verification email to a user.\r\n *\r\n * @remarks\r\n * The verification process is completed by calling {@link applyActionCode}.\r\n *\r\n * @example\r\n * ```javascript\r\n * const actionCodeSettings = {\r\n *   url: 'https://www.example.com/?email=user@example.com',\r\n *   iOS: {\r\n *      bundleId: 'com.example.ios'\r\n *   },\r\n *   android: {\r\n *     packageName: 'com.example.android',\r\n *     installApp: true,\r\n *     minimumVersion: '12'\r\n *   },\r\n *   handleCodeInApp: true\r\n * };\r\n * await sendEmailVerification(user, actionCodeSettings);\r\n * // Obtain code from the user.\r\n * await applyActionCode(auth, code);\r\n * ```\r\n *\r\n * @param user - The user.\r\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\r\n *\r\n * @public\r\n */ async function sendEmailVerification(user, actionCodeSettings) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const idToken = await user.getIdToken();\n    const request = {\n        requestType: \"VERIFY_EMAIL\" /* ActionCodeOperation.VERIFY_EMAIL */ ,\n        idToken\n    };\n    if (actionCodeSettings) {\n        _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);\n    }\n    const { email } = await sendEmailVerification$1(userInternal.auth, request);\n    if (email !== user.email) {\n        await user.reload();\n    }\n}\n/**\r\n * Sends a verification email to a new email address.\r\n *\r\n * @remarks\r\n * The user's email will be updated to the new one after being verified.\r\n *\r\n * If you have a custom email action handler, you can complete the verification process by calling\r\n * {@link applyActionCode}.\r\n *\r\n * @example\r\n * ```javascript\r\n * const actionCodeSettings = {\r\n *   url: 'https://www.example.com/?email=user@example.com',\r\n *   iOS: {\r\n *      bundleId: 'com.example.ios'\r\n *   },\r\n *   android: {\r\n *     packageName: 'com.example.android',\r\n *     installApp: true,\r\n *     minimumVersion: '12'\r\n *   },\r\n *   handleCodeInApp: true\r\n * };\r\n * await verifyBeforeUpdateEmail(user, 'newemail@example.com', actionCodeSettings);\r\n * // Obtain code from the user.\r\n * await applyActionCode(auth, code);\r\n * ```\r\n *\r\n * @param user - The user.\r\n * @param newEmail - The new email address to be verified before update.\r\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\r\n *\r\n * @public\r\n */ async function verifyBeforeUpdateEmail(user, newEmail, actionCodeSettings) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const idToken = await user.getIdToken();\n    const request = {\n        requestType: \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */ ,\n        idToken,\n        newEmail\n    };\n    if (actionCodeSettings) {\n        _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);\n    }\n    const { email } = await verifyAndChangeEmail(userInternal.auth, request);\n    if (email !== user.email) {\n        // If the local copy of the email on user is outdated, reload the\n        // user.\n        await user.reload();\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ async function updateProfile$1(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */ , request);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Updates a user's profile data.\r\n *\r\n * @param user - The user.\r\n * @param profile - The profile's `displayName` and `photoURL` to update.\r\n *\r\n * @public\r\n */ async function updateProfile(user, { displayName, photoURL: photoUrl }) {\n    if (displayName === undefined && photoUrl === undefined) {\n        return;\n    }\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const idToken = await userInternal.getIdToken();\n    const profileRequest = {\n        idToken,\n        displayName,\n        photoUrl,\n        returnSecureToken: true\n    };\n    const response = await _logoutIfInvalidated(userInternal, updateProfile$1(userInternal.auth, profileRequest));\n    userInternal.displayName = response.displayName || null;\n    userInternal.photoURL = response.photoUrl || null;\n    // Update the password provider as well\n    const passwordProvider = userInternal.providerData.find(({ providerId })=>providerId === \"password\" /* ProviderId.PASSWORD */ );\n    if (passwordProvider) {\n        passwordProvider.displayName = userInternal.displayName;\n        passwordProvider.photoURL = userInternal.photoURL;\n    }\n    await userInternal._updateTokensIfNecessary(response);\n}\n/**\r\n * Updates the user's email address.\r\n *\r\n * @remarks\r\n * An email will be sent to the original email address (if it was set) that allows to revoke the\r\n * email address change, in order to protect them from account hijacking.\r\n *\r\n * This method is not supported on any {@link User} signed in by {@link Auth} instances\r\n * created with a {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * Important: this is a security sensitive operation that requires the user to have recently signed\r\n * in. If this requirement isn't met, ask the user to authenticate again and then call\r\n * {@link reauthenticateWithCredential}.\r\n *\r\n * @param user - The user.\r\n * @param newEmail - The new email address.\r\n *\r\n * Throws \"auth/operation-not-allowed\" error when\r\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\r\n * is enabled.\r\n * Deprecated - Use {@link verifyBeforeUpdateEmail} instead.\r\n *\r\n * @public\r\n */ function updateEmail(user, newEmail) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(userInternal.auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(userInternal.auth));\n    }\n    return updateEmailOrPassword(userInternal, newEmail, null);\n}\n/**\r\n * Updates the user's password.\r\n *\r\n * @remarks\r\n * Important: this is a security sensitive operation that requires the user to have recently signed\r\n * in. If this requirement isn't met, ask the user to authenticate again and then call\r\n * {@link reauthenticateWithCredential}.\r\n *\r\n * @param user - The user.\r\n * @param newPassword - The new password.\r\n *\r\n * @public\r\n */ function updatePassword(user, newPassword) {\n    return updateEmailOrPassword((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user), null, newPassword);\n}\nasync function updateEmailOrPassword(user, email, password) {\n    const { auth } = user;\n    const idToken = await user.getIdToken();\n    const request = {\n        idToken,\n        returnSecureToken: true\n    };\n    if (email) {\n        request.email = email;\n    }\n    if (password) {\n        request.password = password;\n    }\n    const response = await _logoutIfInvalidated(user, updateEmailPassword(auth, request));\n    await user._updateTokensIfNecessary(response, /* reload */ true);\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Parse the `AdditionalUserInfo` from the ID token response.\r\n *\r\n */ function _fromIdTokenResponse(idTokenResponse) {\n    var _a, _b;\n    if (!idTokenResponse) {\n        return null;\n    }\n    const { providerId } = idTokenResponse;\n    const profile = idTokenResponse.rawUserInfo ? JSON.parse(idTokenResponse.rawUserInfo) : {};\n    const isNewUser = idTokenResponse.isNewUser || idTokenResponse.kind === \"identitytoolkit#SignupNewUserResponse\" /* IdTokenResponseKind.SignupNewUser */ ;\n    if (!providerId && (idTokenResponse === null || idTokenResponse === void 0 ? void 0 : idTokenResponse.idToken)) {\n        const signInProvider = (_b = (_a = _parseToken(idTokenResponse.idToken)) === null || _a === void 0 ? void 0 : _a.firebase) === null || _b === void 0 ? void 0 : _b[\"sign_in_provider\"];\n        if (signInProvider) {\n            const filteredProviderId = signInProvider !== \"anonymous\" /* ProviderId.ANONYMOUS */  && signInProvider !== \"custom\" /* ProviderId.CUSTOM */  ? signInProvider : null;\n            // Uses generic class in accordance with the legacy SDK.\n            return new GenericAdditionalUserInfo(isNewUser, filteredProviderId);\n        }\n    }\n    if (!providerId) {\n        return null;\n    }\n    switch(providerId){\n        case \"facebook.com\" /* ProviderId.FACEBOOK */ :\n            return new FacebookAdditionalUserInfo(isNewUser, profile);\n        case \"github.com\" /* ProviderId.GITHUB */ :\n            return new GithubAdditionalUserInfo(isNewUser, profile);\n        case \"google.com\" /* ProviderId.GOOGLE */ :\n            return new GoogleAdditionalUserInfo(isNewUser, profile);\n        case \"twitter.com\" /* ProviderId.TWITTER */ :\n            return new TwitterAdditionalUserInfo(isNewUser, profile, idTokenResponse.screenName || null);\n        case \"custom\" /* ProviderId.CUSTOM */ :\n        case \"anonymous\" /* ProviderId.ANONYMOUS */ :\n            return new GenericAdditionalUserInfo(isNewUser, null);\n        default:\n            return new GenericAdditionalUserInfo(isNewUser, providerId, profile);\n    }\n}\nclass GenericAdditionalUserInfo {\n    constructor(isNewUser, providerId, profile = {}){\n        this.isNewUser = isNewUser;\n        this.providerId = providerId;\n        this.profile = profile;\n    }\n}\nclass FederatedAdditionalUserInfoWithUsername extends GenericAdditionalUserInfo {\n    constructor(isNewUser, providerId, profile, username){\n        super(isNewUser, providerId, profile);\n        this.username = username;\n    }\n}\nclass FacebookAdditionalUserInfo extends GenericAdditionalUserInfo {\n    constructor(isNewUser, profile){\n        super(isNewUser, \"facebook.com\" /* ProviderId.FACEBOOK */ , profile);\n    }\n}\nclass GithubAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername {\n    constructor(isNewUser, profile){\n        super(isNewUser, \"github.com\" /* ProviderId.GITHUB */ , profile, typeof (profile === null || profile === void 0 ? void 0 : profile.login) === \"string\" ? profile === null || profile === void 0 ? void 0 : profile.login : null);\n    }\n}\nclass GoogleAdditionalUserInfo extends GenericAdditionalUserInfo {\n    constructor(isNewUser, profile){\n        super(isNewUser, \"google.com\" /* ProviderId.GOOGLE */ , profile);\n    }\n}\nclass TwitterAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername {\n    constructor(isNewUser, profile, screenName){\n        super(isNewUser, \"twitter.com\" /* ProviderId.TWITTER */ , profile, screenName);\n    }\n}\n/**\r\n * Extracts provider specific {@link AdditionalUserInfo} for the given credential.\r\n *\r\n * @param userCredential - The user credential.\r\n *\r\n * @public\r\n */ function getAdditionalUserInfo(userCredential) {\n    const { user, _tokenResponse } = userCredential;\n    if (user.isAnonymous && !_tokenResponse) {\n        // Handle the special case where signInAnonymously() gets called twice.\n        // No network call is made so there's nothing to actually fill this in\n        return {\n            providerId: null,\n            isNewUser: false,\n            profile: null\n        };\n    }\n    return _fromIdTokenResponse(_tokenResponse);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Non-optional auth methods.\n/**\r\n * Changes the type of persistence on the {@link Auth} instance for the currently saved\r\n * `Auth` session and applies this type of persistence for future sign-in requests, including\r\n * sign-in with redirect requests.\r\n *\r\n * @remarks\r\n * This makes it easy for a user signing in to specify whether their session should be\r\n * remembered or not. It also makes it easier to never persist the `Auth` state for applications\r\n * that are shared by other users or have sensitive data.\r\n *\r\n * This method does not work in a Node.js environment or with {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @example\r\n * ```javascript\r\n * setPersistence(auth, browserSessionPersistence);\r\n * ```\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param persistence - The {@link Persistence} to use.\r\n * @returns A `Promise` that resolves once the persistence change has completed\r\n *\r\n * @public\r\n */ function setPersistence(auth, persistence) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).setPersistence(persistence);\n}\n/**\r\n * Loads the reCAPTCHA configuration into the `Auth` instance.\r\n *\r\n * @remarks\r\n * This will load the reCAPTCHA config, which indicates whether the reCAPTCHA\r\n * verification flow should be triggered for each auth provider, into the\r\n * current Auth session.\r\n *\r\n * If initializeRecaptchaConfig() is not invoked, the auth flow will always start\r\n * without reCAPTCHA verification. If the provider is configured to require reCAPTCHA\r\n * verification, the SDK will transparently load the reCAPTCHA config and restart the\r\n * auth flows.\r\n *\r\n * Thus, by calling this optional method, you will reduce the latency of future auth flows.\r\n * Loading the reCAPTCHA config early will also enhance the signal collected by reCAPTCHA.\r\n *\r\n * This method does not work in a Node.js environment.\r\n *\r\n * @example\r\n * ```javascript\r\n * initializeRecaptchaConfig(auth);\r\n * ```\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n *\r\n * @public\r\n */ function initializeRecaptchaConfig(auth) {\n    return _initializeRecaptchaConfig(auth);\n}\n/**\r\n * Validates the password against the password policy configured for the project or tenant.\r\n *\r\n * @remarks\r\n * If no tenant ID is set on the `Auth` instance, then this method will use the password\r\n * policy configured for the project. Otherwise, this method will use the policy configured\r\n * for the tenant. If a password policy has not been configured, then the default policy\r\n * configured for all projects will be used.\r\n *\r\n * If an auth flow fails because a submitted password does not meet the password policy\r\n * requirements and this method has previously been called, then this method will use the\r\n * most recent policy available when called again.\r\n *\r\n * @example\r\n * ```javascript\r\n * validatePassword(auth, 'some-password');\r\n * ```\r\n *\r\n * @param auth The {@link Auth} instance.\r\n * @param password The password to validate.\r\n *\r\n * @public\r\n */ async function validatePassword(auth, password) {\n    const authInternal = _castAuth(auth);\n    return authInternal.validatePassword(password);\n}\n/**\r\n * Adds an observer for changes to the signed-in user's ID token.\r\n *\r\n * @remarks\r\n * This includes sign-in, sign-out, and token refresh events.\r\n * This will not be triggered automatically upon ID token expiration. Use {@link User.getIdToken} to refresh the ID token.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param nextOrObserver - callback triggered on change.\r\n * @param error - Deprecated. This callback is never triggered. Errors\r\n * on signing in/out can be caught in promises returned from\r\n * sign-in/sign-out functions.\r\n * @param completed - Deprecated. This callback is never triggered.\r\n *\r\n * @public\r\n */ function onIdTokenChanged(auth, nextOrObserver, error, completed) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).onIdTokenChanged(nextOrObserver, error, completed);\n}\n/**\r\n * Adds a blocking callback that runs before an auth state change\r\n * sets a new user.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param callback - callback triggered before new user value is set.\r\n *   If this throws, it blocks the user from being set.\r\n * @param onAbort - callback triggered if a later `beforeAuthStateChanged()`\r\n *   callback throws, allowing you to undo any side effects.\r\n */ function beforeAuthStateChanged(auth, callback, onAbort) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).beforeAuthStateChanged(callback, onAbort);\n}\n/**\r\n * Adds an observer for changes to the user's sign-in state.\r\n *\r\n * @remarks\r\n * To keep the old behavior, see {@link onIdTokenChanged}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param nextOrObserver - callback triggered on change.\r\n * @param error - Deprecated. This callback is never triggered. Errors\r\n * on signing in/out can be caught in promises returned from\r\n * sign-in/sign-out functions.\r\n * @param completed - Deprecated. This callback is never triggered.\r\n *\r\n * @public\r\n */ function onAuthStateChanged(auth, nextOrObserver, error, completed) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).onAuthStateChanged(nextOrObserver, error, completed);\n}\n/**\r\n * Sets the current language to the default device/browser preference.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n *\r\n * @public\r\n */ function useDeviceLanguage(auth) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).useDeviceLanguage();\n}\n/**\r\n * Asynchronously sets the provided user as {@link Auth.currentUser} on the\r\n * {@link Auth} instance.\r\n *\r\n * @remarks\r\n * A new instance copy of the user provided will be made and set as currentUser.\r\n *\r\n * This will trigger {@link onAuthStateChanged} and {@link onIdTokenChanged} listeners\r\n * like other sign in methods.\r\n *\r\n * The operation fails with an error if the user to be updated belongs to a different Firebase\r\n * project.\r\n *\r\n * This method is not supported by {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param user - The new {@link User}.\r\n *\r\n * @public\r\n */ function updateCurrentUser(auth, user) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).updateCurrentUser(user);\n}\n/**\r\n * Signs out the current user.\r\n *\r\n * @remarks\r\n * This method is not supported by {@link Auth} instances created with a\r\n * {@link @firebase/app#FirebaseServerApp}.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n *\r\n * @public\r\n */ function signOut(auth) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).signOut();\n}\n/**\r\n * Revokes the given access token. Currently only supports Apple OAuth access tokens.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param token - The Apple OAuth access token.\r\n *\r\n * @public\r\n */ function revokeAccessToken(auth, token) {\n    const authInternal = _castAuth(auth);\n    return authInternal.revokeAccessToken(token);\n}\n/**\r\n * Deletes and signs out the user.\r\n *\r\n * @remarks\r\n * Important: this is a security-sensitive operation that requires the user to have recently\r\n * signed in. If this requirement isn't met, ask the user to authenticate again and then call\r\n * {@link reauthenticateWithCredential}.\r\n *\r\n * @param user - The user.\r\n *\r\n * @public\r\n */ async function deleteUser(user) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user).delete();\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class MultiFactorSessionImpl {\n    constructor(type, credential, user){\n        this.type = type;\n        this.credential = credential;\n        this.user = user;\n    }\n    static _fromIdtoken(idToken, user) {\n        return new MultiFactorSessionImpl(\"enroll\" /* MultiFactorSessionType.ENROLL */ , idToken, user);\n    }\n    static _fromMfaPendingCredential(mfaPendingCredential) {\n        return new MultiFactorSessionImpl(\"signin\" /* MultiFactorSessionType.SIGN_IN */ , mfaPendingCredential);\n    }\n    toJSON() {\n        const key = this.type === \"enroll\" /* MultiFactorSessionType.ENROLL */  ? \"idToken\" : \"pendingCredential\";\n        return {\n            multiFactorSession: {\n                [key]: this.credential\n            }\n        };\n    }\n    static fromJSON(obj) {\n        var _a, _b;\n        if (obj === null || obj === void 0 ? void 0 : obj.multiFactorSession) {\n            if ((_a = obj.multiFactorSession) === null || _a === void 0 ? void 0 : _a.pendingCredential) {\n                return MultiFactorSessionImpl._fromMfaPendingCredential(obj.multiFactorSession.pendingCredential);\n            } else if ((_b = obj.multiFactorSession) === null || _b === void 0 ? void 0 : _b.idToken) {\n                return MultiFactorSessionImpl._fromIdtoken(obj.multiFactorSession.idToken);\n            }\n        }\n        return null;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class MultiFactorResolverImpl {\n    constructor(session, hints, signInResolver){\n        this.session = session;\n        this.hints = hints;\n        this.signInResolver = signInResolver;\n    }\n    /** @internal */ static _fromError(authExtern, error) {\n        const auth = _castAuth(authExtern);\n        const serverResponse = error.customData._serverResponse;\n        const hints = (serverResponse.mfaInfo || []).map((enrollment)=>MultiFactorInfoImpl._fromServerResponse(auth, enrollment));\n        _assert(serverResponse.mfaPendingCredential, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        const session = MultiFactorSessionImpl._fromMfaPendingCredential(serverResponse.mfaPendingCredential);\n        return new MultiFactorResolverImpl(session, hints, async (assertion)=>{\n            const mfaResponse = await assertion._process(auth, session);\n            // Clear out the unneeded fields from the old login response\n            delete serverResponse.mfaInfo;\n            delete serverResponse.mfaPendingCredential;\n            // Use in the new token & refresh token in the old response\n            const idTokenResponse = Object.assign(Object.assign({}, serverResponse), {\n                idToken: mfaResponse.idToken,\n                refreshToken: mfaResponse.refreshToken\n            });\n            // TODO: we should collapse this switch statement into UserCredentialImpl._forOperation and have it support the SIGN_IN case\n            switch(error.operationType){\n                case \"signIn\" /* OperationType.SIGN_IN */ :\n                    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, error.operationType, idTokenResponse);\n                    await auth._updateCurrentUser(userCredential.user);\n                    return userCredential;\n                case \"reauthenticate\" /* OperationType.REAUTHENTICATE */ :\n                    _assert(error.user, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n                    return UserCredentialImpl._forOperation(error.user, error.operationType, idTokenResponse);\n                default:\n                    _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n            }\n        });\n    }\n    async resolveSignIn(assertionExtern) {\n        const assertion = assertionExtern;\n        return this.signInResolver(assertion);\n    }\n}\n/**\r\n * Provides a {@link MultiFactorResolver} suitable for completion of a\r\n * multi-factor flow.\r\n *\r\n * @param auth - The {@link Auth} instance.\r\n * @param error - The {@link MultiFactorError} raised during a sign-in, or\r\n * reauthentication operation.\r\n *\r\n * @public\r\n */ function getMultiFactorResolver(auth, error) {\n    var _a;\n    const authModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n    const errorInternal = error;\n    _assert(error.customData.operationType, authModular, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n    _assert((_a = errorInternal.customData._serverResponse) === null || _a === void 0 ? void 0 : _a.mfaPendingCredential, authModular, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n    return MultiFactorResolverImpl._fromError(authModular, errorInternal);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function startEnrollTotpMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v2/accounts/mfaEnrollment:start\" /* Endpoint.START_MFA_ENROLLMENT */ , _addTidIfNecessary(auth, request));\n}\nfunction finalizeEnrollTotpMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v2/accounts/mfaEnrollment:finalize\" /* Endpoint.FINALIZE_MFA_ENROLLMENT */ , _addTidIfNecessary(auth, request));\n}\nfunction withdrawMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v2/accounts/mfaEnrollment:withdraw\" /* Endpoint.WITHDRAW_MFA */ , _addTidIfNecessary(auth, request));\n}\nclass MultiFactorUserImpl {\n    constructor(user){\n        this.user = user;\n        this.enrolledFactors = [];\n        user._onReload((userInfo)=>{\n            if (userInfo.mfaInfo) {\n                this.enrolledFactors = userInfo.mfaInfo.map((enrollment)=>MultiFactorInfoImpl._fromServerResponse(user.auth, enrollment));\n            }\n        });\n    }\n    static _fromUser(user) {\n        return new MultiFactorUserImpl(user);\n    }\n    async getSession() {\n        return MultiFactorSessionImpl._fromIdtoken(await this.user.getIdToken(), this.user);\n    }\n    async enroll(assertionExtern, displayName) {\n        const assertion = assertionExtern;\n        const session = await this.getSession();\n        const finalizeMfaResponse = await _logoutIfInvalidated(this.user, assertion._process(this.user.auth, session, displayName));\n        // New tokens will be issued after enrollment of the new second factors.\n        // They need to be updated on the user.\n        await this.user._updateTokensIfNecessary(finalizeMfaResponse);\n        // The user needs to be reloaded to get the new multi-factor information\n        // from server. USER_RELOADED event will be triggered and `enrolledFactors`\n        // will be updated.\n        return this.user.reload();\n    }\n    async unenroll(infoOrUid) {\n        const mfaEnrollmentId = typeof infoOrUid === \"string\" ? infoOrUid : infoOrUid.uid;\n        const idToken = await this.user.getIdToken();\n        try {\n            const idTokenResponse = await _logoutIfInvalidated(this.user, withdrawMfa(this.user.auth, {\n                idToken,\n                mfaEnrollmentId\n            }));\n            // Remove the second factor from the user's list.\n            this.enrolledFactors = this.enrolledFactors.filter(({ uid })=>uid !== mfaEnrollmentId);\n            // Depending on whether the backend decided to revoke the user's session,\n            // the tokenResponse may be empty. If the tokens were not updated (and they\n            // are now invalid), reloading the user will discover this and invalidate\n            // the user's state accordingly.\n            await this.user._updateTokensIfNecessary(idTokenResponse);\n            await this.user.reload();\n        } catch (e) {\n            throw e;\n        }\n    }\n}\nconst multiFactorUserCache = new WeakMap();\n/**\r\n * The {@link MultiFactorUser} corresponding to the user.\r\n *\r\n * @remarks\r\n * This is used to access all multi-factor properties and operations related to the user.\r\n *\r\n * @param user - The user.\r\n *\r\n * @public\r\n */ function multiFactor(user) {\n    const userModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    if (!multiFactorUserCache.has(userModular)) {\n        multiFactorUserCache.set(userModular, MultiFactorUserImpl._fromUser(userModular));\n    }\n    return multiFactorUserCache.get(userModular);\n}\nvar name = \"@firebase/auth\";\nvar version = \"1.7.3\";\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class AuthInterop {\n    constructor(auth){\n        this.auth = auth;\n        this.internalListeners = new Map();\n    }\n    getUid() {\n        var _a;\n        this.assertAuthConfigured();\n        return ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.uid) || null;\n    }\n    async getToken(forceRefresh) {\n        this.assertAuthConfigured();\n        await this.auth._initializationPromise;\n        if (!this.auth.currentUser) {\n            return null;\n        }\n        const accessToken = await this.auth.currentUser.getIdToken(forceRefresh);\n        return {\n            accessToken\n        };\n    }\n    addAuthTokenListener(listener) {\n        this.assertAuthConfigured();\n        if (this.internalListeners.has(listener)) {\n            return;\n        }\n        const unsubscribe = this.auth.onIdTokenChanged((user)=>{\n            listener((user === null || user === void 0 ? void 0 : user.stsTokenManager.accessToken) || null);\n        });\n        this.internalListeners.set(listener, unsubscribe);\n        this.updateProactiveRefresh();\n    }\n    removeAuthTokenListener(listener) {\n        this.assertAuthConfigured();\n        const unsubscribe = this.internalListeners.get(listener);\n        if (!unsubscribe) {\n            return;\n        }\n        this.internalListeners.delete(listener);\n        unsubscribe();\n        this.updateProactiveRefresh();\n    }\n    assertAuthConfigured() {\n        _assert(this.auth._initializationPromise, \"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */ );\n    }\n    updateProactiveRefresh() {\n        if (this.internalListeners.size > 0) {\n            this.auth._startProactiveRefresh();\n        } else {\n            this.auth._stopProactiveRefresh();\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function getVersionForPlatform(clientPlatform) {\n    switch(clientPlatform){\n        case \"Node\" /* ClientPlatform.NODE */ :\n            return \"node\";\n        case \"ReactNative\" /* ClientPlatform.REACT_NATIVE */ :\n            return \"rn\";\n        case \"Worker\" /* ClientPlatform.WORKER */ :\n            return \"webworker\";\n        case \"Cordova\" /* ClientPlatform.CORDOVA */ :\n            return \"cordova\";\n        case \"WebExtension\" /* ClientPlatform.WEB_EXTENSION */ :\n            return \"web-extension\";\n        default:\n            return undefined;\n    }\n}\n/** @internal */ function registerAuth(clientPlatform) {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(\"auth\" /* _ComponentName.AUTH */ , (container, { options: deps })=>{\n        const app = container.getProvider(\"app\").getImmediate();\n        const heartbeatServiceProvider = container.getProvider(\"heartbeat\");\n        const appCheckServiceProvider = container.getProvider(\"app-check-internal\");\n        const { apiKey, authDomain } = app.options;\n        _assert(apiKey && !apiKey.includes(\":\"), \"invalid-api-key\" /* AuthErrorCode.INVALID_API_KEY */ , {\n            appName: app.name\n        });\n        const config = {\n            apiKey,\n            authDomain,\n            clientPlatform,\n            apiHost: \"identitytoolkit.googleapis.com\" /* DefaultConfig.API_HOST */ ,\n            tokenApiHost: \"securetoken.googleapis.com\" /* DefaultConfig.TOKEN_API_HOST */ ,\n            apiScheme: \"https\" /* DefaultConfig.API_SCHEME */ ,\n            sdkClientVersion: _getClientVersion(clientPlatform)\n        };\n        const authInstance = new AuthImpl(app, heartbeatServiceProvider, appCheckServiceProvider, config);\n        _initializeAuthInstance(authInstance, deps);\n        return authInstance;\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */ )/**\r\n         * Auth can only be initialized by explicitly calling getAuth() or initializeAuth()\r\n         * For why we do this, See go/firebase-next-auth-init\r\n         */ .setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */ )/**\r\n         * Because all firebase products that depend on auth depend on auth-internal directly,\r\n         * we need to initialize auth-internal after auth is initialized to make it available to other firebase products.\r\n         */ .setInstanceCreatedCallback((container, _instanceIdentifier, _instance)=>{\n        const authInternalProvider = container.getProvider(\"auth-internal\" /* _ComponentName.AUTH_INTERNAL */ );\n        authInternalProvider.initialize();\n    }));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(\"auth-internal\" /* _ComponentName.AUTH_INTERNAL */ , (container)=>{\n        const auth = _castAuth(container.getProvider(\"auth\" /* _ComponentName.AUTH */ ).getImmediate());\n        return ((auth)=>new AuthInterop(auth))(auth);\n    }, \"PRIVATE\" /* ComponentType.PRIVATE */ ).setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */ ));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, getVersionForPlatform(clientPlatform));\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, \"esm2017\");\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Initialize the fetch polyfill, the types are slightly off so just cast and hope for the best\nFetchProvider.initialize(undici__WEBPACK_IMPORTED_MODULE_3__.fetch, undici__WEBPACK_IMPORTED_MODULE_3__.Headers, undici__WEBPACK_IMPORTED_MODULE_3__.Response);\n// First, we set up the various platform-specific features for Node (register\n// the version and declare the Node getAuth function)\nfunction getAuth(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)()) {\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, \"auth\");\n    if (provider.isInitialized()) {\n        return provider.getImmediate();\n    }\n    const auth = initializeAuth(app);\n    const authEmulatorHost = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getDefaultEmulatorHost)(\"auth\");\n    if (authEmulatorHost) {\n        connectAuthEmulator(auth, `http://${authEmulatorHost}`);\n    }\n    return auth;\n}\nregisterAuth(\"Node\" /* ClientPlatform.NODE */ );\n// The rest of this file contains no-ops and errors for browser-specific\n// methods. We keep the browser and Node entry points the same, but features\n// that only work in browsers are set to either do nothing (setPersistence) or\n// to reject with an auth/operation-not-supported-in-this-environment error.\n// The below exports are pulled into the main entry point by a rollup alias\n// plugin (overwriting the default browser imports).\n/** auth/operation-not-supported-in-this-environment */ const NOT_AVAILABLE_ERROR = _createError(\"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */ );\n/** Reject with auth/operation-not-supported-in-this-environment */ async function fail() {\n    throw NOT_AVAILABLE_ERROR;\n}\n/**\r\n * A class which will throw with\r\n * auth/operation-not-supported-in-this-environment if instantiated\r\n */ class FailClass {\n    constructor(){\n        throw NOT_AVAILABLE_ERROR;\n    }\n}\nconst browserLocalPersistence = inMemoryPersistence;\nconst browserSessionPersistence = inMemoryPersistence;\nconst indexedDBLocalPersistence = inMemoryPersistence;\nconst browserPopupRedirectResolver = NOT_AVAILABLE_ERROR;\nconst PhoneAuthProvider = FailClass;\nconst signInWithPhoneNumber = fail;\nconst linkWithPhoneNumber = fail;\nconst reauthenticateWithPhoneNumber = fail;\nconst updatePhoneNumber = fail;\nconst signInWithPopup = fail;\nconst linkWithPopup = fail;\nconst reauthenticateWithPopup = fail;\nconst signInWithRedirect = fail;\nconst linkWithRedirect = fail;\nconst reauthenticateWithRedirect = fail;\nconst getRedirectResult = fail;\nconst RecaptchaVerifier = FailClass;\nclass PhoneMultiFactorGenerator {\n    static assertion() {\n        throw NOT_AVAILABLE_ERROR;\n    }\n}\n// Set persistence should no-op instead of fail. Changing the prototype will\n// make sure both setPersistence(auth, persistence) and\n// auth.setPersistence(persistence) are covered.\nAuthImpl.prototype.setPersistence = async ()=>{};\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function finalizeSignInTotpMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */ , \"/v2/accounts/mfaSignIn:finalize\" /* Endpoint.FINALIZE_MFA_SIGN_IN */ , _addTidIfNecessary(auth, request));\n}\nclass MultiFactorAssertionImpl {\n    constructor(factorId){\n        this.factorId = factorId;\n    }\n    _process(auth, session, displayName) {\n        switch(session.type){\n            case \"enroll\" /* MultiFactorSessionType.ENROLL */ :\n                return this._finalizeEnroll(auth, session.credential, displayName);\n            case \"signin\" /* MultiFactorSessionType.SIGN_IN */ :\n                return this._finalizeSignIn(auth, session.credential);\n            default:\n                return debugFail(\"unexpected MultiFactorSessionType\");\n        }\n    }\n}\n/**\r\n * Provider for generating a {@link TotpMultiFactorAssertion}.\r\n *\r\n * @public\r\n */ class TotpMultiFactorGenerator {\n    /**\r\n     * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of\r\n     * the TOTP (time-based one-time password) second factor.\r\n     * This assertion is used to complete enrollment in TOTP second factor.\r\n     *\r\n     * @param secret A {@link TotpSecret} containing the shared secret key and other TOTP parameters.\r\n     * @param oneTimePassword One-time password from TOTP App.\r\n     * @returns A {@link TotpMultiFactorAssertion} which can be used with\r\n     * {@link MultiFactorUser.enroll}.\r\n     */ static assertionForEnrollment(secret, oneTimePassword) {\n        return TotpMultiFactorAssertionImpl._fromSecret(secret, oneTimePassword);\n    }\n    /**\r\n     * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of the TOTP second factor.\r\n     * This assertion is used to complete signIn with TOTP as the second factor.\r\n     *\r\n     * @param enrollmentId identifies the enrolled TOTP second factor.\r\n     * @param oneTimePassword One-time password from TOTP App.\r\n     * @returns A {@link TotpMultiFactorAssertion} which can be used with\r\n     * {@link MultiFactorResolver.resolveSignIn}.\r\n     */ static assertionForSignIn(enrollmentId, oneTimePassword) {\n        return TotpMultiFactorAssertionImpl._fromEnrollmentId(enrollmentId, oneTimePassword);\n    }\n    /**\r\n     * Returns a promise to {@link TotpSecret} which contains the TOTP shared secret key and other parameters.\r\n     * Creates a TOTP secret as part of enrolling a TOTP second factor.\r\n     * Used for generating a QR code URL or inputting into a TOTP app.\r\n     * This method uses the auth instance corresponding to the user in the multiFactorSession.\r\n     *\r\n     * @param session The {@link MultiFactorSession} that the user is part of.\r\n     * @returns A promise to {@link TotpSecret}.\r\n     */ static async generateSecret(session) {\n        var _a;\n        const mfaSession = session;\n        _assert(typeof ((_a = mfaSession.user) === null || _a === void 0 ? void 0 : _a.auth) !== \"undefined\", \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */ );\n        const response = await startEnrollTotpMfa(mfaSession.user.auth, {\n            idToken: mfaSession.credential,\n            totpEnrollmentInfo: {}\n        });\n        return TotpSecret._fromStartTotpMfaEnrollmentResponse(response, mfaSession.user.auth);\n    }\n}\n/**\r\n * The identifier of the TOTP second factor: `totp`.\r\n */ TotpMultiFactorGenerator.FACTOR_ID = \"totp\" /* FactorId.TOTP */ ;\nclass TotpMultiFactorAssertionImpl extends MultiFactorAssertionImpl {\n    constructor(otp, enrollmentId, secret){\n        super(\"totp\" /* FactorId.TOTP */ );\n        this.otp = otp;\n        this.enrollmentId = enrollmentId;\n        this.secret = secret;\n    }\n    /** @internal */ static _fromSecret(secret, otp) {\n        return new TotpMultiFactorAssertionImpl(otp, undefined, secret);\n    }\n    /** @internal */ static _fromEnrollmentId(enrollmentId, otp) {\n        return new TotpMultiFactorAssertionImpl(otp, enrollmentId);\n    }\n    /** @internal */ async _finalizeEnroll(auth, idToken, displayName) {\n        _assert(typeof this.secret !== \"undefined\", auth, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        return finalizeEnrollTotpMfa(auth, {\n            idToken,\n            displayName,\n            totpVerificationInfo: this.secret._makeTotpVerificationInfo(this.otp)\n        });\n    }\n    /** @internal */ async _finalizeSignIn(auth, mfaPendingCredential) {\n        _assert(this.enrollmentId !== undefined && this.otp !== undefined, auth, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */ );\n        const totpVerificationInfo = {\n            verificationCode: this.otp\n        };\n        return finalizeSignInTotpMfa(auth, {\n            mfaPendingCredential,\n            mfaEnrollmentId: this.enrollmentId,\n            totpVerificationInfo\n        });\n    }\n}\n/**\r\n * Provider for generating a {@link TotpMultiFactorAssertion}.\r\n *\r\n * Stores the shared secret key and other parameters to generate time-based OTPs.\r\n * Implements methods to retrieve the shared secret key and generate a QR code URL.\r\n * @public\r\n */ class TotpSecret {\n    // The public members are declared outside the constructor so the docs can be generated.\n    constructor(secretKey, hashingAlgorithm, codeLength, codeIntervalSeconds, enrollmentCompletionDeadline, sessionInfo, auth){\n        this.sessionInfo = sessionInfo;\n        this.auth = auth;\n        this.secretKey = secretKey;\n        this.hashingAlgorithm = hashingAlgorithm;\n        this.codeLength = codeLength;\n        this.codeIntervalSeconds = codeIntervalSeconds;\n        this.enrollmentCompletionDeadline = enrollmentCompletionDeadline;\n    }\n    /** @internal */ static _fromStartTotpMfaEnrollmentResponse(response, auth) {\n        return new TotpSecret(response.totpSessionInfo.sharedSecretKey, response.totpSessionInfo.hashingAlgorithm, response.totpSessionInfo.verificationCodeLength, response.totpSessionInfo.periodSec, new Date(response.totpSessionInfo.finalizeEnrollmentTime).toUTCString(), response.totpSessionInfo.sessionInfo, auth);\n    }\n    /** @internal */ _makeTotpVerificationInfo(otp) {\n        return {\n            sessionInfo: this.sessionInfo,\n            verificationCode: otp\n        };\n    }\n    /**\r\n     * Returns a QR code URL as described in\r\n     * https://github.com/google/google-authenticator/wiki/Key-Uri-Format\r\n     * This can be displayed to the user as a QR code to be scanned into a TOTP app like Google Authenticator.\r\n     * If the optional parameters are unspecified, an accountName of <userEmail> and issuer of <firebaseAppName> are used.\r\n     *\r\n     * @param accountName the name of the account/app along with a user identifier.\r\n     * @param issuer issuer of the TOTP (likely the app name).\r\n     * @returns A QR code URL string.\r\n     */ generateQrCodeUrl(accountName, issuer) {\n        var _a;\n        let useDefaults = false;\n        if (_isEmptyString(accountName) || _isEmptyString(issuer)) {\n            useDefaults = true;\n        }\n        if (useDefaults) {\n            if (_isEmptyString(accountName)) {\n                accountName = ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.email) || \"unknownuser\";\n            }\n            if (_isEmptyString(issuer)) {\n                issuer = this.auth.name;\n            }\n        }\n        return `otpauth://totp/${issuer}:${accountName}?secret=${this.secretKey}&issuer=${issuer}&algorithm=${this.hashingAlgorithm}&digits=${this.codeLength}`;\n    }\n}\n/** @internal */ function _isEmptyString(input) {\n    return typeof input === \"undefined\" || (input === null || input === void 0 ? void 0 : input.length) === 0;\n}\n //# sourceMappingURL=totp-d821ac28.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvZGlzdC9ub2RlLWVzbS90b3RwLWQ4MjFhYzI4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkg7QUFDMkk7QUFDek87QUFDaUI7QUFDd0M7QUFDcEM7QUFFcEQ7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0Q7Ozs7Q0FJQyxHQUNELE1BQU0rQixXQUFXO0lBQ2IsMkJBQTJCLEdBQzNCQyxPQUFPO0lBQ1BDLE1BQU07QUFDVjtBQUNBOzs7O0NBSUMsR0FDRCxNQUFNQyxhQUFhO0lBQ2YseUJBQXlCLEdBQ3pCQyxVQUFVO0lBQ1YsdUJBQXVCLEdBQ3ZCQyxRQUFRO0lBQ1IsdUJBQXVCLEdBQ3ZCQyxRQUFRO0lBQ1Isc0JBQXNCLEdBQ3RCQyxVQUFVO0lBQ1YsbUJBQW1CLEdBQ25CTixPQUFPO0lBQ1Asd0JBQXdCLEdBQ3hCTyxTQUFTO0FBQ2I7QUFDQTs7OztDQUlDLEdBQ0QsTUFBTUMsZUFBZTtJQUNqQiw4QkFBOEIsR0FDOUJDLFlBQVk7SUFDWixrQ0FBa0MsR0FDbENDLGdCQUFnQjtJQUNoQiw0QkFBNEIsR0FDNUJQLFVBQVU7SUFDViwwQkFBMEIsR0FDMUJDLFFBQVE7SUFDUiwwQkFBMEIsR0FDMUJDLFFBQVE7SUFDUix5QkFBeUIsR0FDekJMLE9BQU87SUFDUCwyQkFBMkIsR0FDM0JPLFNBQVM7QUFDYjtBQUNBOzs7O0NBSUMsR0FDRCxNQUFNSSxnQkFBZ0I7SUFDbEIscUZBQXFGLEdBQ3JGQyxNQUFNO0lBQ04sc0ZBQXNGLEdBQ3RGQyxnQkFBZ0I7SUFDaEIsMkNBQTJDLEdBQzNDQyxTQUFTO0FBQ2I7QUFDQTs7OztDQUlDLEdBQ0QsTUFBTUMsc0JBQXNCO0lBQ3hCLG1DQUFtQyxHQUNuQ0Ms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QUFDLENBQUM7SUFDM0o7QUFDSjtBQUNBLGNBQWMsR0FDZCxTQUFTWSxlQUFlQyxLQUFLO0lBQ3pCLE9BQU8sT0FBT0EsVUFBVSxlQUFlLENBQUNBLFVBQVUsUUFBUUEsVUFBVSxLQUFLLElBQUksS0FBSyxJQUFJQSxNQUFNL3hCLE1BQU0sTUFBTTtBQUM1RztBQUVpckYsQ0FDanJGLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZyZWUtbmV4dGpzLWFkbWluLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9kaXN0L25vZGUtZXNtL3RvdHAtZDgyMWFjMjguanM/YWZiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTREtfVkVSU0lPTiwgX2lzRmlyZWJhc2VTZXJ2ZXJBcHAsIF9nZXRQcm92aWRlciwgX3JlZ2lzdGVyQ29tcG9uZW50LCByZWdpc3RlclZlcnNpb24sIGdldEFwcCB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgRXJyb3JGYWN0b3J5LCBpc0Jyb3dzZXJFeHRlbnNpb24sIGlzTW9iaWxlQ29yZG92YSwgaXNSZWFjdE5hdGl2ZSwgRmlyZWJhc2VFcnJvciwgcXVlcnlzdHJpbmcsIGdldE1vZHVsYXJJbnN0YW5jZSwgYmFzZTY0RGVjb2RlLCBnZXRVQSwgaXNJRSwgY3JlYXRlU3Vic2NyaWJlLCBkZWVwRXF1YWwsIHF1ZXJ5c3RyaW5nRGVjb2RlLCBleHRyYWN0UXVlcnlzdHJpbmcsIGdldERlZmF1bHRFbXVsYXRvckhvc3QgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBfX3Jlc3QgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IGZldGNoIGFzIGZldGNoJDEsIEhlYWRlcnMgYXMgSGVhZGVycyQxLCBSZXNwb25zZSBhcyBSZXNwb25zZSQxIH0gZnJvbSAndW5kaWNpJztcbmltcG9ydCB7IExvZ2dlciwgTG9nTGV2ZWwgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGVudW0gb2YgZmFjdG9ycyB0aGF0IG1heSBiZSB1c2VkIGZvciBtdWx0aWZhY3RvciBhdXRoZW50aWNhdGlvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgRmFjdG9ySWQgPSB7XHJcbiAgICAvKiogUGhvbmUgYXMgc2Vjb25kIGZhY3RvciAqL1xyXG4gICAgUEhPTkU6ICdwaG9uZScsXHJcbiAgICBUT1RQOiAndG90cCdcclxufTtcclxuLyoqXHJcbiAqIEVudW1lcmF0aW9uIG9mIHN1cHBvcnRlZCBwcm92aWRlcnMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IFByb3ZpZGVySWQgPSB7XHJcbiAgICAvKiogRmFjZWJvb2sgcHJvdmlkZXIgSUQgKi9cclxuICAgIEZBQ0VCT09LOiAnZmFjZWJvb2suY29tJyxcclxuICAgIC8qKiBHaXRIdWIgcHJvdmlkZXIgSUQgKi9cclxuICAgIEdJVEhVQjogJ2dpdGh1Yi5jb20nLFxyXG4gICAgLyoqIEdvb2dsZSBwcm92aWRlciBJRCAqL1xyXG4gICAgR09PR0xFOiAnZ29vZ2xlLmNvbScsXHJcbiAgICAvKiogUGFzc3dvcmQgcHJvdmlkZXIgKi9cclxuICAgIFBBU1NXT1JEOiAncGFzc3dvcmQnLFxyXG4gICAgLyoqIFBob25lIHByb3ZpZGVyICovXHJcbiAgICBQSE9ORTogJ3Bob25lJyxcclxuICAgIC8qKiBUd2l0dGVyIHByb3ZpZGVyIElEICovXHJcbiAgICBUV0lUVEVSOiAndHdpdHRlci5jb20nXHJcbn07XHJcbi8qKlxyXG4gKiBFbnVtZXJhdGlvbiBvZiBzdXBwb3J0ZWQgc2lnbi1pbiBtZXRob2RzLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBTaWduSW5NZXRob2QgPSB7XHJcbiAgICAvKiogRW1haWwgbGluayBzaWduIGluIG1ldGhvZCAqL1xyXG4gICAgRU1BSUxfTElOSzogJ2VtYWlsTGluaycsXHJcbiAgICAvKiogRW1haWwvcGFzc3dvcmQgc2lnbiBpbiBtZXRob2QgKi9cclxuICAgIEVNQUlMX1BBU1NXT1JEOiAncGFzc3dvcmQnLFxyXG4gICAgLyoqIEZhY2Vib29rIHNpZ24gaW4gbWV0aG9kICovXHJcbiAgICBGQUNFQk9PSzogJ2ZhY2Vib29rLmNvbScsXHJcbiAgICAvKiogR2l0SHViIHNpZ24gaW4gbWV0aG9kICovXHJcbiAgICBHSVRIVUI6ICdnaXRodWIuY29tJyxcclxuICAgIC8qKiBHb29nbGUgc2lnbiBpbiBtZXRob2QgKi9cclxuICAgIEdPT0dMRTogJ2dvb2dsZS5jb20nLFxyXG4gICAgLyoqIFBob25lIHNpZ24gaW4gbWV0aG9kICovXHJcbiAgICBQSE9ORTogJ3Bob25lJyxcclxuICAgIC8qKiBUd2l0dGVyIHNpZ24gaW4gbWV0aG9kICovXHJcbiAgICBUV0lUVEVSOiAndHdpdHRlci5jb20nXHJcbn07XHJcbi8qKlxyXG4gKiBFbnVtZXJhdGlvbiBvZiBzdXBwb3J0ZWQgb3BlcmF0aW9uIHR5cGVzLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBPcGVyYXRpb25UeXBlID0ge1xyXG4gICAgLyoqIE9wZXJhdGlvbiBpbnZvbHZpbmcgbGlua2luZyBhbiBhZGRpdGlvbmFsIHByb3ZpZGVyIHRvIGFuIGFscmVhZHkgc2lnbmVkLWluIHVzZXIuICovXHJcbiAgICBMSU5LOiAnbGluaycsXHJcbiAgICAvKiogT3BlcmF0aW9uIGludm9sdmluZyB1c2luZyBhIHByb3ZpZGVyIHRvIHJlYXV0aGVudGljYXRlIGFuIGFscmVhZHkgc2lnbmVkLWluIHVzZXIuICovXHJcbiAgICBSRUFVVEhFTlRJQ0FURTogJ3JlYXV0aGVudGljYXRlJyxcclxuICAgIC8qKiBPcGVyYXRpb24gaW52b2x2aW5nIHNpZ25pbmcgaW4gYSB1c2VyLiAqL1xyXG4gICAgU0lHTl9JTjogJ3NpZ25JbidcclxufTtcclxuLyoqXHJcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHRoZSBwb3NzaWJsZSBlbWFpbCBhY3Rpb24gdHlwZXMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IEFjdGlvbkNvZGVPcGVyYXRpb24gPSB7XHJcbiAgICAvKiogVGhlIGVtYWlsIGxpbmsgc2lnbi1pbiBhY3Rpb24uICovXHJcbiAgICBFTUFJTF9TSUdOSU46ICdFTUFJTF9TSUdOSU4nLFxyXG4gICAgLyoqIFRoZSBwYXNzd29yZCByZXNldCBhY3Rpb24uICovXHJcbiAgICBQQVNTV09SRF9SRVNFVDogJ1BBU1NXT1JEX1JFU0VUJyxcclxuICAgIC8qKiBUaGUgZW1haWwgcmV2b2NhdGlvbiBhY3Rpb24uICovXHJcbiAgICBSRUNPVkVSX0VNQUlMOiAnUkVDT1ZFUl9FTUFJTCcsXHJcbiAgICAvKiogVGhlIHJldmVydCBzZWNvbmQgZmFjdG9yIGFkZGl0aW9uIGVtYWlsIGFjdGlvbi4gKi9cclxuICAgIFJFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OOiAnUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT04nLFxyXG4gICAgLyoqIFRoZSByZXZlcnQgc2Vjb25kIGZhY3RvciBhZGRpdGlvbiBlbWFpbCBhY3Rpb24uICovXHJcbiAgICBWRVJJRllfQU5EX0NIQU5HRV9FTUFJTDogJ1ZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMJyxcclxuICAgIC8qKiBUaGUgZW1haWwgdmVyaWZpY2F0aW9uIGFjdGlvbi4gKi9cclxuICAgIFZFUklGWV9FTUFJTDogJ1ZFUklGWV9FTUFJTCdcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gX2RlYnVnRXJyb3JNYXAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIFtcImFkbWluLXJlc3RyaWN0ZWQtb3BlcmF0aW9uXCIgLyogQXV0aEVycm9yQ29kZS5BRE1JTl9PTkxZX09QRVJBVElPTiAqL106ICdUaGlzIG9wZXJhdGlvbiBpcyByZXN0cmljdGVkIHRvIGFkbWluaXN0cmF0b3JzIG9ubHkuJyxcclxuICAgICAgICBbXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi9dOiAnJyxcclxuICAgICAgICBbXCJhcHAtbm90LWF1dGhvcml6ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkFQUF9OT1RfQVVUSE9SSVpFRCAqL106IFwiVGhpcyBhcHAsIGlkZW50aWZpZWQgYnkgdGhlIGRvbWFpbiB3aGVyZSBpdCdzIGhvc3RlZCwgaXMgbm90IFwiICtcclxuICAgICAgICAgICAgJ2F1dGhvcml6ZWQgdG8gdXNlIEZpcmViYXNlIEF1dGhlbnRpY2F0aW9uIHdpdGggdGhlIHByb3ZpZGVkIEFQSSBrZXkuICcgK1xyXG4gICAgICAgICAgICAnUmV2aWV3IHlvdXIga2V5IGNvbmZpZ3VyYXRpb24gaW4gdGhlIEdvb2dsZSBBUEkgY29uc29sZS4nLFxyXG4gICAgICAgIFtcImFwcC1ub3QtaW5zdGFsbGVkXCIgLyogQXV0aEVycm9yQ29kZS5BUFBfTk9UX0lOU1RBTExFRCAqL106ICdUaGUgcmVxdWVzdGVkIG1vYmlsZSBhcHBsaWNhdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBpZGVudGlmaWVyICgnICtcclxuICAgICAgICAgICAgJ0FuZHJvaWQgcGFja2FnZSBuYW1lIG9yIGlPUyBidW5kbGUgSUQpIHByb3ZpZGVkIGlzIG5vdCBpbnN0YWxsZWQgb24gJyArXHJcbiAgICAgICAgICAgICd0aGlzIGRldmljZS4nLFxyXG4gICAgICAgIFtcImNhcHRjaGEtY2hlY2stZmFpbGVkXCIgLyogQXV0aEVycm9yQ29kZS5DQVBUQ0hBX0NIRUNLX0ZBSUxFRCAqL106ICdUaGUgcmVDQVBUQ0hBIHJlc3BvbnNlIHRva2VuIHByb3ZpZGVkIGlzIGVpdGhlciBpbnZhbGlkLCBleHBpcmVkLCAnICtcclxuICAgICAgICAgICAgJ2FscmVhZHkgdXNlZCBvciB0aGUgZG9tYWluIGFzc29jaWF0ZWQgd2l0aCBpdCBkb2VzIG5vdCBtYXRjaCB0aGUgbGlzdCAnICtcclxuICAgICAgICAgICAgJ29mIHdoaXRlbGlzdGVkIGRvbWFpbnMuJyxcclxuICAgICAgICBbXCJjb2RlLWV4cGlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkNPREVfRVhQSVJFRCAqL106ICdUaGUgU01TIGNvZGUgaGFzIGV4cGlyZWQuIFBsZWFzZSByZS1zZW5kIHRoZSB2ZXJpZmljYXRpb24gY29kZSB0byB0cnkgJyArXHJcbiAgICAgICAgICAgICdhZ2Fpbi4nLFxyXG4gICAgICAgIFtcImNvcmRvdmEtbm90LXJlYWR5XCIgLyogQXV0aEVycm9yQ29kZS5DT1JET1ZBX05PVF9SRUFEWSAqL106ICdDb3Jkb3ZhIGZyYW1ld29yayBpcyBub3QgcmVhZHkuJyxcclxuICAgICAgICBbXCJjb3JzLXVuc3VwcG9ydGVkXCIgLyogQXV0aEVycm9yQ29kZS5DT1JTX1VOU1VQUE9SVEVEICovXTogJ1RoaXMgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkLicsXHJcbiAgICAgICAgW1wiY3JlZGVudGlhbC1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9BTFJFQURZX0lOX1VTRSAqL106ICdUaGlzIGNyZWRlbnRpYWwgaXMgYWxyZWFkeSBhc3NvY2lhdGVkIHdpdGggYSBkaWZmZXJlbnQgdXNlciBhY2NvdW50LicsXHJcbiAgICAgICAgW1wiY3VzdG9tLXRva2VuLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX01JU01BVENIICovXTogJ1RoZSBjdXN0b20gdG9rZW4gY29ycmVzcG9uZHMgdG8gYSBkaWZmZXJlbnQgYXVkaWVuY2UuJyxcclxuICAgICAgICBbXCJyZXF1aXJlcy1yZWNlbnQtbG9naW5cIiAvKiBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfVE9PX09MRF9MT0dJTl9BR0FJTiAqL106ICdUaGlzIG9wZXJhdGlvbiBpcyBzZW5zaXRpdmUgYW5kIHJlcXVpcmVzIHJlY2VudCBhdXRoZW50aWNhdGlvbi4gTG9nIGluICcgK1xyXG4gICAgICAgICAgICAnYWdhaW4gYmVmb3JlIHJldHJ5aW5nIHRoaXMgcmVxdWVzdC4nLFxyXG4gICAgICAgIFtcImRlcGVuZGVudC1zZGstaW5pdGlhbGl6ZWQtYmVmb3JlLWF1dGhcIiAvKiBBdXRoRXJyb3JDb2RlLkRFUEVOREVOVF9TREtfSU5JVF9CRUZPUkVfQVVUSCAqL106ICdBbm90aGVyIEZpcmViYXNlIFNESyB3YXMgaW5pdGlhbGl6ZWQgYW5kIGlzIHRyeWluZyB0byB1c2UgQXV0aCBiZWZvcmUgQXV0aCBpcyAnICtcclxuICAgICAgICAgICAgJ2luaXRpYWxpemVkLiBQbGVhc2UgYmUgc3VyZSB0byBjYWxsIGBpbml0aWFsaXplQXV0aGAgb3IgYGdldEF1dGhgIGJlZm9yZSAnICtcclxuICAgICAgICAgICAgJ3N0YXJ0aW5nIGFueSBvdGhlciBGaXJlYmFzZSBTREsuJyxcclxuICAgICAgICBbXCJkeW5hbWljLWxpbmstbm90LWFjdGl2YXRlZFwiIC8qIEF1dGhFcnJvckNvZGUuRFlOQU1JQ19MSU5LX05PVF9BQ1RJVkFURUQgKi9dOiAnUGxlYXNlIGFjdGl2YXRlIER5bmFtaWMgTGlua3MgaW4gdGhlIEZpcmViYXNlIENvbnNvbGUgYW5kIGFncmVlIHRvIHRoZSB0ZXJtcyBhbmQgJyArXHJcbiAgICAgICAgICAgICdjb25kaXRpb25zLicsXHJcbiAgICAgICAgW1wiZW1haWwtY2hhbmdlLW5lZWRzLXZlcmlmaWNhdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuRU1BSUxfQ0hBTkdFX05FRURTX1ZFUklGSUNBVElPTiAqL106ICdNdWx0aS1mYWN0b3IgdXNlcnMgbXVzdCBhbHdheXMgaGF2ZSBhIHZlcmlmaWVkIGVtYWlsLicsXHJcbiAgICAgICAgW1wiZW1haWwtYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLkVNQUlMX0VYSVNUUyAqL106ICdUaGUgZW1haWwgYWRkcmVzcyBpcyBhbHJlYWR5IGluIHVzZSBieSBhbm90aGVyIGFjY291bnQuJyxcclxuICAgICAgICBbXCJlbXVsYXRvci1jb25maWctZmFpbGVkXCIgLyogQXV0aEVycm9yQ29kZS5FTVVMQVRPUl9DT05GSUdfRkFJTEVEICovXTogJ0F1dGggaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkIHRvIG1ha2UgYSBuZXR3b3JrIGNhbGwuIEF1dGggY2FuICcgK1xyXG4gICAgICAgICAgICAnbm8gbG9uZ2VyIGJlIGNvbmZpZ3VyZWQgdG8gdXNlIHRoZSBlbXVsYXRvci4gVHJ5IGNhbGxpbmcgJyArXHJcbiAgICAgICAgICAgICdcImNvbm5lY3RBdXRoRW11bGF0b3IoKVwiIHNvb25lci4nLFxyXG4gICAgICAgIFtcImV4cGlyZWQtYWN0aW9uLWNvZGVcIiAvKiBBdXRoRXJyb3JDb2RlLkVYUElSRURfT09CX0NPREUgKi9dOiAnVGhlIGFjdGlvbiBjb2RlIGhhcyBleHBpcmVkLicsXHJcbiAgICAgICAgW1wiY2FuY2VsbGVkLXBvcHVwLXJlcXVlc3RcIiAvKiBBdXRoRXJyb3JDb2RlLkVYUElSRURfUE9QVVBfUkVRVUVTVCAqL106ICdUaGlzIG9wZXJhdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQgZHVlIHRvIGFub3RoZXIgY29uZmxpY3RpbmcgcG9wdXAgYmVpbmcgb3BlbmVkLicsXHJcbiAgICAgICAgW1wiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovXTogJ0FuIGludGVybmFsIEF1dGhFcnJvciBoYXMgb2NjdXJyZWQuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLWFwcC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0FQUF9DUkVERU5USUFMICovXTogJ1RoZSBwaG9uZSB2ZXJpZmljYXRpb24gcmVxdWVzdCBjb250YWlucyBhbiBpbnZhbGlkIGFwcGxpY2F0aW9uIHZlcmlmaWVyLicgK1xyXG4gICAgICAgICAgICAnIFRoZSByZUNBUFRDSEEgdG9rZW4gcmVzcG9uc2UgaXMgZWl0aGVyIGludmFsaWQgb3IgZXhwaXJlZC4nLFxyXG4gICAgICAgIFtcImludmFsaWQtYXBwLWlkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0FQUF9JRCAqL106ICdUaGUgbW9iaWxlIGFwcCBpZGVudGlmaWVyIGlzIG5vdCByZWdpc3RlZCBmb3IgdGhlIGN1cnJlbnQgcHJvamVjdC4nLFxyXG4gICAgICAgIFtcImludmFsaWQtdXNlci10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRIICovXTogXCJUaGlzIHVzZXIncyBjcmVkZW50aWFsIGlzbid0IHZhbGlkIGZvciB0aGlzIHByb2plY3QuIFRoaXMgY2FuIGhhcHBlbiBcIiArXHJcbiAgICAgICAgICAgIFwiaWYgdGhlIHVzZXIncyB0b2tlbiBoYXMgYmVlbiB0YW1wZXJlZCB3aXRoLCBvciBpZiB0aGUgdXNlciBpc24ndCBmb3IgXCIgK1xyXG4gICAgICAgICAgICAndGhlIHByb2plY3QgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQVBJIGtleS4nLFxyXG4gICAgICAgIFtcImludmFsaWQtYXV0aC1ldmVudFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRIX0VWRU5UICovXTogJ0FuIGludGVybmFsIEF1dGhFcnJvciBoYXMgb2NjdXJyZWQuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLXZlcmlmaWNhdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NPREUgKi9dOiAnVGhlIFNNUyB2ZXJpZmljYXRpb24gY29kZSB1c2VkIHRvIGNyZWF0ZSB0aGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIGlzICcgK1xyXG4gICAgICAgICAgICAnaW52YWxpZC4gUGxlYXNlIHJlc2VuZCB0aGUgdmVyaWZpY2F0aW9uIGNvZGUgc21zIGFuZCBiZSBzdXJlIHRvIHVzZSB0aGUgJyArXHJcbiAgICAgICAgICAgICd2ZXJpZmljYXRpb24gY29kZSBwcm92aWRlZCBieSB0aGUgdXNlci4nLFxyXG4gICAgICAgIFtcImludmFsaWQtY29udGludWUtdXJpXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NPTlRJTlVFX1VSSSAqL106ICdUaGUgY29udGludWUgVVJMIHByb3ZpZGVkIGluIHRoZSByZXF1ZXN0IGlzIGludmFsaWQuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLWNvcmRvdmEtY29uZmlndXJhdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DT1JET1ZBX0NPTkZJR1VSQVRJT04gKi9dOiAnVGhlIGZvbGxvd2luZyBDb3Jkb3ZhIHBsdWdpbnMgbXVzdCBiZSBpbnN0YWxsZWQgdG8gZW5hYmxlIE9BdXRoIHNpZ24taW46ICcgK1xyXG4gICAgICAgICAgICAnY29yZG92YS1wbHVnaW4tYnVpbGRpbmZvLCBjb3Jkb3ZhLXVuaXZlcnNhbC1saW5rcy1wbHVnaW4sICcgK1xyXG4gICAgICAgICAgICAnY29yZG92YS1wbHVnaW4tYnJvd3NlcnRhYiwgY29yZG92YS1wbHVnaW4taW5hcHBicm93c2VyIGFuZCAnICtcclxuICAgICAgICAgICAgJ2NvcmRvdmEtcGx1Z2luLWN1c3RvbXVybHNjaGVtZS4nLFxyXG4gICAgICAgIFtcImludmFsaWQtY3VzdG9tLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NVU1RPTV9UT0tFTiAqL106ICdUaGUgY3VzdG9tIHRva2VuIGZvcm1hdCBpcyBpbmNvcnJlY3QuIFBsZWFzZSBjaGVjayB0aGUgZG9jdW1lbnRhdGlvbi4nLFxyXG4gICAgICAgIFtcImludmFsaWQtZHluYW1pYy1saW5rLWRvbWFpblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9EWU5BTUlDX0xJTktfRE9NQUlOICovXTogJ1RoZSBwcm92aWRlZCBkeW5hbWljIGxpbmsgZG9tYWluIGlzIG5vdCBjb25maWd1cmVkIG9yIGF1dGhvcml6ZWQgZm9yIHRoZSBjdXJyZW50IHByb2plY3QuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLWVtYWlsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0VNQUlMICovXTogJ1RoZSBlbWFpbCBhZGRyZXNzIGlzIGJhZGx5IGZvcm1hdHRlZC4nLFxyXG4gICAgICAgIFtcImludmFsaWQtZW11bGF0b3Itc2NoZW1lXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0VNVUxBVE9SX1NDSEVNRSAqL106ICdFbXVsYXRvciBVUkwgbXVzdCBzdGFydCB3aXRoIGEgdmFsaWQgc2NoZW1lIChodHRwOi8vIG9yIGh0dHBzOi8vKS4nLFxyXG4gICAgICAgIFtcImludmFsaWQtYXBpLWtleVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BUElfS0VZICovXTogJ1lvdXIgQVBJIGtleSBpcyBpbnZhbGlkLCBwbGVhc2UgY2hlY2sgeW91IGhhdmUgY29waWVkIGl0IGNvcnJlY3RseS4nLFxyXG4gICAgICAgIFtcImludmFsaWQtY2VydC1oYXNoXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NFUlRfSEFTSCAqL106ICdUaGUgU0hBLTEgY2VydGlmaWNhdGUgaGFzaCBwcm92aWRlZCBpcyBpbnZhbGlkLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NSRURFTlRJQUwgKi9dOiAnVGhlIHN1cHBsaWVkIGF1dGggY3JlZGVudGlhbCBpcyBpbmNvcnJlY3QsIG1hbGZvcm1lZCBvciBoYXMgZXhwaXJlZC4nLFxyXG4gICAgICAgIFtcImludmFsaWQtbWVzc2FnZS1wYXlsb2FkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0VfUEFZTE9BRCAqL106ICdUaGUgZW1haWwgdGVtcGxhdGUgY29ycmVzcG9uZGluZyB0byB0aGlzIGFjdGlvbiBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgaW4gaXRzIG1lc3NhZ2UuICcgK1xyXG4gICAgICAgICAgICAnUGxlYXNlIGZpeCBieSBnb2luZyB0byB0aGUgQXV0aCBlbWFpbCB0ZW1wbGF0ZXMgc2VjdGlvbiBpbiB0aGUgRmlyZWJhc2UgQ29uc29sZS4nLFxyXG4gICAgICAgIFtcImludmFsaWQtbXVsdGktZmFjdG9yLXNlc3Npb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfTUZBX1NFU1NJT04gKi9dOiAnVGhlIHJlcXVlc3QgZG9lcyBub3QgY29udGFpbiBhIHZhbGlkIHByb29mIG9mIGZpcnN0IGZhY3RvciBzdWNjZXNzZnVsIHNpZ24taW4uJyxcclxuICAgICAgICBbXCJpbnZhbGlkLW9hdXRoLXByb3ZpZGVyXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX09BVVRIX1BST1ZJREVSICovXTogJ0VtYWlsQXV0aFByb3ZpZGVyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHRoaXMgb3BlcmF0aW9uLiBUaGlzIG9wZXJhdGlvbiAnICtcclxuICAgICAgICAgICAgJ29ubHkgc3VwcG9ydHMgT0F1dGggcHJvdmlkZXJzLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC1vYXV0aC1jbGllbnQtaWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfT0FVVEhfQ0xJRU5UX0lEICovXTogJ1RoZSBPQXV0aCBjbGllbnQgSUQgcHJvdmlkZWQgaXMgZWl0aGVyIGludmFsaWQgb3IgZG9lcyBub3QgbWF0Y2ggdGhlICcgK1xyXG4gICAgICAgICAgICAnc3BlY2lmaWVkIEFQSSBrZXkuJyxcclxuICAgICAgICBbXCJ1bmF1dGhvcml6ZWQtZG9tYWluXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX09SSUdJTiAqL106ICdUaGlzIGRvbWFpbiBpcyBub3QgYXV0aG9yaXplZCBmb3IgT0F1dGggb3BlcmF0aW9ucyBmb3IgeW91ciBGaXJlYmFzZSAnICtcclxuICAgICAgICAgICAgJ3Byb2plY3QuIEVkaXQgdGhlIGxpc3Qgb2YgYXV0aG9yaXplZCBkb21haW5zIGZyb20gdGhlIEZpcmViYXNlIGNvbnNvbGUuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLWFjdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX09PQl9DT0RFICovXTogJ1RoZSBhY3Rpb24gY29kZSBpcyBpbnZhbGlkLiBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIGNvZGUgaXMgbWFsZm9ybWVkLCAnICtcclxuICAgICAgICAgICAgJ2V4cGlyZWQsIG9yIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC4nLFxyXG4gICAgICAgIFtcIndyb25nLXBhc3N3b3JkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1BBU1NXT1JEICovXTogJ1RoZSBwYXNzd29yZCBpcyBpbnZhbGlkIG9yIHRoZSB1c2VyIGRvZXMgbm90IGhhdmUgYSBwYXNzd29yZC4nLFxyXG4gICAgICAgIFtcImludmFsaWQtcGVyc2lzdGVuY2UtdHlwZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9QRVJTSVNURU5DRSAqL106ICdUaGUgc3BlY2lmaWVkIHBlcnNpc3RlbmNlIHR5cGUgaXMgaW52YWxpZC4gSXQgY2FuIG9ubHkgYmUgbG9jYWwsIHNlc3Npb24gb3Igbm9uZS4nLFxyXG4gICAgICAgIFtcImludmFsaWQtcGhvbmUtbnVtYmVyXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1BIT05FX05VTUJFUiAqL106ICdUaGUgZm9ybWF0IG9mIHRoZSBwaG9uZSBudW1iZXIgcHJvdmlkZWQgaXMgaW5jb3JyZWN0LiBQbGVhc2UgZW50ZXIgdGhlICcgK1xyXG4gICAgICAgICAgICAncGhvbmUgbnVtYmVyIGluIGEgZm9ybWF0IHRoYXQgY2FuIGJlIHBhcnNlZCBpbnRvIEUuMTY0IGZvcm1hdC4gRS4xNjQgJyArXHJcbiAgICAgICAgICAgICdwaG9uZSBudW1iZXJzIGFyZSB3cml0dGVuIGluIHRoZSBmb3JtYXQgWytdW2NvdW50cnkgY29kZV1bc3Vic2NyaWJlciAnICtcclxuICAgICAgICAgICAgJ251bWJlciBpbmNsdWRpbmcgYXJlYSBjb2RlXS4nLFxyXG4gICAgICAgIFtcImludmFsaWQtcHJvdmlkZXItaWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUFJPVklERVJfSUQgKi9dOiAnVGhlIHNwZWNpZmllZCBwcm92aWRlciBJRCBpcyBpbnZhbGlkLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC1yZWNpcGllbnQtZW1haWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDSVBJRU5UX0VNQUlMICovXTogJ1RoZSBlbWFpbCBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYWN0aW9uIGZhaWxlZCB0byBzZW5kIGFzIHRoZSBwcm92aWRlZCAnICtcclxuICAgICAgICAgICAgJ3JlY2lwaWVudCBlbWFpbCBhZGRyZXNzIGlzIGludmFsaWQuJyxcclxuICAgICAgICBbXCJpbnZhbGlkLXNlbmRlclwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9TRU5ERVIgKi9dOiAnVGhlIGVtYWlsIHRlbXBsYXRlIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBhY3Rpb24gY29udGFpbnMgYW4gaW52YWxpZCBzZW5kZXIgZW1haWwgb3IgbmFtZS4gJyArXHJcbiAgICAgICAgICAgICdQbGVhc2UgZml4IGJ5IGdvaW5nIHRvIHRoZSBBdXRoIGVtYWlsIHRlbXBsYXRlcyBzZWN0aW9uIGluIHRoZSBGaXJlYmFzZSBDb25zb2xlLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC12ZXJpZmljYXRpb24taWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfU0VTU0lPTl9JTkZPICovXTogJ1RoZSB2ZXJpZmljYXRpb24gSUQgdXNlZCB0byBjcmVhdGUgdGhlIHBob25lIGF1dGggY3JlZGVudGlhbCBpcyBpbnZhbGlkLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC10ZW5hbnQtaWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfVEVOQU5UX0lEICovXTogXCJUaGUgQXV0aCBpbnN0YW5jZSdzIHRlbmFudCBJRCBpcyBpbnZhbGlkLlwiLFxyXG4gICAgICAgIFtcImxvZ2luLWJsb2NrZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkxPR0lOX0JMT0NLRUQgKi9dOiAnTG9naW4gYmxvY2tlZCBieSB1c2VyLXByb3ZpZGVkIG1ldGhvZDogeyRvcmlnaW5hbE1lc3NhZ2V9JyxcclxuICAgICAgICBbXCJtaXNzaW5nLWFuZHJvaWQtcGtnLW5hbWVcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUUgKi9dOiAnQW4gQW5kcm9pZCBQYWNrYWdlIE5hbWUgbXVzdCBiZSBwcm92aWRlZCBpZiB0aGUgQW5kcm9pZCBBcHAgaXMgcmVxdWlyZWQgdG8gYmUgaW5zdGFsbGVkLicsXHJcbiAgICAgICAgW1wiYXV0aC1kb21haW4tY29uZmlnLXJlcXVpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0FVVEhfRE9NQUlOICovXTogJ0JlIHN1cmUgdG8gaW5jbHVkZSBhdXRoRG9tYWluIHdoZW4gY2FsbGluZyBmaXJlYmFzZS5pbml0aWFsaXplQXBwKCksICcgK1xyXG4gICAgICAgICAgICAnYnkgZm9sbG93aW5nIHRoZSBpbnN0cnVjdGlvbnMgaW4gdGhlIEZpcmViYXNlIGNvbnNvbGUuJyxcclxuICAgICAgICBbXCJtaXNzaW5nLWFwcC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0FQUF9DUkVERU5USUFMICovXTogJ1RoZSBwaG9uZSB2ZXJpZmljYXRpb24gcmVxdWVzdCBpcyBtaXNzaW5nIGFuIGFwcGxpY2F0aW9uIHZlcmlmaWVyICcgK1xyXG4gICAgICAgICAgICAnYXNzZXJ0aW9uLiBBIHJlQ0FQVENIQSByZXNwb25zZSB0b2tlbiBuZWVkcyB0byBiZSBwcm92aWRlZC4nLFxyXG4gICAgICAgIFtcIm1pc3NpbmctdmVyaWZpY2F0aW9uLWNvZGVcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQ09ERSAqL106ICdUaGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIHdhcyBjcmVhdGVkIHdpdGggYW4gZW1wdHkgU01TIHZlcmlmaWNhdGlvbiBjb2RlLicsXHJcbiAgICAgICAgW1wibWlzc2luZy1jb250aW51ZS11cmlcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQ09OVElOVUVfVVJJICovXTogJ0EgY29udGludWUgVVJMIG11c3QgYmUgcHJvdmlkZWQgaW4gdGhlIHJlcXVlc3QuJyxcclxuICAgICAgICBbXCJtaXNzaW5nLWlmcmFtZS1zdGFydFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19JRlJBTUVfU1RBUlQgKi9dOiAnQW4gaW50ZXJuYWwgQXV0aEVycm9yIGhhcyBvY2N1cnJlZC4nLFxyXG4gICAgICAgIFtcIm1pc3NpbmctaW9zLWJ1bmRsZS1pZFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19JT1NfQlVORExFX0lEICovXTogJ0FuIGlPUyBCdW5kbGUgSUQgbXVzdCBiZSBwcm92aWRlZCBpZiBhbiBBcHAgU3RvcmUgSUQgaXMgcHJvdmlkZWQuJyxcclxuICAgICAgICBbXCJtaXNzaW5nLW9yLWludmFsaWQtbm9uY2VcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfT1JfSU5WQUxJRF9OT05DRSAqL106ICdUaGUgcmVxdWVzdCBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQgbm9uY2UuIFRoaXMgY2FuIG9jY3VyIGlmIHRoZSAnICtcclxuICAgICAgICAgICAgJ1NIQS0yNTYgaGFzaCBvZiB0aGUgcHJvdmlkZWQgcmF3IG5vbmNlIGRvZXMgbm90IG1hdGNoIHRoZSBoYXNoZWQgbm9uY2UgJyArXHJcbiAgICAgICAgICAgICdpbiB0aGUgSUQgdG9rZW4gcGF5bG9hZC4nLFxyXG4gICAgICAgIFtcIm1pc3NpbmctcGFzc3dvcmRcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUEFTU1dPUkQgKi9dOiAnQSBub24tZW1wdHkgcGFzc3dvcmQgbXVzdCBiZSBwcm92aWRlZCcsXHJcbiAgICAgICAgW1wibWlzc2luZy1tdWx0aS1mYWN0b3ItaW5mb1wiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19NRkFfSU5GTyAqL106ICdObyBzZWNvbmQgZmFjdG9yIGlkZW50aWZpZXIgaXMgcHJvdmlkZWQuJyxcclxuICAgICAgICBbXCJtaXNzaW5nLW11bHRpLWZhY3Rvci1zZXNzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX01GQV9TRVNTSU9OICovXTogJ1RoZSByZXF1ZXN0IGlzIG1pc3NpbmcgcHJvb2Ygb2YgZmlyc3QgZmFjdG9yIHN1Y2Nlc3NmdWwgc2lnbi1pbi4nLFxyXG4gICAgICAgIFtcIm1pc3NpbmctcGhvbmUtbnVtYmVyXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1BIT05FX05VTUJFUiAqL106ICdUbyBzZW5kIHZlcmlmaWNhdGlvbiBjb2RlcywgcHJvdmlkZSBhIHBob25lIG51bWJlciBmb3IgdGhlIHJlY2lwaWVudC4nLFxyXG4gICAgICAgIFtcIm1pc3NpbmctdmVyaWZpY2F0aW9uLWlkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1NFU1NJT05fSU5GTyAqL106ICdUaGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIHdhcyBjcmVhdGVkIHdpdGggYW4gZW1wdHkgdmVyaWZpY2F0aW9uIElELicsXHJcbiAgICAgICAgW1wiYXBwLWRlbGV0ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk1PRFVMRV9ERVNUUk9ZRUQgKi9dOiAnVGhpcyBpbnN0YW5jZSBvZiBGaXJlYmFzZUFwcCBoYXMgYmVlbiBkZWxldGVkLicsXHJcbiAgICAgICAgW1wibXVsdGktZmFjdG9yLWluZm8tbm90LWZvdW5kXCIgLyogQXV0aEVycm9yQ29kZS5NRkFfSU5GT19OT1RfRk9VTkQgKi9dOiAnVGhlIHVzZXIgZG9lcyBub3QgaGF2ZSBhIHNlY29uZCBmYWN0b3IgbWF0Y2hpbmcgdGhlIGlkZW50aWZpZXIgcHJvdmlkZWQuJyxcclxuICAgICAgICBbXCJtdWx0aS1mYWN0b3ItYXV0aC1yZXF1aXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuTUZBX1JFUVVJUkVEICovXTogJ1Byb29mIG9mIG93bmVyc2hpcCBvZiBhIHNlY29uZCBmYWN0b3IgaXMgcmVxdWlyZWQgdG8gY29tcGxldGUgc2lnbi1pbi4nLFxyXG4gICAgICAgIFtcImFjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLk5FRURfQ09ORklSTUFUSU9OICovXTogJ0FuIGFjY291bnQgYWxyZWFkeSBleGlzdHMgd2l0aCB0aGUgc2FtZSBlbWFpbCBhZGRyZXNzIGJ1dCBkaWZmZXJlbnQgJyArXHJcbiAgICAgICAgICAgICdzaWduLWluIGNyZWRlbnRpYWxzLiBTaWduIGluIHVzaW5nIGEgcHJvdmlkZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgJyArXHJcbiAgICAgICAgICAgICdlbWFpbCBhZGRyZXNzLicsXHJcbiAgICAgICAgW1wibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRCAqL106ICdBIG5ldHdvcmsgQXV0aEVycm9yIChzdWNoIGFzIHRpbWVvdXQsIGludGVycnVwdGVkIGNvbm5lY3Rpb24gb3IgdW5yZWFjaGFibGUgaG9zdCkgaGFzIG9jY3VycmVkLicsXHJcbiAgICAgICAgW1wibm8tYXV0aC1ldmVudFwiIC8qIEF1dGhFcnJvckNvZGUuTk9fQVVUSF9FVkVOVCAqL106ICdBbiBpbnRlcm5hbCBBdXRoRXJyb3IgaGFzIG9jY3VycmVkLicsXHJcbiAgICAgICAgW1wibm8tc3VjaC1wcm92aWRlclwiIC8qIEF1dGhFcnJvckNvZGUuTk9fU1VDSF9QUk9WSURFUiAqL106ICdVc2VyIHdhcyBub3QgbGlua2VkIHRvIGFuIGFjY291bnQgd2l0aCB0aGUgZ2l2ZW4gcHJvdmlkZXIuJyxcclxuICAgICAgICBbXCJudWxsLXVzZXJcIiAvKiBBdXRoRXJyb3JDb2RlLk5VTExfVVNFUiAqL106ICdBIG51bGwgdXNlciBvYmplY3Qgd2FzIHByb3ZpZGVkIGFzIHRoZSBhcmd1bWVudCBmb3IgYW4gb3BlcmF0aW9uIHdoaWNoICcgK1xyXG4gICAgICAgICAgICAncmVxdWlyZXMgYSBub24tbnVsbCB1c2VyIG9iamVjdC4nLFxyXG4gICAgICAgIFtcIm9wZXJhdGlvbi1ub3QtYWxsb3dlZFwiIC8qIEF1dGhFcnJvckNvZGUuT1BFUkFUSU9OX05PVF9BTExPV0VEICovXTogJ1RoZSBnaXZlbiBzaWduLWluIHByb3ZpZGVyIGlzIGRpc2FibGVkIGZvciB0aGlzIEZpcmViYXNlIHByb2plY3QuICcgK1xyXG4gICAgICAgICAgICAnRW5hYmxlIGl0IGluIHRoZSBGaXJlYmFzZSBjb25zb2xlLCB1bmRlciB0aGUgc2lnbi1pbiBtZXRob2QgdGFiIG9mIHRoZSAnICtcclxuICAgICAgICAgICAgJ0F1dGggc2VjdGlvbi4nLFxyXG4gICAgICAgIFtcIm9wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnRcIiAvKiBBdXRoRXJyb3JDb2RlLk9QRVJBVElPTl9OT1RfU1VQUE9SVEVEICovXTogJ1RoaXMgb3BlcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGVudmlyb25tZW50IHRoaXMgYXBwbGljYXRpb24gaXMgJyArXHJcbiAgICAgICAgICAgICdydW5uaW5nIG9uLiBcImxvY2F0aW9uLnByb3RvY29sXCIgbXVzdCBiZSBodHRwLCBodHRwcyBvciBjaHJvbWUtZXh0ZW5zaW9uJyArXHJcbiAgICAgICAgICAgICcgYW5kIHdlYiBzdG9yYWdlIG11c3QgYmUgZW5hYmxlZC4nLFxyXG4gICAgICAgIFtcInBvcHVwLWJsb2NrZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlBPUFVQX0JMT0NLRUQgKi9dOiAnVW5hYmxlIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgcG9wdXAuIEl0IG1heSBoYXZlIGJlZW4gYmxvY2tlZCBieSB0aGUgYnJvd3Nlci4nLFxyXG4gICAgICAgIFtcInBvcHVwLWNsb3NlZC1ieS11c2VyXCIgLyogQXV0aEVycm9yQ29kZS5QT1BVUF9DTE9TRURfQllfVVNFUiAqL106ICdUaGUgcG9wdXAgaGFzIGJlZW4gY2xvc2VkIGJ5IHRoZSB1c2VyIGJlZm9yZSBmaW5hbGl6aW5nIHRoZSBvcGVyYXRpb24uJyxcclxuICAgICAgICBbXCJwcm92aWRlci1hbHJlYWR5LWxpbmtlZFwiIC8qIEF1dGhFcnJvckNvZGUuUFJPVklERVJfQUxSRUFEWV9MSU5LRUQgKi9dOiAnVXNlciBjYW4gb25seSBiZSBsaW5rZWQgdG8gb25lIGlkZW50aXR5IGZvciB0aGUgZ2l2ZW4gcHJvdmlkZXIuJyxcclxuICAgICAgICBbXCJxdW90YS1leGNlZWRlZFwiIC8qIEF1dGhFcnJvckNvZGUuUVVPVEFfRVhDRUVERUQgKi9dOiBcIlRoZSBwcm9qZWN0J3MgcXVvdGEgZm9yIHRoaXMgb3BlcmF0aW9uIGhhcyBiZWVuIGV4Y2VlZGVkLlwiLFxyXG4gICAgICAgIFtcInJlZGlyZWN0LWNhbmNlbGxlZC1ieS11c2VyXCIgLyogQXV0aEVycm9yQ29kZS5SRURJUkVDVF9DQU5DRUxMRURfQllfVVNFUiAqL106ICdUaGUgcmVkaXJlY3Qgb3BlcmF0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCBieSB0aGUgdXNlciBiZWZvcmUgZmluYWxpemluZy4nLFxyXG4gICAgICAgIFtcInJlZGlyZWN0LW9wZXJhdGlvbi1wZW5kaW5nXCIgLyogQXV0aEVycm9yQ29kZS5SRURJUkVDVF9PUEVSQVRJT05fUEVORElORyAqL106ICdBIHJlZGlyZWN0IHNpZ24taW4gb3BlcmF0aW9uIGlzIGFscmVhZHkgcGVuZGluZy4nLFxyXG4gICAgICAgIFtcInJlamVjdGVkLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLlJFSkVDVEVEX0NSRURFTlRJQUwgKi9dOiAnVGhlIHJlcXVlc3QgY29udGFpbnMgbWFsZm9ybWVkIG9yIG1pc21hdGNoaW5nIGNyZWRlbnRpYWxzLicsXHJcbiAgICAgICAgW1wic2Vjb25kLWZhY3Rvci1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuU0VDT05EX0ZBQ1RPUl9BTFJFQURZX0VOUk9MTEVEICovXTogJ1RoZSBzZWNvbmQgZmFjdG9yIGlzIGFscmVhZHkgZW5yb2xsZWQgb24gdGhpcyBhY2NvdW50LicsXHJcbiAgICAgICAgW1wibWF4aW11bS1zZWNvbmQtZmFjdG9yLWNvdW50LWV4Y2VlZGVkXCIgLyogQXV0aEVycm9yQ29kZS5TRUNPTkRfRkFDVE9SX0xJTUlUX0VYQ0VFREVEICovXTogJ1RoZSBtYXhpbXVtIGFsbG93ZWQgbnVtYmVyIG9mIHNlY29uZCBmYWN0b3JzIG9uIGEgdXNlciBoYXMgYmVlbiBleGNlZWRlZC4nLFxyXG4gICAgICAgIFtcInRlbmFudC1pZC1taXNtYXRjaFwiIC8qIEF1dGhFcnJvckNvZGUuVEVOQU5UX0lEX01JU01BVENIICovXTogXCJUaGUgcHJvdmlkZWQgdGVuYW50IElEIGRvZXMgbm90IG1hdGNoIHRoZSBBdXRoIGluc3RhbmNlJ3MgdGVuYW50IElEXCIsXHJcbiAgICAgICAgW1widGltZW91dFwiIC8qIEF1dGhFcnJvckNvZGUuVElNRU9VVCAqL106ICdUaGUgb3BlcmF0aW9uIGhhcyB0aW1lZCBvdXQuJyxcclxuICAgICAgICBbXCJ1c2VyLXRva2VuLWV4cGlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlRPS0VOX0VYUElSRUQgKi9dOiBcIlRoZSB1c2VyJ3MgY3JlZGVudGlhbCBpcyBubyBsb25nZXIgdmFsaWQuIFRoZSB1c2VyIG11c3Qgc2lnbiBpbiBhZ2Fpbi5cIixcclxuICAgICAgICBbXCJ0b28tbWFueS1yZXF1ZXN0c1wiIC8qIEF1dGhFcnJvckNvZGUuVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSICovXTogJ1dlIGhhdmUgYmxvY2tlZCBhbGwgcmVxdWVzdHMgZnJvbSB0aGlzIGRldmljZSBkdWUgdG8gdW51c3VhbCBhY3Rpdml0eS4gJyArXHJcbiAgICAgICAgICAgICdUcnkgYWdhaW4gbGF0ZXIuJyxcclxuICAgICAgICBbXCJ1bmF1dGhvcml6ZWQtY29udGludWUtdXJpXCIgLyogQXV0aEVycm9yQ29kZS5VTkFVVEhPUklaRURfRE9NQUlOICovXTogJ1RoZSBkb21haW4gb2YgdGhlIGNvbnRpbnVlIFVSTCBpcyBub3Qgd2hpdGVsaXN0ZWQuICBQbGVhc2Ugd2hpdGVsaXN0ICcgK1xyXG4gICAgICAgICAgICAndGhlIGRvbWFpbiBpbiB0aGUgRmlyZWJhc2UgY29uc29sZS4nLFxyXG4gICAgICAgIFtcInVuc3VwcG9ydGVkLWZpcnN0LWZhY3RvclwiIC8qIEF1dGhFcnJvckNvZGUuVU5TVVBQT1JURURfRklSU1RfRkFDVE9SICovXTogJ0Vucm9sbGluZyBhIHNlY29uZCBmYWN0b3Igb3Igc2lnbmluZyBpbiB3aXRoIGEgbXVsdGktZmFjdG9yIGFjY291bnQgcmVxdWlyZXMgc2lnbi1pbiB3aXRoIGEgc3VwcG9ydGVkIGZpcnN0IGZhY3Rvci4nLFxyXG4gICAgICAgIFtcInVuc3VwcG9ydGVkLXBlcnNpc3RlbmNlLXR5cGVcIiAvKiBBdXRoRXJyb3JDb2RlLlVOU1VQUE9SVEVEX1BFUlNJU1RFTkNFICovXTogJ1RoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgdGhlIHNwZWNpZmllZCBwZXJzaXN0ZW5jZSB0eXBlLicsXHJcbiAgICAgICAgW1widW5zdXBwb3J0ZWQtdGVuYW50LW9wZXJhdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuVU5TVVBQT1JURURfVEVOQU5UX09QRVJBVElPTiAqL106ICdUaGlzIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIGEgbXVsdGktdGVuYW50IGNvbnRleHQuJyxcclxuICAgICAgICBbXCJ1bnZlcmlmaWVkLWVtYWlsXCIgLyogQXV0aEVycm9yQ29kZS5VTlZFUklGSUVEX0VNQUlMICovXTogJ1RoZSBvcGVyYXRpb24gcmVxdWlyZXMgYSB2ZXJpZmllZCBlbWFpbC4nLFxyXG4gICAgICAgIFtcInVzZXItY2FuY2VsbGVkXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0NBTkNFTExFRCAqL106ICdUaGUgdXNlciBkaWQgbm90IGdyYW50IHlvdXIgYXBwbGljYXRpb24gdGhlIHBlcm1pc3Npb25zIGl0IHJlcXVlc3RlZC4nLFxyXG4gICAgICAgIFtcInVzZXItbm90LWZvdW5kXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RFTEVURUQgKi9dOiAnVGhlcmUgaXMgbm8gdXNlciByZWNvcmQgY29ycmVzcG9uZGluZyB0byB0aGlzIGlkZW50aWZpZXIuIFRoZSB1c2VyIG1heSAnICtcclxuICAgICAgICAgICAgJ2hhdmUgYmVlbiBkZWxldGVkLicsXHJcbiAgICAgICAgW1widXNlci1kaXNhYmxlZFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9ESVNBQkxFRCAqL106ICdUaGUgdXNlciBhY2NvdW50IGhhcyBiZWVuIGRpc2FibGVkIGJ5IGFuIGFkbWluaXN0cmF0b3IuJyxcclxuICAgICAgICBbXCJ1c2VyLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX01JU01BVENIICovXTogJ1RoZSBzdXBwbGllZCBjcmVkZW50aWFscyBkbyBub3QgY29ycmVzcG9uZCB0byB0aGUgcHJldmlvdXNseSBzaWduZWQgaW4gdXNlci4nLFxyXG4gICAgICAgIFtcInVzZXItc2lnbmVkLW91dFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9TSUdORURfT1VUICovXTogJycsXHJcbiAgICAgICAgW1wid2Vhay1wYXNzd29yZFwiIC8qIEF1dGhFcnJvckNvZGUuV0VBS19QQVNTV09SRCAqL106ICdUaGUgcGFzc3dvcmQgbXVzdCBiZSA2IGNoYXJhY3RlcnMgbG9uZyBvciBtb3JlLicsXHJcbiAgICAgICAgW1wid2ViLXN0b3JhZ2UtdW5zdXBwb3J0ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLldFQl9TVE9SQUdFX1VOU1VQUE9SVEVEICovXTogJ1RoaXMgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkIG9yIDNyZCBwYXJ0eSBjb29raWVzIGFuZCBkYXRhIG1heSBiZSBkaXNhYmxlZC4nLFxyXG4gICAgICAgIFtcImFscmVhZHktaW5pdGlhbGl6ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkFMUkVBRFlfSU5JVElBTElaRUQgKi9dOiAnaW5pdGlhbGl6ZUF1dGgoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCB3aXRoICcgK1xyXG4gICAgICAgICAgICAnZGlmZmVyZW50IG9wdGlvbnMuIFRvIGF2b2lkIHRoaXMgZXJyb3IsIGNhbGwgaW5pdGlhbGl6ZUF1dGgoKSB3aXRoIHRoZSAnICtcclxuICAgICAgICAgICAgJ3NhbWUgb3B0aW9ucyBhcyB3aGVuIGl0IHdhcyBvcmlnaW5hbGx5IGNhbGxlZCwgb3IgY2FsbCBnZXRBdXRoKCkgdG8gcmV0dXJuIHRoZScgK1xyXG4gICAgICAgICAgICAnIGFscmVhZHkgaW5pdGlhbGl6ZWQgaW5zdGFuY2UuJyxcclxuICAgICAgICBbXCJtaXNzaW5nLXJlY2FwdGNoYS10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVE9LRU4gKi9dOiAnVGhlIHJlQ0FQVENIQSB0b2tlbiBpcyBtaXNzaW5nIHdoZW4gc2VuZGluZyByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC1yZWNhcHRjaGEtdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX1RPS0VOICovXTogJ1RoZSByZUNBUFRDSEEgdG9rZW4gaXMgaW52YWxpZCB3aGVuIHNlbmRpbmcgcmVxdWVzdCB0byB0aGUgYmFja2VuZC4nLFxyXG4gICAgICAgIFtcImludmFsaWQtcmVjYXB0Y2hhLWFjdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRUNBUFRDSEFfQUNUSU9OICovXTogJ1RoZSByZUNBUFRDSEEgYWN0aW9uIGlzIGludmFsaWQgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcclxuICAgICAgICBbXCJyZWNhcHRjaGEtbm90LWVuYWJsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlJFQ0FQVENIQV9OT1RfRU5BQkxFRCAqL106ICdyZUNBUFRDSEEgRW50ZXJwcmlzZSBpbnRlZ3JhdGlvbiBpcyBub3QgZW5hYmxlZCBmb3IgdGhpcyBwcm9qZWN0LicsXHJcbiAgICAgICAgW1wibWlzc2luZy1jbGllbnQtdHlwZVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19DTElFTlRfVFlQRSAqL106ICdUaGUgcmVDQVBUQ0hBIGNsaWVudCB0eXBlIGlzIG1pc3Npbmcgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcclxuICAgICAgICBbXCJtaXNzaW5nLXJlY2FwdGNoYS12ZXJzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1JFQ0FQVENIQV9WRVJTSU9OICovXTogJ1RoZSByZUNBUFRDSEEgdmVyc2lvbiBpcyBtaXNzaW5nIHdoZW4gc2VuZGluZyByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kLicsXHJcbiAgICAgICAgW1wiaW52YWxpZC1yZXEtdHlwZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRVFfVFlQRSAqL106ICdJbnZhbGlkIHJlcXVlc3QgcGFyYW1ldGVycy4nLFxyXG4gICAgICAgIFtcImludmFsaWQtcmVjYXB0Y2hhLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT04gKi9dOiAnVGhlIHJlQ0FQVENIQSB2ZXJzaW9uIGlzIGludmFsaWQgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcclxuICAgICAgICBbXCJ1bnN1cHBvcnRlZC1wYXNzd29yZC1wb2xpY3ktc2NoZW1hLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLlVOU1VQUE9SVEVEX1BBU1NXT1JEX1BPTElDWV9TQ0hFTUFfVkVSU0lPTiAqL106ICdUaGUgcGFzc3dvcmQgcG9saWN5IHJlY2VpdmVkIGZyb20gdGhlIGJhY2tlbmQgdXNlcyBhIHNjaGVtYSB2ZXJzaW9uIHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHZlcnNpb24gb2YgdGhlIEZpcmViYXNlIFNESy4nLFxyXG4gICAgICAgIFtcInBhc3N3b3JkLWRvZXMtbm90LW1lZXQtcmVxdWlyZW1lbnRzXCIgLyogQXV0aEVycm9yQ29kZS5QQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UUyAqL106ICdUaGUgcGFzc3dvcmQgZG9lcyBub3QgbWVldCB0aGUgcmVxdWlyZW1lbnRzLidcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gX3Byb2RFcnJvck1hcCgpIHtcclxuICAgIC8vIFdlIHdpbGwgaW5jbHVkZSB0aGlzIG9uZSBtZXNzYWdlIGluIHRoZSBwcm9kIGVycm9yIG1hcCBzaW5jZSBieSB0aGUgdmVyeVxyXG4gICAgLy8gbmF0dXJlIG9mIHRoaXMgZXJyb3IsIGRldmVsb3BlcnMgd2lsbCBuZXZlciBiZSBhYmxlIHRvIHNlZSB0aGUgbWVzc2FnZVxyXG4gICAgLy8gdXNpbmcgdGhlIGRlYnVnRXJyb3JNYXAgKHdoaWNoIGlzIGluc3RhbGxlZCBkdXJpbmcgYXV0aCBpbml0aWFsaXphdGlvbikuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIFtcImRlcGVuZGVudC1zZGstaW5pdGlhbGl6ZWQtYmVmb3JlLWF1dGhcIiAvKiBBdXRoRXJyb3JDb2RlLkRFUEVOREVOVF9TREtfSU5JVF9CRUZPUkVfQVVUSCAqL106ICdBbm90aGVyIEZpcmViYXNlIFNESyB3YXMgaW5pdGlhbGl6ZWQgYW5kIGlzIHRyeWluZyB0byB1c2UgQXV0aCBiZWZvcmUgQXV0aCBpcyAnICtcclxuICAgICAgICAgICAgJ2luaXRpYWxpemVkLiBQbGVhc2UgYmUgc3VyZSB0byBjYWxsIGBpbml0aWFsaXplQXV0aGAgb3IgYGdldEF1dGhgIGJlZm9yZSAnICtcclxuICAgICAgICAgICAgJ3N0YXJ0aW5nIGFueSBvdGhlciBGaXJlYmFzZSBTREsuJ1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQSB2ZXJib3NlIGVycm9yIG1hcCB3aXRoIGRldGFpbGVkIGRlc2NyaXB0aW9ucyBmb3IgbW9zdCBlcnJvciBjb2Rlcy5cclxuICpcclxuICogU2VlIGRpc2N1c3Npb24gYXQge0BsaW5rIEF1dGhFcnJvck1hcH1cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgZGVidWdFcnJvck1hcCA9IF9kZWJ1Z0Vycm9yTWFwO1xyXG4vKipcclxuICogQSBtaW5pbWFsIGVycm9yIG1hcCB3aXRoIGFsbCB2ZXJib3NlIGVycm9yIG1lc3NhZ2VzIHN0cmlwcGVkLlxyXG4gKlxyXG4gKiBTZWUgZGlzY3Vzc2lvbiBhdCB7QGxpbmsgQXV0aEVycm9yTWFwfVxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBwcm9kRXJyb3JNYXAgPSBfcHJvZEVycm9yTWFwO1xyXG5jb25zdCBfREVGQVVMVF9BVVRIX0VSUk9SX0ZBQ1RPUlkgPSBuZXcgRXJyb3JGYWN0b3J5KCdhdXRoJywgJ0ZpcmViYXNlJywgX3Byb2RFcnJvck1hcCgpKTtcclxuLyoqXHJcbiAqIEEgbWFwIG9mIHBvdGVudGlhbCBgQXV0aGAgZXJyb3IgY29kZXMsIGZvciBlYXNpZXIgY29tcGFyaXNvbiB3aXRoIGVycm9yc1xyXG4gKiB0aHJvd24gYnkgdGhlIFNESy5cclxuICpcclxuICogQHJlbWFya3NcclxuICogTm90ZSB0aGF0IHlvdSBjYW4ndCB0cmVlLXNoYWtlIGluZGl2aWR1YWwga2V5c1xyXG4gKiBpbiB0aGUgbWFwLCBzbyBieSB1c2luZyB0aGUgbWFwIHlvdSBtaWdodCBzdWJzdGFudGlhbGx5IGluY3JlYXNlIHlvdXJcclxuICogYnVuZGxlIHNpemUuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IEFVVEhfRVJST1JfQ09ERVNfTUFQX0RPX05PVF9VU0VfSU5URVJOQUxMWSA9IHtcclxuICAgIEFETUlOX09OTFlfT1BFUkFUSU9OOiAnYXV0aC9hZG1pbi1yZXN0cmljdGVkLW9wZXJhdGlvbicsXHJcbiAgICBBUkdVTUVOVF9FUlJPUjogJ2F1dGgvYXJndW1lbnQtZXJyb3InLFxyXG4gICAgQVBQX05PVF9BVVRIT1JJWkVEOiAnYXV0aC9hcHAtbm90LWF1dGhvcml6ZWQnLFxyXG4gICAgQVBQX05PVF9JTlNUQUxMRUQ6ICdhdXRoL2FwcC1ub3QtaW5zdGFsbGVkJyxcclxuICAgIENBUFRDSEFfQ0hFQ0tfRkFJTEVEOiAnYXV0aC9jYXB0Y2hhLWNoZWNrLWZhaWxlZCcsXHJcbiAgICBDT0RFX0VYUElSRUQ6ICdhdXRoL2NvZGUtZXhwaXJlZCcsXHJcbiAgICBDT1JET1ZBX05PVF9SRUFEWTogJ2F1dGgvY29yZG92YS1ub3QtcmVhZHknLFxyXG4gICAgQ09SU19VTlNVUFBPUlRFRDogJ2F1dGgvY29ycy11bnN1cHBvcnRlZCcsXHJcbiAgICBDUkVERU5USUFMX0FMUkVBRFlfSU5fVVNFOiAnYXV0aC9jcmVkZW50aWFsLWFscmVhZHktaW4tdXNlJyxcclxuICAgIENSRURFTlRJQUxfTUlTTUFUQ0g6ICdhdXRoL2N1c3RvbS10b2tlbi1taXNtYXRjaCcsXHJcbiAgICBDUkVERU5USUFMX1RPT19PTERfTE9HSU5fQUdBSU46ICdhdXRoL3JlcXVpcmVzLXJlY2VudC1sb2dpbicsXHJcbiAgICBERVBFTkRFTlRfU0RLX0lOSVRfQkVGT1JFX0FVVEg6ICdhdXRoL2RlcGVuZGVudC1zZGstaW5pdGlhbGl6ZWQtYmVmb3JlLWF1dGgnLFxyXG4gICAgRFlOQU1JQ19MSU5LX05PVF9BQ1RJVkFURUQ6ICdhdXRoL2R5bmFtaWMtbGluay1ub3QtYWN0aXZhdGVkJyxcclxuICAgIEVNQUlMX0NIQU5HRV9ORUVEU19WRVJJRklDQVRJT046ICdhdXRoL2VtYWlsLWNoYW5nZS1uZWVkcy12ZXJpZmljYXRpb24nLFxyXG4gICAgRU1BSUxfRVhJU1RTOiAnYXV0aC9lbWFpbC1hbHJlYWR5LWluLXVzZScsXHJcbiAgICBFTVVMQVRPUl9DT05GSUdfRkFJTEVEOiAnYXV0aC9lbXVsYXRvci1jb25maWctZmFpbGVkJyxcclxuICAgIEVYUElSRURfT09CX0NPREU6ICdhdXRoL2V4cGlyZWQtYWN0aW9uLWNvZGUnLFxyXG4gICAgRVhQSVJFRF9QT1BVUF9SRVFVRVNUOiAnYXV0aC9jYW5jZWxsZWQtcG9wdXAtcmVxdWVzdCcsXHJcbiAgICBJTlRFUk5BTF9FUlJPUjogJ2F1dGgvaW50ZXJuYWwtZXJyb3InLFxyXG4gICAgSU5WQUxJRF9BUElfS0VZOiAnYXV0aC9pbnZhbGlkLWFwaS1rZXknLFxyXG4gICAgSU5WQUxJRF9BUFBfQ1JFREVOVElBTDogJ2F1dGgvaW52YWxpZC1hcHAtY3JlZGVudGlhbCcsXHJcbiAgICBJTlZBTElEX0FQUF9JRDogJ2F1dGgvaW52YWxpZC1hcHAtaWQnLFxyXG4gICAgSU5WQUxJRF9BVVRIOiAnYXV0aC9pbnZhbGlkLXVzZXItdG9rZW4nLFxyXG4gICAgSU5WQUxJRF9BVVRIX0VWRU5UOiAnYXV0aC9pbnZhbGlkLWF1dGgtZXZlbnQnLFxyXG4gICAgSU5WQUxJRF9DRVJUX0hBU0g6ICdhdXRoL2ludmFsaWQtY2VydC1oYXNoJyxcclxuICAgIElOVkFMSURfQ09ERTogJ2F1dGgvaW52YWxpZC12ZXJpZmljYXRpb24tY29kZScsXHJcbiAgICBJTlZBTElEX0NPTlRJTlVFX1VSSTogJ2F1dGgvaW52YWxpZC1jb250aW51ZS11cmknLFxyXG4gICAgSU5WQUxJRF9DT1JET1ZBX0NPTkZJR1VSQVRJT046ICdhdXRoL2ludmFsaWQtY29yZG92YS1jb25maWd1cmF0aW9uJyxcclxuICAgIElOVkFMSURfQ1VTVE9NX1RPS0VOOiAnYXV0aC9pbnZhbGlkLWN1c3RvbS10b2tlbicsXHJcbiAgICBJTlZBTElEX0RZTkFNSUNfTElOS19ET01BSU46ICdhdXRoL2ludmFsaWQtZHluYW1pYy1saW5rLWRvbWFpbicsXHJcbiAgICBJTlZBTElEX0VNQUlMOiAnYXV0aC9pbnZhbGlkLWVtYWlsJyxcclxuICAgIElOVkFMSURfRU1VTEFUT1JfU0NIRU1FOiAnYXV0aC9pbnZhbGlkLWVtdWxhdG9yLXNjaGVtZScsXHJcbiAgICBJTlZBTElEX0lEUF9SRVNQT05TRTogJ2F1dGgvaW52YWxpZC1jcmVkZW50aWFsJyxcclxuICAgIElOVkFMSURfTE9HSU5fQ1JFREVOVElBTFM6ICdhdXRoL2ludmFsaWQtY3JlZGVudGlhbCcsXHJcbiAgICBJTlZBTElEX01FU1NBR0VfUEFZTE9BRDogJ2F1dGgvaW52YWxpZC1tZXNzYWdlLXBheWxvYWQnLFxyXG4gICAgSU5WQUxJRF9NRkFfU0VTU0lPTjogJ2F1dGgvaW52YWxpZC1tdWx0aS1mYWN0b3Itc2Vzc2lvbicsXHJcbiAgICBJTlZBTElEX09BVVRIX0NMSUVOVF9JRDogJ2F1dGgvaW52YWxpZC1vYXV0aC1jbGllbnQtaWQnLFxyXG4gICAgSU5WQUxJRF9PQVVUSF9QUk9WSURFUjogJ2F1dGgvaW52YWxpZC1vYXV0aC1wcm92aWRlcicsXHJcbiAgICBJTlZBTElEX09PQl9DT0RFOiAnYXV0aC9pbnZhbGlkLWFjdGlvbi1jb2RlJyxcclxuICAgIElOVkFMSURfT1JJR0lOOiAnYXV0aC91bmF1dGhvcml6ZWQtZG9tYWluJyxcclxuICAgIElOVkFMSURfUEFTU1dPUkQ6ICdhdXRoL3dyb25nLXBhc3N3b3JkJyxcclxuICAgIElOVkFMSURfUEVSU0lTVEVOQ0U6ICdhdXRoL2ludmFsaWQtcGVyc2lzdGVuY2UtdHlwZScsXHJcbiAgICBJTlZBTElEX1BIT05FX05VTUJFUjogJ2F1dGgvaW52YWxpZC1waG9uZS1udW1iZXInLFxyXG4gICAgSU5WQUxJRF9QUk9WSURFUl9JRDogJ2F1dGgvaW52YWxpZC1wcm92aWRlci1pZCcsXHJcbiAgICBJTlZBTElEX1JFQ0lQSUVOVF9FTUFJTDogJ2F1dGgvaW52YWxpZC1yZWNpcGllbnQtZW1haWwnLFxyXG4gICAgSU5WQUxJRF9TRU5ERVI6ICdhdXRoL2ludmFsaWQtc2VuZGVyJyxcclxuICAgIElOVkFMSURfU0VTU0lPTl9JTkZPOiAnYXV0aC9pbnZhbGlkLXZlcmlmaWNhdGlvbi1pZCcsXHJcbiAgICBJTlZBTElEX1RFTkFOVF9JRDogJ2F1dGgvaW52YWxpZC10ZW5hbnQtaWQnLFxyXG4gICAgTUZBX0lORk9fTk9UX0ZPVU5EOiAnYXV0aC9tdWx0aS1mYWN0b3ItaW5mby1ub3QtZm91bmQnLFxyXG4gICAgTUZBX1JFUVVJUkVEOiAnYXV0aC9tdWx0aS1mYWN0b3ItYXV0aC1yZXF1aXJlZCcsXHJcbiAgICBNSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FOiAnYXV0aC9taXNzaW5nLWFuZHJvaWQtcGtnLW5hbWUnLFxyXG4gICAgTUlTU0lOR19BUFBfQ1JFREVOVElBTDogJ2F1dGgvbWlzc2luZy1hcHAtY3JlZGVudGlhbCcsXHJcbiAgICBNSVNTSU5HX0FVVEhfRE9NQUlOOiAnYXV0aC9hdXRoLWRvbWFpbi1jb25maWctcmVxdWlyZWQnLFxyXG4gICAgTUlTU0lOR19DT0RFOiAnYXV0aC9taXNzaW5nLXZlcmlmaWNhdGlvbi1jb2RlJyxcclxuICAgIE1JU1NJTkdfQ09OVElOVUVfVVJJOiAnYXV0aC9taXNzaW5nLWNvbnRpbnVlLXVyaScsXHJcbiAgICBNSVNTSU5HX0lGUkFNRV9TVEFSVDogJ2F1dGgvbWlzc2luZy1pZnJhbWUtc3RhcnQnLFxyXG4gICAgTUlTU0lOR19JT1NfQlVORExFX0lEOiAnYXV0aC9taXNzaW5nLWlvcy1idW5kbGUtaWQnLFxyXG4gICAgTUlTU0lOR19PUl9JTlZBTElEX05PTkNFOiAnYXV0aC9taXNzaW5nLW9yLWludmFsaWQtbm9uY2UnLFxyXG4gICAgTUlTU0lOR19NRkFfSU5GTzogJ2F1dGgvbWlzc2luZy1tdWx0aS1mYWN0b3ItaW5mbycsXHJcbiAgICBNSVNTSU5HX01GQV9TRVNTSU9OOiAnYXV0aC9taXNzaW5nLW11bHRpLWZhY3Rvci1zZXNzaW9uJyxcclxuICAgIE1JU1NJTkdfUEhPTkVfTlVNQkVSOiAnYXV0aC9taXNzaW5nLXBob25lLW51bWJlcicsXHJcbiAgICBNSVNTSU5HX1NFU1NJT05fSU5GTzogJ2F1dGgvbWlzc2luZy12ZXJpZmljYXRpb24taWQnLFxyXG4gICAgTU9EVUxFX0RFU1RST1lFRDogJ2F1dGgvYXBwLWRlbGV0ZWQnLFxyXG4gICAgTkVFRF9DT05GSVJNQVRJT046ICdhdXRoL2FjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWwnLFxyXG4gICAgTkVUV09SS19SRVFVRVNUX0ZBSUxFRDogJ2F1dGgvbmV0d29yay1yZXF1ZXN0LWZhaWxlZCcsXHJcbiAgICBOVUxMX1VTRVI6ICdhdXRoL251bGwtdXNlcicsXHJcbiAgICBOT19BVVRIX0VWRU5UOiAnYXV0aC9uby1hdXRoLWV2ZW50JyxcclxuICAgIE5PX1NVQ0hfUFJPVklERVI6ICdhdXRoL25vLXN1Y2gtcHJvdmlkZXInLFxyXG4gICAgT1BFUkFUSU9OX05PVF9BTExPV0VEOiAnYXV0aC9vcGVyYXRpb24tbm90LWFsbG93ZWQnLFxyXG4gICAgT1BFUkFUSU9OX05PVF9TVVBQT1JURUQ6ICdhdXRoL29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQnLFxyXG4gICAgUE9QVVBfQkxPQ0tFRDogJ2F1dGgvcG9wdXAtYmxvY2tlZCcsXHJcbiAgICBQT1BVUF9DTE9TRURfQllfVVNFUjogJ2F1dGgvcG9wdXAtY2xvc2VkLWJ5LXVzZXInLFxyXG4gICAgUFJPVklERVJfQUxSRUFEWV9MSU5LRUQ6ICdhdXRoL3Byb3ZpZGVyLWFscmVhZHktbGlua2VkJyxcclxuICAgIFFVT1RBX0VYQ0VFREVEOiAnYXV0aC9xdW90YS1leGNlZWRlZCcsXHJcbiAgICBSRURJUkVDVF9DQU5DRUxMRURfQllfVVNFUjogJ2F1dGgvcmVkaXJlY3QtY2FuY2VsbGVkLWJ5LXVzZXInLFxyXG4gICAgUkVESVJFQ1RfT1BFUkFUSU9OX1BFTkRJTkc6ICdhdXRoL3JlZGlyZWN0LW9wZXJhdGlvbi1wZW5kaW5nJyxcclxuICAgIFJFSkVDVEVEX0NSRURFTlRJQUw6ICdhdXRoL3JlamVjdGVkLWNyZWRlbnRpYWwnLFxyXG4gICAgU0VDT05EX0ZBQ1RPUl9BTFJFQURZX0VOUk9MTEVEOiAnYXV0aC9zZWNvbmQtZmFjdG9yLWFscmVhZHktaW4tdXNlJyxcclxuICAgIFNFQ09ORF9GQUNUT1JfTElNSVRfRVhDRUVERUQ6ICdhdXRoL21heGltdW0tc2Vjb25kLWZhY3Rvci1jb3VudC1leGNlZWRlZCcsXHJcbiAgICBURU5BTlRfSURfTUlTTUFUQ0g6ICdhdXRoL3RlbmFudC1pZC1taXNtYXRjaCcsXHJcbiAgICBUSU1FT1VUOiAnYXV0aC90aW1lb3V0JyxcclxuICAgIFRPS0VOX0VYUElSRUQ6ICdhdXRoL3VzZXItdG9rZW4tZXhwaXJlZCcsXHJcbiAgICBUT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVI6ICdhdXRoL3Rvby1tYW55LXJlcXVlc3RzJyxcclxuICAgIFVOQVVUSE9SSVpFRF9ET01BSU46ICdhdXRoL3VuYXV0aG9yaXplZC1jb250aW51ZS11cmknLFxyXG4gICAgVU5TVVBQT1JURURfRklSU1RfRkFDVE9SOiAnYXV0aC91bnN1cHBvcnRlZC1maXJzdC1mYWN0b3InLFxyXG4gICAgVU5TVVBQT1JURURfUEVSU0lTVEVOQ0U6ICdhdXRoL3Vuc3VwcG9ydGVkLXBlcnNpc3RlbmNlLXR5cGUnLFxyXG4gICAgVU5TVVBQT1JURURfVEVOQU5UX09QRVJBVElPTjogJ2F1dGgvdW5zdXBwb3J0ZWQtdGVuYW50LW9wZXJhdGlvbicsXHJcbiAgICBVTlZFUklGSUVEX0VNQUlMOiAnYXV0aC91bnZlcmlmaWVkLWVtYWlsJyxcclxuICAgIFVTRVJfQ0FOQ0VMTEVEOiAnYXV0aC91c2VyLWNhbmNlbGxlZCcsXHJcbiAgICBVU0VSX0RFTEVURUQ6ICdhdXRoL3VzZXItbm90LWZvdW5kJyxcclxuICAgIFVTRVJfRElTQUJMRUQ6ICdhdXRoL3VzZXItZGlzYWJsZWQnLFxyXG4gICAgVVNFUl9NSVNNQVRDSDogJ2F1dGgvdXNlci1taXNtYXRjaCcsXHJcbiAgICBVU0VSX1NJR05FRF9PVVQ6ICdhdXRoL3VzZXItc2lnbmVkLW91dCcsXHJcbiAgICBXRUFLX1BBU1NXT1JEOiAnYXV0aC93ZWFrLXBhc3N3b3JkJyxcclxuICAgIFdFQl9TVE9SQUdFX1VOU1VQUE9SVEVEOiAnYXV0aC93ZWItc3RvcmFnZS11bnN1cHBvcnRlZCcsXHJcbiAgICBBTFJFQURZX0lOSVRJQUxJWkVEOiAnYXV0aC9hbHJlYWR5LWluaXRpYWxpemVkJyxcclxuICAgIFJFQ0FQVENIQV9OT1RfRU5BQkxFRDogJ2F1dGgvcmVjYXB0Y2hhLW5vdC1lbmFibGVkJyxcclxuICAgIE1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOOiAnYXV0aC9taXNzaW5nLXJlY2FwdGNoYS10b2tlbicsXHJcbiAgICBJTlZBTElEX1JFQ0FQVENIQV9UT0tFTjogJ2F1dGgvaW52YWxpZC1yZWNhcHRjaGEtdG9rZW4nLFxyXG4gICAgSU5WQUxJRF9SRUNBUFRDSEFfQUNUSU9OOiAnYXV0aC9pbnZhbGlkLXJlY2FwdGNoYS1hY3Rpb24nLFxyXG4gICAgTUlTU0lOR19DTElFTlRfVFlQRTogJ2F1dGgvbWlzc2luZy1jbGllbnQtdHlwZScsXHJcbiAgICBNSVNTSU5HX1JFQ0FQVENIQV9WRVJTSU9OOiAnYXV0aC9taXNzaW5nLXJlY2FwdGNoYS12ZXJzaW9uJyxcclxuICAgIElOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT046ICdhdXRoL2ludmFsaWQtcmVjYXB0Y2hhLXZlcnNpb24nLFxyXG4gICAgSU5WQUxJRF9SRVFfVFlQRTogJ2F1dGgvaW52YWxpZC1yZXEtdHlwZSdcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgbG9nQ2xpZW50ID0gbmV3IExvZ2dlcignQGZpcmViYXNlL2F1dGgnKTtcclxuZnVuY3Rpb24gX2xvZ1dhcm4obXNnLCAuLi5hcmdzKSB7XHJcbiAgICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IExvZ0xldmVsLldBUk4pIHtcclxuICAgICAgICBsb2dDbGllbnQud2FybihgQXV0aCAoJHtTREtfVkVSU0lPTn0pOiAke21zZ31gLCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBfbG9nRXJyb3IobXNnLCAuLi5hcmdzKSB7XHJcbiAgICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IExvZ0xldmVsLkVSUk9SKSB7XHJcbiAgICAgICAgbG9nQ2xpZW50LmVycm9yKGBBdXRoICgke1NES19WRVJTSU9OfSk6ICR7bXNnfWAsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIF9mYWlsKGF1dGhPckNvZGUsIC4uLnJlc3QpIHtcclxuICAgIHRocm93IGNyZWF0ZUVycm9ySW50ZXJuYWwoYXV0aE9yQ29kZSwgLi4ucmVzdCk7XHJcbn1cclxuZnVuY3Rpb24gX2NyZWF0ZUVycm9yKGF1dGhPckNvZGUsIC4uLnJlc3QpIHtcclxuICAgIHJldHVybiBjcmVhdGVFcnJvckludGVybmFsKGF1dGhPckNvZGUsIC4uLnJlc3QpO1xyXG59XHJcbmZ1bmN0aW9uIF9lcnJvcldpdGhDdXN0b21NZXNzYWdlKGF1dGgsIGNvZGUsIG1lc3NhZ2UpIHtcclxuICAgIGNvbnN0IGVycm9yTWFwID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9kRXJyb3JNYXAoKSksIHsgW2NvZGVdOiBtZXNzYWdlIH0pO1xyXG4gICAgY29uc3QgZmFjdG9yeSA9IG5ldyBFcnJvckZhY3RvcnkoJ2F1dGgnLCAnRmlyZWJhc2UnLCBlcnJvck1hcCk7XHJcbiAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGUoY29kZSwge1xyXG4gICAgICAgIGFwcE5hbWU6IGF1dGgubmFtZVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkge1xyXG4gICAgcmV0dXJuIF9lcnJvcldpdGhDdXN0b21NZXNzYWdlKGF1dGgsIFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiIC8qIEF1dGhFcnJvckNvZGUuT1BFUkFUSU9OX05PVF9TVVBQT1JURUQgKi8sICdPcGVyYXRpb25zIHRoYXQgYWx0ZXIgdGhlIGN1cnJlbnQgdXNlciBhcmUgbm90IHN1cHBvcnRlZCBpbiBjb25qdW5jdGlvbiB3aXRoIEZpcmViYXNlU2VydmVyQXBwJyk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRXJyb3JJbnRlcm5hbChhdXRoT3JDb2RlLCAuLi5yZXN0KSB7XHJcbiAgICBpZiAodHlwZW9mIGF1dGhPckNvZGUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY29uc3QgY29kZSA9IHJlc3RbMF07XHJcbiAgICAgICAgY29uc3QgZnVsbFBhcmFtcyA9IFsuLi5yZXN0LnNsaWNlKDEpXTtcclxuICAgICAgICBpZiAoZnVsbFBhcmFtc1swXSkge1xyXG4gICAgICAgICAgICBmdWxsUGFyYW1zWzBdLmFwcE5hbWUgPSBhdXRoT3JDb2RlLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhdXRoT3JDb2RlLl9lcnJvckZhY3RvcnkuY3JlYXRlKGNvZGUsIC4uLmZ1bGxQYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9ERUZBVUxUX0FVVEhfRVJST1JfRkFDVE9SWS5jcmVhdGUoYXV0aE9yQ29kZSwgLi4ucmVzdCk7XHJcbn1cclxuZnVuY3Rpb24gX2Fzc2VydChhc3NlcnRpb24sIGF1dGhPckNvZGUsIC4uLnJlc3QpIHtcclxuICAgIGlmICghYXNzZXJ0aW9uKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3JJbnRlcm5hbChhdXRoT3JDb2RlLCAuLi5yZXN0KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVW5jb25kaXRpb25hbGx5IGZhaWxzLCB0aHJvd2luZyBhbiBpbnRlcm5hbCBlcnJvciB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlLlxyXG4gKlxyXG4gKiBAcGFyYW0gZmFpbHVyZSB0eXBlIG9mIGZhaWx1cmUgZW5jb3VudGVyZWRcclxuICogQHRocm93cyBFcnJvclxyXG4gKi9cclxuZnVuY3Rpb24gZGVidWdGYWlsKGZhaWx1cmUpIHtcclxuICAgIC8vIExvZyB0aGUgZmFpbHVyZSBpbiBhZGRpdGlvbiB0byB0aHJvdyBhbiBleGNlcHRpb24sIGp1c3QgaW4gY2FzZSB0aGVcclxuICAgIC8vIGV4Y2VwdGlvbiBpcyBzd2FsbG93ZWQuXHJcbiAgICBjb25zdCBtZXNzYWdlID0gYElOVEVSTkFMIEFTU0VSVElPTiBGQUlMRUQ6IGAgKyBmYWlsdXJlO1xyXG4gICAgX2xvZ0Vycm9yKG1lc3NhZ2UpO1xyXG4gICAgLy8gTk9URTogV2UgZG9uJ3QgdXNlIEZpcmViYXNlRXJyb3IgaGVyZSBiZWNhdXNlIHRoZXNlIGFyZSBpbnRlcm5hbCBmYWlsdXJlc1xyXG4gICAgLy8gdGhhdCBjYW5ub3QgYmUgaGFuZGxlZCBieSB0aGUgdXNlci4gKEFsc28gaXQgd291bGQgY3JlYXRlIGEgY2lyY3VsYXJcclxuICAgIC8vIGRlcGVuZGVuY3kgYmV0d2VlbiB0aGUgZXJyb3IgYW5kIGFzc2VydCBtb2R1bGVzIHdoaWNoIGRvZXNuJ3Qgd29yay4pXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbn1cclxuLyoqXHJcbiAqIEZhaWxzIGlmIHRoZSBnaXZlbiBhc3NlcnRpb24gY29uZGl0aW9uIGlzIGZhbHNlLCB0aHJvd2luZyBhbiBFcnJvciB3aXRoIHRoZVxyXG4gKiBnaXZlbiBtZXNzYWdlIGlmIGl0IGRpZC5cclxuICpcclxuICogQHBhcmFtIGFzc2VydGlvblxyXG4gKiBAcGFyYW0gbWVzc2FnZVxyXG4gKi9cclxuZnVuY3Rpb24gZGVidWdBc3NlcnQoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoIWFzc2VydGlvbikge1xyXG4gICAgICAgIGRlYnVnRmFpbChtZXNzYWdlKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0Q3VycmVudFVybCgpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICgoX2EgPSBzZWxmLmxvY2F0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHJlZikpIHx8ICcnO1xyXG59XHJcbmZ1bmN0aW9uIF9pc0h0dHBPckh0dHBzKCkge1xyXG4gICAgcmV0dXJuIF9nZXRDdXJyZW50U2NoZW1lKCkgPT09ICdodHRwOicgfHwgX2dldEN1cnJlbnRTY2hlbWUoKSA9PT0gJ2h0dHBzOic7XHJcbn1cclxuZnVuY3Rpb24gX2dldEN1cnJlbnRTY2hlbWUoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAoKF9hID0gc2VsZi5sb2NhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb3RvY29sKSkgfHwgbnVsbDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgd29ya2luZyBvbmxpbmVcclxuICovXHJcbmZ1bmN0aW9uIF9pc09ubGluZSgpIHtcclxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIG5hdmlnYXRvciAmJlxyXG4gICAgICAgICdvbkxpbmUnIGluIG5hdmlnYXRvciAmJlxyXG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3Iub25MaW5lID09PSAnYm9vbGVhbicgJiZcclxuICAgICAgICAvLyBBcHBseSBvbmx5IGZvciB0cmFkaXRpb25hbCB3ZWIgYXBwcyBhbmQgQ2hyb21lIGV4dGVuc2lvbnMuXHJcbiAgICAgICAgLy8gVGhpcyBpcyBlc3BlY2lhbGx5IHRydWUgZm9yIENvcmRvdmEgYXBwcyB3aGljaCBoYXZlIHVucmVsaWFibGVcclxuICAgICAgICAvLyBuYXZpZ2F0b3Iub25MaW5lIGJlaGF2aW9yIHVubGVzcyBjb3Jkb3ZhLXBsdWdpbi1uZXR3b3JrLWluZm9ybWF0aW9uIGlzXHJcbiAgICAgICAgLy8gaW5zdGFsbGVkIHdoaWNoIG92ZXJ3cml0ZXMgdGhlIG5hdGl2ZSBuYXZpZ2F0b3Iub25MaW5lIHZhbHVlIGFuZFxyXG4gICAgICAgIC8vIGRlZmluZXMgbmF2aWdhdG9yLmNvbm5lY3Rpb24uXHJcbiAgICAgICAgKF9pc0h0dHBPckh0dHBzKCkgfHwgaXNCcm93c2VyRXh0ZW5zaW9uKCkgfHwgJ2Nvbm5lY3Rpb24nIGluIG5hdmlnYXRvcikpIHtcclxuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm9uTGluZTtcclxuICAgIH1cclxuICAgIC8vIElmIHdlIGNhbid0IGRldGVybWluZSB0aGUgc3RhdGUsIGFzc3VtZSBpdCBpcyBvbmxpbmUuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBfZ2V0VXNlckxhbmd1YWdlKCkge1xyXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuYXZpZ2F0b3JMYW5ndWFnZSA9IG5hdmlnYXRvcjtcclxuICAgIHJldHVybiAoXHJcbiAgICAvLyBNb3N0IHJlbGlhYmxlLCBidXQgb25seSBzdXBwb3J0ZWQgaW4gQ2hyb21lL0ZpcmVmb3guXHJcbiAgICAobmF2aWdhdG9yTGFuZ3VhZ2UubGFuZ3VhZ2VzICYmIG5hdmlnYXRvckxhbmd1YWdlLmxhbmd1YWdlc1swXSkgfHxcclxuICAgICAgICAvLyBTdXBwb3J0ZWQgaW4gbW9zdCBicm93c2VycywgYnV0IHJldHVybnMgdGhlIGxhbmd1YWdlIG9mIHRoZSBicm93c2VyXHJcbiAgICAgICAgLy8gVUksIG5vdCB0aGUgbGFuZ3VhZ2Ugc2V0IGluIGJyb3dzZXIgc2V0dGluZ3MuXHJcbiAgICAgICAgbmF2aWdhdG9yTGFuZ3VhZ2UubGFuZ3VhZ2UgfHxcclxuICAgICAgICAvLyBDb3VsZG4ndCBkZXRlcm1pbmUgbGFuZ3VhZ2UuXHJcbiAgICAgICAgbnVsbCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgc3RydWN0dXJlIHRvIGhlbHAgcGljayBiZXR3ZWVuIGEgcmFuZ2Ugb2YgbG9uZyBhbmQgc2hvcnQgZGVsYXkgZHVyYXRpb25zXHJcbiAqIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gSW4gZ2VuZXJhbCwgdGhlIGxvbmcgZGVsYXkgaXMgdXNlZCBmb3JcclxuICogbW9iaWxlIGVudmlyb25tZW50cyB3aGVyZWFzIHNob3J0IGRlbGF5cyBhcmUgdXNlZCBmb3IgZGVza3RvcCBlbnZpcm9ubWVudHMuXHJcbiAqL1xyXG5jbGFzcyBEZWxheSB7XHJcbiAgICBjb25zdHJ1Y3RvcihzaG9ydERlbGF5LCBsb25nRGVsYXkpIHtcclxuICAgICAgICB0aGlzLnNob3J0RGVsYXkgPSBzaG9ydERlbGF5O1xyXG4gICAgICAgIHRoaXMubG9uZ0RlbGF5ID0gbG9uZ0RlbGF5O1xyXG4gICAgICAgIC8vIEludGVybmFsIGVycm9yIHdoZW4gaW1wcm9wZXJseSBpbml0aWFsaXplZC5cclxuICAgICAgICBkZWJ1Z0Fzc2VydChsb25nRGVsYXkgPiBzaG9ydERlbGF5LCAnU2hvcnQgZGVsYXkgc2hvdWxkIGJlIGxlc3MgdGhhbiBsb25nIGRlbGF5IScpO1xyXG4gICAgICAgIHRoaXMuaXNNb2JpbGUgPSBpc01vYmlsZUNvcmRvdmEoKSB8fCBpc1JlYWN0TmF0aXZlKCk7XHJcbiAgICB9XHJcbiAgICBnZXQoKSB7XHJcbiAgICAgICAgaWYgKCFfaXNPbmxpbmUoKSkge1xyXG4gICAgICAgICAgICAvLyBQaWNrIHRoZSBzaG9ydGVyIHRpbWVvdXQuXHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbig1MDAwIC8qIERlbGF5TWluLk9GRkxJTkUgKi8sIHRoaXMuc2hvcnREZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZW52aXJvbm1lbnQsIHJldHVybiB0aGUgbG9uZyBkZWxheSwgb3RoZXJ3aXNlXHJcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBzaG9ydCBkZWxheS5cclxuICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGltcHJvdmVkIGluIHRoZSBmdXR1cmUgdG8gZHluYW1pY2FsbHkgY2hhbmdlIGJhc2VkIG9uIG90aGVyXHJcbiAgICAgICAgLy8gdmFyaWFibGVzIGluc3RlYWQgb2YganVzdCByZWFkaW5nIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxyXG4gICAgICAgIHJldHVybiB0aGlzLmlzTW9iaWxlID8gdGhpcy5sb25nRGVsYXkgOiB0aGlzLnNob3J0RGVsYXk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gX2VtdWxhdG9yVXJsKGNvbmZpZywgcGF0aCkge1xyXG4gICAgZGVidWdBc3NlcnQoY29uZmlnLmVtdWxhdG9yLCAnRW11bGF0b3Igc2hvdWxkIGFsd2F5cyBiZSBzZXQgaGVyZScpO1xyXG4gICAgY29uc3QgeyB1cmwgfSA9IGNvbmZpZy5lbXVsYXRvcjtcclxuICAgIGlmICghcGF0aCkge1xyXG4gICAgICAgIHJldHVybiB1cmw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYCR7dXJsfSR7cGF0aC5zdGFydHNXaXRoKCcvJykgPyBwYXRoLnNsaWNlKDEpIDogcGF0aH1gO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEZldGNoUHJvdmlkZXIge1xyXG4gICAgc3RhdGljIGluaXRpYWxpemUoZmV0Y2hJbXBsLCBoZWFkZXJzSW1wbCwgcmVzcG9uc2VJbXBsKSB7XHJcbiAgICAgICAgdGhpcy5mZXRjaEltcGwgPSBmZXRjaEltcGw7XHJcbiAgICAgICAgaWYgKGhlYWRlcnNJbXBsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc0ltcGwgPSBoZWFkZXJzSW1wbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlSW1wbCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlSW1wbCA9IHJlc3BvbnNlSW1wbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZmV0Y2goKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmV0Y2hJbXBsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoSW1wbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAnZmV0Y2gnIGluIHNlbGYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuZmV0Y2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5mZXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5mZXRjaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmZXRjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZldGNoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWJ1Z0ZhaWwoJ0NvdWxkIG5vdCBmaW5kIGZldGNoIGltcGxlbWVudGF0aW9uLCBtYWtlIHN1cmUgeW91IGNhbGwgRmV0Y2hQcm92aWRlci5pbml0aWFsaXplKCkgd2l0aCBhbiBhcHByb3ByaWF0ZSBwb2x5ZmlsbCcpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGhlYWRlcnMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyc0ltcGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc0ltcGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgJ0hlYWRlcnMnIGluIHNlbGYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuSGVhZGVycztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzLkhlYWRlcnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuSGVhZGVycztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBIZWFkZXJzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gSGVhZGVycztcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVidWdGYWlsKCdDb3VsZCBub3QgZmluZCBIZWFkZXJzIGltcGxlbWVudGF0aW9uLCBtYWtlIHN1cmUgeW91IGNhbGwgRmV0Y2hQcm92aWRlci5pbml0aWFsaXplKCkgd2l0aCBhbiBhcHByb3ByaWF0ZSBwb2x5ZmlsbCcpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHJlc3BvbnNlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNlSW1wbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZUltcGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgJ1Jlc3BvbnNlJyBpbiBzZWxmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLlJlc3BvbnNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMuUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuUmVzcG9uc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgUmVzcG9uc2UgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZXNwb25zZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVidWdGYWlsKCdDb3VsZCBub3QgZmluZCBSZXNwb25zZSBpbXBsZW1lbnRhdGlvbiwgbWFrZSBzdXJlIHlvdSBjYWxsIEZldGNoUHJvdmlkZXIuaW5pdGlhbGl6ZSgpIHdpdGggYW4gYXBwcm9wcmlhdGUgcG9seWZpbGwnKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogTWFwIGZyb20gZXJyb3JzIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIgdG8gZXJyb3JzIHRvIGRldmVsb3BlciB2aXNpYmxlIGVycm9yc1xyXG4gKi9cclxuY29uc3QgU0VSVkVSX0VSUk9SX01BUCA9IHtcclxuICAgIC8vIEN1c3RvbSB0b2tlbiBlcnJvcnMuXHJcbiAgICBbXCJDUkVERU5USUFMX01JU01BVENIXCIgLyogU2VydmVyRXJyb3IuQ1JFREVOVElBTF9NSVNNQVRDSCAqL106IFwiY3VzdG9tLXRva2VuLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX01JU01BVENIICovLFxyXG4gICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdGhlIFNESyBzZW5kcyBhIGJhZCByZXF1ZXN0LlxyXG4gICAgW1wiTUlTU0lOR19DVVNUT01fVE9LRU5cIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX0NVU1RPTV9UT0tFTiAqL106IFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLFxyXG4gICAgLy8gQ3JlYXRlIEF1dGggVVJJIGVycm9ycy5cclxuICAgIFtcIklOVkFMSURfSURFTlRJRklFUlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfSURFTlRJRklFUiAqL106IFwiaW52YWxpZC1lbWFpbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9FTUFJTCAqLyxcclxuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBTREsgc2VuZHMgYSBiYWQgcmVxdWVzdC5cclxuICAgIFtcIk1JU1NJTkdfQ09OVElOVUVfVVJJXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19DT05USU5VRV9VUkkgKi9dOiBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyxcclxuICAgIC8vIFNpZ24gaW4gd2l0aCBlbWFpbCBhbmQgcGFzc3dvcmQgZXJyb3JzIChzb21lIGFwcGx5IHRvIHNpZ24gdXAgdG9vKS5cclxuICAgIFtcIklOVkFMSURfUEFTU1dPUkRcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX1BBU1NXT1JEICovXTogXCJ3cm9uZy1wYXNzd29yZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9QQVNTV09SRCAqLyxcclxuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBTREsgc2VuZHMgYSBiYWQgcmVxdWVzdC5cclxuICAgIFtcIk1JU1NJTkdfUEFTU1dPUkRcIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX1BBU1NXT1JEICovXTogXCJtaXNzaW5nLXBhc3N3b3JkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1BBU1NXT1JEICovLFxyXG4gICAgLy8gVGhyb3duIGlmIEVtYWlsIEVudW1lcmF0aW9uIFByb3RlY3Rpb24gaXMgZW5hYmxlZCBpbiB0aGUgcHJvamVjdCBhbmQgdGhlIGVtYWlsIG9yIHBhc3N3b3JkIGlzXHJcbiAgICAvLyBpbnZhbGlkLlxyXG4gICAgW1wiSU5WQUxJRF9MT0dJTl9DUkVERU5USUFMU1wiIC8qIFNlcnZlckVycm9yLklOVkFMSURfTE9HSU5fQ1JFREVOVElBTFMgKi9dOiBcImludmFsaWQtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DUkVERU5USUFMICovLFxyXG4gICAgLy8gU2lnbiB1cCB3aXRoIGVtYWlsIGFuZCBwYXNzd29yZCBlcnJvcnMuXHJcbiAgICBbXCJFTUFJTF9FWElTVFNcIiAvKiBTZXJ2ZXJFcnJvci5FTUFJTF9FWElTVFMgKi9dOiBcImVtYWlsLWFscmVhZHktaW4tdXNlXCIgLyogQXV0aEVycm9yQ29kZS5FTUFJTF9FWElTVFMgKi8sXHJcbiAgICBbXCJQQVNTV09SRF9MT0dJTl9ESVNBQkxFRFwiIC8qIFNlcnZlckVycm9yLlBBU1NXT1JEX0xPR0lOX0RJU0FCTEVEICovXTogXCJvcGVyYXRpb24tbm90LWFsbG93ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk9QRVJBVElPTl9OT1RfQUxMT1dFRCAqLyxcclxuICAgIC8vIFZlcmlmeSBhc3NlcnRpb24gZm9yIHNpZ24gaW4gd2l0aCBjcmVkZW50aWFsIGVycm9yczpcclxuICAgIFtcIklOVkFMSURfSURQX1JFU1BPTlNFXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9JRFBfUkVTUE9OU0UgKi9dOiBcImludmFsaWQtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DUkVERU5USUFMICovLFxyXG4gICAgW1wiSU5WQUxJRF9QRU5ESU5HX1RPS0VOXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9QRU5ESU5HX1RPS0VOICovXTogXCJpbnZhbGlkLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ1JFREVOVElBTCAqLyxcclxuICAgIFtcIkZFREVSQVRFRF9VU0VSX0lEX0FMUkVBRFlfTElOS0VEXCIgLyogU2VydmVyRXJyb3IuRkVERVJBVEVEX1VTRVJfSURfQUxSRUFEWV9MSU5LRUQgKi9dOiBcImNyZWRlbnRpYWwtYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfQUxSRUFEWV9JTl9VU0UgKi8sXHJcbiAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgU0RLIHNlbmRzIGEgYmFkIHJlcXVlc3QuXHJcbiAgICBbXCJNSVNTSU5HX1JFUV9UWVBFXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19SRVFfVFlQRSAqL106IFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLFxyXG4gICAgLy8gU2VuZCBQYXNzd29yZCByZXNldCBlbWFpbCBlcnJvcnM6XHJcbiAgICBbXCJFTUFJTF9OT1RfRk9VTkRcIiAvKiBTZXJ2ZXJFcnJvci5FTUFJTF9OT1RfRk9VTkQgKi9dOiBcInVzZXItbm90LWZvdW5kXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RFTEVURUQgKi8sXHJcbiAgICBbXCJSRVNFVF9QQVNTV09SRF9FWENFRURfTElNSVRcIiAvKiBTZXJ2ZXJFcnJvci5SRVNFVF9QQVNTV09SRF9FWENFRURfTElNSVQgKi9dOiBcInRvby1tYW55LXJlcXVlc3RzXCIgLyogQXV0aEVycm9yQ29kZS5UT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVIgKi8sXHJcbiAgICBbXCJFWFBJUkVEX09PQl9DT0RFXCIgLyogU2VydmVyRXJyb3IuRVhQSVJFRF9PT0JfQ09ERSAqL106IFwiZXhwaXJlZC1hY3Rpb24tY29kZVwiIC8qIEF1dGhFcnJvckNvZGUuRVhQSVJFRF9PT0JfQ09ERSAqLyxcclxuICAgIFtcIklOVkFMSURfT09CX0NPREVcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX09PQl9DT0RFICovXTogXCJpbnZhbGlkLWFjdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX09PQl9DT0RFICovLFxyXG4gICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdGhlIFNESyBzZW5kcyBhIGJhZCByZXF1ZXN0LlxyXG4gICAgW1wiTUlTU0lOR19PT0JfQ09ERVwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfT09CX0NPREUgKi9dOiBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyxcclxuICAgIC8vIE9wZXJhdGlvbnMgdGhhdCByZXF1aXJlIElEIHRva2VuIGluIHJlcXVlc3Q6XHJcbiAgICBbXCJDUkVERU5USUFMX1RPT19PTERfTE9HSU5fQUdBSU5cIiAvKiBTZXJ2ZXJFcnJvci5DUkVERU5USUFMX1RPT19PTERfTE9HSU5fQUdBSU4gKi9dOiBcInJlcXVpcmVzLXJlY2VudC1sb2dpblwiIC8qIEF1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOICovLFxyXG4gICAgW1wiSU5WQUxJRF9JRF9UT0tFTlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfSURfVE9LRU4gKi9dOiBcImludmFsaWQtdXNlci10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRIICovLFxyXG4gICAgW1wiVE9LRU5fRVhQSVJFRFwiIC8qIFNlcnZlckVycm9yLlRPS0VOX0VYUElSRUQgKi9dOiBcInVzZXItdG9rZW4tZXhwaXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuVE9LRU5fRVhQSVJFRCAqLyxcclxuICAgIFtcIlVTRVJfTk9UX0ZPVU5EXCIgLyogU2VydmVyRXJyb3IuVVNFUl9OT1RfRk9VTkQgKi9dOiBcInVzZXItdG9rZW4tZXhwaXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuVE9LRU5fRVhQSVJFRCAqLyxcclxuICAgIC8vIE90aGVyIGVycm9ycy5cclxuICAgIFtcIlRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUlwiIC8qIFNlcnZlckVycm9yLlRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUiAqL106IFwidG9vLW1hbnktcmVxdWVzdHNcIiAvKiBBdXRoRXJyb3JDb2RlLlRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUiAqLyxcclxuICAgIFtcIlBBU1NXT1JEX0RPRVNfTk9UX01FRVRfUkVRVUlSRU1FTlRTXCIgLyogU2VydmVyRXJyb3IuUEFTU1dPUkRfRE9FU19OT1RfTUVFVF9SRVFVSVJFTUVOVFMgKi9dOiBcInBhc3N3b3JkLWRvZXMtbm90LW1lZXQtcmVxdWlyZW1lbnRzXCIgLyogQXV0aEVycm9yQ29kZS5QQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UUyAqLyxcclxuICAgIC8vIFBob25lIEF1dGggcmVsYXRlZCBlcnJvcnMuXHJcbiAgICBbXCJJTlZBTElEX0NPREVcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX0NPREUgKi9dOiBcImludmFsaWQtdmVyaWZpY2F0aW9uLWNvZGVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ09ERSAqLyxcclxuICAgIFtcIklOVkFMSURfU0VTU0lPTl9JTkZPXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9TRVNTSU9OX0lORk8gKi9dOiBcImludmFsaWQtdmVyaWZpY2F0aW9uLWlkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1NFU1NJT05fSU5GTyAqLyxcclxuICAgIFtcIklOVkFMSURfVEVNUE9SQVJZX1BST09GXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9URU1QT1JBUllfUFJPT0YgKi9dOiBcImludmFsaWQtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DUkVERU5USUFMICovLFxyXG4gICAgW1wiTUlTU0lOR19TRVNTSU9OX0lORk9cIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX1NFU1NJT05fSU5GTyAqL106IFwibWlzc2luZy12ZXJpZmljYXRpb24taWRcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfU0VTU0lPTl9JTkZPICovLFxyXG4gICAgW1wiU0VTU0lPTl9FWFBJUkVEXCIgLyogU2VydmVyRXJyb3IuU0VTU0lPTl9FWFBJUkVEICovXTogXCJjb2RlLWV4cGlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkNPREVfRVhQSVJFRCAqLyxcclxuICAgIC8vIE90aGVyIGFjdGlvbiBjb2RlIGVycm9ycyB3aGVuIGFkZGl0aW9uYWwgc2V0dGluZ3MgcGFzc2VkLlxyXG4gICAgLy8gTUlTU0lOR19DT05USU5VRV9VUkkgaXMgZ2V0dGluZyBtYXBwZWQgdG8gSU5URVJOQUxfRVJST1IgYWJvdmUuXHJcbiAgICAvLyBUaGlzIGlzIE9LIGFzIHRoaXMgZXJyb3Igd2lsbCBiZSBjYXVnaHQgYnkgY2xpZW50IHNpZGUgdmFsaWRhdGlvbi5cclxuICAgIFtcIk1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUVcIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FICovXTogXCJtaXNzaW5nLWFuZHJvaWQtcGtnLW5hbWVcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUUgKi8sXHJcbiAgICBbXCJVTkFVVEhPUklaRURfRE9NQUlOXCIgLyogU2VydmVyRXJyb3IuVU5BVVRIT1JJWkVEX0RPTUFJTiAqL106IFwidW5hdXRob3JpemVkLWNvbnRpbnVlLXVyaVwiIC8qIEF1dGhFcnJvckNvZGUuVU5BVVRIT1JJWkVEX0RPTUFJTiAqLyxcclxuICAgIC8vIGdldFByb2plY3RDb25maWcgZXJyb3JzIHdoZW4gY2xpZW50SWQgaXMgcGFzc2VkLlxyXG4gICAgW1wiSU5WQUxJRF9PQVVUSF9DTElFTlRfSURcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX09BVVRIX0NMSUVOVF9JRCAqL106IFwiaW52YWxpZC1vYXV0aC1jbGllbnQtaWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfT0FVVEhfQ0xJRU5UX0lEICovLFxyXG4gICAgLy8gVXNlciBhY3Rpb25zIChzaWduLXVwIG9yIGRlbGV0aW9uKSBkaXNhYmxlZCBlcnJvcnMuXHJcbiAgICBbXCJBRE1JTl9PTkxZX09QRVJBVElPTlwiIC8qIFNlcnZlckVycm9yLkFETUlOX09OTFlfT1BFUkFUSU9OICovXTogXCJhZG1pbi1yZXN0cmljdGVkLW9wZXJhdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuQURNSU5fT05MWV9PUEVSQVRJT04gKi8sXHJcbiAgICAvLyBNdWx0aSBmYWN0b3IgcmVsYXRlZCBlcnJvcnMuXHJcbiAgICBbXCJJTlZBTElEX01GQV9QRU5ESU5HX0NSRURFTlRJQUxcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX01GQV9QRU5ESU5HX0NSRURFTlRJQUwgKi9dOiBcImludmFsaWQtbXVsdGktZmFjdG9yLXNlc3Npb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfTUZBX1NFU1NJT04gKi8sXHJcbiAgICBbXCJNRkFfRU5ST0xMTUVOVF9OT1RfRk9VTkRcIiAvKiBTZXJ2ZXJFcnJvci5NRkFfRU5ST0xMTUVOVF9OT1RfRk9VTkQgKi9dOiBcIm11bHRpLWZhY3Rvci1pbmZvLW5vdC1mb3VuZFwiIC8qIEF1dGhFcnJvckNvZGUuTUZBX0lORk9fTk9UX0ZPVU5EICovLFxyXG4gICAgW1wiTUlTU0lOR19NRkFfRU5ST0xMTUVOVF9JRFwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfTUZBX0VOUk9MTE1FTlRfSUQgKi9dOiBcIm1pc3NpbmctbXVsdGktZmFjdG9yLWluZm9cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfTUZBX0lORk8gKi8sXHJcbiAgICBbXCJNSVNTSU5HX01GQV9QRU5ESU5HX0NSRURFTlRJQUxcIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX01GQV9QRU5ESU5HX0NSRURFTlRJQUwgKi9dOiBcIm1pc3NpbmctbXVsdGktZmFjdG9yLXNlc3Npb25cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfTUZBX1NFU1NJT04gKi8sXHJcbiAgICBbXCJTRUNPTkRfRkFDVE9SX0VYSVNUU1wiIC8qIFNlcnZlckVycm9yLlNFQ09ORF9GQUNUT1JfRVhJU1RTICovXTogXCJzZWNvbmQtZmFjdG9yLWFscmVhZHktaW4tdXNlXCIgLyogQXV0aEVycm9yQ29kZS5TRUNPTkRfRkFDVE9SX0FMUkVBRFlfRU5ST0xMRUQgKi8sXHJcbiAgICBbXCJTRUNPTkRfRkFDVE9SX0xJTUlUX0VYQ0VFREVEXCIgLyogU2VydmVyRXJyb3IuU0VDT05EX0ZBQ1RPUl9MSU1JVF9FWENFRURFRCAqL106IFwibWF4aW11bS1zZWNvbmQtZmFjdG9yLWNvdW50LWV4Y2VlZGVkXCIgLyogQXV0aEVycm9yQ29kZS5TRUNPTkRfRkFDVE9SX0xJTUlUX0VYQ0VFREVEICovLFxyXG4gICAgLy8gQmxvY2tpbmcgZnVuY3Rpb25zIHJlbGF0ZWQgZXJyb3JzLlxyXG4gICAgW1wiQkxPQ0tJTkdfRlVOQ1RJT05fRVJST1JfUkVTUE9OU0VcIiAvKiBTZXJ2ZXJFcnJvci5CTE9DS0lOR19GVU5DVElPTl9FUlJPUl9SRVNQT05TRSAqL106IFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLFxyXG4gICAgLy8gUmVjYXB0Y2hhIHJlbGF0ZWQgZXJyb3JzLlxyXG4gICAgW1wiUkVDQVBUQ0hBX05PVF9FTkFCTEVEXCIgLyogU2VydmVyRXJyb3IuUkVDQVBUQ0hBX05PVF9FTkFCTEVEICovXTogXCJyZWNhcHRjaGEtbm90LWVuYWJsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlJFQ0FQVENIQV9OT1RfRU5BQkxFRCAqLyxcclxuICAgIFtcIk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19SRUNBUFRDSEFfVE9LRU4gKi9dOiBcIm1pc3NpbmctcmVjYXB0Y2hhLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1JFQ0FQVENIQV9UT0tFTiAqLyxcclxuICAgIFtcIklOVkFMSURfUkVDQVBUQ0hBX1RPS0VOXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9SRUNBUFRDSEFfVE9LRU4gKi9dOiBcImludmFsaWQtcmVjYXB0Y2hhLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0FQVENIQV9UT0tFTiAqLyxcclxuICAgIFtcIklOVkFMSURfUkVDQVBUQ0hBX0FDVElPTlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfUkVDQVBUQ0hBX0FDVElPTiAqL106IFwiaW52YWxpZC1yZWNhcHRjaGEtYWN0aW9uXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0FQVENIQV9BQ1RJT04gKi8sXHJcbiAgICBbXCJNSVNTSU5HX0NMSUVOVF9UWVBFXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19DTElFTlRfVFlQRSAqL106IFwibWlzc2luZy1jbGllbnQtdHlwZVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19DTElFTlRfVFlQRSAqLyxcclxuICAgIFtcIk1JU1NJTkdfUkVDQVBUQ0hBX1ZFUlNJT05cIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX1JFQ0FQVENIQV9WRVJTSU9OICovXTogXCJtaXNzaW5nLXJlY2FwdGNoYS12ZXJzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1JFQ0FQVENIQV9WRVJTSU9OICovLFxyXG4gICAgW1wiSU5WQUxJRF9SRUNBUFRDSEFfVkVSU0lPTlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT04gKi9dOiBcImludmFsaWQtcmVjYXB0Y2hhLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT04gKi8sXHJcbiAgICBbXCJJTlZBTElEX1JFUV9UWVBFXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9SRVFfVFlQRSAqL106IFwiaW52YWxpZC1yZXEtdHlwZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRVFfVFlQRSAqL1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0FQSV9USU1FT1VUX01TID0gbmV3IERlbGF5KDMwMDAwLCA2MDAwMCk7XHJcbmZ1bmN0aW9uIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICBpZiAoYXV0aC50ZW5hbnRJZCAmJiAhcmVxdWVzdC50ZW5hbnRJZCkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpLCB7IHRlbmFudElkOiBhdXRoLnRlbmFudElkIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcXVlc3Q7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIG1ldGhvZCwgcGF0aCwgcmVxdWVzdCwgY3VzdG9tRXJyb3JNYXAgPSB7fSkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtRmV0Y2hXaXRoRXJyb3JIYW5kbGluZyhhdXRoLCBjdXN0b21FcnJvck1hcCwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGxldCBib2R5ID0ge307XHJcbiAgICAgICAgbGV0IHBhcmFtcyA9IHt9O1xyXG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiR0VUXCIgLyogSHR0cE1ldGhvZC5HRVQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHJlcXVlc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBib2R5ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gcXVlcnlzdHJpbmcoT2JqZWN0LmFzc2lnbih7IGtleTogYXV0aC5jb25maWcuYXBpS2V5IH0sIHBhcmFtcykpLnNsaWNlKDEpO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCBhdXRoLl9nZXRBZGRpdGlvbmFsSGVhZGVycygpO1xyXG4gICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIiAvKiBIdHRwSGVhZGVyLkNPTlRFTlRfVFlQRSAqL10gPSAnYXBwbGljYXRpb24vanNvbic7XHJcbiAgICAgICAgaWYgKGF1dGgubGFuZ3VhZ2VDb2RlKSB7XHJcbiAgICAgICAgICAgIGhlYWRlcnNbXCJYLUZpcmViYXNlLUxvY2FsZVwiIC8qIEh0dHBIZWFkZXIuWF9GSVJFQkFTRV9MT0NBTEUgKi9dID0gYXV0aC5sYW5ndWFnZUNvZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBGZXRjaFByb3ZpZGVyLmZldGNoKCkoX2dldEZpbmFsVGFyZ2V0KGF1dGgsIGF1dGguY29uZmlnLmFwaUhvc3QsIHBhdGgsIHF1ZXJ5KSwgT2JqZWN0LmFzc2lnbih7IG1ldGhvZCxcclxuICAgICAgICAgICAgaGVhZGVycywgcmVmZXJyZXJQb2xpY3k6ICduby1yZWZlcnJlcicgfSwgYm9keSkpO1xyXG4gICAgfSk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gX3BlcmZvcm1GZXRjaFdpdGhFcnJvckhhbmRsaW5nKGF1dGgsIGN1c3RvbUVycm9yTWFwLCBmZXRjaEZuKSB7XHJcbiAgICBhdXRoLl9jYW5Jbml0RW11bGF0b3IgPSBmYWxzZTtcclxuICAgIGNvbnN0IGVycm9yTWFwID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBTRVJWRVJfRVJST1JfTUFQKSwgY3VzdG9tRXJyb3JNYXApO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBuZXR3b3JrVGltZW91dCA9IG5ldyBOZXR3b3JrVGltZW91dChhdXRoKTtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFByb21pc2UucmFjZShbXHJcbiAgICAgICAgICAgIGZldGNoRm4oKSxcclxuICAgICAgICAgICAgbmV0d29ya1RpbWVvdXQucHJvbWlzZVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgdGhpcyBwb2ludCwgdGhlIGZldGNoIHN1Y2NlZWRlZCBhbmQgdGhlIG5ldHdvcmtUaW1lb3V0XHJcbiAgICAgICAgLy8gZGlkbid0IHRocm93OyBjbGVhciB0aGUgbmV0d29yayB0aW1lb3V0IGRlbGF5IHNvIHRoYXQgTm9kZSB3b24ndCBoYW5nXHJcbiAgICAgICAgbmV0d29ya1RpbWVvdXQuY2xlYXJOZXR3b3JrVGltZW91dCgpO1xyXG4gICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgaWYgKCduZWVkQ29uZmlybWF0aW9uJyBpbiBqc29uKSB7XHJcbiAgICAgICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgXCJhY2NvdW50LWV4aXN0cy13aXRoLWRpZmZlcmVudC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5ORUVEX0NPTkZJUk1BVElPTiAqLywganNvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXNwb25zZS5vayAmJiAhKCdlcnJvck1lc3NhZ2UnIGluIGpzb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqc29uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gcmVzcG9uc2Uub2sgPyBqc29uLmVycm9yTWVzc2FnZSA6IGpzb24uZXJyb3IubWVzc2FnZTtcclxuICAgICAgICAgICAgY29uc3QgW3NlcnZlckVycm9yQ29kZSwgc2VydmVyRXJyb3JNZXNzYWdlXSA9IGVycm9yTWVzc2FnZS5zcGxpdCgnIDogJyk7XHJcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJFcnJvckNvZGUgPT09IFwiRkVERVJBVEVEX1VTRVJfSURfQUxSRUFEWV9MSU5LRURcIiAvKiBTZXJ2ZXJFcnJvci5GRURFUkFURURfVVNFUl9JRF9BTFJFQURZX0xJTktFRCAqLykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgX21ha2VUYWdnZWRFcnJvcihhdXRoLCBcImNyZWRlbnRpYWwtYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfQUxSRUFEWV9JTl9VU0UgKi8sIGpzb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNlcnZlckVycm9yQ29kZSA9PT0gXCJFTUFJTF9FWElTVFNcIiAvKiBTZXJ2ZXJFcnJvci5FTUFJTF9FWElTVFMgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgXCJlbWFpbC1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuRU1BSUxfRVhJU1RTICovLCBqc29uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXJ2ZXJFcnJvckNvZGUgPT09IFwiVVNFUl9ESVNBQkxFRFwiIC8qIFNlcnZlckVycm9yLlVTRVJfRElTQUJMRUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgXCJ1c2VyLWRpc2FibGVkXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RJU0FCTEVEICovLCBqc29uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBhdXRoRXJyb3IgPSBlcnJvck1hcFtzZXJ2ZXJFcnJvckNvZGVdIHx8XHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJFcnJvckNvZGVcclxuICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bX1xcc10rL2csICctJyk7XHJcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJFcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IF9lcnJvcldpdGhDdXN0b21NZXNzYWdlKGF1dGgsIGF1dGhFcnJvciwgc2VydmVyRXJyb3JNZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9mYWlsKGF1dGgsIGF1dGhFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGFuZ2luZyB0aGlzIHRvIGEgZGlmZmVyZW50IGVycm9yIGNvZGUgd2lsbCBsb2cgdXNlciBvdXQgd2hlbiB0aGVyZSBpcyBhIG5ldHdvcmsgZXJyb3JcclxuICAgICAgICAvLyBiZWNhdXNlIHdlIHRyZWF0IGFueSBlcnJvciBvdGhlciB0aGFuIE5FVFdPUktfUkVRVUVTVF9GQUlMRUQgYXMgdG9rZW4gaXMgaW52YWxpZC5cclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmlyZWJhc2UvZmlyZWJhc2UtanMtc2RrL2Jsb2IvNGZiYzczNjEwZDcwYmU0ZTA4NTJlN2RlNjNhMzljYjc4OTdlODU0Ni9wYWNrYWdlcy9hdXRoL3NyYy9jb3JlL2F1dGgvYXV0aF9pbXBsLnRzI0wzMDktTDMxNlxyXG4gICAgICAgIF9mYWlsKGF1dGgsIFwibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRCAqLywgeyAnbWVzc2FnZSc6IFN0cmluZyhlKSB9KTtcclxuICAgIH1cclxufVxyXG5hc3luYyBmdW5jdGlvbiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgbWV0aG9kLCBwYXRoLCByZXF1ZXN0LCBjdXN0b21FcnJvck1hcCA9IHt9KSB7XHJcbiAgICBjb25zdCBzZXJ2ZXJSZXNwb25zZSA9IChhd2FpdCBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgbWV0aG9kLCBwYXRoLCByZXF1ZXN0LCBjdXN0b21FcnJvck1hcCkpO1xyXG4gICAgaWYgKCdtZmFQZW5kaW5nQ3JlZGVudGlhbCcgaW4gc2VydmVyUmVzcG9uc2UpIHtcclxuICAgICAgICBfZmFpbChhdXRoLCBcIm11bHRpLWZhY3Rvci1hdXRoLXJlcXVpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5NRkFfUkVRVUlSRUQgKi8sIHtcclxuICAgICAgICAgICAgX3NlcnZlclJlc3BvbnNlOiBzZXJ2ZXJSZXNwb25zZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlcnZlclJlc3BvbnNlO1xyXG59XHJcbmZ1bmN0aW9uIF9nZXRGaW5hbFRhcmdldChhdXRoLCBob3N0LCBwYXRoLCBxdWVyeSkge1xyXG4gICAgY29uc3QgYmFzZSA9IGAke2hvc3R9JHtwYXRofT8ke3F1ZXJ5fWA7XHJcbiAgICBpZiAoIWF1dGguY29uZmlnLmVtdWxhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke2F1dGguY29uZmlnLmFwaVNjaGVtZX06Ly8ke2Jhc2V9YDtcclxuICAgIH1cclxuICAgIHJldHVybiBfZW11bGF0b3JVcmwoYXV0aC5jb25maWcsIGJhc2UpO1xyXG59XHJcbmZ1bmN0aW9uIF9wYXJzZUVuZm9yY2VtZW50U3RhdGUoZW5mb3JjZW1lbnRTdGF0ZVN0cikge1xyXG4gICAgc3dpdGNoIChlbmZvcmNlbWVudFN0YXRlU3RyKSB7XHJcbiAgICAgICAgY2FzZSAnRU5GT1JDRSc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIkVORk9SQ0VcIiAvKiBFbmZvcmNlbWVudFN0YXRlLkVORk9SQ0UgKi87XHJcbiAgICAgICAgY2FzZSAnQVVESVQnOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJBVURJVFwiIC8qIEVuZm9yY2VtZW50U3RhdGUuQVVESVQgKi87XHJcbiAgICAgICAgY2FzZSAnT0ZGJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiT0ZGXCIgLyogRW5mb3JjZW1lbnRTdGF0ZS5PRkYgKi87XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIFwiRU5GT1JDRU1FTlRfU1RBVEVfVU5TUEVDSUZJRURcIiAvKiBFbmZvcmNlbWVudFN0YXRlLkVORk9SQ0VNRU5UX1NUQVRFX1VOU1BFQ0lGSUVEICovO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIE5ldHdvcmtUaW1lb3V0IHtcclxuICAgIGNvbnN0cnVjdG9yKGF1dGgpIHtcclxuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xyXG4gICAgICAgIC8vIE5vZGUgdGltZXJzIGFuZCBicm93c2VyIHRpbWVycyBhcmUgZnVuZGFtZW50YWxseSBpbmNvbXBhdGlibGUsIGJ1dCB3ZVxyXG4gICAgICAgIC8vIGRvbid0IGNhcmUgYWJvdXQgdGhlIHZhbHVlIGhlcmVcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChfY3JlYXRlRXJyb3IodGhpcy5hdXRoLCBcIm5ldHdvcmstcmVxdWVzdC1mYWlsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk5FVFdPUktfUkVRVUVTVF9GQUlMRUQgKi8pKTtcclxuICAgICAgICAgICAgfSwgREVGQVVMVF9BUElfVElNRU9VVF9NUy5nZXQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjbGVhck5ldHdvcmtUaW1lb3V0KCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBfbWFrZVRhZ2dlZEVycm9yKGF1dGgsIGNvZGUsIHJlc3BvbnNlKSB7XHJcbiAgICBjb25zdCBlcnJvclBhcmFtcyA9IHtcclxuICAgICAgICBhcHBOYW1lOiBhdXRoLm5hbWVcclxuICAgIH07XHJcbiAgICBpZiAocmVzcG9uc2UuZW1haWwpIHtcclxuICAgICAgICBlcnJvclBhcmFtcy5lbWFpbCA9IHJlc3BvbnNlLmVtYWlsO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlc3BvbnNlLnBob25lTnVtYmVyKSB7XHJcbiAgICAgICAgZXJyb3JQYXJhbXMucGhvbmVOdW1iZXIgPSByZXNwb25zZS5waG9uZU51bWJlcjtcclxuICAgIH1cclxuICAgIGNvbnN0IGVycm9yID0gX2NyZWF0ZUVycm9yKGF1dGgsIGNvZGUsIGVycm9yUGFyYW1zKTtcclxuICAgIC8vIFdlIGtub3cgY3VzdG9tRGF0YSBpcyBkZWZpbmVkIG9uIGVycm9yIGJlY2F1c2UgZXJyb3JQYXJhbXMgaXMgZGVmaW5lZFxyXG4gICAgZXJyb3IuY3VzdG9tRGF0YS5fdG9rZW5SZXNwb25zZSA9IHJlc3BvbnNlO1xyXG4gICAgcmV0dXJuIGVycm9yO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZShncmVjYXB0Y2hhKSB7XHJcbiAgICByZXR1cm4gKGdyZWNhcHRjaGEgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgIGdyZWNhcHRjaGEuZW50ZXJwcmlzZSAhPT0gdW5kZWZpbmVkKTtcclxufVxyXG5jbGFzcyBSZWNhcHRjaGFDb25maWcge1xyXG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcmVDQVBUQ0hBIHNpdGUga2V5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2l0ZUtleSA9ICcnO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsaXN0IG9mIHByb3ZpZGVycyBhbmQgdGhlaXIgZW5hYmxlbWVudCBzdGF0dXMgZm9yIHJlQ0FQVENIQSBFbnRlcnByaXNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZSA9IFtdO1xyXG4gICAgICAgIGlmIChyZXNwb25zZS5yZWNhcHRjaGFLZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY2FwdGNoYUtleSB1bmRlZmluZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRXhhbXBsZSByZXNwb25zZS5yZWNhcHRjaGFLZXk6IFwicHJvamVjdHMvcHJvajEyMy9rZXlzL3NpdGVrZXkxMjNcIlxyXG4gICAgICAgIHRoaXMuc2l0ZUtleSA9IHJlc3BvbnNlLnJlY2FwdGNoYUtleS5zcGxpdCgnLycpWzNdO1xyXG4gICAgICAgIHRoaXMucmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZSA9IHJlc3BvbnNlLnJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlQ0FQVENIQSBFbnRlcnByaXNlIGVuZm9yY2VtZW50IHN0YXRlIGZvciB0aGUgZ2l2ZW4gcHJvdmlkZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByb3ZpZGVyU3RyIC0gVGhlIHByb3ZpZGVyIHdob3NlIGVuZm9yY2VtZW50IHN0YXRlIGlzIHRvIGJlIHJldHVybmVkLlxyXG4gICAgICogQHJldHVybnMgVGhlIHJlQ0FQVENIQSBFbnRlcnByaXNlIGVuZm9yY2VtZW50IHN0YXRlIGZvciB0aGUgZ2l2ZW4gcHJvdmlkZXIuXHJcbiAgICAgKi9cclxuICAgIGdldFByb3ZpZGVyRW5mb3JjZW1lbnRTdGF0ZShwcm92aWRlclN0cikge1xyXG4gICAgICAgIGlmICghdGhpcy5yZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlIHx8XHJcbiAgICAgICAgICAgIHRoaXMucmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgcmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZSBvZiB0aGlzLnJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUucHJvdmlkZXIgJiZcclxuICAgICAgICAgICAgICAgIHJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUucHJvdmlkZXIgPT09IHByb3ZpZGVyU3RyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BhcnNlRW5mb3JjZW1lbnRTdGF0ZShyZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlLmVuZm9yY2VtZW50U3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlQ0FQVENIQSBFbnRlcnByaXNlIGVuZm9yY2VtZW50IHN0YXRlIGZvciB0aGUgcHJvdmlkZXIgaXMgc2V0IHRvIEVORk9SQ0Ugb3IgQVVESVQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByb3ZpZGVyU3RyIC0gVGhlIHByb3ZpZGVyIHdob3NlIGVuYWJsZW1lbnQgc3RhdGUgaXMgdG8gYmUgcmV0dXJuZWQuXHJcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIG9yIG5vdCByZUNBUFRDSEEgRW50ZXJwcmlzZSBwcm90ZWN0aW9uIGlzIGVuYWJsZWQgZm9yIHRoZSBnaXZlbiBwcm92aWRlci5cclxuICAgICAqL1xyXG4gICAgaXNQcm92aWRlckVuYWJsZWQocHJvdmlkZXJTdHIpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0UHJvdmlkZXJFbmZvcmNlbWVudFN0YXRlKHByb3ZpZGVyU3RyKSA9PT1cclxuICAgICAgICAgICAgXCJFTkZPUkNFXCIgLyogRW5mb3JjZW1lbnRTdGF0ZS5FTkZPUkNFICovIHx8XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0UHJvdmlkZXJFbmZvcmNlbWVudFN0YXRlKHByb3ZpZGVyU3RyKSA9PT0gXCJBVURJVFwiIC8qIEVuZm9yY2VtZW50U3RhdGUuQVVESVQgKi8pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldFJlY2FwdGNoYUNvbmZpZyhhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiR0VUXCIgLyogSHR0cE1ldGhvZC5HRVQgKi8sIFwiL3YyL3JlY2FwdGNoYUNvbmZpZ1wiIC8qIEVuZHBvaW50LkdFVF9SRUNBUFRDSEFfQ09ORklHICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUFjY291bnQoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOmRlbGV0ZVwiIC8qIEVuZHBvaW50LkRFTEVURV9BQ0NPVU5UICovLCByZXF1ZXN0KTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBkZWxldGVMaW5rZWRBY2NvdW50cyhhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6dXBkYXRlXCIgLyogRW5kcG9pbnQuU0VUX0FDQ09VTlRfSU5GTyAqLywgcmVxdWVzdCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZ2V0QWNjb3VudEluZm8oYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOmxvb2t1cFwiIC8qIEVuZHBvaW50LkdFVF9BQ0NPVU5UX0lORk8gKi8sIHJlcXVlc3QpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIHV0Y1RpbWVzdGFtcFRvRGF0ZVN0cmluZyh1dGNUaW1lc3RhbXApIHtcclxuICAgIGlmICghdXRjVGltZXN0YW1wKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gQ29udmVydCB0byBkYXRlIG9iamVjdC5cclxuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoTnVtYmVyKHV0Y1RpbWVzdGFtcCkpO1xyXG4gICAgICAgIC8vIFRlc3QgZGF0ZSBpcyB2YWxpZC5cclxuICAgICAgICBpZiAoIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIFVUQyBkYXRlIHN0cmluZy5cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGUudG9VVENTdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcuIHVuZGVmaW5lZCB3aWxsIGJlIHJldHVybmVkLlxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyBhIEpTT04gV2ViIFRva2VuIChKV1QpIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHVzZXIgdG8gYSBGaXJlYmFzZSBzZXJ2aWNlLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRva2VuIGlmIGl0IGhhcyBub3QgZXhwaXJlZCBvciBpZiBpdCB3aWxsIG5vdCBleHBpcmUgaW4gdGhlIG5leHQgZml2ZVxyXG4gKiBtaW51dGVzLiBPdGhlcndpc2UsIHRoaXMgd2lsbCByZWZyZXNoIHRoZSB0b2tlbiBhbmQgcmV0dXJuIGEgbmV3IG9uZS5cclxuICpcclxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cclxuICogQHBhcmFtIGZvcmNlUmVmcmVzaCAtIEZvcmNlIHJlZnJlc2ggcmVnYXJkbGVzcyBvZiB0b2tlbiBleHBpcmF0aW9uLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRJZFRva2VuKHVzZXIsIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpLmdldElkVG9rZW4oZm9yY2VSZWZyZXNoKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIGRlc2VyaWFsaXplZCBKU09OIFdlYiBUb2tlbiAoSldUKSB1c2VkIHRvIGlkZW50aWZ5IHRoZSB1c2VyIHRvIGEgRmlyZWJhc2Ugc2VydmljZS5cclxuICpcclxuICogQHJlbWFya3NcclxuICogUmV0dXJucyB0aGUgY3VycmVudCB0b2tlbiBpZiBpdCBoYXMgbm90IGV4cGlyZWQgb3IgaWYgaXQgd2lsbCBub3QgZXhwaXJlIGluIHRoZSBuZXh0IGZpdmVcclxuICogbWludXRlcy4gT3RoZXJ3aXNlLCB0aGlzIHdpbGwgcmVmcmVzaCB0aGUgdG9rZW4gYW5kIHJldHVybiBhIG5ldyBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXHJcbiAqIEBwYXJhbSBmb3JjZVJlZnJlc2ggLSBGb3JjZSByZWZyZXNoIHJlZ2FyZGxlc3Mgb2YgdG9rZW4gZXhwaXJhdGlvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2V0SWRUb2tlblJlc3VsdCh1c2VyLCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xyXG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xyXG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCB1c2VySW50ZXJuYWwuZ2V0SWRUb2tlbihmb3JjZVJlZnJlc2gpO1xyXG4gICAgY29uc3QgY2xhaW1zID0gX3BhcnNlVG9rZW4odG9rZW4pO1xyXG4gICAgX2Fzc2VydChjbGFpbXMgJiYgY2xhaW1zLmV4cCAmJiBjbGFpbXMuYXV0aF90aW1lICYmIGNsYWltcy5pYXQsIHVzZXJJbnRlcm5hbC5hdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICBjb25zdCBmaXJlYmFzZSA9IHR5cGVvZiBjbGFpbXMuZmlyZWJhc2UgPT09ICdvYmplY3QnID8gY2xhaW1zLmZpcmViYXNlIDogdW5kZWZpbmVkO1xyXG4gICAgY29uc3Qgc2lnbkluUHJvdmlkZXIgPSBmaXJlYmFzZSA9PT0gbnVsbCB8fCBmaXJlYmFzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlyZWJhc2VbJ3NpZ25faW5fcHJvdmlkZXInXTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2xhaW1zLFxyXG4gICAgICAgIHRva2VuLFxyXG4gICAgICAgIGF1dGhUaW1lOiB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcoc2Vjb25kc1N0cmluZ1RvTWlsbGlzZWNvbmRzKGNsYWltcy5hdXRoX3RpbWUpKSxcclxuICAgICAgICBpc3N1ZWRBdFRpbWU6IHV0Y1RpbWVzdGFtcFRvRGF0ZVN0cmluZyhzZWNvbmRzU3RyaW5nVG9NaWxsaXNlY29uZHMoY2xhaW1zLmlhdCkpLFxyXG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcoc2Vjb25kc1N0cmluZ1RvTWlsbGlzZWNvbmRzKGNsYWltcy5leHApKSxcclxuICAgICAgICBzaWduSW5Qcm92aWRlcjogc2lnbkluUHJvdmlkZXIgfHwgbnVsbCxcclxuICAgICAgICBzaWduSW5TZWNvbmRGYWN0b3I6IChmaXJlYmFzZSA9PT0gbnVsbCB8fCBmaXJlYmFzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlyZWJhc2VbJ3NpZ25faW5fc2Vjb25kX2ZhY3RvciddKSB8fCBudWxsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHNlY29uZHNTdHJpbmdUb01pbGxpc2Vjb25kcyhzZWNvbmRzKSB7XHJcbiAgICByZXR1cm4gTnVtYmVyKHNlY29uZHMpICogMTAwMDtcclxufVxyXG5mdW5jdGlvbiBfcGFyc2VUb2tlbih0b2tlbikge1xyXG4gICAgY29uc3QgW2FsZ29yaXRobSwgcGF5bG9hZCwgc2lnbmF0dXJlXSA9IHRva2VuLnNwbGl0KCcuJyk7XHJcbiAgICBpZiAoYWxnb3JpdGhtID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICBwYXlsb2FkID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICBzaWduYXR1cmUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIF9sb2dFcnJvcignSldUIG1hbGZvcm1lZCwgY29udGFpbmVkIGZld2VyIHRoYW4gMyBzZWN0aW9ucycpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkZWNvZGVkID0gYmFzZTY0RGVjb2RlKHBheWxvYWQpO1xyXG4gICAgICAgIGlmICghZGVjb2RlZCkge1xyXG4gICAgICAgICAgICBfbG9nRXJyb3IoJ0ZhaWxlZCB0byBkZWNvZGUgYmFzZTY0IEpXVCBwYXlsb2FkJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVkKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgX2xvZ0Vycm9yKCdDYXVnaHQgZXJyb3IgcGFyc2luZyBKV1QgcGF5bG9hZCBhcyBKU09OJywgZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0IGV4cGlyZXNJbiBUVEwgZnJvbSBhIHRva2VuIGJ5IHN1YnRyYWN0aW5nIHRoZSBleHBpcmF0aW9uIGZyb20gdGhlIGlzc3VhbmNlLlxyXG4gKi9cclxuZnVuY3Rpb24gX3Rva2VuRXhwaXJlc0luKHRva2VuKSB7XHJcbiAgICBjb25zdCBwYXJzZWRUb2tlbiA9IF9wYXJzZVRva2VuKHRva2VuKTtcclxuICAgIF9hc3NlcnQocGFyc2VkVG9rZW4sIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgIF9hc3NlcnQodHlwZW9mIHBhcnNlZFRva2VuLmV4cCAhPT0gJ3VuZGVmaW5lZCcsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgIF9hc3NlcnQodHlwZW9mIHBhcnNlZFRva2VuLmlhdCAhPT0gJ3VuZGVmaW5lZCcsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgIHJldHVybiBOdW1iZXIocGFyc2VkVG9rZW4uZXhwKSAtIE51bWJlcihwYXJzZWRUb2tlbi5pYXQpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIF9sb2dvdXRJZkludmFsaWRhdGVkKHVzZXIsIHByb21pc2UsIGJ5cGFzc0F1dGhTdGF0ZSA9IGZhbHNlKSB7XHJcbiAgICBpZiAoYnlwYXNzQXV0aFN0YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IgJiYgaXNVc2VySW52YWxpZGF0ZWQoZSkpIHtcclxuICAgICAgICAgICAgaWYgKHVzZXIuYXV0aC5jdXJyZW50VXNlciA9PT0gdXNlcikge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdXNlci5hdXRoLnNpZ25PdXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzVXNlckludmFsaWRhdGVkKHsgY29kZSB9KSB7XHJcbiAgICByZXR1cm4gKGNvZGUgPT09IGBhdXRoLyR7XCJ1c2VyLWRpc2FibGVkXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RJU0FCTEVEICovfWAgfHxcclxuICAgICAgICBjb2RlID09PSBgYXV0aC8ke1widXNlci10b2tlbi1leHBpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5UT0tFTl9FWFBJUkVEICovfWApO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFByb2FjdGl2ZVJlZnJlc2gge1xyXG4gICAgY29uc3RydWN0b3IodXNlcikge1xyXG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XHJcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAvLyBOb2RlIHRpbWVycyBhbmQgYnJvd3NlciB0aW1lcnMgcmV0dXJuIGZ1bmRhbWVudGFsbHkgZGlmZmVyZW50IHR5cGVzLlxyXG4gICAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IGNhcmUgd2hhdCB0aGUgdmFsdWUgaXMgYnV0IFRTIHdvbid0IGFjY2VwdCB1bmtub3duIGFuZFxyXG4gICAgICAgIC8vIHdlIGNhbid0IGNhc3QgcHJvcGVybHkgaW4gYm90aCBlbnZpcm9ubWVudHMuXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICB0aGlzLnRpbWVySWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZXJyb3JCYWNrb2ZmID0gMzAwMDAgLyogRHVyYXRpb24uUkVUUllfQkFDS09GRl9NSU4gKi87XHJcbiAgICB9XHJcbiAgICBfc3RhcnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2NoZWR1bGUoKTtcclxuICAgIH1cclxuICAgIF9zdG9wKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLnRpbWVySWQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0SW50ZXJ2YWwod2FzRXJyb3IpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHdhc0Vycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGludGVydmFsID0gdGhpcy5lcnJvckJhY2tvZmY7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JCYWNrb2ZmID0gTWF0aC5taW4odGhpcy5lcnJvckJhY2tvZmYgKiAyLCA5NjAwMDAgLyogRHVyYXRpb24uUkVUUllfQkFDS09GRl9NQVggKi8pO1xyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJ2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgZXJyb3IgYmFja29mZlxyXG4gICAgICAgICAgICB0aGlzLmVycm9yQmFja29mZiA9IDMwMDAwIC8qIER1cmF0aW9uLlJFVFJZX0JBQ0tPRkZfTUlOICovO1xyXG4gICAgICAgICAgICBjb25zdCBleHBUaW1lID0gKF9hID0gdGhpcy51c2VyLnN0c1Rva2VuTWFuYWdlci5leHBpcmF0aW9uVGltZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcclxuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBleHBUaW1lIC0gRGF0ZS5ub3coKSAtIDMwMDAwMCAvKiBEdXJhdGlvbi5PRkZTRVQgKi87XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBpbnRlcnZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2NoZWR1bGUod2FzRXJyb3IgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHtcclxuICAgICAgICAgICAgLy8gSnVzdCBpbiBjYXNlLi4uXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSB0aGlzLmdldEludGVydmFsKHdhc0Vycm9yKTtcclxuICAgICAgICB0aGlzLnRpbWVySWQgPSBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5pdGVyYXRpb24oKTtcclxuICAgICAgICB9LCBpbnRlcnZhbCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBpdGVyYXRpb24oKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy51c2VyLmdldElkVG9rZW4odHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIE9ubHkgcmV0cnkgb24gbmV0d29yayBlcnJvcnNcclxuICAgICAgICAgICAgaWYgKChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUuY29kZSkgPT09XHJcbiAgICAgICAgICAgICAgICBgYXV0aC8ke1wibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRCAqL31gKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlKC8qIHdhc0Vycm9yICovIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zY2hlZHVsZSgpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFVzZXJNZXRhZGF0YSB7XHJcbiAgICBjb25zdHJ1Y3RvcihjcmVhdGVkQXQsIGxhc3RMb2dpbkF0KSB7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVkQXQgPSBjcmVhdGVkQXQ7XHJcbiAgICAgICAgdGhpcy5sYXN0TG9naW5BdCA9IGxhc3RMb2dpbkF0O1xyXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVUaW1lKCk7XHJcbiAgICB9XHJcbiAgICBfaW5pdGlhbGl6ZVRpbWUoKSB7XHJcbiAgICAgICAgdGhpcy5sYXN0U2lnbkluVGltZSA9IHV0Y1RpbWVzdGFtcFRvRGF0ZVN0cmluZyh0aGlzLmxhc3RMb2dpbkF0KTtcclxuICAgICAgICB0aGlzLmNyZWF0aW9uVGltZSA9IHV0Y1RpbWVzdGFtcFRvRGF0ZVN0cmluZyh0aGlzLmNyZWF0ZWRBdCk7XHJcbiAgICB9XHJcbiAgICBfY29weShtZXRhZGF0YSkge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlZEF0ID0gbWV0YWRhdGEuY3JlYXRlZEF0O1xyXG4gICAgICAgIHRoaXMubGFzdExvZ2luQXQgPSBtZXRhZGF0YS5sYXN0TG9naW5BdDtcclxuICAgICAgICB0aGlzLl9pbml0aWFsaXplVGltZSgpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogdGhpcy5jcmVhdGVkQXQsXHJcbiAgICAgICAgICAgIGxhc3RMb2dpbkF0OiB0aGlzLmxhc3RMb2dpbkF0XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VyKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBhdXRoID0gdXNlci5hdXRoO1xyXG4gICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh1c2VyLCBnZXRBY2NvdW50SW5mbyhhdXRoLCB7IGlkVG9rZW4gfSkpO1xyXG4gICAgX2Fzc2VydChyZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UudXNlcnMubGVuZ3RoLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICBjb25zdCBjb3JlQWNjb3VudCA9IHJlc3BvbnNlLnVzZXJzWzBdO1xyXG4gICAgdXNlci5fbm90aWZ5UmVsb2FkTGlzdGVuZXIoY29yZUFjY291bnQpO1xyXG4gICAgY29uc3QgbmV3UHJvdmlkZXJEYXRhID0gKChfYSA9IGNvcmVBY2NvdW50LnByb3ZpZGVyVXNlckluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpXHJcbiAgICAgICAgPyBleHRyYWN0UHJvdmlkZXJEYXRhKGNvcmVBY2NvdW50LnByb3ZpZGVyVXNlckluZm8pXHJcbiAgICAgICAgOiBbXTtcclxuICAgIGNvbnN0IHByb3ZpZGVyRGF0YSA9IG1lcmdlUHJvdmlkZXJEYXRhKHVzZXIucHJvdmlkZXJEYXRhLCBuZXdQcm92aWRlckRhdGEpO1xyXG4gICAgLy8gUHJlc2VydmVzIHRoZSBub24tbm9ueW1vdXMgc3RhdHVzIG9mIHRoZSBzdG9yZWQgdXNlciwgZXZlbiBpZiBubyBtb3JlXHJcbiAgICAvLyBjcmVkZW50aWFscyAoZmVkZXJhdGVkIG9yIGVtYWlsL3Bhc3N3b3JkKSBhcmUgbGlua2VkIHRvIHRoZSB1c2VyLiBJZlxyXG4gICAgLy8gdGhlIHVzZXIgd2FzIHByZXZpb3VzbHkgYW5vbnltb3VzLCB0aGVuIHVzZSBwcm92aWRlciBkYXRhIHRvIHVwZGF0ZS5cclxuICAgIC8vIE9uIHRoZSBvdGhlciBoYW5kLCBpZiBpdCB3YXMgbm90IGFub255bW91cyBiZWZvcmUsIGl0IHNob3VsZCBuZXZlciBiZVxyXG4gICAgLy8gY29uc2lkZXJlZCBhbm9ueW1vdXMgbm93LlxyXG4gICAgY29uc3Qgb2xkSXNBbm9ueW1vdXMgPSB1c2VyLmlzQW5vbnltb3VzO1xyXG4gICAgY29uc3QgbmV3SXNBbm9ueW1vdXMgPSAhKHVzZXIuZW1haWwgJiYgY29yZUFjY291bnQucGFzc3dvcmRIYXNoKSAmJiAhKHByb3ZpZGVyRGF0YSA9PT0gbnVsbCB8fCBwcm92aWRlckRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3ZpZGVyRGF0YS5sZW5ndGgpO1xyXG4gICAgY29uc3QgaXNBbm9ueW1vdXMgPSAhb2xkSXNBbm9ueW1vdXMgPyBmYWxzZSA6IG5ld0lzQW5vbnltb3VzO1xyXG4gICAgY29uc3QgdXBkYXRlcyA9IHtcclxuICAgICAgICB1aWQ6IGNvcmVBY2NvdW50LmxvY2FsSWQsXHJcbiAgICAgICAgZGlzcGxheU5hbWU6IGNvcmVBY2NvdW50LmRpc3BsYXlOYW1lIHx8IG51bGwsXHJcbiAgICAgICAgcGhvdG9VUkw6IGNvcmVBY2NvdW50LnBob3RvVXJsIHx8IG51bGwsXHJcbiAgICAgICAgZW1haWw6IGNvcmVBY2NvdW50LmVtYWlsIHx8IG51bGwsXHJcbiAgICAgICAgZW1haWxWZXJpZmllZDogY29yZUFjY291bnQuZW1haWxWZXJpZmllZCB8fCBmYWxzZSxcclxuICAgICAgICBwaG9uZU51bWJlcjogY29yZUFjY291bnQucGhvbmVOdW1iZXIgfHwgbnVsbCxcclxuICAgICAgICB0ZW5hbnRJZDogY29yZUFjY291bnQudGVuYW50SWQgfHwgbnVsbCxcclxuICAgICAgICBwcm92aWRlckRhdGEsXHJcbiAgICAgICAgbWV0YWRhdGE6IG5ldyBVc2VyTWV0YWRhdGEoY29yZUFjY291bnQuY3JlYXRlZEF0LCBjb3JlQWNjb3VudC5sYXN0TG9naW5BdCksXHJcbiAgICAgICAgaXNBbm9ueW1vdXNcclxuICAgIH07XHJcbiAgICBPYmplY3QuYXNzaWduKHVzZXIsIHVwZGF0ZXMpO1xyXG59XHJcbi8qKlxyXG4gKiBSZWxvYWRzIHVzZXIgYWNjb3VudCBkYXRhLCBpZiBzaWduZWQgaW4uXHJcbiAqXHJcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHJlbG9hZCh1c2VyKSB7XHJcbiAgICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XHJcbiAgICBhd2FpdCBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VySW50ZXJuYWwpO1xyXG4gICAgLy8gRXZlbiB0aG91Z2ggdGhlIGN1cnJlbnQgdXNlciBoYXNuJ3QgY2hhbmdlZCwgdXBkYXRlXHJcbiAgICAvLyBjdXJyZW50IHVzZXIgd2lsbCB0cmlnZ2VyIGEgcGVyc2lzdGVuY2UgdXBkYXRlIHcvIHRoZVxyXG4gICAgLy8gbmV3IGluZm8uXHJcbiAgICBhd2FpdCB1c2VySW50ZXJuYWwuYXV0aC5fcGVyc2lzdFVzZXJJZkN1cnJlbnQodXNlckludGVybmFsKTtcclxuICAgIHVzZXJJbnRlcm5hbC5hdXRoLl9ub3RpZnlMaXN0ZW5lcnNJZkN1cnJlbnQodXNlckludGVybmFsKTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZVByb3ZpZGVyRGF0YShvcmlnaW5hbCwgbmV3RGF0YSkge1xyXG4gICAgY29uc3QgZGVkdXBlZCA9IG9yaWdpbmFsLmZpbHRlcihvID0+ICFuZXdEYXRhLnNvbWUobiA9PiBuLnByb3ZpZGVySWQgPT09IG8ucHJvdmlkZXJJZCkpO1xyXG4gICAgcmV0dXJuIFsuLi5kZWR1cGVkLCAuLi5uZXdEYXRhXTtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0UHJvdmlkZXJEYXRhKHByb3ZpZGVycykge1xyXG4gICAgcmV0dXJuIHByb3ZpZGVycy5tYXAoKF9hKSA9PiB7XHJcbiAgICAgICAgdmFyIHsgcHJvdmlkZXJJZCB9ID0gX2EsIHByb3ZpZGVyID0gX19yZXN0KF9hLCBbXCJwcm92aWRlcklkXCJdKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcm92aWRlcklkLFxyXG4gICAgICAgICAgICB1aWQ6IHByb3ZpZGVyLnJhd0lkIHx8ICcnLFxyXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogcHJvdmlkZXIuZGlzcGxheU5hbWUgfHwgbnVsbCxcclxuICAgICAgICAgICAgZW1haWw6IHByb3ZpZGVyLmVtYWlsIHx8IG51bGwsXHJcbiAgICAgICAgICAgIHBob25lTnVtYmVyOiBwcm92aWRlci5waG9uZU51bWJlciB8fCBudWxsLFxyXG4gICAgICAgICAgICBwaG90b1VSTDogcHJvdmlkZXIucGhvdG9VcmwgfHwgbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0U3RzVG9rZW4oYXV0aCwgcmVmcmVzaFRva2VuKSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9wZXJmb3JtRmV0Y2hXaXRoRXJyb3JIYW5kbGluZyhhdXRoLCB7fSwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGJvZHkgPSBxdWVyeXN0cmluZyh7XHJcbiAgICAgICAgICAgICdncmFudF90eXBlJzogJ3JlZnJlc2hfdG9rZW4nLFxyXG4gICAgICAgICAgICAncmVmcmVzaF90b2tlbic6IHJlZnJlc2hUb2tlblxyXG4gICAgICAgIH0pLnNsaWNlKDEpO1xyXG4gICAgICAgIGNvbnN0IHsgdG9rZW5BcGlIb3N0LCBhcGlLZXkgfSA9IGF1dGguY29uZmlnO1xyXG4gICAgICAgIGNvbnN0IHVybCA9IF9nZXRGaW5hbFRhcmdldChhdXRoLCB0b2tlbkFwaUhvc3QsIFwiL3YxL3Rva2VuXCIgLyogRW5kcG9pbnQuVE9LRU4gKi8sIGBrZXk9JHthcGlLZXl9YCk7XHJcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IGF1dGguX2dldEFkZGl0aW9uYWxIZWFkZXJzKCk7XHJcbiAgICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiIC8qIEh0dHBIZWFkZXIuQ09OVEVOVF9UWVBFICovXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xyXG4gICAgICAgIHJldHVybiBGZXRjaFByb3ZpZGVyLmZldGNoKCkodXJsLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLFxyXG4gICAgICAgICAgICBoZWFkZXJzLFxyXG4gICAgICAgICAgICBib2R5XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIC8vIFRoZSByZXNwb25zZSBjb21lcyBiYWNrIGluIHNuYWtlX2Nhc2UuIENvbnZlcnQgdG8gY2FtZWw6XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFjY2Vzc1Rva2VuOiByZXNwb25zZS5hY2Nlc3NfdG9rZW4sXHJcbiAgICAgICAgZXhwaXJlc0luOiByZXNwb25zZS5leHBpcmVzX2luLFxyXG4gICAgICAgIHJlZnJlc2hUb2tlbjogcmVzcG9uc2UucmVmcmVzaF90b2tlblxyXG4gICAgfTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiByZXZva2VUb2tlbihhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjIvYWNjb3VudHM6cmV2b2tlVG9rZW5cIiAvKiBFbmRwb2ludC5SRVZPS0VfVE9LRU4gKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFdlIG5lZWQgdG8gbWFyayB0aGlzIGNsYXNzIGFzIGludGVybmFsIGV4cGxpY2l0bHkgdG8gZXhjbHVkZSBpdCBpbiB0aGUgcHVibGljIHR5cGluZ3MsIGJlY2F1c2VcclxuICogaXQgcmVmZXJlbmNlcyBBdXRoSW50ZXJuYWwgd2hpY2ggaGFzIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSB3aXRoIFVzZXJJbnRlcm5hbC5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBTdHNUb2tlbk1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRXhwaXJlZCgpIHtcclxuICAgICAgICByZXR1cm4gKCF0aGlzLmV4cGlyYXRpb25UaW1lIHx8XHJcbiAgICAgICAgICAgIERhdGUubm93KCkgPiB0aGlzLmV4cGlyYXRpb25UaW1lIC0gMzAwMDAgLyogQnVmZmVyLlRPS0VOX1JFRlJFU0ggKi8pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlRnJvbVNlcnZlclJlc3BvbnNlKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgX2Fzc2VydChyZXNwb25zZS5pZFRva2VuLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgcmVzcG9uc2UuaWRUb2tlbiAhPT0gJ3VuZGVmaW5lZCcsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICBfYXNzZXJ0KHR5cGVvZiByZXNwb25zZS5yZWZyZXNoVG9rZW4gIT09ICd1bmRlZmluZWQnLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgY29uc3QgZXhwaXJlc0luID0gJ2V4cGlyZXNJbicgaW4gcmVzcG9uc2UgJiYgdHlwZW9mIHJlc3BvbnNlLmV4cGlyZXNJbiAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgPyBOdW1iZXIocmVzcG9uc2UuZXhwaXJlc0luKVxyXG4gICAgICAgICAgICA6IF90b2tlbkV4cGlyZXNJbihyZXNwb25zZS5pZFRva2VuKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRva2Vuc0FuZEV4cGlyYXRpb24ocmVzcG9uc2UuaWRUb2tlbiwgcmVzcG9uc2UucmVmcmVzaFRva2VuLCBleHBpcmVzSW4pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlRnJvbUlkVG9rZW4oaWRUb2tlbikge1xyXG4gICAgICAgIF9hc3NlcnQoaWRUb2tlbi5sZW5ndGggIT09IDAsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICBjb25zdCBleHBpcmVzSW4gPSBfdG9rZW5FeHBpcmVzSW4oaWRUb2tlbik7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUb2tlbnNBbmRFeHBpcmF0aW9uKGlkVG9rZW4sIG51bGwsIGV4cGlyZXNJbik7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRUb2tlbihhdXRoLCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xyXG4gICAgICAgIGlmICghZm9yY2VSZWZyZXNoICYmIHRoaXMuYWNjZXNzVG9rZW4gJiYgIXRoaXMuaXNFeHBpcmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjY2Vzc1Rva2VuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfYXNzZXJ0KHRoaXMucmVmcmVzaFRva2VuLCBhdXRoLCBcInVzZXItdG9rZW4tZXhwaXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuVE9LRU5fRVhQSVJFRCAqLyk7XHJcbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaFRva2VuKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVmcmVzaChhdXRoLCB0aGlzLnJlZnJlc2hUb2tlbik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjY2Vzc1Rva2VuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNsZWFyUmVmcmVzaFRva2VuKCkge1xyXG4gICAgICAgIHRoaXMucmVmcmVzaFRva2VuID0gbnVsbDtcclxuICAgIH1cclxuICAgIGFzeW5jIHJlZnJlc2goYXV0aCwgb2xkVG9rZW4pIHtcclxuICAgICAgICBjb25zdCB7IGFjY2Vzc1Rva2VuLCByZWZyZXNoVG9rZW4sIGV4cGlyZXNJbiB9ID0gYXdhaXQgcmVxdWVzdFN0c1Rva2VuKGF1dGgsIG9sZFRva2VuKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRva2Vuc0FuZEV4cGlyYXRpb24oYWNjZXNzVG9rZW4sIHJlZnJlc2hUb2tlbiwgTnVtYmVyKGV4cGlyZXNJbikpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlVG9rZW5zQW5kRXhwaXJhdGlvbihhY2Nlc3NUb2tlbiwgcmVmcmVzaFRva2VuLCBleHBpcmVzSW5TZWMpIHtcclxuICAgICAgICB0aGlzLnJlZnJlc2hUb2tlbiA9IHJlZnJlc2hUb2tlbiB8fCBudWxsO1xyXG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbiB8fCBudWxsO1xyXG4gICAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBEYXRlLm5vdygpICsgZXhwaXJlc0luU2VjICogMTAwMDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tSlNPTihhcHBOYW1lLCBvYmplY3QpIHtcclxuICAgICAgICBjb25zdCB7IHJlZnJlc2hUb2tlbiwgYWNjZXNzVG9rZW4sIGV4cGlyYXRpb25UaW1lIH0gPSBvYmplY3Q7XHJcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyBTdHNUb2tlbk1hbmFnZXIoKTtcclxuICAgICAgICBpZiAocmVmcmVzaFRva2VuKSB7XHJcbiAgICAgICAgICAgIF9hc3NlcnQodHlwZW9mIHJlZnJlc2hUb2tlbiA9PT0gJ3N0cmluZycsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLCB7XHJcbiAgICAgICAgICAgICAgICBhcHBOYW1lXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBtYW5hZ2VyLnJlZnJlc2hUb2tlbiA9IHJlZnJlc2hUb2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgICAgIF9hc3NlcnQodHlwZW9mIGFjY2Vzc1Rva2VuID09PSAnc3RyaW5nJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sIHtcclxuICAgICAgICAgICAgICAgIGFwcE5hbWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1hbmFnZXIuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4cGlyYXRpb25UaW1lKSB7XHJcbiAgICAgICAgICAgIF9hc3NlcnQodHlwZW9mIGV4cGlyYXRpb25UaW1lID09PSAnbnVtYmVyJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sIHtcclxuICAgICAgICAgICAgICAgIGFwcE5hbWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1hbmFnZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmVmcmVzaFRva2VuOiB0aGlzLnJlZnJlc2hUb2tlbixcclxuICAgICAgICAgICAgYWNjZXNzVG9rZW46IHRoaXMuYWNjZXNzVG9rZW4sXHJcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lOiB0aGlzLmV4cGlyYXRpb25UaW1lXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIF9hc3NpZ24oc3RzVG9rZW5NYW5hZ2VyKSB7XHJcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHN0c1Rva2VuTWFuYWdlci5hY2Nlc3NUb2tlbjtcclxuICAgICAgICB0aGlzLnJlZnJlc2hUb2tlbiA9IHN0c1Rva2VuTWFuYWdlci5yZWZyZXNoVG9rZW47XHJcbiAgICAgICAgdGhpcy5leHBpcmF0aW9uVGltZSA9IHN0c1Rva2VuTWFuYWdlci5leHBpcmF0aW9uVGltZTtcclxuICAgIH1cclxuICAgIF9jbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgU3RzVG9rZW5NYW5hZ2VyKCksIHRoaXMudG9KU09OKCkpO1xyXG4gICAgfVxyXG4gICAgX3BlcmZvcm1SZWZyZXNoKCkge1xyXG4gICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ25vdCBpbXBsZW1lbnRlZCcpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKGFzc2VydGlvbiwgYXBwTmFtZSkge1xyXG4gICAgX2Fzc2VydCh0eXBlb2YgYXNzZXJ0aW9uID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXNzZXJ0aW9uID09PSAndW5kZWZpbmVkJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sIHsgYXBwTmFtZSB9KTtcclxufVxyXG5jbGFzcyBVc2VySW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfYSkge1xyXG4gICAgICAgIHZhciB7IHVpZCwgYXV0aCwgc3RzVG9rZW5NYW5hZ2VyIH0gPSBfYSwgb3B0ID0gX19yZXN0KF9hLCBbXCJ1aWRcIiwgXCJhdXRoXCIsIFwic3RzVG9rZW5NYW5hZ2VyXCJdKTtcclxuICAgICAgICAvLyBGb3IgdGhlIHVzZXIgb2JqZWN0LCBwcm92aWRlciBpcyBhbHdheXMgRmlyZWJhc2UuXHJcbiAgICAgICAgdGhpcy5wcm92aWRlcklkID0gXCJmaXJlYmFzZVwiIC8qIFByb3ZpZGVySWQuRklSRUJBU0UgKi87XHJcbiAgICAgICAgdGhpcy5wcm9hY3RpdmVSZWZyZXNoID0gbmV3IFByb2FjdGl2ZVJlZnJlc2godGhpcyk7XHJcbiAgICAgICAgdGhpcy5yZWxvYWRVc2VySW5mbyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZWxvYWRMaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51aWQgPSB1aWQ7XHJcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcclxuICAgICAgICB0aGlzLnN0c1Rva2VuTWFuYWdlciA9IHN0c1Rva2VuTWFuYWdlcjtcclxuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gc3RzVG9rZW5NYW5hZ2VyLmFjY2Vzc1Rva2VuO1xyXG4gICAgICAgIHRoaXMuZGlzcGxheU5hbWUgPSBvcHQuZGlzcGxheU5hbWUgfHwgbnVsbDtcclxuICAgICAgICB0aGlzLmVtYWlsID0gb3B0LmVtYWlsIHx8IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbWFpbFZlcmlmaWVkID0gb3B0LmVtYWlsVmVyaWZpZWQgfHwgZmFsc2U7XHJcbiAgICAgICAgdGhpcy5waG9uZU51bWJlciA9IG9wdC5waG9uZU51bWJlciB8fCBudWxsO1xyXG4gICAgICAgIHRoaXMucGhvdG9VUkwgPSBvcHQucGhvdG9VUkwgfHwgbnVsbDtcclxuICAgICAgICB0aGlzLmlzQW5vbnltb3VzID0gb3B0LmlzQW5vbnltb3VzIHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudGVuYW50SWQgPSBvcHQudGVuYW50SWQgfHwgbnVsbDtcclxuICAgICAgICB0aGlzLnByb3ZpZGVyRGF0YSA9IG9wdC5wcm92aWRlckRhdGEgPyBbLi4ub3B0LnByb3ZpZGVyRGF0YV0gOiBbXTtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbmV3IFVzZXJNZXRhZGF0YShvcHQuY3JlYXRlZEF0IHx8IHVuZGVmaW5lZCwgb3B0Lmxhc3RMb2dpbkF0IHx8IHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRJZFRva2VuKGZvcmNlUmVmcmVzaCkge1xyXG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodGhpcywgdGhpcy5zdHNUb2tlbk1hbmFnZXIuZ2V0VG9rZW4odGhpcy5hdXRoLCBmb3JjZVJlZnJlc2gpKTtcclxuICAgICAgICBfYXNzZXJ0KGFjY2Vzc1Rva2VuLCB0aGlzLmF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICBpZiAodGhpcy5hY2Nlc3NUb2tlbiAhPT0gYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmF1dGguX3BlcnNpc3RVc2VySWZDdXJyZW50KHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmF1dGguX25vdGlmeUxpc3RlbmVyc0lmQ3VycmVudCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFjY2Vzc1Rva2VuO1xyXG4gICAgfVxyXG4gICAgZ2V0SWRUb2tlblJlc3VsdChmb3JjZVJlZnJlc2gpIHtcclxuICAgICAgICByZXR1cm4gZ2V0SWRUb2tlblJlc3VsdCh0aGlzLCBmb3JjZVJlZnJlc2gpO1xyXG4gICAgfVxyXG4gICAgcmVsb2FkKCkge1xyXG4gICAgICAgIHJldHVybiByZWxvYWQodGhpcyk7XHJcbiAgICB9XHJcbiAgICBfYXNzaWduKHVzZXIpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gdXNlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9hc3NlcnQodGhpcy51aWQgPT09IHVzZXIudWlkLCB0aGlzLmF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICB0aGlzLmRpc3BsYXlOYW1lID0gdXNlci5kaXNwbGF5TmFtZTtcclxuICAgICAgICB0aGlzLnBob3RvVVJMID0gdXNlci5waG90b1VSTDtcclxuICAgICAgICB0aGlzLmVtYWlsID0gdXNlci5lbWFpbDtcclxuICAgICAgICB0aGlzLmVtYWlsVmVyaWZpZWQgPSB1c2VyLmVtYWlsVmVyaWZpZWQ7XHJcbiAgICAgICAgdGhpcy5waG9uZU51bWJlciA9IHVzZXIucGhvbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5pc0Fub255bW91cyA9IHVzZXIuaXNBbm9ueW1vdXM7XHJcbiAgICAgICAgdGhpcy50ZW5hbnRJZCA9IHVzZXIudGVuYW50SWQ7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlckRhdGEgPSB1c2VyLnByb3ZpZGVyRGF0YS5tYXAodXNlckluZm8gPT4gKE9iamVjdC5hc3NpZ24oe30sIHVzZXJJbmZvKSkpO1xyXG4gICAgICAgIHRoaXMubWV0YWRhdGEuX2NvcHkodXNlci5tZXRhZGF0YSk7XHJcbiAgICAgICAgdGhpcy5zdHNUb2tlbk1hbmFnZXIuX2Fzc2lnbih1c2VyLnN0c1Rva2VuTWFuYWdlcik7XHJcbiAgICB9XHJcbiAgICBfY2xvbmUoYXV0aCkge1xyXG4gICAgICAgIGNvbnN0IG5ld1VzZXIgPSBuZXcgVXNlckltcGwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzKSwgeyBhdXRoLCBzdHNUb2tlbk1hbmFnZXI6IHRoaXMuc3RzVG9rZW5NYW5hZ2VyLl9jbG9uZSgpIH0pKTtcclxuICAgICAgICBuZXdVc2VyLm1ldGFkYXRhLl9jb3B5KHRoaXMubWV0YWRhdGEpO1xyXG4gICAgICAgIHJldHVybiBuZXdVc2VyO1xyXG4gICAgfVxyXG4gICAgX29uUmVsb2FkKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgLy8gVGhlcmUgc2hvdWxkIG9ubHkgZXZlciBiZSBvbmUgbGlzdGVuZXIsIGFuZCB0aGF0IGlzIGEgc2luZ2xlIGluc3RhbmNlIG9mIE11bHRpRmFjdG9yVXNlclxyXG4gICAgICAgIF9hc3NlcnQoIXRoaXMucmVsb2FkTGlzdGVuZXIsIHRoaXMuYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIHRoaXMucmVsb2FkTGlzdGVuZXIgPSBjYWxsYmFjaztcclxuICAgICAgICBpZiAodGhpcy5yZWxvYWRVc2VySW5mbykge1xyXG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlSZWxvYWRMaXN0ZW5lcih0aGlzLnJlbG9hZFVzZXJJbmZvKTtcclxuICAgICAgICAgICAgdGhpcy5yZWxvYWRVc2VySW5mbyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX25vdGlmeVJlbG9hZExpc3RlbmVyKHVzZXJJbmZvKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVsb2FkTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWxvYWRMaXN0ZW5lcih1c2VySW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJZiBubyBsaXN0ZW5lciBpcyBzdWJzY3JpYmVkIHlldCwgc2F2ZSB0aGUgcmVzdWx0IHNvIGl0J3MgYXZhaWxhYmxlIHdoZW4gdGhleSBkbyBzdWJzY3JpYmVcclxuICAgICAgICAgICAgdGhpcy5yZWxvYWRVc2VySW5mbyA9IHVzZXJJbmZvO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zdGFydFByb2FjdGl2ZVJlZnJlc2goKSB7XHJcbiAgICAgICAgdGhpcy5wcm9hY3RpdmVSZWZyZXNoLl9zdGFydCgpO1xyXG4gICAgfVxyXG4gICAgX3N0b3BQcm9hY3RpdmVSZWZyZXNoKCkge1xyXG4gICAgICAgIHRoaXMucHJvYWN0aXZlUmVmcmVzaC5fc3RvcCgpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgX3VwZGF0ZVRva2Vuc0lmTmVjZXNzYXJ5KHJlc3BvbnNlLCByZWxvYWQgPSBmYWxzZSkge1xyXG4gICAgICAgIGxldCB0b2tlbnNSZWZyZXNoZWQgPSBmYWxzZTtcclxuICAgICAgICBpZiAocmVzcG9uc2UuaWRUb2tlbiAmJlxyXG4gICAgICAgICAgICByZXNwb25zZS5pZFRva2VuICE9PSB0aGlzLnN0c1Rva2VuTWFuYWdlci5hY2Nlc3NUb2tlbikge1xyXG4gICAgICAgICAgICB0aGlzLnN0c1Rva2VuTWFuYWdlci51cGRhdGVGcm9tU2VydmVyUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB0b2tlbnNSZWZyZXNoZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVsb2FkKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IF9yZWxvYWRXaXRob3V0U2F2aW5nKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhd2FpdCB0aGlzLmF1dGguX3BlcnNpc3RVc2VySWZDdXJyZW50KHRoaXMpO1xyXG4gICAgICAgIGlmICh0b2tlbnNSZWZyZXNoZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5hdXRoLl9ub3RpZnlMaXN0ZW5lcnNJZkN1cnJlbnQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgZGVsZXRlKCkge1xyXG4gICAgICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcCh0aGlzLmF1dGguYXBwKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IodGhpcy5hdXRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB0aGlzLmdldElkVG9rZW4oKTtcclxuICAgICAgICBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh0aGlzLCBkZWxldGVBY2NvdW50KHRoaXMuYXV0aCwgeyBpZFRva2VuIH0pKTtcclxuICAgICAgICB0aGlzLnN0c1Rva2VuTWFuYWdlci5jbGVhclJlZnJlc2hUb2tlbigpO1xyXG4gICAgICAgIC8vIFRPRE86IERldGVybWluZSBpZiBjYW5jZWxsYWJsZS1wcm9taXNlcyBhcmUgbmVjZXNzYXJ5IHRvIHVzZSBpbiB0aGlzIGNsYXNzIHNvIHRoYXQgZGVsZXRlKClcclxuICAgICAgICAvLyAgICAgICBjYW5jZWxzIHBlbmRpbmcgYWN0aW9ucy4uLlxyXG4gICAgICAgIHJldHVybiB0aGlzLmF1dGguc2lnbk91dCgpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB1aWQ6IHRoaXMudWlkLCBlbWFpbDogdGhpcy5lbWFpbCB8fCB1bmRlZmluZWQsIGVtYWlsVmVyaWZpZWQ6IHRoaXMuZW1haWxWZXJpZmllZCwgZGlzcGxheU5hbWU6IHRoaXMuZGlzcGxheU5hbWUgfHwgdW5kZWZpbmVkLCBpc0Fub255bW91czogdGhpcy5pc0Fub255bW91cywgcGhvdG9VUkw6IHRoaXMucGhvdG9VUkwgfHwgdW5kZWZpbmVkLCBwaG9uZU51bWJlcjogdGhpcy5waG9uZU51bWJlciB8fCB1bmRlZmluZWQsIHRlbmFudElkOiB0aGlzLnRlbmFudElkIHx8IHVuZGVmaW5lZCwgcHJvdmlkZXJEYXRhOiB0aGlzLnByb3ZpZGVyRGF0YS5tYXAodXNlckluZm8gPT4gKE9iamVjdC5hc3NpZ24oe30sIHVzZXJJbmZvKSkpLCBzdHNUb2tlbk1hbmFnZXI6IHRoaXMuc3RzVG9rZW5NYW5hZ2VyLnRvSlNPTigpLCBcclxuICAgICAgICAgICAgLy8gUmVkaXJlY3QgZXZlbnQgSUQgbXVzdCBiZSBtYWludGFpbmVkIGluIGNhc2UgdGhlcmUgaXMgYSBwZW5kaW5nXHJcbiAgICAgICAgICAgIC8vIHJlZGlyZWN0IGV2ZW50LlxyXG4gICAgICAgICAgICBfcmVkaXJlY3RFdmVudElkOiB0aGlzLl9yZWRpcmVjdEV2ZW50SWQgfSwgdGhpcy5tZXRhZGF0YS50b0pTT04oKSksIHsgXHJcbiAgICAgICAgICAgIC8vIFJlcXVpcmVkIGZvciBjb21wYXRpYmlsaXR5IHdpdGggdGhlIGxlZ2FjeSBTREsgKGdvL2ZpcmViYXNlLWF1dGgtc2RrLXBlcnNpc3RlbmNlLXBhcnNpbmcpOlxyXG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMuYXV0aC5jb25maWcuYXBpS2V5LCBhcHBOYW1lOiB0aGlzLmF1dGgubmFtZSB9KTtcclxuICAgIH1cclxuICAgIGdldCByZWZyZXNoVG9rZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RzVG9rZW5NYW5hZ2VyLnJlZnJlc2hUb2tlbiB8fCAnJztcclxuICAgIH1cclxuICAgIHN0YXRpYyBfZnJvbUpTT04oYXV0aCwgb2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcclxuICAgICAgICBjb25zdCBkaXNwbGF5TmFtZSA9IChfYSA9IG9iamVjdC5kaXNwbGF5TmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGVtYWlsID0gKF9iID0gb2JqZWN0LmVtYWlsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgcGhvbmVOdW1iZXIgPSAoX2MgPSBvYmplY3QucGhvbmVOdW1iZXIpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBwaG90b1VSTCA9IChfZCA9IG9iamVjdC5waG90b1VSTCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IHRlbmFudElkID0gKF9lID0gb2JqZWN0LnRlbmFudElkKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgX3JlZGlyZWN0RXZlbnRJZCA9IChfZiA9IG9iamVjdC5fcmVkaXJlY3RFdmVudElkKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgY3JlYXRlZEF0ID0gKF9nID0gb2JqZWN0LmNyZWF0ZWRBdCkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGxhc3RMb2dpbkF0ID0gKF9oID0gb2JqZWN0Lmxhc3RMb2dpbkF0KSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgeyB1aWQsIGVtYWlsVmVyaWZpZWQsIGlzQW5vbnltb3VzLCBwcm92aWRlckRhdGEsIHN0c1Rva2VuTWFuYWdlcjogcGxhaW5PYmplY3RUb2tlbk1hbmFnZXIgfSA9IG9iamVjdDtcclxuICAgICAgICBfYXNzZXJ0KHVpZCAmJiBwbGFpbk9iamVjdFRva2VuTWFuYWdlciwgYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIGNvbnN0IHN0c1Rva2VuTWFuYWdlciA9IFN0c1Rva2VuTWFuYWdlci5mcm9tSlNPTih0aGlzLm5hbWUsIHBsYWluT2JqZWN0VG9rZW5NYW5hZ2VyKTtcclxuICAgICAgICBfYXNzZXJ0KHR5cGVvZiB1aWQgPT09ICdzdHJpbmcnLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQoZGlzcGxheU5hbWUsIGF1dGgubmFtZSk7XHJcbiAgICAgICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQoZW1haWwsIGF1dGgubmFtZSk7XHJcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgZW1haWxWZXJpZmllZCA9PT0gJ2Jvb2xlYW4nLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgaXNBbm9ueW1vdXMgPT09ICdib29sZWFuJywgYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKHBob25lTnVtYmVyLCBhdXRoLm5hbWUpO1xyXG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKHBob3RvVVJMLCBhdXRoLm5hbWUpO1xyXG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKHRlbmFudElkLCBhdXRoLm5hbWUpO1xyXG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKF9yZWRpcmVjdEV2ZW50SWQsIGF1dGgubmFtZSk7XHJcbiAgICAgICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQoY3JlYXRlZEF0LCBhdXRoLm5hbWUpO1xyXG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKGxhc3RMb2dpbkF0LCBhdXRoLm5hbWUpO1xyXG4gICAgICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlckltcGwoe1xyXG4gICAgICAgICAgICB1aWQsXHJcbiAgICAgICAgICAgIGF1dGgsXHJcbiAgICAgICAgICAgIGVtYWlsLFxyXG4gICAgICAgICAgICBlbWFpbFZlcmlmaWVkLFxyXG4gICAgICAgICAgICBkaXNwbGF5TmFtZSxcclxuICAgICAgICAgICAgaXNBbm9ueW1vdXMsXHJcbiAgICAgICAgICAgIHBob3RvVVJMLFxyXG4gICAgICAgICAgICBwaG9uZU51bWJlcixcclxuICAgICAgICAgICAgdGVuYW50SWQsXHJcbiAgICAgICAgICAgIHN0c1Rva2VuTWFuYWdlcixcclxuICAgICAgICAgICAgY3JlYXRlZEF0LFxyXG4gICAgICAgICAgICBsYXN0TG9naW5BdFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChwcm92aWRlckRhdGEgJiYgQXJyYXkuaXNBcnJheShwcm92aWRlckRhdGEpKSB7XHJcbiAgICAgICAgICAgIHVzZXIucHJvdmlkZXJEYXRhID0gcHJvdmlkZXJEYXRhLm1hcCh1c2VySW5mbyA9PiAoT2JqZWN0LmFzc2lnbih7fSwgdXNlckluZm8pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfcmVkaXJlY3RFdmVudElkKSB7XHJcbiAgICAgICAgICAgIHVzZXIuX3JlZGlyZWN0RXZlbnRJZCA9IF9yZWRpcmVjdEV2ZW50SWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1c2VyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIGEgVXNlciBmcm9tIGFuIGlkVG9rZW4gc2VydmVyIHJlc3BvbnNlXHJcbiAgICAgKiBAcGFyYW0gYXV0aFxyXG4gICAgICogQHBhcmFtIGlkVG9rZW5SZXNwb25zZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXN5bmMgX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aCwgaWRUb2tlblJlc3BvbnNlLCBpc0Fub255bW91cyA9IGZhbHNlKSB7XHJcbiAgICAgICAgY29uc3Qgc3RzVG9rZW5NYW5hZ2VyID0gbmV3IFN0c1Rva2VuTWFuYWdlcigpO1xyXG4gICAgICAgIHN0c1Rva2VuTWFuYWdlci51cGRhdGVGcm9tU2VydmVyUmVzcG9uc2UoaWRUb2tlblJlc3BvbnNlKTtcclxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBGaXJlYmFzZSBBdXRoIHVzZXIuXHJcbiAgICAgICAgY29uc3QgdXNlciA9IG5ldyBVc2VySW1wbCh7XHJcbiAgICAgICAgICAgIHVpZDogaWRUb2tlblJlc3BvbnNlLmxvY2FsSWQsXHJcbiAgICAgICAgICAgIGF1dGgsXHJcbiAgICAgICAgICAgIHN0c1Rva2VuTWFuYWdlcixcclxuICAgICAgICAgICAgaXNBbm9ueW1vdXNcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBVcGRhdGVzIHRoZSB1c2VyIGluZm8gYW5kIGRhdGEgYW5kIHJlc29sdmVzIHdpdGggYSB1c2VyIGluc3RhbmNlLlxyXG4gICAgICAgIGF3YWl0IF9yZWxvYWRXaXRob3V0U2F2aW5nKHVzZXIpO1xyXG4gICAgICAgIHJldHVybiB1c2VyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIGEgVXNlciBmcm9tIGFuIGlkVG9rZW4gc2VydmVyIHJlc3BvbnNlXHJcbiAgICAgKiBAcGFyYW0gYXV0aFxyXG4gICAgICogQHBhcmFtIGlkVG9rZW5SZXNwb25zZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXN5bmMgX2Zyb21HZXRBY2NvdW50SW5mb1Jlc3BvbnNlKGF1dGgsIHJlc3BvbnNlLCBpZFRva2VuKSB7XHJcbiAgICAgICAgY29uc3QgY29yZUFjY291bnQgPSByZXNwb25zZS51c2Vyc1swXTtcclxuICAgICAgICBfYXNzZXJ0KGNvcmVBY2NvdW50LmxvY2FsSWQgIT09IHVuZGVmaW5lZCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyRGF0YSA9IGNvcmVBY2NvdW50LnByb3ZpZGVyVXNlckluZm8gIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA/IGV4dHJhY3RQcm92aWRlckRhdGEoY29yZUFjY291bnQucHJvdmlkZXJVc2VySW5mbylcclxuICAgICAgICAgICAgOiBbXTtcclxuICAgICAgICBjb25zdCBpc0Fub255bW91cyA9ICEoY29yZUFjY291bnQuZW1haWwgJiYgY29yZUFjY291bnQucGFzc3dvcmRIYXNoKSAmJiAhKHByb3ZpZGVyRGF0YSA9PT0gbnVsbCB8fCBwcm92aWRlckRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3ZpZGVyRGF0YS5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IHN0c1Rva2VuTWFuYWdlciA9IG5ldyBTdHNUb2tlbk1hbmFnZXIoKTtcclxuICAgICAgICBzdHNUb2tlbk1hbmFnZXIudXBkYXRlRnJvbUlkVG9rZW4oaWRUb2tlbik7XHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgRmlyZWJhc2UgQXV0aCB1c2VyLlxyXG4gICAgICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlckltcGwoe1xyXG4gICAgICAgICAgICB1aWQ6IGNvcmVBY2NvdW50LmxvY2FsSWQsXHJcbiAgICAgICAgICAgIGF1dGgsXHJcbiAgICAgICAgICAgIHN0c1Rva2VuTWFuYWdlcixcclxuICAgICAgICAgICAgaXNBbm9ueW1vdXNcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyB1cGRhdGUgdGhlIHVzZXIgd2l0aCBkYXRhIGZyb20gdGhlIEdldEFjY291bnRJbmZvIHJlc3BvbnNlLlxyXG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSB7XHJcbiAgICAgICAgICAgIHVpZDogY29yZUFjY291bnQubG9jYWxJZCxcclxuICAgICAgICAgICAgZGlzcGxheU5hbWU6IGNvcmVBY2NvdW50LmRpc3BsYXlOYW1lIHx8IG51bGwsXHJcbiAgICAgICAgICAgIHBob3RvVVJMOiBjb3JlQWNjb3VudC5waG90b1VybCB8fCBudWxsLFxyXG4gICAgICAgICAgICBlbWFpbDogY29yZUFjY291bnQuZW1haWwgfHwgbnVsbCxcclxuICAgICAgICAgICAgZW1haWxWZXJpZmllZDogY29yZUFjY291bnQuZW1haWxWZXJpZmllZCB8fCBmYWxzZSxcclxuICAgICAgICAgICAgcGhvbmVOdW1iZXI6IGNvcmVBY2NvdW50LnBob25lTnVtYmVyIHx8IG51bGwsXHJcbiAgICAgICAgICAgIHRlbmFudElkOiBjb3JlQWNjb3VudC50ZW5hbnRJZCB8fCBudWxsLFxyXG4gICAgICAgICAgICBwcm92aWRlckRhdGEsXHJcbiAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgVXNlck1ldGFkYXRhKGNvcmVBY2NvdW50LmNyZWF0ZWRBdCwgY29yZUFjY291bnQubGFzdExvZ2luQXQpLFxyXG4gICAgICAgICAgICBpc0Fub255bW91czogIShjb3JlQWNjb3VudC5lbWFpbCAmJiBjb3JlQWNjb3VudC5wYXNzd29yZEhhc2gpICYmXHJcbiAgICAgICAgICAgICAgICAhKHByb3ZpZGVyRGF0YSA9PT0gbnVsbCB8fCBwcm92aWRlckRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3ZpZGVyRGF0YS5sZW5ndGgpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHVzZXIsIHVwZGF0ZXMpO1xyXG4gICAgICAgIHJldHVybiB1c2VyO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGluc3RhbmNlQ2FjaGUgPSBuZXcgTWFwKCk7XHJcbmZ1bmN0aW9uIF9nZXRJbnN0YW5jZShjbHMpIHtcclxuICAgIGRlYnVnQXNzZXJ0KGNscyBpbnN0YW5jZW9mIEZ1bmN0aW9uLCAnRXhwZWN0ZWQgYSBjbGFzcyBkZWZpbml0aW9uJyk7XHJcbiAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZUNhY2hlLmdldChjbHMpO1xyXG4gICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgZGVidWdBc3NlcnQoaW5zdGFuY2UgaW5zdGFuY2VvZiBjbHMsICdJbnN0YW5jZSBzdG9yZWQgaW4gY2FjaGUgbWlzbWF0Y2hlZCB3aXRoIGNsYXNzJyk7XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgaW5zdGFuY2UgPSBuZXcgY2xzKCk7XHJcbiAgICBpbnN0YW5jZUNhY2hlLnNldChjbHMsIGluc3RhbmNlKTtcclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBJbk1lbW9yeVBlcnNpc3RlbmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiTk9ORVwiIC8qIFBlcnNpc3RlbmNlVHlwZS5OT05FICovO1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHt9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgX2lzQXZhaWxhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgX3NldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5zdG9yYWdlW2tleV0gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGFzeW5jIF9nZXQoa2V5KSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnN0b3JhZ2Vba2V5XTtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGFzeW5jIF9yZW1vdmUoa2V5KSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RvcmFnZVtrZXldO1xyXG4gICAgfVxyXG4gICAgX2FkZExpc3RlbmVyKF9rZXksIF9saXN0ZW5lcikge1xyXG4gICAgICAgIC8vIExpc3RlbmVycyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgaW4tbWVtb3J5IHN0b3JhZ2Ugc2luY2UgaXQgY2Fubm90IGJlIHNoYXJlZCBhY3Jvc3Mgd2luZG93cy93b3JrZXJzXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgX3JlbW92ZUxpc3RlbmVyKF9rZXksIF9saXN0ZW5lcikge1xyXG4gICAgICAgIC8vIExpc3RlbmVycyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgaW4tbWVtb3J5IHN0b3JhZ2Ugc2luY2UgaXQgY2Fubm90IGJlIHNoYXJlZCBhY3Jvc3Mgd2luZG93cy93b3JrZXJzXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG59XHJcbkluTWVtb3J5UGVyc2lzdGVuY2UudHlwZSA9ICdOT05FJztcclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBQZXJzaXN0ZW5jZX0gb2YgdHlwZSAnTk9ORScuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGluTWVtb3J5UGVyc2lzdGVuY2UgPSBJbk1lbW9yeVBlcnNpc3RlbmNlO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBfcGVyc2lzdGVuY2VLZXlOYW1lKGtleSwgYXBpS2V5LCBhcHBOYW1lKSB7XHJcbiAgICByZXR1cm4gYCR7XCJmaXJlYmFzZVwiIC8qIE5hbWVzcGFjZS5QRVJTSVNURU5DRSAqL306JHtrZXl9OiR7YXBpS2V5fToke2FwcE5hbWV9YDtcclxufVxyXG5jbGFzcyBQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHBlcnNpc3RlbmNlLCBhdXRoLCB1c2VyS2V5KSB7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xyXG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XHJcbiAgICAgICAgdGhpcy51c2VyS2V5ID0gdXNlcktleTtcclxuICAgICAgICBjb25zdCB7IGNvbmZpZywgbmFtZSB9ID0gdGhpcy5hdXRoO1xyXG4gICAgICAgIHRoaXMuZnVsbFVzZXJLZXkgPSBfcGVyc2lzdGVuY2VLZXlOYW1lKHRoaXMudXNlcktleSwgY29uZmlnLmFwaUtleSwgbmFtZSk7XHJcbiAgICAgICAgdGhpcy5mdWxsUGVyc2lzdGVuY2VLZXkgPSBfcGVyc2lzdGVuY2VLZXlOYW1lKFwicGVyc2lzdGVuY2VcIiAvKiBLZXlOYW1lLlBFUlNJU1RFTkNFX1VTRVIgKi8sIGNvbmZpZy5hcGlLZXksIG5hbWUpO1xyXG4gICAgICAgIHRoaXMuYm91bmRFdmVudEhhbmRsZXIgPSBhdXRoLl9vblN0b3JhZ2VFdmVudC5iaW5kKGF1dGgpO1xyXG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UuX2FkZExpc3RlbmVyKHRoaXMuZnVsbFVzZXJLZXksIHRoaXMuYm91bmRFdmVudEhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgc2V0Q3VycmVudFVzZXIodXNlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLl9zZXQodGhpcy5mdWxsVXNlcktleSwgdXNlci50b0pTT04oKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRDdXJyZW50VXNlcigpIHtcclxuICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5fZ2V0KHRoaXMuZnVsbFVzZXJLZXkpO1xyXG4gICAgICAgIHJldHVybiBibG9iID8gVXNlckltcGwuX2Zyb21KU09OKHRoaXMuYXV0aCwgYmxvYikgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlQ3VycmVudFVzZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuX3JlbW92ZSh0aGlzLmZ1bGxVc2VyS2V5KTtcclxuICAgIH1cclxuICAgIHNhdmVQZXJzaXN0ZW5jZUZvclJlZGlyZWN0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLl9zZXQodGhpcy5mdWxsUGVyc2lzdGVuY2VLZXksIHRoaXMucGVyc2lzdGVuY2UudHlwZSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzZXRQZXJzaXN0ZW5jZShuZXdQZXJzaXN0ZW5jZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbmNlID09PSBuZXdQZXJzaXN0ZW5jZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gYXdhaXQgdGhpcy5nZXRDdXJyZW50VXNlcigpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucmVtb3ZlQ3VycmVudFVzZXIoKTtcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlID0gbmV3UGVyc2lzdGVuY2U7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRVc2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEN1cnJlbnRVc2VyKGN1cnJlbnRVc2VyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWxldGUoKSB7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZS5fcmVtb3ZlTGlzdGVuZXIodGhpcy5mdWxsVXNlcktleSwgdGhpcy5ib3VuZEV2ZW50SGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKGF1dGgsIHBlcnNpc3RlbmNlSGllcmFyY2h5LCB1c2VyS2V5ID0gXCJhdXRoVXNlclwiIC8qIEtleU5hbWUuQVVUSF9VU0VSICovKSB7XHJcbiAgICAgICAgaWYgKCFwZXJzaXN0ZW5jZUhpZXJhcmNoeS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyKF9nZXRJbnN0YW5jZShpbk1lbW9yeVBlcnNpc3RlbmNlKSwgYXV0aCwgdXNlcktleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVsaW1pbmF0ZSBhbnkgcGVyc2lzdGVuY2VzIHRoYXQgYXJlIG5vdCBhdmFpbGFibGVcclxuICAgICAgICBjb25zdCBhdmFpbGFibGVQZXJzaXN0ZW5jZXMgPSAoYXdhaXQgUHJvbWlzZS5hbGwocGVyc2lzdGVuY2VIaWVyYXJjaHkubWFwKGFzeW5jIChwZXJzaXN0ZW5jZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYXdhaXQgcGVyc2lzdGVuY2UuX2lzQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwZXJzaXN0ZW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pKSkuZmlsdGVyKHBlcnNpc3RlbmNlID0+IHBlcnNpc3RlbmNlKTtcclxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIGZpcnN0IHBlcnNpc3RlbmNlIGxpc3RlZCwgb3IgaW4gbWVtb3J5IGlmIG5vbmUgYXZhaWxhYmxlXHJcbiAgICAgICAgbGV0IHNlbGVjdGVkUGVyc2lzdGVuY2UgPSBhdmFpbGFibGVQZXJzaXN0ZW5jZXNbMF0gfHxcclxuICAgICAgICAgICAgX2dldEluc3RhbmNlKGluTWVtb3J5UGVyc2lzdGVuY2UpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IF9wZXJzaXN0ZW5jZUtleU5hbWUodXNlcktleSwgYXV0aC5jb25maWcuYXBpS2V5LCBhdXRoLm5hbWUpO1xyXG4gICAgICAgIC8vIFB1bGwgb3V0IHRoZSBleGlzdGluZyB1c2VyLCBzZXR0aW5nIHRoZSBjaG9zZW4gcGVyc2lzdGVuY2UgdG8gdGhhdFxyXG4gICAgICAgIC8vIHBlcnNpc3RlbmNlIGlmIHRoZSB1c2VyIGV4aXN0cy5cclxuICAgICAgICBsZXQgdXNlclRvTWlncmF0ZSA9IG51bGw7XHJcbiAgICAgICAgLy8gTm90ZSwgaGVyZSB3ZSBjaGVjayBmb3IgYSB1c2VyIGluIF9hbGxfIHBlcnNpc3RlbmNlcywgbm90IGp1c3QgdGhlXHJcbiAgICAgICAgLy8gb25lcyBkZWVtZWQgYXZhaWxhYmxlLiBJZiB3ZSBjYW4gbWlncmF0ZSBhIHVzZXIgb3V0IG9mIGEgYnJva2VuXHJcbiAgICAgICAgLy8gcGVyc2lzdGVuY2UsIHdlIHdpbGwgKGJ1dCBvbmx5IGlmIHRoYXQgcGVyc2lzdGVuY2Ugc3VwcG9ydHMgbWlncmF0aW9uKS5cclxuICAgICAgICBmb3IgKGNvbnN0IHBlcnNpc3RlbmNlIG9mIHBlcnNpc3RlbmNlSGllcmFyY2h5KSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgcGVyc2lzdGVuY2UuX2dldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJsb2IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyID0gVXNlckltcGwuX2Zyb21KU09OKGF1dGgsIGJsb2IpOyAvLyB0aHJvd3MgZm9yIHVucGFyc2FibGUgYmxvYiAod3JvbmcgZm9ybWF0KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXJzaXN0ZW5jZSAhPT0gc2VsZWN0ZWRQZXJzaXN0ZW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyVG9NaWdyYXRlID0gdXNlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRQZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIGZpbmQgdGhlIHVzZXIgaW4gYSBwZXJzaXN0ZW5jZSB0aGF0IGRvZXMgc3VwcG9ydCBtaWdyYXRpb24sIHVzZVxyXG4gICAgICAgIC8vIHRoYXQgbWlncmF0aW9uIHBhdGggKG9mIG9ubHkgcGVyc2lzdGVuY2VzIHRoYXQgc3VwcG9ydCBtaWdyYXRpb24pXHJcbiAgICAgICAgY29uc3QgbWlncmF0aW9uSGllcmFyY2h5ID0gYXZhaWxhYmxlUGVyc2lzdGVuY2VzLmZpbHRlcihwID0+IHAuX3Nob3VsZEFsbG93TWlncmF0aW9uKTtcclxuICAgICAgICAvLyBJZiB0aGUgcGVyc2lzdGVuY2UgZG9lcyBfbm90XyBhbGxvdyBtaWdyYXRpb24sIGp1c3QgZmluaXNoIG9mZiBoZXJlXHJcbiAgICAgICAgaWYgKCFzZWxlY3RlZFBlcnNpc3RlbmNlLl9zaG91bGRBbGxvd01pZ3JhdGlvbiB8fFxyXG4gICAgICAgICAgICAhbWlncmF0aW9uSGllcmFyY2h5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlVXNlck1hbmFnZXIoc2VsZWN0ZWRQZXJzaXN0ZW5jZSwgYXV0aCwgdXNlcktleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbGVjdGVkUGVyc2lzdGVuY2UgPSBtaWdyYXRpb25IaWVyYXJjaHlbMF07XHJcbiAgICAgICAgaWYgKHVzZXJUb01pZ3JhdGUpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBub3JtYWxseSBzaG91bGRuJ3QgdGhyb3cgc2luY2UgY2hvc2VuUGVyc2lzdGVuY2UuaXNBdmFpbGFibGUoKSBpcyB0cnVlLCBidXQgaWYgaXQgZG9lc1xyXG4gICAgICAgICAgICAvLyB3ZSdsbCBqdXN0IGxldCBpdCBidWJibGUgdG8gc3VyZmFjZSB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgIGF3YWl0IHNlbGVjdGVkUGVyc2lzdGVuY2UuX3NldChrZXksIHVzZXJUb01pZ3JhdGUudG9KU09OKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBdHRlbXB0IHRvIGNsZWFyIHRoZSBrZXkgaW4gb3RoZXIgcGVyc2lzdGVuY2VzIGJ1dCBpZ25vcmUgZXJyb3JzLiBUaGlzIGhlbHBzIHByZXZlbnQgaXNzdWVzXHJcbiAgICAgICAgLy8gc3VjaCBhcyB1c2VycyBnZXR0aW5nIHN0dWNrIHdpdGggYSBwcmV2aW91cyBhY2NvdW50IGFmdGVyIHNpZ25pbmcgb3V0IGFuZCByZWZyZXNoaW5nIHRoZSB0YWIuXHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocGVyc2lzdGVuY2VIaWVyYXJjaHkubWFwKGFzeW5jIChwZXJzaXN0ZW5jZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocGVyc2lzdGVuY2UgIT09IHNlbGVjdGVkUGVyc2lzdGVuY2UpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcGVyc2lzdGVuY2UuX3JlbW92ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlVXNlck1hbmFnZXIoc2VsZWN0ZWRQZXJzaXN0ZW5jZSwgYXV0aCwgdXNlcktleSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIERldGVybWluZSB0aGUgYnJvd3NlciBmb3IgdGhlIHB1cnBvc2VzIG9mIHJlcG9ydGluZyB1c2FnZSB0byB0aGUgQVBJXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0QnJvd3Nlck5hbWUodXNlckFnZW50KSB7XHJcbiAgICBjb25zdCB1YSA9IHVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgaWYgKHVhLmluY2x1ZGVzKCdvcGVyYS8nKSB8fCB1YS5pbmNsdWRlcygnb3ByLycpIHx8IHVhLmluY2x1ZGVzKCdvcGlvcy8nKSkge1xyXG4gICAgICAgIHJldHVybiBcIk9wZXJhXCIgLyogQnJvd3Nlck5hbWUuT1BFUkEgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChfaXNJRU1vYmlsZSh1YSkpIHtcclxuICAgICAgICAvLyBXaW5kb3dzIHBob25lIElFTW9iaWxlIGJyb3dzZXIuXHJcbiAgICAgICAgcmV0dXJuIFwiSUVNb2JpbGVcIiAvKiBCcm93c2VyTmFtZS5JRU1PQklMRSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHVhLmluY2x1ZGVzKCdtc2llJykgfHwgdWEuaW5jbHVkZXMoJ3RyaWRlbnQvJykpIHtcclxuICAgICAgICByZXR1cm4gXCJJRVwiIC8qIEJyb3dzZXJOYW1lLklFICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodWEuaW5jbHVkZXMoJ2VkZ2UvJykpIHtcclxuICAgICAgICByZXR1cm4gXCJFZGdlXCIgLyogQnJvd3Nlck5hbWUuRURHRSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKF9pc0ZpcmVmb3godWEpKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiRmlyZWZveFwiIC8qIEJyb3dzZXJOYW1lLkZJUkVGT1ggKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh1YS5pbmNsdWRlcygnc2lsay8nKSkge1xyXG4gICAgICAgIHJldHVybiBcIlNpbGtcIiAvKiBCcm93c2VyTmFtZS5TSUxLICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoX2lzQmxhY2tCZXJyeSh1YSkpIHtcclxuICAgICAgICAvLyBCbGFja2JlcnJ5IGJyb3dzZXIuXHJcbiAgICAgICAgcmV0dXJuIFwiQmxhY2tiZXJyeVwiIC8qIEJyb3dzZXJOYW1lLkJMQUNLQkVSUlkgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChfaXNXZWJPUyh1YSkpIHtcclxuICAgICAgICAvLyBXZWJPUyBkZWZhdWx0IGJyb3dzZXIuXHJcbiAgICAgICAgcmV0dXJuIFwiV2Vib3NcIiAvKiBCcm93c2VyTmFtZS5XRUJPUyAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKF9pc1NhZmFyaSh1YSkpIHtcclxuICAgICAgICByZXR1cm4gXCJTYWZhcmlcIiAvKiBCcm93c2VyTmFtZS5TQUZBUkkgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgodWEuaW5jbHVkZXMoJ2Nocm9tZS8nKSB8fCBfaXNDaHJvbWVJT1ModWEpKSAmJlxyXG4gICAgICAgICF1YS5pbmNsdWRlcygnZWRnZS8nKSkge1xyXG4gICAgICAgIHJldHVybiBcIkNocm9tZVwiIC8qIEJyb3dzZXJOYW1lLkNIUk9NRSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKF9pc0FuZHJvaWQodWEpKSB7XHJcbiAgICAgICAgLy8gQW5kcm9pZCBzdG9jayBicm93c2VyLlxyXG4gICAgICAgIHJldHVybiBcIkFuZHJvaWRcIiAvKiBCcm93c2VyTmFtZS5BTkRST0lEICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gTW9zdCBtb2Rlcm4gYnJvd3NlcnMgaGF2ZSBuYW1lL3ZlcnNpb24gYXQgZW5kIG9mIHVzZXIgYWdlbnQgc3RyaW5nLlxyXG4gICAgICAgIGNvbnN0IHJlID0gLyhbYS16QS1aXFxkXFwuXSspXFwvW2EtekEtWlxcZFxcLl0qJC87XHJcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHVzZXJBZ2VudC5tYXRjaChyZSk7XHJcbiAgICAgICAgaWYgKChtYXRjaGVzID09PSBudWxsIHx8IG1hdGNoZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoZXMubGVuZ3RoKSA9PT0gMikge1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1sxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCJPdGhlclwiIC8qIEJyb3dzZXJOYW1lLk9USEVSICovO1xyXG59XHJcbmZ1bmN0aW9uIF9pc0ZpcmVmb3godWEgPSBnZXRVQSgpKSB7XHJcbiAgICByZXR1cm4gL2ZpcmVmb3hcXC8vaS50ZXN0KHVhKTtcclxufVxyXG5mdW5jdGlvbiBfaXNTYWZhcmkodXNlckFnZW50ID0gZ2V0VUEoKSkge1xyXG4gICAgY29uc3QgdWEgPSB1c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcclxuICAgIHJldHVybiAodWEuaW5jbHVkZXMoJ3NhZmFyaS8nKSAmJlxyXG4gICAgICAgICF1YS5pbmNsdWRlcygnY2hyb21lLycpICYmXHJcbiAgICAgICAgIXVhLmluY2x1ZGVzKCdjcmlvcy8nKSAmJlxyXG4gICAgICAgICF1YS5pbmNsdWRlcygnYW5kcm9pZCcpKTtcclxufVxyXG5mdW5jdGlvbiBfaXNDaHJvbWVJT1ModWEgPSBnZXRVQSgpKSB7XHJcbiAgICByZXR1cm4gL2NyaW9zXFwvL2kudGVzdCh1YSk7XHJcbn1cclxuZnVuY3Rpb24gX2lzSUVNb2JpbGUodWEgPSBnZXRVQSgpKSB7XHJcbiAgICByZXR1cm4gL2llbW9iaWxlL2kudGVzdCh1YSk7XHJcbn1cclxuZnVuY3Rpb24gX2lzQW5kcm9pZCh1YSA9IGdldFVBKCkpIHtcclxuICAgIHJldHVybiAvYW5kcm9pZC9pLnRlc3QodWEpO1xyXG59XHJcbmZ1bmN0aW9uIF9pc0JsYWNrQmVycnkodWEgPSBnZXRVQSgpKSB7XHJcbiAgICByZXR1cm4gL2JsYWNrYmVycnkvaS50ZXN0KHVhKTtcclxufVxyXG5mdW5jdGlvbiBfaXNXZWJPUyh1YSA9IGdldFVBKCkpIHtcclxuICAgIHJldHVybiAvd2Vib3MvaS50ZXN0KHVhKTtcclxufVxyXG5mdW5jdGlvbiBfaXNJT1ModWEgPSBnZXRVQSgpKSB7XHJcbiAgICByZXR1cm4gKC9pcGhvbmV8aXBhZHxpcG9kL2kudGVzdCh1YSkgfHxcclxuICAgICAgICAoL21hY2ludG9zaC9pLnRlc3QodWEpICYmIC9tb2JpbGUvaS50ZXN0KHVhKSkpO1xyXG59XHJcbmZ1bmN0aW9uIF9pc0lPUzdPcjgodWEgPSBnZXRVQSgpKSB7XHJcbiAgICByZXR1cm4gKC8oaVBhZHxpUGhvbmV8aVBvZCkuKk9TIDdfXFxkL2kudGVzdCh1YSkgfHxcclxuICAgICAgICAvKGlQYWR8aVBob25lfGlQb2QpLipPUyA4X1xcZC9pLnRlc3QodWEpKTtcclxufVxyXG5mdW5jdGlvbiBfaXNJRTEwKCkge1xyXG4gICAgcmV0dXJuIGlzSUUoKSAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPT09IDEwO1xyXG59XHJcbmZ1bmN0aW9uIF9pc01vYmlsZUJyb3dzZXIodWEgPSBnZXRVQSgpKSB7XHJcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgZ2V0QnJvd3Nlck5hbWUgZXF1aXZhbGVudCBmb3IgT1MuXHJcbiAgICByZXR1cm4gKF9pc0lPUyh1YSkgfHxcclxuICAgICAgICBfaXNBbmRyb2lkKHVhKSB8fFxyXG4gICAgICAgIF9pc1dlYk9TKHVhKSB8fFxyXG4gICAgICAgIF9pc0JsYWNrQmVycnkodWEpIHx8XHJcbiAgICAgICAgL3dpbmRvd3MgcGhvbmUvaS50ZXN0KHVhKSB8fFxyXG4gICAgICAgIF9pc0lFTW9iaWxlKHVhKSk7XHJcbn1cclxuZnVuY3Rpb24gX2lzSWZyYW1lKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBjdXJyZW50IHdpbmRvdyBpcyBub3QgdGhlIHRvcCB3aW5kb3cuXHJcbiAgICAgICAgLy8gSWYgc28sIHJldHVybiB0cnVlLlxyXG4gICAgICAgIHJldHVybiAhISh3aW5kb3cgJiYgd2luZG93ICE9PSB3aW5kb3cudG9wKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qXHJcbiAqIERldGVybWluZSB0aGUgU0RLIHZlcnNpb24gc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0Q2xpZW50VmVyc2lvbihjbGllbnRQbGF0Zm9ybSwgZnJhbWV3b3JrcyA9IFtdKSB7XHJcbiAgICBsZXQgcmVwb3J0ZWRQbGF0Zm9ybTtcclxuICAgIHN3aXRjaCAoY2xpZW50UGxhdGZvcm0pIHtcclxuICAgICAgICBjYXNlIFwiQnJvd3NlclwiIC8qIENsaWVudFBsYXRmb3JtLkJST1dTRVIgKi86XHJcbiAgICAgICAgICAgIC8vIEluIGEgYnJvd3NlciBlbnZpcm9ubWVudCwgcmVwb3J0IHRoZSBicm93c2VyIG5hbWUuXHJcbiAgICAgICAgICAgIHJlcG9ydGVkUGxhdGZvcm0gPSBfZ2V0QnJvd3Nlck5hbWUoZ2V0VUEoKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJXb3JrZXJcIiAvKiBDbGllbnRQbGF0Zm9ybS5XT1JLRVIgKi86XHJcbiAgICAgICAgICAgIC8vIFRlY2huaWNhbGx5IGEgd29ya2VyIHJ1bnMgZnJvbSBhIGJyb3dzZXIgYnV0IHdlIG5lZWQgdG8gZGlmZmVyZW50aWF0ZSBhXHJcbiAgICAgICAgICAgIC8vIHdvcmtlciBmcm9tIGEgYnJvd3Nlci5cclxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IENocm9tZS1Xb3JrZXIvSnNDb3JlLzQuOS4xL0ZpcmViYXNlQ29yZS13ZWIuXHJcbiAgICAgICAgICAgIHJlcG9ydGVkUGxhdGZvcm0gPSBgJHtfZ2V0QnJvd3Nlck5hbWUoZ2V0VUEoKSl9LSR7Y2xpZW50UGxhdGZvcm19YDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmVwb3J0ZWRQbGF0Zm9ybSA9IGNsaWVudFBsYXRmb3JtO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVwb3J0ZWRGcmFtZXdvcmtzID0gZnJhbWV3b3Jrcy5sZW5ndGhcclxuICAgICAgICA/IGZyYW1ld29ya3Muam9pbignLCcpXHJcbiAgICAgICAgOiAnRmlyZWJhc2VDb3JlLXdlYic7IC8qIGRlZmF1bHQgdmFsdWUgaWYgbm8gb3RoZXIgZnJhbWV3b3JrIGlzIHVzZWQgKi9cclxuICAgIHJldHVybiBgJHtyZXBvcnRlZFBsYXRmb3JtfS8ke1wiSnNDb3JlXCIgLyogQ2xpZW50SW1wbGVtZW50YXRpb24uQ09SRSAqL30vJHtTREtfVkVSU0lPTn0vJHtyZXBvcnRlZEZyYW1ld29ya3N9YDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBBdXRoTWlkZGxld2FyZVF1ZXVlIHtcclxuICAgIGNvbnN0cnVjdG9yKGF1dGgpIHtcclxuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xyXG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcclxuICAgIH1cclxuICAgIHB1c2hDYWxsYmFjayhjYWxsYmFjaywgb25BYm9ydCkge1xyXG4gICAgICAgIC8vIFRoZSBjYWxsYmFjayBjb3VsZCBiZSBzeW5jIG9yIGFzeW5jLiBXcmFwIGl0IGludG8gYVxyXG4gICAgICAgIC8vIGZ1bmN0aW9uIHRoYXQgaXMgYWx3YXlzIGFzeW5jLlxyXG4gICAgICAgIGNvbnN0IHdyYXBwZWRDYWxsYmFjayA9ICh1c2VyKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYWxsYmFjayh1c2VyKTtcclxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciByZXNvbHZlIHdpdGggZXhpc3RpbmcgcHJvbWlzZSBvciB3cmFwIGEgbm9uLXByb21pc2VcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSBpbnRvIGEgcHJvbWlzZS5cclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU3luYyBjYWxsYmFjayB0aHJvd3MuXHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBBdHRhY2ggdGhlIG9uQWJvcnQgaWYgcHJlc2VudFxyXG4gICAgICAgIHdyYXBwZWRDYWxsYmFjay5vbkFib3J0ID0gb25BYm9ydDtcclxuICAgICAgICB0aGlzLnF1ZXVlLnB1c2god3JhcHBlZENhbGxiYWNrKTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucXVldWUubGVuZ3RoIC0gMTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBVbnN1YnNjcmliZS4gUmVwbGFjZSB3aXRoIG5vLW9wLiBEbyBub3QgcmVtb3ZlIGZyb20gYXJyYXksIG9yIGl0IHdpbGwgZGlzdHVyYlxyXG4gICAgICAgICAgICAvLyBpbmRleGluZyBvZiBvdGhlciBlbGVtZW50cy5cclxuICAgICAgICAgICAgdGhpcy5xdWV1ZVtpbmRleF0gPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcnVuTWlkZGxld2FyZShuZXh0VXNlcikge1xyXG4gICAgICAgIGlmICh0aGlzLmF1dGguY3VycmVudFVzZXIgPT09IG5leHRVc2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2hpbGUgcnVubmluZyB0aGUgbWlkZGxld2FyZSwgYnVpbGQgYSB0ZW1wb3Jhcnkgc3RhY2sgb2Ygb25BYm9ydFxyXG4gICAgICAgIC8vIGNhbGxiYWNrcyB0byBjYWxsIGlmIG9uZSBtaWRkbGV3YXJlIGNhbGxiYWNrIHJlamVjdHMuXHJcbiAgICAgICAgY29uc3Qgb25BYm9ydFN0YWNrID0gW107XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBiZWZvcmVTdGF0ZUNhbGxiYWNrIG9mIHRoaXMucXVldWUpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGJlZm9yZVN0YXRlQ2FsbGJhY2sobmV4dFVzZXIpO1xyXG4gICAgICAgICAgICAgICAgLy8gT25seSBwdXNoIHRoZSBvbkFib3J0IGlmIHRoZSBjYWxsYmFjayBzdWNjZWVkc1xyXG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZVN0YXRlQ2FsbGJhY2sub25BYm9ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uQWJvcnRTdGFjay5wdXNoKGJlZm9yZVN0YXRlQ2FsbGJhY2sub25BYm9ydCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gUnVuIGFsbCBvbkFib3J0LCB3aXRoIHNlcGFyYXRlIHRyeS9jYXRjaCB0byBpZ25vcmUgYW55IGVycm9ycyBhbmRcclxuICAgICAgICAgICAgLy8gY29udGludWVcclxuICAgICAgICAgICAgb25BYm9ydFN0YWNrLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBvbkFib3J0IG9mIG9uQWJvcnRTdGFjaykge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBvbkFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoXykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIHN3YWxsb3cgZXJyb3IgKi9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyB0aGlzLmF1dGguX2Vycm9yRmFjdG9yeS5jcmVhdGUoXCJsb2dpbi1ibG9ja2VkXCIgLyogQXV0aEVycm9yQ29kZS5MT0dJTl9CTE9DS0VEICovLCB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE1lc3NhZ2U6IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRmV0Y2hlcyB0aGUgcGFzc3dvcmQgcG9saWN5IGZvciB0aGUgY3VycmVudGx5IHNldCB0ZW5hbnQgb3IgdGhlIHByb2plY3QgaWYgbm8gdGVuYW50IGlzIHNldC5cclxuICpcclxuICogQHBhcmFtIGF1dGggQXV0aCBvYmplY3QuXHJcbiAqIEBwYXJhbSByZXF1ZXN0IFBhc3N3b3JkIHBvbGljeSByZXF1ZXN0LlxyXG4gKiBAcmV0dXJucyBQYXNzd29yZCBwb2xpY3kgcmVzcG9uc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBfZ2V0UGFzc3dvcmRQb2xpY3koYXV0aCwgcmVxdWVzdCA9IHt9KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiR0VUXCIgLyogSHR0cE1ldGhvZC5HRVQgKi8sIFwiL3YyL3Bhc3N3b3JkUG9saWN5XCIgLyogRW5kcG9pbnQuR0VUX1BBU1NXT1JEX1BPTElDWSAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBNaW5pbXVtIG1pbiBwYXNzd29yZCBsZW5ndGggZW5mb3JjZWQgYnkgdGhlIGJhY2tlbmQsIGV2ZW4gaWYgbm8gbWluaW11bSBsZW5ndGggaXMgc2V0LlxyXG5jb25zdCBNSU5JTVVNX01JTl9QQVNTV09SRF9MRU5HVEggPSA2O1xyXG4vKipcclxuICogU3RvcmVzIHBhc3N3b3JkIHBvbGljeSByZXF1aXJlbWVudHMgYW5kIHByb3ZpZGVzIHBhc3N3b3JkIHZhbGlkYXRpb24gYWdhaW5zdCB0aGUgcG9saWN5LlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFBhc3N3b3JkUG9saWN5SW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICAvLyBPbmx5IGluY2x1ZGUgY3VzdG9tIHN0cmVuZ3RoIG9wdGlvbnMgZGVmaW5lZCBpbiB0aGUgcmVzcG9uc2UuXHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2VPcHRpb25zID0gcmVzcG9uc2UuY3VzdG9tU3RyZW5ndGhPcHRpb25zO1xyXG4gICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zID0ge307XHJcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIG9uY2UgdGhlIGJhY2tlbmQgaXMgdXBkYXRlZCB0byBpbmNsdWRlIHRoZSBtaW5pbXVtIG1pbiBwYXNzd29yZCBsZW5ndGggaW5zdGVhZCBvZiB1bmRlZmluZWQgd2hlbiB0aGVyZSBpcyBubyBtaW5pbXVtIGxlbmd0aCBzZXQuXHJcbiAgICAgICAgdGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMubWluUGFzc3dvcmRMZW5ndGggPVxyXG4gICAgICAgICAgICAoX2EgPSByZXNwb25zZU9wdGlvbnMubWluUGFzc3dvcmRMZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IE1JTklNVU1fTUlOX1BBU1NXT1JEX0xFTkdUSDtcclxuICAgICAgICBpZiAocmVzcG9uc2VPcHRpb25zLm1heFBhc3N3b3JkTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLm1heFBhc3N3b3JkTGVuZ3RoID1cclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucy5tYXhQYXNzd29yZExlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5jb250YWluc0xvd2VyY2FzZUNoYXJhY3RlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTG93ZXJjYXNlTGV0dGVyID1cclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucy5jb250YWluc0xvd2VyY2FzZUNoYXJhY3RlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5jb250YWluc1VwcGVyY2FzZUNoYXJhY3RlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zVXBwZXJjYXNlTGV0dGVyID1cclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucy5jb250YWluc1VwcGVyY2FzZUNoYXJhY3RlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5jb250YWluc051bWVyaWNDaGFyYWN0ZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc051bWVyaWNDaGFyYWN0ZXIgPVxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VPcHRpb25zLmNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyID1cclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbmZvcmNlbWVudFN0YXRlID0gcmVzcG9uc2UuZW5mb3JjZW1lbnRTdGF0ZTtcclxuICAgICAgICBpZiAodGhpcy5lbmZvcmNlbWVudFN0YXRlID09PSAnRU5GT1JDRU1FTlRfU1RBVEVfVU5TUEVDSUZJRUQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5mb3JjZW1lbnRTdGF0ZSA9ICdPRkYnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVc2UgYW4gZW1wdHkgc3RyaW5nIGlmIG5vIG5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhcmUgc3BlY2lmaWVkIGluIHRoZSByZXNwb25zZS5cclxuICAgICAgICB0aGlzLmFsbG93ZWROb25BbHBoYW51bWVyaWNDaGFyYWN0ZXJzID1cclxuICAgICAgICAgICAgKF9jID0gKF9iID0gcmVzcG9uc2UuYWxsb3dlZE5vbkFscGhhbnVtZXJpY0NoYXJhY3RlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5qb2luKCcnKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJyc7XHJcbiAgICAgICAgdGhpcy5mb3JjZVVwZ3JhZGVPblNpZ25pbiA9IChfZCA9IHJlc3BvbnNlLmZvcmNlVXBncmFkZU9uU2lnbmluKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBmYWxzZTtcclxuICAgICAgICB0aGlzLnNjaGVtYVZlcnNpb24gPSByZXNwb25zZS5zY2hlbWFWZXJzaW9uO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVQYXNzd29yZChwYXNzd29yZCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHtcclxuICAgICAgICAgICAgaXNWYWxpZDogdHJ1ZSxcclxuICAgICAgICAgICAgcGFzc3dvcmRQb2xpY3k6IHRoaXNcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIENoZWNrIHRoZSBwYXNzd29yZCBsZW5ndGggYW5kIGNoYXJhY3RlciBvcHRpb25zLlxyXG4gICAgICAgIHRoaXMudmFsaWRhdGVQYXNzd29yZExlbmd0aE9wdGlvbnMocGFzc3dvcmQsIHN0YXR1cyk7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZVBhc3N3b3JkQ2hhcmFjdGVyT3B0aW9ucyhwYXNzd29yZCwgc3RhdHVzKTtcclxuICAgICAgICAvLyBDb21iaW5lIHRoZSBzdGF0dXMgaW50byBzaW5nbGUgaXNWYWxpZCBwcm9wZXJ0eS5cclxuICAgICAgICBzdGF0dXMuaXNWYWxpZCAmJiAoc3RhdHVzLmlzVmFsaWQgPSAoX2EgPSBzdGF0dXMubWVldHNNaW5QYXNzd29yZExlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSk7XHJcbiAgICAgICAgc3RhdHVzLmlzVmFsaWQgJiYgKHN0YXR1cy5pc1ZhbGlkID0gKF9iID0gc3RhdHVzLm1lZXRzTWF4UGFzc3dvcmRMZW5ndGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUpO1xyXG4gICAgICAgIHN0YXR1cy5pc1ZhbGlkICYmIChzdGF0dXMuaXNWYWxpZCA9IChfYyA9IHN0YXR1cy5jb250YWluc0xvd2VyY2FzZUxldHRlcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdHJ1ZSk7XHJcbiAgICAgICAgc3RhdHVzLmlzVmFsaWQgJiYgKHN0YXR1cy5pc1ZhbGlkID0gKF9kID0gc3RhdHVzLmNvbnRhaW5zVXBwZXJjYXNlTGV0dGVyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0cnVlKTtcclxuICAgICAgICBzdGF0dXMuaXNWYWxpZCAmJiAoc3RhdHVzLmlzVmFsaWQgPSAoX2UgPSBzdGF0dXMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0cnVlKTtcclxuICAgICAgICBzdGF0dXMuaXNWYWxpZCAmJiAoc3RhdHVzLmlzVmFsaWQgPSAoX2YgPSBzdGF0dXMuY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHRydWUpO1xyXG4gICAgICAgIHJldHVybiBzdGF0dXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBwYXNzd29yZCBtZWV0cyB0aGUgbGVuZ3RoIG9wdGlvbnMgZm9yIHRoZSBwb2xpY3kuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIFBhc3N3b3JkIHRvIHZhbGlkYXRlLlxyXG4gICAgICogQHBhcmFtIHN0YXR1cyBWYWxpZGF0aW9uIHN0YXR1cy5cclxuICAgICAqL1xyXG4gICAgdmFsaWRhdGVQYXNzd29yZExlbmd0aE9wdGlvbnMocGFzc3dvcmQsIHN0YXR1cykge1xyXG4gICAgICAgIGNvbnN0IG1pblBhc3N3b3JkTGVuZ3RoID0gdGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMubWluUGFzc3dvcmRMZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbWF4UGFzc3dvcmRMZW5ndGggPSB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5tYXhQYXNzd29yZExlbmd0aDtcclxuICAgICAgICBpZiAobWluUGFzc3dvcmRMZW5ndGgpIHtcclxuICAgICAgICAgICAgc3RhdHVzLm1lZXRzTWluUGFzc3dvcmRMZW5ndGggPSBwYXNzd29yZC5sZW5ndGggPj0gbWluUGFzc3dvcmRMZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXhQYXNzd29yZExlbmd0aCkge1xyXG4gICAgICAgICAgICBzdGF0dXMubWVldHNNYXhQYXNzd29yZExlbmd0aCA9IHBhc3N3b3JkLmxlbmd0aCA8PSBtYXhQYXNzd29yZExlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBwYXNzd29yZCBtZWV0cyB0aGUgY2hhcmFjdGVyIG9wdGlvbnMgZm9yIHRoZSBwb2xpY3kuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIFBhc3N3b3JkIHRvIHZhbGlkYXRlLlxyXG4gICAgICogQHBhcmFtIHN0YXR1cyBWYWxpZGF0aW9uIHN0YXR1cy5cclxuICAgICAqL1xyXG4gICAgdmFsaWRhdGVQYXNzd29yZENoYXJhY3Rlck9wdGlvbnMocGFzc3dvcmQsIHN0YXR1cykge1xyXG4gICAgICAgIC8vIEFzc2lnbiBzdGF0dXNlcyBmb3IgcmVxdWlyZW1lbnRzIGV2ZW4gaWYgdGhlIHBhc3N3b3JkIGlzIGFuIGVtcHR5IHN0cmluZy5cclxuICAgICAgICB0aGlzLnVwZGF0ZVBhc3N3b3JkQ2hhcmFjdGVyT3B0aW9uc1N0YXR1c2VzKHN0YXR1cywgXHJcbiAgICAgICAgLyogY29udGFpbnNMb3dlcmNhc2VDaGFyYWN0ZXI9ICovIGZhbHNlLCBcclxuICAgICAgICAvKiBjb250YWluc1VwcGVyY2FzZUNoYXJhY3Rlcj0gKi8gZmFsc2UsIFxyXG4gICAgICAgIC8qIGNvbnRhaW5zTnVtZXJpY0NoYXJhY3Rlcj0gKi8gZmFsc2UsIFxyXG4gICAgICAgIC8qIGNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyPSAqLyBmYWxzZSk7XHJcbiAgICAgICAgbGV0IHBhc3N3b3JkQ2hhcjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhc3N3b3JkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhc3N3b3JkQ2hhciA9IHBhc3N3b3JkLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVQYXNzd29yZENoYXJhY3Rlck9wdGlvbnNTdGF0dXNlcyhzdGF0dXMsIFxyXG4gICAgICAgICAgICAvKiBjb250YWluc0xvd2VyY2FzZUNoYXJhY3Rlcj0gKi8gcGFzc3dvcmRDaGFyID49ICdhJyAmJlxyXG4gICAgICAgICAgICAgICAgcGFzc3dvcmRDaGFyIDw9ICd6JywgXHJcbiAgICAgICAgICAgIC8qIGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyPSAqLyBwYXNzd29yZENoYXIgPj0gJ0EnICYmXHJcbiAgICAgICAgICAgICAgICBwYXNzd29yZENoYXIgPD0gJ1onLCBcclxuICAgICAgICAgICAgLyogY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyPSAqLyBwYXNzd29yZENoYXIgPj0gJzAnICYmXHJcbiAgICAgICAgICAgICAgICBwYXNzd29yZENoYXIgPD0gJzknLCBcclxuICAgICAgICAgICAgLyogY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXI9ICovIHRoaXMuYWxsb3dlZE5vbkFscGhhbnVtZXJpY0NoYXJhY3RlcnMuaW5jbHVkZXMocGFzc3dvcmRDaGFyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBydW5uaW5nIHZhbGlkYXRpb24gc3RhdHVzIHdpdGggdGhlIHN0YXR1c2VzIGZvciB0aGUgY2hhcmFjdGVyIG9wdGlvbnMuXHJcbiAgICAgKiBFeHBlY3RlZCB0byBiZSBjYWxsZWQgZWFjaCB0aW1lIGEgY2hhcmFjdGVyIGlzIHByb2Nlc3NlZCB0byB1cGRhdGUgZWFjaCBvcHRpb24gc3RhdHVzXHJcbiAgICAgKiBiYXNlZCBvbiB0aGUgY3VycmVudCBjaGFyYWN0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXR1cyBWYWxpZGF0aW9uIHN0YXR1cy5cclxuICAgICAqIEBwYXJhbSBjb250YWluc0xvd2VyY2FzZUNoYXJhY3RlciBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgaXMgYSBsb3dlcmNhc2UgbGV0dGVyLlxyXG4gICAgICogQHBhcmFtIGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyIFdoZXRoZXIgdGhlIGNoYXJhY3RlciBpcyBhbiB1cHBlcmNhc2UgbGV0dGVyLlxyXG4gICAgICogQHBhcmFtIGNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlciBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgaXMgYSBudW1lcmljIGNoYXJhY3Rlci5cclxuICAgICAqIEBwYXJhbSBjb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlciBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgaXMgYSBub24tYWxwaGFudW1lcmljIGNoYXJhY3Rlci5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlUGFzc3dvcmRDaGFyYWN0ZXJPcHRpb25zU3RhdHVzZXMoc3RhdHVzLCBjb250YWluc0xvd2VyY2FzZUNoYXJhY3RlciwgY29udGFpbnNVcHBlcmNhc2VDaGFyYWN0ZXIsIGNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlciwgY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMuY29udGFpbnNMb3dlcmNhc2VMZXR0ZXIpIHtcclxuICAgICAgICAgICAgc3RhdHVzLmNvbnRhaW5zTG93ZXJjYXNlTGV0dGVyIHx8IChzdGF0dXMuY29udGFpbnNMb3dlcmNhc2VMZXR0ZXIgPSBjb250YWluc0xvd2VyY2FzZUNoYXJhY3Rlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc1VwcGVyY2FzZUxldHRlcikge1xyXG4gICAgICAgICAgICBzdGF0dXMuY29udGFpbnNVcHBlcmNhc2VMZXR0ZXIgfHwgKHN0YXR1cy5jb250YWluc1VwcGVyY2FzZUxldHRlciA9IGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTnVtZXJpY0NoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICBzdGF0dXMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyIHx8IChzdGF0dXMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyID0gY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICAgIHN0YXR1cy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlciB8fCAoc3RhdHVzLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyID0gY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBBdXRoSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIGhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlciwgYXBwQ2hlY2tTZXJ2aWNlUHJvdmlkZXIsIGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xyXG4gICAgICAgIHRoaXMuaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyID0gaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tTZXJ2aWNlUHJvdmlkZXIgPSBhcHBDaGVja1NlcnZpY2VQcm92aWRlcjtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICB0aGlzLmN1cnJlbnRVc2VyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVtdWxhdG9yQ29uZmlnID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbnMgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB0aGlzLmF1dGhTdGF0ZVN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24odGhpcyk7XHJcbiAgICAgICAgdGhpcy5pZFRva2VuU3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbih0aGlzKTtcclxuICAgICAgICB0aGlzLmJlZm9yZVN0YXRlUXVldWUgPSBuZXcgQXV0aE1pZGRsZXdhcmVRdWV1ZSh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlZGlyZWN0VXNlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pc1Byb2FjdGl2ZVJlZnJlc2hFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5FWFBFQ1RFRF9QQVNTV09SRF9QT0xJQ1lfU0NIRU1BX1ZFUlNJT04gPSAxO1xyXG4gICAgICAgIC8vIEFueSBuZXR3b3JrIGNhbGxzIHdpbGwgc2V0IHRoaXMgdG8gdHJ1ZSBhbmQgcHJldmVudCBzdWJzZXF1ZW50IGVtdWxhdG9yXHJcbiAgICAgICAgLy8gaW5pdGlhbGl6YXRpb25cclxuICAgICAgICB0aGlzLl9jYW5Jbml0RW11bGF0b3IgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9kZWxldGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2Vycm9yRmFjdG9yeSA9IF9ERUZBVUxUX0FVVEhfRVJST1JfRkFDVE9SWTtcclxuICAgICAgICB0aGlzLl9hZ2VudFJlY2FwdGNoYUNvbmZpZyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdGVuYW50UmVjYXB0Y2hhQ29uZmlncyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3Byb2plY3RQYXNzd29yZFBvbGljeSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdGVuYW50UGFzc3dvcmRQb2xpY2llcyA9IHt9O1xyXG4gICAgICAgIC8vIFRyYWNrcyB0aGUgbGFzdCBub3RpZmllZCBVSUQgZm9yIHN0YXRlIGNoYW5nZSBsaXN0ZW5lcnMgdG8gcHJldmVudFxyXG4gICAgICAgIC8vIHJlcGVhdGVkIGNhbGxzIHRvIHRoZSBjYWxsYmFja3MuIFVuZGVmaW5lZCBtZWFucyBpdCdzIG5ldmVyIGJlZW5cclxuICAgICAgICAvLyBjYWxsZWQsIHdoZXJlYXMgbnVsbCBtZWFucyBpdCdzIGJlZW4gY2FsbGVkIHdpdGggYSBzaWduZWQgb3V0IHVzZXJcclxuICAgICAgICB0aGlzLmxhc3ROb3RpZmllZFVpZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmxhbmd1YWdlQ29kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50ZW5hbnRJZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHsgYXBwVmVyaWZpY2F0aW9uRGlzYWJsZWRGb3JUZXN0aW5nOiBmYWxzZSB9O1xyXG4gICAgICAgIHRoaXMuZnJhbWV3b3JrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IGFwcC5uYW1lO1xyXG4gICAgICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IGNvbmZpZy5zZGtDbGllbnRWZXJzaW9uO1xyXG4gICAgfVxyXG4gICAgX2luaXRpYWxpemVXaXRoUGVyc2lzdGVuY2UocGVyc2lzdGVuY2VIaWVyYXJjaHksIHBvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xyXG4gICAgICAgIGlmIChwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyID0gX2dldEluc3RhbmNlKHBvcHVwUmVkaXJlY3RSZXNvbHZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGFwcCBkZWxldGlvbiB0aHJvdWdob3V0IGluaXRpYWxpemF0aW9uIChhZnRlciBlYWNoXHJcbiAgICAgICAgLy8gcHJvbWlzZSByZXNvbHV0aW9uKVxyXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemF0aW9uUHJvbWlzZSA9IHRoaXMucXVldWUoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGVyc2lzdGVuY2VNYW5hZ2VyID0gYXdhaXQgUGVyc2lzdGVuY2VVc2VyTWFuYWdlci5jcmVhdGUodGhpcywgcGVyc2lzdGVuY2VIaWVyYXJjaHkpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHJlc29sdmVyIGVhcmx5IGlmIG5lY2Vzc2FyeSAob25seSBhcHBsaWNhYmxlIHRvIHdlYjpcclxuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGNhdXNlIHRoZSBpZnJhbWUgdG8gbG9hZCBpbW1lZGlhdGVseSBpbiBjZXJ0YWluIGNhc2VzKVxyXG4gICAgICAgICAgICBpZiAoKF9hID0gdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX3Nob3VsZEluaXRQcm9hY3RpdmVseSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBmYWlscywgZG9uJ3QgaGFsdCBhdXRoIGxvYWRpbmdcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyLl9pbml0aWFsaXplKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvKiBJZ25vcmUgdGhlIGVycm9yICovXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplQ3VycmVudFVzZXIocG9wdXBSZWRpcmVjdFJlc29sdmVyKTtcclxuICAgICAgICAgICAgdGhpcy5sYXN0Tm90aWZpZWRVaWQgPSAoKF9iID0gdGhpcy5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnVpZCkgfHwgbnVsbDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgcGVyc2lzdGVuY2UgaXMgY2hhbmdlZCBpbiBhbm90aGVyIHdpbmRvdywgdGhlIHVzZXIgbWFuYWdlciB3aWxsIGxldCB1cyBrbm93XHJcbiAgICAgKi9cclxuICAgIGFzeW5jIF9vblN0b3JhZ2VFdmVudCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2UuZ2V0Q3VycmVudFVzZXIoKTtcclxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudFVzZXIgJiYgIXVzZXIpIHtcclxuICAgICAgICAgICAgLy8gTm8gY2hhbmdlLCBkbyBub3RoaW5nICh3YXMgc2lnbmVkIG91dCBhbmQgcmVtYWluZWQgc2lnbmVkIG91dCkuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlIHNhbWUgdXNlciBpcyB0byBiZSBzeW5jaHJvbml6ZWQuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIgJiYgdXNlciAmJiB0aGlzLmN1cnJlbnRVc2VyLnVpZCA9PT0gdXNlci51aWQpIHtcclxuICAgICAgICAgICAgLy8gRGF0YSB1cGRhdGUsIHNpbXBseSBjb3B5IGRhdGEgY2hhbmdlcy5cclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFVzZXIuX2Fzc2lnbih1c2VyKTtcclxuICAgICAgICAgICAgLy8gSWYgdG9rZW5zIGNoYW5nZWQgZnJvbSBwcmV2aW91cyB1c2VyIHRva2VucywgdGhpcyB3aWxsIHRyaWdnZXJcclxuICAgICAgICAgICAgLy8gbm90aWZ5QXV0aExpc3RlbmVyc18uXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3VycmVudFVzZXIuZ2V0SWRUb2tlbigpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBjdXJyZW50IEF1dGggc3RhdGUuIEVpdGhlciBhIG5ldyBsb2dpbiBvciBsb2dvdXQuXHJcbiAgICAgICAgLy8gU2tpcCBibG9ja2luZyBjYWxsYmFja3MsIHRoZXkgc2hvdWxkIG5vdCBhcHBseSB0byBhIGNoYW5nZSBpbiBhbm90aGVyIHRhYi5cclxuICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVDdXJyZW50VXNlcih1c2VyLCAvKiBza2lwQmVmb3JlU3RhdGVDYWxsYmFja3MgKi8gdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBpbml0aWFsaXplQ3VycmVudFVzZXJGcm9tSWRUb2tlbihpZFRva2VuKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRBY2NvdW50SW5mbyh0aGlzLCB7IGlkVG9rZW4gfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBVc2VySW1wbC5fZnJvbUdldEFjY291bnRJbmZvUmVzcG9uc2UodGhpcywgcmVzcG9uc2UsIGlkVG9rZW4pO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGaXJlYmFzZVNlcnZlckFwcCBjb3VsZCBub3QgbG9naW4gdXNlciB3aXRoIHByb3ZpZGVkIGF1dGhJZFRva2VuOiAnLCBlcnIpO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgaW5pdGlhbGl6ZUN1cnJlbnRVc2VyKHBvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAodGhpcy5hcHApKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkVG9rZW4gPSB0aGlzLmFwcC5zZXR0aW5ncy5hdXRoSWRUb2tlbjtcclxuICAgICAgICAgICAgaWYgKGlkVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBhdXRoIG9wZXJhdGlvbiBpbiB0aGUgbmV4dCB0aWNrIHRvIGFsbG93IGEgbW9tZW50IGZvciB0aGUgY3VzdG9tZXIncyBhcHAgdG9cclxuICAgICAgICAgICAgICAgIC8vIGF0dGFjaCBhbiBlbXVsYXRvciwgaWYgZGVzaXJlZC5cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaW5pdGlhbGl6ZUN1cnJlbnRVc2VyRnJvbUlkVG9rZW4oaWRUb2tlbikudGhlbihyZXNvbHZlLCByZXNvbHZlKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSBwZW5kaW5nIHJlZGlyZWN0IGV2ZW50LlxyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzbHlTdG9yZWRVc2VyID0gKGF3YWl0IHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5nZXRDdXJyZW50VXNlcigpKTtcclxuICAgICAgICBsZXQgZnV0dXJlQ3VycmVudFVzZXIgPSBwcmV2aW91c2x5U3RvcmVkVXNlcjtcclxuICAgICAgICBsZXQgbmVlZHNUb2NoZWNrTWlkZGxld2FyZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChwb3B1cFJlZGlyZWN0UmVzb2x2ZXIgJiYgdGhpcy5jb25maWcuYXV0aERvbWFpbikge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmdldE9ySW5pdFJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZGlyZWN0VXNlckV2ZW50SWQgPSAoX2EgPSB0aGlzLnJlZGlyZWN0VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9yZWRpcmVjdEV2ZW50SWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZFVzZXJFdmVudElkID0gZnV0dXJlQ3VycmVudFVzZXIgPT09IG51bGwgfHwgZnV0dXJlQ3VycmVudFVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZ1dHVyZUN1cnJlbnRVc2VyLl9yZWRpcmVjdEV2ZW50SWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudHJ5UmVkaXJlY3RTaWduSW4ocG9wdXBSZWRpcmVjdFJlc29sdmVyKTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCB1c2VyIChpLmUuIHRoZSBvbGQgXCJjdXJyZW50VXNlclwiKSBoYXMgYSByZWRpcmVjdElkIHRoYXRcclxuICAgICAgICAgICAgLy8gbWF0Y2hlcyB0aGUgcmVkaXJlY3QgdXNlciwgdGhlbiB3ZSB3YW50IHRvIGluaXRpYWxseSBzaWduIGluIHdpdGggdGhlXHJcbiAgICAgICAgICAgIC8vIG5ldyB1c2VyIG9iamVjdCBmcm9tIHJlc3VsdC5cclxuICAgICAgICAgICAgLy8gVE9ETyhzYW1naG8pOiBNb3JlIHRob3JvdWdobHkgdGVzdCBhbGwgb2YgdGhpc1xyXG4gICAgICAgICAgICBpZiAoKCFyZWRpcmVjdFVzZXJFdmVudElkIHx8IHJlZGlyZWN0VXNlckV2ZW50SWQgPT09IHN0b3JlZFVzZXJFdmVudElkKSAmJlxyXG4gICAgICAgICAgICAgICAgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdC51c2VyKSkge1xyXG4gICAgICAgICAgICAgICAgZnV0dXJlQ3VycmVudFVzZXIgPSByZXN1bHQudXNlcjtcclxuICAgICAgICAgICAgICAgIG5lZWRzVG9jaGVja01pZGRsZXdhcmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIG5vIHVzZXIgaW4gcGVyc2lzdGVuY2UsIHRoZXJlIGlzIG5vIGN1cnJlbnQgdXNlci4gU2V0IHRvIG51bGwuXHJcbiAgICAgICAgaWYgKCFmdXR1cmVDdXJyZW50VXNlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWZ1dHVyZUN1cnJlbnRVc2VyLl9yZWRpcmVjdEV2ZW50SWQpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBpc24ndCBhIHJlZGlyZWN0IGxpbmsgb3BlcmF0aW9uLCB3ZSBjYW4gcmVsb2FkIGFuZCBiYWlsLlxyXG4gICAgICAgICAgICAvLyBGaXJzdCB0aG91Z2gsIGVuc3VyZSB0aGF0IHdlIGNoZWNrIHRoZSBtaWRkbGV3YXJlIGlzIGhhcHB5LlxyXG4gICAgICAgICAgICBpZiAobmVlZHNUb2NoZWNrTWlkZGxld2FyZSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmJlZm9yZVN0YXRlUXVldWUucnVuTWlkZGxld2FyZShmdXR1cmVDdXJyZW50VXNlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1dHVyZUN1cnJlbnRVc2VyID0gcHJldmlvdXNseVN0b3JlZFVzZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Uga25vdyB0aGlzIGlzIGF2YWlsYWJsZSBzaW5jZSB0aGUgYml0IGlzIG9ubHkgc2V0IHdoZW4gdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzb2x2ZXIgaXMgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyLl9vdmVycmlkZVJlZGlyZWN0UmVzdWx0KHRoaXMsICgpID0+IFByb21pc2UucmVqZWN0KGUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZnV0dXJlQ3VycmVudFVzZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbG9hZEFuZFNldEN1cnJlbnRVc2VyT3JDbGVhcihmdXR1cmVDdXJyZW50VXNlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9hc3NlcnQodGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyLCB0aGlzLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5nZXRPckluaXRSZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlcigpO1xyXG4gICAgICAgIC8vIElmIHRoZSByZWRpcmVjdCB1c2VyJ3MgZXZlbnQgSUQgbWF0Y2hlcyB0aGUgY3VycmVudCB1c2VyJ3MgZXZlbnQgSUQsXHJcbiAgICAgICAgLy8gRE8gTk9UIHJlbG9hZCB0aGUgY3VycmVudCB1c2VyLCBvdGhlcndpc2UgdGhleSdsbCBiZSBjbGVhcmVkIGZyb20gc3RvcmFnZS5cclxuICAgICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBmb3IgdGhlIHJlYXV0aGVudGljYXRlV2l0aFJlZGlyZWN0KCkgZmxvdy5cclxuICAgICAgICBpZiAodGhpcy5yZWRpcmVjdFVzZXIgJiZcclxuICAgICAgICAgICAgdGhpcy5yZWRpcmVjdFVzZXIuX3JlZGlyZWN0RXZlbnRJZCA9PT0gZnV0dXJlQ3VycmVudFVzZXIuX3JlZGlyZWN0RXZlbnRJZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKGZ1dHVyZUN1cnJlbnRVc2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsb2FkQW5kU2V0Q3VycmVudFVzZXJPckNsZWFyKGZ1dHVyZUN1cnJlbnRVc2VyKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHRyeVJlZGlyZWN0U2lnbkluKHJlZGlyZWN0UmVzb2x2ZXIpIHtcclxuICAgICAgICAvLyBUaGUgcmVkaXJlY3QgdXNlciBuZWVkcyB0byBiZSBjaGVja2VkIChhbmQgc2lnbmVkIGluIGlmIGF2YWlsYWJsZSlcclxuICAgICAgICAvLyBkdXJpbmcgYXV0aCBpbml0aWFsaXphdGlvbi4gQWxsIG9mIHRoZSBub3JtYWwgc2lnbiBpbiBhbmQgbGluay9yZWF1dGhcclxuICAgICAgICAvLyBmbG93cyBjYWxsIGJhY2sgaW50byBhdXRoIGFuZCBwdXNoIHRoaW5ncyBvbnRvIHRoZSBwcm9taXNlIHF1ZXVlLiBXZVxyXG4gICAgICAgIC8vIG5lZWQgdG8gYXdhaXQgdGhlIHJlc3VsdCBvZiB0aGUgcmVkaXJlY3Qgc2lnbiBpbiAqaW5zaWRlIHRoZSBwcm9taXNlXHJcbiAgICAgICAgLy8gcXVldWUqLiBUaGlzIHByZXNlbnRzIGEgcHJvYmxlbTogd2UgcnVuIGludG8gZGVhZGxvY2suIFNlZTpcclxuICAgICAgICAvLyAgICDilIw+IFtJbml0aWFsaXphdGlvbl0g4pSA4pSA4pSA4pSA4pSA4pSQXHJcbiAgICAgICAgLy8gICAg4pSMPiBbPG90aGVyIHF1ZXVlIHRhc2tzPl0g4pSCXHJcbiAgICAgICAgLy8gICAg4pSU4pSAIFtnZXRSZWRpcmVjdFJlc3VsdF0gPOKUgOKUmFxyXG4gICAgICAgIC8vICAgIHdoZXJlIFtdIGFyZSB0YXNrcyBvbiB0aGUgcXVldWUgYW5kIGFycm93cyBkZW5vdGUgYXdhaXRzXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6YXRpb24gd2lsbCBuZXZlciBjb21wbGV0ZSBiZWNhdXNlIGl0J3Mgd2FpdGluZyBvbiBzb21ldGhpbmdcclxuICAgICAgICAvLyB0aGF0J3Mgd2FpdGluZyBmb3IgaW5pdGlhbGl6YXRpb24gdG8gY29tcGxldGUhXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBJbnN0ZWFkLCB0aGlzIG1ldGhvZCBjYWxscyBnZXRSZWRpcmVjdFJlc3VsdCgpIChzdG9yZWQgaW5cclxuICAgICAgICAvLyBfY29tcGxldGVSZWRpcmVjdEZuKSB3aXRoIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IGluc3RydWN0cyBhbGwgb2ZcclxuICAgICAgICAvLyB0aGUgdW5kZXJseWluZyBhdXRoIG9wZXJhdGlvbnMgdG8gc2tpcCBhbnl0aGluZyB0aGF0IG11dGF0ZXMgYXV0aCBzdGF0ZS5cclxuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBXZSBrbm93IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlciBpcyBzZXQgc2luY2UgcmVkaXJlY3RSZXNvbHZlclxyXG4gICAgICAgICAgICAvLyBpcyBwYXNzZWQgaW4uIFRoZSBfY29tcGxldGVSZWRpcmVjdEZuIGV4cGVjdHMgdGhlIHVud3JhcHBlZCBleHRlcm4uXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlci5fY29tcGxldGVSZWRpcmVjdEZuKHRoaXMsIHJlZGlyZWN0UmVzb2x2ZXIsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBTd2FsbG93IGFueSBlcnJvcnMgaGVyZTsgdGhlIGNvZGUgY2FuIHJldHJpZXZlIHRoZW0gaW5cclxuICAgICAgICAgICAgLy8gZ2V0UmVkaXJlY3RSZXN1bHQoKS5cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0UmVkaXJlY3RVc2VyKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcmVsb2FkQW5kU2V0Q3VycmVudFVzZXJPckNsZWFyKHVzZXIpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUuY29kZSkgIT09XHJcbiAgICAgICAgICAgICAgICBgYXV0aC8ke1wibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRCAqL31gKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcncyB3cm9uZyB3aXRoIHRoZSB1c2VyJ3MgdG9rZW4uIExvZyB0aGVtIG91dCBhbmQgcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVtIGZyb20gc3RvcmFnZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcihudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKHVzZXIpO1xyXG4gICAgfVxyXG4gICAgdXNlRGV2aWNlTGFuZ3VhZ2UoKSB7XHJcbiAgICAgICAgdGhpcy5sYW5ndWFnZUNvZGUgPSBfZ2V0VXNlckxhbmd1YWdlKCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfZGVsZXRlKCkge1xyXG4gICAgICAgIHRoaXMuX2RlbGV0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgdXBkYXRlQ3VycmVudFVzZXIodXNlckV4dGVybikge1xyXG4gICAgICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcCh0aGlzLmFwcCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhlIHB1YmxpYyB1cGRhdGVDdXJyZW50VXNlciBtZXRob2QgbmVlZHMgdG8gbWFrZSBhIGNvcHkgb2YgdGhlIHVzZXIsXHJcbiAgICAgICAgLy8gYW5kIGFsc28gY2hlY2sgdGhhdCB0aGUgcHJvamVjdCBtYXRjaGVzXHJcbiAgICAgICAgY29uc3QgdXNlciA9IHVzZXJFeHRlcm5cclxuICAgICAgICAgICAgPyBnZXRNb2R1bGFySW5zdGFuY2UodXNlckV4dGVybilcclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIGlmICh1c2VyKSB7XHJcbiAgICAgICAgICAgIF9hc3NlcnQodXNlci5hdXRoLmNvbmZpZy5hcGlLZXkgPT09IHRoaXMuY29uZmlnLmFwaUtleSwgdGhpcywgXCJpbnZhbGlkLXVzZXItdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVVUSCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVDdXJyZW50VXNlcih1c2VyICYmIHVzZXIuX2Nsb25lKHRoaXMpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIF91cGRhdGVDdXJyZW50VXNlcih1c2VyLCBza2lwQmVmb3JlU3RhdGVDYWxsYmFja3MgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kZWxldGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVzZXIpIHtcclxuICAgICAgICAgICAgX2Fzc2VydCh0aGlzLnRlbmFudElkID09PSB1c2VyLnRlbmFudElkLCB0aGlzLCBcInRlbmFudC1pZC1taXNtYXRjaFwiIC8qIEF1dGhFcnJvckNvZGUuVEVOQU5UX0lEX01JU01BVENIICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFza2lwQmVmb3JlU3RhdGVDYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5iZWZvcmVTdGF0ZVF1ZXVlLnJ1bk1pZGRsZXdhcmUodXNlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKHVzZXIpO1xyXG4gICAgICAgICAgICB0aGlzLm5vdGlmeUF1dGhMaXN0ZW5lcnMoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIHNpZ25PdXQoKSB7XHJcbiAgICAgICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKHRoaXMuYXBwKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSdW4gZmlyc3QsIHRvIGJsb2NrIF9zZXRSZWRpcmVjdFVzZXIoKSBpZiBhbnkgY2FsbGJhY2tzIGZhaWwuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5iZWZvcmVTdGF0ZVF1ZXVlLnJ1bk1pZGRsZXdhcmUobnVsbCk7XHJcbiAgICAgICAgLy8gQ2xlYXIgdGhlIHJlZGlyZWN0IHVzZXIgd2hlbiBzaWduT3V0IGlzIGNhbGxlZFxyXG4gICAgICAgIGlmICh0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyIHx8IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXRSZWRpcmVjdFVzZXIobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByZXZlbnQgY2FsbGJhY2tzIGZyb20gYmVpbmcgY2FsbGVkIGFnYWluIGluIF91cGRhdGVDdXJyZW50VXNlciwgYXNcclxuICAgICAgICAvLyB0aGV5IHdlcmUgYWxyZWFkeSBjYWxsZWQgaW4gdGhlIGZpcnN0IGxpbmUuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUN1cnJlbnRVc2VyKG51bGwsIC8qIHNraXBCZWZvcmVTdGF0ZUNhbGxiYWNrcyAqLyB0cnVlKTtcclxuICAgIH1cclxuICAgIHNldFBlcnNpc3RlbmNlKHBlcnNpc3RlbmNlKSB7XHJcbiAgICAgICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKHRoaXMuYXBwKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5zZXRQZXJzaXN0ZW5jZShfZ2V0SW5zdGFuY2UocGVyc2lzdGVuY2UpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9nZXRSZWNhcHRjaGFDb25maWcoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGVuYW50SWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWdlbnRSZWNhcHRjaGFDb25maWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVuYW50UmVjYXB0Y2hhQ29uZmlnc1t0aGlzLnRlbmFudElkXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyB2YWxpZGF0ZVBhc3N3b3JkKHBhc3N3b3JkKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9nZXRQYXNzd29yZFBvbGljeUludGVybmFsKCkpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlUGFzc3dvcmRQb2xpY3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUGFzc3dvcmQgcG9saWN5IHdpbGwgYmUgZGVmaW5lZCBhZnRlciBmZXRjaGluZy5cclxuICAgICAgICBjb25zdCBwYXNzd29yZFBvbGljeSA9IHRoaXMuX2dldFBhc3N3b3JkUG9saWN5SW50ZXJuYWwoKTtcclxuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBwb2xpY3kgc2NoZW1hIHZlcnNpb24gaXMgc3VwcG9ydGVkIGJ5IHRoZSBTREsuXHJcbiAgICAgICAgLy8gVE9ETzogVXBkYXRlIHRoaXMgbG9naWMgdG8gdXNlIGEgbWF4IHN1cHBvcnRlZCBwb2xpY3kgc2NoZW1hIHZlcnNpb24gb25jZSB3ZSBoYXZlIG11bHRpcGxlIHNjaGVtYSB2ZXJzaW9ucy5cclxuICAgICAgICBpZiAocGFzc3dvcmRQb2xpY3kuc2NoZW1hVmVyc2lvbiAhPT1cclxuICAgICAgICAgICAgdGhpcy5FWFBFQ1RFRF9QQVNTV09SRF9QT0xJQ1lfU0NIRU1BX1ZFUlNJT04pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuX2Vycm9yRmFjdG9yeS5jcmVhdGUoXCJ1bnN1cHBvcnRlZC1wYXNzd29yZC1wb2xpY3ktc2NoZW1hLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLlVOU1VQUE9SVEVEX1BBU1NXT1JEX1BPTElDWV9TQ0hFTUFfVkVSU0lPTiAqLywge30pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhc3N3b3JkUG9saWN5LnZhbGlkYXRlUGFzc3dvcmQocGFzc3dvcmQpO1xyXG4gICAgfVxyXG4gICAgX2dldFBhc3N3b3JkUG9saWN5SW50ZXJuYWwoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGVuYW50SWQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3RQYXNzd29yZFBvbGljeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZW5hbnRQYXNzd29yZFBvbGljaWVzW3RoaXMudGVuYW50SWRdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIF91cGRhdGVQYXNzd29yZFBvbGljeSgpIHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9nZXRQYXNzd29yZFBvbGljeSh0aGlzKTtcclxuICAgICAgICBjb25zdCBwYXNzd29yZFBvbGljeSA9IG5ldyBQYXNzd29yZFBvbGljeUltcGwocmVzcG9uc2UpO1xyXG4gICAgICAgIGlmICh0aGlzLnRlbmFudElkID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2plY3RQYXNzd29yZFBvbGljeSA9IHBhc3N3b3JkUG9saWN5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdGVuYW50UGFzc3dvcmRQb2xpY2llc1t0aGlzLnRlbmFudElkXSA9IHBhc3N3b3JkUG9saWN5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9nZXRQZXJzaXN0ZW5jZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hc3NlcnRlZFBlcnNpc3RlbmNlLnBlcnNpc3RlbmNlLnR5cGU7XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlRXJyb3JNYXAoZXJyb3JNYXApIHtcclxuICAgICAgICB0aGlzLl9lcnJvckZhY3RvcnkgPSBuZXcgRXJyb3JGYWN0b3J5KCdhdXRoJywgJ0ZpcmViYXNlJywgZXJyb3JNYXAoKSk7XHJcbiAgICB9XHJcbiAgICBvbkF1dGhTdGF0ZUNoYW5nZWQobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlclN0YXRlTGlzdGVuZXIodGhpcy5hdXRoU3RhdGVTdWJzY3JpcHRpb24sIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKTtcclxuICAgIH1cclxuICAgIGJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQoY2FsbGJhY2ssIG9uQWJvcnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTdGF0ZVF1ZXVlLnB1c2hDYWxsYmFjayhjYWxsYmFjaywgb25BYm9ydCk7XHJcbiAgICB9XHJcbiAgICBvbklkVG9rZW5DaGFuZ2VkKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJTdGF0ZUxpc3RlbmVyKHRoaXMuaWRUb2tlblN1YnNjcmlwdGlvbiwgbmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpO1xyXG4gICAgfVxyXG4gICAgYXV0aFN0YXRlUmVhZHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5vbkF1dGhTdGF0ZUNoYW5nZWQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXZva2VzIHRoZSBnaXZlbiBhY2Nlc3MgdG9rZW4uIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIEFwcGxlIE9BdXRoIGFjY2VzcyB0b2tlbnMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJldm9rZUFjY2Vzc1Rva2VuKHRva2VuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHRoaXMuY3VycmVudFVzZXIuZ2V0SWRUb2tlbigpO1xyXG4gICAgICAgICAgICAvLyBHZW5lcmFsaXplIHRoaXMgdG8gYWNjZXB0IG90aGVyIHByb3ZpZGVycyBvbmNlIHN1cHBvcnRlZC5cclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgIHByb3ZpZGVySWQ6ICdhcHBsZS5jb20nLFxyXG4gICAgICAgICAgICAgICAgdG9rZW5UeXBlOiBcIkFDQ0VTU19UT0tFTlwiIC8qIFRva2VuVHlwZS5BQ0NFU1NfVE9LRU4gKi8sXHJcbiAgICAgICAgICAgICAgICB0b2tlbixcclxuICAgICAgICAgICAgICAgIGlkVG9rZW5cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGVuYW50SWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC50ZW5hbnRJZCA9IHRoaXMudGVuYW50SWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXdhaXQgcmV2b2tlVG9rZW4odGhpcywgcmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMuY29uZmlnLmFwaUtleSxcclxuICAgICAgICAgICAgYXV0aERvbWFpbjogdGhpcy5jb25maWcuYXV0aERvbWFpbixcclxuICAgICAgICAgICAgYXBwTmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBjdXJyZW50VXNlcjogKF9hID0gdGhpcy5fY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0pTT04oKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBfc2V0UmVkaXJlY3RVc2VyKHVzZXIsIHBvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xyXG4gICAgICAgIGNvbnN0IHJlZGlyZWN0TWFuYWdlciA9IGF3YWl0IHRoaXMuZ2V0T3JJbml0UmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIocG9wdXBSZWRpcmVjdFJlc29sdmVyKTtcclxuICAgICAgICByZXR1cm4gdXNlciA9PT0gbnVsbFxyXG4gICAgICAgICAgICA/IHJlZGlyZWN0TWFuYWdlci5yZW1vdmVDdXJyZW50VXNlcigpXHJcbiAgICAgICAgICAgIDogcmVkaXJlY3RNYW5hZ2VyLnNldEN1cnJlbnRVc2VyKHVzZXIpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0T3JJbml0UmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIocG9wdXBSZWRpcmVjdFJlc29sdmVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gKHBvcHVwUmVkaXJlY3RSZXNvbHZlciAmJiBfZ2V0SW5zdGFuY2UocG9wdXBSZWRpcmVjdFJlc29sdmVyKSkgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlcjtcclxuICAgICAgICAgICAgX2Fzc2VydChyZXNvbHZlciwgdGhpcywgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xyXG4gICAgICAgICAgICB0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyID0gYXdhaXQgUGVyc2lzdGVuY2VVc2VyTWFuYWdlci5jcmVhdGUodGhpcywgW19nZXRJbnN0YW5jZShyZXNvbHZlci5fcmVkaXJlY3RQZXJzaXN0ZW5jZSldLCBcInJlZGlyZWN0VXNlclwiIC8qIEtleU5hbWUuUkVESVJFQ1RfVVNFUiAqLyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVkaXJlY3RVc2VyID1cclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIuZ2V0Q3VycmVudFVzZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfcmVkaXJlY3RVc2VyRm9ySWQoaWQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSd2ZSBjbGVhcmVkIGFueSBwZW5kaW5nIHBlcnNpc3RlbmNlIGFjdGlvbnMgaWYgd2UncmUgbm90IGluXHJcbiAgICAgICAgLy8gdGhlIGluaXRpYWxpemVyXHJcbiAgICAgICAgaWYgKHRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKChfYSA9IHRoaXMuX2N1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX3JlZGlyZWN0RXZlbnRJZCkgPT09IGlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VXNlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCgoX2IgPSB0aGlzLnJlZGlyZWN0VXNlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLl9yZWRpcmVjdEV2ZW50SWQpID09PSBpZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWRpcmVjdFVzZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgX3BlcnNpc3RVc2VySWZDdXJyZW50KHVzZXIpIHtcclxuICAgICAgICBpZiAodXNlciA9PT0gdGhpcy5jdXJyZW50VXNlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlcikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBOb3RpZmllcyBsaXN0ZW5lcnMgb25seSBpZiB0aGUgdXNlciBpcyBjdXJyZW50ICovXHJcbiAgICBfbm90aWZ5TGlzdGVuZXJzSWZDdXJyZW50KHVzZXIpIHtcclxuICAgICAgICBpZiAodXNlciA9PT0gdGhpcy5jdXJyZW50VXNlcikge1xyXG4gICAgICAgICAgICB0aGlzLm5vdGlmeUF1dGhMaXN0ZW5lcnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfa2V5KCkge1xyXG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbmZpZy5hdXRoRG9tYWlufToke3RoaXMuY29uZmlnLmFwaUtleX06JHt0aGlzLm5hbWV9YDtcclxuICAgIH1cclxuICAgIF9zdGFydFByb2FjdGl2ZVJlZnJlc2goKSB7XHJcbiAgICAgICAgdGhpcy5pc1Byb2FjdGl2ZVJlZnJlc2hFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50VXNlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VXNlci5fc3RhcnRQcm9hY3RpdmVSZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3N0b3BQcm9hY3RpdmVSZWZyZXNoKCkge1xyXG4gICAgICAgIHRoaXMuaXNQcm9hY3RpdmVSZWZyZXNoRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRVc2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRVc2VyLl9zdG9wUHJvYWN0aXZlUmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHRoZSBjdXJyZW50IHVzZXIgY2FzdCBhcyB0aGUgaW50ZXJuYWwgdHlwZSAqL1xyXG4gICAgZ2V0IF9jdXJyZW50VXNlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VXNlcjtcclxuICAgIH1cclxuICAgIG5vdGlmeUF1dGhMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlkVG9rZW5TdWJzY3JpcHRpb24ubmV4dCh0aGlzLmN1cnJlbnRVc2VyKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50VWlkID0gKF9iID0gKF9hID0gdGhpcy5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVpZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5sYXN0Tm90aWZpZWRVaWQgIT09IGN1cnJlbnRVaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0Tm90aWZpZWRVaWQgPSBjdXJyZW50VWlkO1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhTdGF0ZVN1YnNjcmlwdGlvbi5uZXh0KHRoaXMuY3VycmVudFVzZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZ2lzdGVyU3RhdGVMaXN0ZW5lcihzdWJzY3JpcHRpb24sIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2IgPSB0eXBlb2YgbmV4dE9yT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbidcclxuICAgICAgICAgICAgPyBuZXh0T3JPYnNlcnZlclxyXG4gICAgICAgICAgICA6IG5leHRPck9ic2VydmVyLm5leHQuYmluZChuZXh0T3JPYnNlcnZlcik7XHJcbiAgICAgICAgbGV0IGlzVW5zdWJzY3JpYmVkID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuX2lzSW5pdGlhbGl6ZWRcclxuICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoKVxyXG4gICAgICAgICAgICA6IHRoaXMuX2luaXRpYWxpemF0aW9uUHJvbWlzZTtcclxuICAgICAgICBfYXNzZXJ0KHByb21pc2UsIHRoaXMsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICAvLyBUaGUgY2FsbGJhY2sgbmVlZHMgdG8gYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5IHBlciB0aGUgc3BlYy5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICAgICAgcHJvbWlzZS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzVW5zdWJzY3JpYmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2IodGhpcy5jdXJyZW50VXNlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXh0T3JPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN1YnNjcmlwdGlvbi5hZGRPYnNlcnZlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpc1Vuc3Vic2NyaWJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdWJzY3JpcHRpb24uYWRkT2JzZXJ2ZXIobmV4dE9yT2JzZXJ2ZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaXNVbnN1YnNjcmliZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVucHJvdGVjdGVkIChmcm9tIHJhY2UgY29uZGl0aW9ucykgbWV0aG9kIHRvIHNldCB0aGUgY3VycmVudCB1c2VyLiBUaGlzXHJcbiAgICAgKiBzaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSB3aXRoaW4gYSBxdWV1ZWQgY2FsbGJhY2suIFRoaXMgaXMgbmVjZXNzYXJ5XHJcbiAgICAgKiBiZWNhdXNlIHRoZSBxdWV1ZSBzaG91bGRuJ3QgcmVseSBvbiBhbm90aGVyIHF1ZXVlZCBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZGlyZWN0bHlTZXRDdXJyZW50VXNlcih1c2VyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIgJiYgdGhpcy5jdXJyZW50VXNlciAhPT0gdXNlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VXNlci5fc3RvcFByb2FjdGl2ZVJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVzZXIgJiYgdGhpcy5pc1Byb2FjdGl2ZVJlZnJlc2hFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHVzZXIuX3N0YXJ0UHJvYWN0aXZlUmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1cnJlbnRVc2VyID0gdXNlcjtcclxuICAgICAgICBpZiAodXNlcikge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2Uuc2V0Q3VycmVudFVzZXIodXNlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2UucmVtb3ZlQ3VycmVudFVzZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBxdWV1ZShhY3Rpb24pIHtcclxuICAgICAgICAvLyBJbiBjYXNlIHNvbWV0aGluZyBlcnJvcnMsIHRoZSBjYWxsYmFjayBzdGlsbCBzaG91bGQgYmUgY2FsbGVkIGluIG9yZGVyXHJcbiAgICAgICAgLy8gdG8ga2VlcCB0aGUgcHJvbWlzZSBjaGFpbiBhbGl2ZVxyXG4gICAgICAgIHRoaXMub3BlcmF0aW9ucyA9IHRoaXMub3BlcmF0aW9ucy50aGVuKGFjdGlvbiwgYWN0aW9uKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zO1xyXG4gICAgfVxyXG4gICAgZ2V0IGFzc2VydGVkUGVyc2lzdGVuY2UoKSB7XHJcbiAgICAgICAgX2Fzc2VydCh0aGlzLnBlcnNpc3RlbmNlTWFuYWdlciwgdGhpcywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlTWFuYWdlcjtcclxuICAgIH1cclxuICAgIF9sb2dGcmFtZXdvcmsoZnJhbWV3b3JrKSB7XHJcbiAgICAgICAgaWYgKCFmcmFtZXdvcmsgfHwgdGhpcy5mcmFtZXdvcmtzLmluY2x1ZGVzKGZyYW1ld29yaykpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZyYW1ld29ya3MucHVzaChmcmFtZXdvcmspO1xyXG4gICAgICAgIC8vIFNvcnQgYWxwaGFiZXRpY2FsbHkgc28gdGhhdCBcIkZpcmViYXNlQ29yZS13ZWIsRmlyZWJhc2VVSS13ZWJcIiBhbmRcclxuICAgICAgICAvLyBcIkZpcmViYXNlVUktd2ViLEZpcmViYXNlQ29yZS13ZWJcIiBhcmVuJ3Qgdmlld2VkIGFzIGRpZmZlcmVudC5cclxuICAgICAgICB0aGlzLmZyYW1ld29ya3Muc29ydCgpO1xyXG4gICAgICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IF9nZXRDbGllbnRWZXJzaW9uKHRoaXMuY29uZmlnLmNsaWVudFBsYXRmb3JtLCB0aGlzLl9nZXRGcmFtZXdvcmtzKCkpO1xyXG4gICAgfVxyXG4gICAgX2dldEZyYW1ld29ya3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWV3b3JrcztcclxuICAgIH1cclxuICAgIGFzeW5jIF9nZXRBZGRpdGlvbmFsSGVhZGVycygpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgLy8gQWRkaXRpb25hbCBoZWFkZXJzIG9uIGV2ZXJ5IHJlcXVlc3RcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xyXG4gICAgICAgICAgICBbXCJYLUNsaWVudC1WZXJzaW9uXCIgLyogSHR0cEhlYWRlci5YX0NMSUVOVF9WRVJTSU9OICovXTogdGhpcy5jbGllbnRWZXJzaW9uXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5hcHAub3B0aW9ucy5hcHBJZCkge1xyXG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1GaXJlYmFzZS1nbXBpZFwiIC8qIEh0dHBIZWFkZXIuWF9GSVJFQkFTRV9HTVBJRCAqL10gPSB0aGlzLmFwcC5vcHRpb25zLmFwcElkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGUgaGVhcnRiZWF0IHNlcnZpY2UgZXhpc3RzLCBhZGQgdGhlIGhlYXJ0YmVhdCBzdHJpbmdcclxuICAgICAgICBjb25zdCBoZWFydGJlYXRzSGVhZGVyID0gYXdhaXQgKChfYSA9IHRoaXMuaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyXHJcbiAgICAgICAgICAgIC5nZXRJbW1lZGlhdGUoe1xyXG4gICAgICAgICAgICBvcHRpb25hbDogdHJ1ZVxyXG4gICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0SGVhcnRiZWF0c0hlYWRlcigpKTtcclxuICAgICAgICBpZiAoaGVhcnRiZWF0c0hlYWRlcikge1xyXG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1GaXJlYmFzZS1DbGllbnRcIiAvKiBIdHRwSGVhZGVyLlhfRklSRUJBU0VfQ0xJRU5UICovXSA9IGhlYXJ0YmVhdHNIZWFkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZSBBcHAgQ2hlY2sgc2VydmljZSBleGlzdHMsIGFkZCB0aGUgQXBwIENoZWNrIHRva2VuIGluIHRoZSBoZWFkZXJzXHJcbiAgICAgICAgY29uc3QgYXBwQ2hlY2tUb2tlbiA9IGF3YWl0IHRoaXMuX2dldEFwcENoZWNrVG9rZW4oKTtcclxuICAgICAgICBpZiAoYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1GaXJlYmFzZS1BcHBDaGVja1wiIC8qIEh0dHBIZWFkZXIuWF9GSVJFQkFTRV9BUFBfQ0hFQ0sgKi9dID0gYXBwQ2hlY2tUb2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfZ2V0QXBwQ2hlY2tUb2tlbigpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgYXBwQ2hlY2tUb2tlblJlc3VsdCA9IGF3YWl0ICgoX2EgPSB0aGlzLmFwcENoZWNrU2VydmljZVByb3ZpZGVyXHJcbiAgICAgICAgICAgIC5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFRva2VuKCkpO1xyXG4gICAgICAgIGlmIChhcHBDaGVja1Rva2VuUmVzdWx0ID09PSBudWxsIHx8IGFwcENoZWNrVG9rZW5SZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwcENoZWNrVG9rZW5SZXN1bHQuZXJyb3IpIHtcclxuICAgICAgICAgICAgLy8gQ29udGV4dDogYXBwQ2hlY2suZ2V0VG9rZW4oKSB3aWxsIG5ldmVyIHRocm93IGV2ZW4gaWYgYW4gZXJyb3IgaGFwcGVuZWQuXHJcbiAgICAgICAgICAgIC8vIEluIHRoZSBlcnJvciBjYXNlLCBhIGR1bW15IHRva2VuIHdpbGwgYmUgcmV0dXJuZWQgYWxvbmcgd2l0aCBhbiBlcnJvciBmaWVsZCBkZXNjcmliaW5nXHJcbiAgICAgICAgICAgIC8vIHRoZSBlcnJvci4gSW4gZ2VuZXJhbCwgd2Ugc2hvdWxkbid0IGNhcmUgYWJvdXQgdGhlIGVycm9yIGNvbmRpdGlvbiBhbmQganVzdCB1c2VcclxuICAgICAgICAgICAgLy8gdGhlIHRva2VuIChhY3R1YWwgb3IgZHVtbXkpIHRvIHNlbmQgcmVxdWVzdHMuXHJcbiAgICAgICAgICAgIF9sb2dXYXJuKGBFcnJvciB3aGlsZSByZXRyaWV2aW5nIEFwcCBDaGVjayB0b2tlbjogJHthcHBDaGVja1Rva2VuUmVzdWx0LmVycm9yfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXBwQ2hlY2tUb2tlblJlc3VsdCA9PT0gbnVsbCB8fCBhcHBDaGVja1Rva2VuUmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHBDaGVja1Rva2VuUmVzdWx0LnRva2VuO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBNZXRob2QgdG8gYmUgdXNlZCB0byBjYXN0IGRvd24gdG8gb3VyIHByaXZhdGUgaW1wbG1lbnRhdGlvbiBvZiBBdXRoLlxyXG4gKiBJdCB3aWxsIGFsc28gaGFuZGxlIHVud3JhcHBpbmcgZnJvbSB0aGUgY29tcGF0IHR5cGUgaWYgbmVjZXNzYXJ5XHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIEF1dGggb2JqZWN0IHBhc3NlZCBpbiBmcm9tIGRldmVsb3BlclxyXG4gKi9cclxuZnVuY3Rpb24gX2Nhc3RBdXRoKGF1dGgpIHtcclxuICAgIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCk7XHJcbn1cclxuLyoqIEhlbHBlciBjbGFzcyB0byB3cmFwIHN1YnNjcmliZXIgbG9naWMgKi9cclxuY2xhc3MgU3Vic2NyaXB0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGF1dGgpIHtcclxuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYWRkT2JzZXJ2ZXIgPSBjcmVhdGVTdWJzY3JpYmUob2JzZXJ2ZXIgPT4gKHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcikpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG5leHQoKSB7XHJcbiAgICAgICAgX2Fzc2VydCh0aGlzLm9ic2VydmVyLCB0aGlzLmF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZlci5uZXh0LmJpbmQodGhpcy5vYnNlcnZlcik7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IGV4dGVybmFsSlNQcm92aWRlciA9IHtcclxuICAgIGFzeW5jIGxvYWRKUygpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBsb2FkIGV4dGVybmFsIHNjcmlwdHMnKTtcclxuICAgIH0sXHJcbiAgICByZWNhcHRjaGFWMlNjcmlwdDogJycsXHJcbiAgICByZWNhcHRjaGFFbnRlcnByaXNlU2NyaXB0OiAnJyxcclxuICAgIGdhcGlTY3JpcHQ6ICcnXHJcbn07XHJcbmZ1bmN0aW9uIF9sb2FkSlModXJsKSB7XHJcbiAgICByZXR1cm4gZXh0ZXJuYWxKU1Byb3ZpZGVyLmxvYWRKUyh1cmwpO1xyXG59XHJcbmZ1bmN0aW9uIF9yZWNhcHRjaGFFbnRlcnByaXNlU2NyaXB0VXJsKCkge1xyXG4gICAgcmV0dXJuIGV4dGVybmFsSlNQcm92aWRlci5yZWNhcHRjaGFFbnRlcnByaXNlU2NyaXB0O1xyXG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMgKi9cclxuY29uc3QgUkVDQVBUQ0hBX0VOVEVSUFJJU0VfVkVSSUZJRVJfVFlQRSA9ICdyZWNhcHRjaGEtZW50ZXJwcmlzZSc7XHJcbmNvbnN0IEZBS0VfVE9LRU4gPSAnTk9fUkVDQVBUQ0hBJztcclxuY2xhc3MgUmVjYXB0Y2hhRW50ZXJwcmlzZVZlcmlmaWVyIHtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhdXRoRXh0ZXJuIC0gVGhlIGNvcnJlc3BvbmRpbmcgRmlyZWJhc2Uge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYXV0aEV4dGVybikge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElkZW50aWZpZXMgdGhlIHR5cGUgb2YgYXBwbGljYXRpb24gdmVyaWZpZXIgKGUuZy4gXCJyZWNhcHRjaGEtZW50ZXJwcmlzZVwiKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSBSRUNBUFRDSEFfRU5URVJQUklTRV9WRVJJRklFUl9UWVBFO1xyXG4gICAgICAgIHRoaXMuYXV0aCA9IF9jYXN0QXV0aChhdXRoRXh0ZXJuKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXhlY3V0ZXMgdGhlIHZlcmlmaWNhdGlvbiBwcm9jZXNzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSBmb3IgYSB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgdmFsaWRpdHkgb2YgYSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICBhc3luYyB2ZXJpZnkoYWN0aW9uID0gJ3ZlcmlmeScsIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XHJcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gcmV0cmlldmVTaXRlS2V5KGF1dGgpIHtcclxuICAgICAgICAgICAgaWYgKCFmb3JjZVJlZnJlc2gpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhdXRoLnRlbmFudElkID09IG51bGwgJiYgYXV0aC5fYWdlbnRSZWNhcHRjaGFDb25maWcgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRoLl9hZ2VudFJlY2FwdGNoYUNvbmZpZy5zaXRlS2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGF1dGgudGVuYW50SWQgIT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGF1dGguX3RlbmFudFJlY2FwdGNoYUNvbmZpZ3NbYXV0aC50ZW5hbnRJZF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRoLl90ZW5hbnRSZWNhcHRjaGFDb25maWdzW2F1dGgudGVuYW50SWRdLnNpdGVLZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIGdldFJlY2FwdGNoYUNvbmZpZyhhdXRoLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqLyxcclxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBcIlJFQ0FQVENIQV9FTlRFUlBSSVNFXCIgLyogUmVjYXB0Y2hhVmVyc2lvbi5FTlRFUlBSSVNFICovXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UucmVjYXB0Y2hhS2V5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcigncmVjYXB0Y2hhIEVudGVycHJpc2Ugc2l0ZSBrZXkgdW5kZWZpbmVkJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZmlnID0gbmV3IFJlY2FwdGNoYUNvbmZpZyhyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdXRoLnRlbmFudElkID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGguX2FnZW50UmVjYXB0Y2hhQ29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aC5fdGVuYW50UmVjYXB0Y2hhQ29uZmlnc1thdXRoLnRlbmFudElkXSA9IGNvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShjb25maWcuc2l0ZUtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJldHJpZXZlUmVjYXB0Y2hhVG9rZW4oc2l0ZUtleSwgcmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdyZWNhcHRjaGEgPSB3aW5kb3cuZ3JlY2FwdGNoYTtcclxuICAgICAgICAgICAgaWYgKGlzRW50ZXJwcmlzZShncmVjYXB0Y2hhKSkge1xyXG4gICAgICAgICAgICAgICAgZ3JlY2FwdGNoYS5lbnRlcnByaXNlLnJlYWR5KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBncmVjYXB0Y2hhLmVudGVycHJpc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmV4ZWN1dGUoc2l0ZUtleSwgeyBhY3Rpb24gfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4odG9rZW4gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKEZBS0VfVE9LRU4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoRXJyb3IoJ05vIHJlQ0FQVENIQSBlbnRlcnByaXNlIHNjcmlwdCBsb2FkZWQuJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHJpZXZlU2l0ZUtleSh0aGlzLmF1dGgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihzaXRlS2V5ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghZm9yY2VSZWZyZXNoICYmIGlzRW50ZXJwcmlzZSh3aW5kb3cuZ3JlY2FwdGNoYSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXRyaWV2ZVJlY2FwdGNoYVRva2VuKHNpdGVLZXksIHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignUmVjYXB0Y2hhVmVyaWZpZXIgaXMgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlcicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gX3JlY2FwdGNoYUVudGVycHJpc2VTY3JpcHRVcmwoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodXJsLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gc2l0ZUtleTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX2xvYWRKUyh1cmwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmlldmVSZWNhcHRjaGFUb2tlbihzaXRlS2V5LCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaW5qZWN0UmVjYXB0Y2hhRmllbGRzKGF1dGgsIHJlcXVlc3QsIGFjdGlvbiwgY2FwdGNoYVJlc3AgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgdmVyaWZpZXIgPSBuZXcgUmVjYXB0Y2hhRW50ZXJwcmlzZVZlcmlmaWVyKGF1dGgpO1xyXG4gICAgbGV0IGNhcHRjaGFSZXNwb25zZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY2FwdGNoYVJlc3BvbnNlID0gYXdhaXQgdmVyaWZpZXIudmVyaWZ5KGFjdGlvbik7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjYXB0Y2hhUmVzcG9uc2UgPSBhd2FpdCB2ZXJpZmllci52ZXJpZnkoYWN0aW9uLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5ld1JlcXVlc3QgPSBPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KTtcclxuICAgIGlmICghY2FwdGNoYVJlc3ApIHtcclxuICAgICAgICBPYmplY3QuYXNzaWduKG5ld1JlcXVlc3QsIHsgY2FwdGNoYVJlc3BvbnNlIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdSZXF1ZXN0LCB7ICdjYXB0Y2hhUmVzcCc6IGNhcHRjaGFSZXNwb25zZSB9KTtcclxuICAgIH1cclxuICAgIE9iamVjdC5hc3NpZ24obmV3UmVxdWVzdCwgeyAnY2xpZW50VHlwZSc6IFwiQ0xJRU5UX1RZUEVfV0VCXCIgLyogUmVjYXB0Y2hhQ2xpZW50VHlwZS5XRUIgKi8gfSk7XHJcbiAgICBPYmplY3QuYXNzaWduKG5ld1JlcXVlc3QsIHtcclxuICAgICAgICAncmVjYXB0Y2hhVmVyc2lvbic6IFwiUkVDQVBUQ0hBX0VOVEVSUFJJU0VcIiAvKiBSZWNhcHRjaGFWZXJzaW9uLkVOVEVSUFJJU0UgKi9cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5ld1JlcXVlc3Q7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlUmVjYXB0Y2hhRmxvdyhhdXRoSW5zdGFuY2UsIHJlcXVlc3QsIGFjdGlvbk5hbWUsIGFjdGlvbk1ldGhvZCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgaWYgKChfYSA9IGF1dGhJbnN0YW5jZVxyXG4gICAgICAgIC5fZ2V0UmVjYXB0Y2hhQ29uZmlnKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1Byb3ZpZGVyRW5hYmxlZChcIkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhUHJvdmlkZXIuRU1BSUxfUEFTU1dPUkRfUFJPVklERVIgKi8pKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdFdpdGhSZWNhcHRjaGEgPSBhd2FpdCBpbmplY3RSZWNhcHRjaGFGaWVsZHMoYXV0aEluc3RhbmNlLCByZXF1ZXN0LCBhY3Rpb25OYW1lLCBhY3Rpb25OYW1lID09PSBcImdldE9vYkNvZGVcIiAvKiBSZWNhcHRjaGFBY3Rpb25OYW1lLkdFVF9PT0JfQ09ERSAqLyk7XHJcbiAgICAgICAgcmV0dXJuIGFjdGlvbk1ldGhvZChhdXRoSW5zdGFuY2UsIHJlcXVlc3RXaXRoUmVjYXB0Y2hhKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBhY3Rpb25NZXRob2QoYXV0aEluc3RhbmNlLCByZXF1ZXN0KS5jYXRjaChhc3luYyAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGBhdXRoLyR7XCJtaXNzaW5nLXJlY2FwdGNoYS10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVE9LRU4gKi99YCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCR7YWN0aW9uTmFtZX0gaXMgcHJvdGVjdGVkIGJ5IHJlQ0FQVENIQSBFbnRlcnByaXNlIGZvciB0aGlzIHByb2plY3QuIEF1dG9tYXRpY2FsbHkgdHJpZ2dlcmluZyB0aGUgcmVDQVBUQ0hBIGZsb3cgYW5kIHJlc3RhcnRpbmcgdGhlIGZsb3cuYCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0V2l0aFJlY2FwdGNoYSA9IGF3YWl0IGluamVjdFJlY2FwdGNoYUZpZWxkcyhhdXRoSW5zdGFuY2UsIHJlcXVlc3QsIGFjdGlvbk5hbWUsIGFjdGlvbk5hbWUgPT09IFwiZ2V0T29iQ29kZVwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuR0VUX09PQl9DT0RFICovKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb25NZXRob2QoYXV0aEluc3RhbmNlLCByZXF1ZXN0V2l0aFJlY2FwdGNoYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gX2luaXRpYWxpemVSZWNhcHRjaGFDb25maWcoYXV0aCkge1xyXG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRSZWNhcHRjaGFDb25maWcoYXV0aEludGVybmFsLCB7XHJcbiAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqLyxcclxuICAgICAgICB2ZXJzaW9uOiBcIlJFQ0FQVENIQV9FTlRFUlBSSVNFXCIgLyogUmVjYXB0Y2hhVmVyc2lvbi5FTlRFUlBSSVNFICovXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBSZWNhcHRjaGFDb25maWcocmVzcG9uc2UpO1xyXG4gICAgaWYgKGF1dGhJbnRlcm5hbC50ZW5hbnRJZCA9PSBudWxsKSB7XHJcbiAgICAgICAgYXV0aEludGVybmFsLl9hZ2VudFJlY2FwdGNoYUNvbmZpZyA9IGNvbmZpZztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGF1dGhJbnRlcm5hbC5fdGVuYW50UmVjYXB0Y2hhQ29uZmlnc1thdXRoSW50ZXJuYWwudGVuYW50SWRdID0gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbmZpZy5pc1Byb3ZpZGVyRW5hYmxlZChcIkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhUHJvdmlkZXIuRU1BSUxfUEFTU1dPUkRfUFJPVklERVIgKi8pKSB7XHJcbiAgICAgICAgY29uc3QgdmVyaWZpZXIgPSBuZXcgUmVjYXB0Y2hhRW50ZXJwcmlzZVZlcmlmaWVyKGF1dGhJbnRlcm5hbCk7XHJcbiAgICAgICAgdm9pZCB2ZXJpZmllci52ZXJpZnkoKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSW5pdGlhbGl6ZXMgYW4ge0BsaW5rIEF1dGh9IGluc3RhbmNlIHdpdGggZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlclxyXG4gKiB7QGxpbmsgRGVwZW5kZW5jaWVzfS5cclxuICpcclxuICogQHJlbWFya3NcclxuICpcclxuICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgbW9yZSBjb250cm9sIG92ZXIgdGhlIHtAbGluayBBdXRofSBpbnN0YW5jZSB0aGFuXHJcbiAqIHtAbGluayBnZXRBdXRofS4gYGdldEF1dGhgIHVzZXMgcGxhdGZvcm0tc3BlY2lmaWMgZGVmYXVsdHMgdG8gc3VwcGx5XHJcbiAqIHRoZSB7QGxpbmsgRGVwZW5kZW5jaWVzfS4gSW4gZ2VuZXJhbCwgYGdldEF1dGhgIGlzIHRoZSBlYXNpZXN0IHdheSB0b1xyXG4gKiBpbml0aWFsaXplIEF1dGggYW5kIHdvcmtzIGZvciBtb3N0IHVzZSBjYXNlcy4gVXNlIGBpbml0aWFsaXplQXV0aGAgaWYgeW91XHJcbiAqIG5lZWQgY29udHJvbCBvdmVyIHdoaWNoIHBlcnNpc3RlbmNlIGxheWVyIGlzIHVzZWQsIG9yIHRvIG1pbmltaXplIGJ1bmRsZVxyXG4gKiBzaXplIGlmIHlvdSdyZSBub3QgdXNpbmcgZWl0aGVyIGBzaWduSW5XaXRoUG9wdXBgIG9yIGBzaWduSW5XaXRoUmVkaXJlY3RgLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZSwgaWYgeW91ciBhcHAgb25seSB1c2VzIGFub255bW91cyBhY2NvdW50cyBhbmQgeW91IG9ubHkgd2FudFxyXG4gKiBhY2NvdW50cyBzYXZlZCBmb3IgdGhlIGN1cnJlbnQgc2Vzc2lvbiwgaW5pdGlhbGl6ZSBgQXV0aGAgd2l0aDpcclxuICpcclxuICogYGBganNcclxuICogY29uc3QgYXV0aCA9IGluaXRpYWxpemVBdXRoKGFwcCwge1xyXG4gKiAgIHBlcnNpc3RlbmNlOiBicm93c2VyU2Vzc2lvblBlcnNpc3RlbmNlLFxyXG4gKiAgIHBvcHVwUmVkaXJlY3RSZXNvbHZlcjogdW5kZWZpbmVkLFxyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGluaXRpYWxpemVBdXRoKGFwcCwgZGVwcykge1xyXG4gICAgY29uc3QgcHJvdmlkZXIgPSBfZ2V0UHJvdmlkZXIoYXBwLCAnYXV0aCcpO1xyXG4gICAgaWYgKHByb3ZpZGVyLmlzSW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgIGNvbnN0IGF1dGggPSBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICBjb25zdCBpbml0aWFsT3B0aW9ucyA9IHByb3ZpZGVyLmdldE9wdGlvbnMoKTtcclxuICAgICAgICBpZiAoZGVlcEVxdWFsKGluaXRpYWxPcHRpb25zLCBkZXBzICE9PSBudWxsICYmIGRlcHMgIT09IHZvaWQgMCA/IGRlcHMgOiB7fSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGF1dGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfZmFpbChhdXRoLCBcImFscmVhZHktaW5pdGlhbGl6ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkFMUkVBRFlfSU5JVElBTElaRUQgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGF1dGggPSBwcm92aWRlci5pbml0aWFsaXplKHsgb3B0aW9uczogZGVwcyB9KTtcclxuICAgIHJldHVybiBhdXRoO1xyXG59XHJcbmZ1bmN0aW9uIF9pbml0aWFsaXplQXV0aEluc3RhbmNlKGF1dGgsIGRlcHMpIHtcclxuICAgIGNvbnN0IHBlcnNpc3RlbmNlID0gKGRlcHMgPT09IG51bGwgfHwgZGVwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVwcy5wZXJzaXN0ZW5jZSkgfHwgW107XHJcbiAgICBjb25zdCBoaWVyYXJjaHkgPSAoQXJyYXkuaXNBcnJheShwZXJzaXN0ZW5jZSkgPyBwZXJzaXN0ZW5jZSA6IFtwZXJzaXN0ZW5jZV0pLm1hcChfZ2V0SW5zdGFuY2UpO1xyXG4gICAgaWYgKGRlcHMgPT09IG51bGwgfHwgZGVwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVwcy5lcnJvck1hcCkge1xyXG4gICAgICAgIGF1dGguX3VwZGF0ZUVycm9yTWFwKGRlcHMuZXJyb3JNYXApO1xyXG4gICAgfVxyXG4gICAgLy8gVGhpcyBwcm9taXNlIGlzIGludGVuZGVkIHRvIGZsb2F0OyBhdXRoIGluaXRpYWxpemF0aW9uIGhhcHBlbnMgaW4gdGhlXHJcbiAgICAvLyBiYWNrZ3JvdW5kLCBtZWFud2hpbGUgdGhlIGF1dGggb2JqZWN0IG1heSBiZSB1c2VkIGJ5IHRoZSBhcHAuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICBhdXRoLl9pbml0aWFsaXplV2l0aFBlcnNpc3RlbmNlKGhpZXJhcmNoeSwgZGVwcyA9PT0gbnVsbCB8fCBkZXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXBzLnBvcHVwUmVkaXJlY3RSZXNvbHZlcik7XHJcbn1cblxuLyoqXHJcbiAqIENoYW5nZXMgdGhlIHtAbGluayBBdXRofSBpbnN0YW5jZSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBGaXJlYmFzZSBBdXRoIEVtdWxhdG9yLCBpbnN0ZWFkIG9mIHByb2R1Y3Rpb25cclxuICogRmlyZWJhc2UgQXV0aCBzZXJ2aWNlcy5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhpcyBtdXN0IGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5IGltbWVkaWF0ZWx5IGZvbGxvd2luZyB0aGUgZmlyc3QgY2FsbCB0b1xyXG4gKiB7QGxpbmsgaW5pdGlhbGl6ZUF1dGh9LiAgRG8gbm90IHVzZSB3aXRoIHByb2R1Y3Rpb24gY3JlZGVudGlhbHMgYXMgZW11bGF0b3JcclxuICogdHJhZmZpYyBpcyBub3QgZW5jcnlwdGVkLlxyXG4gKlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIGNvbm5lY3RBdXRoRW11bGF0b3IoYXV0aCwgJ2h0dHA6Ly8xMjcuMC4wLjE6OTA5OScsIHsgZGlzYWJsZVdhcm5pbmdzOiB0cnVlIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBhdCB3aGljaCB0aGUgZW11bGF0b3IgaXMgcnVubmluZyAoZWcsICdodHRwOi8vbG9jYWxob3N0OjkwOTknKS5cclxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gYG9wdGlvbnMuZGlzYWJsZVdhcm5pbmdzYCBkZWZhdWx0cyB0byBgZmFsc2VgLiBTZXQgaXQgdG9cclxuICogYHRydWVgIHRvIGRpc2FibGUgdGhlIHdhcm5pbmcgYmFubmVyIGF0dGFjaGVkIHRvIHRoZSBET00uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGNvbm5lY3RBdXRoRW11bGF0b3IoYXV0aCwgdXJsLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XHJcbiAgICBfYXNzZXJ0KGF1dGhJbnRlcm5hbC5fY2FuSW5pdEVtdWxhdG9yLCBhdXRoSW50ZXJuYWwsIFwiZW11bGF0b3ItY29uZmlnLWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuRU1VTEFUT1JfQ09ORklHX0ZBSUxFRCAqLyk7XHJcbiAgICBfYXNzZXJ0KC9eaHR0cHM/OlxcL1xcLy8udGVzdCh1cmwpLCBhdXRoSW50ZXJuYWwsIFwiaW52YWxpZC1lbXVsYXRvci1zY2hlbWVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfRU1VTEFUT1JfU0NIRU1FICovKTtcclxuICAgIGNvbnN0IGRpc2FibGVXYXJuaW5ncyA9ICEhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kaXNhYmxlV2FybmluZ3MpO1xyXG4gICAgY29uc3QgcHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2wodXJsKTtcclxuICAgIGNvbnN0IHsgaG9zdCwgcG9ydCB9ID0gZXh0cmFjdEhvc3RBbmRQb3J0KHVybCk7XHJcbiAgICBjb25zdCBwb3J0U3RyID0gcG9ydCA9PT0gbnVsbCA/ICcnIDogYDoke3BvcnR9YDtcclxuICAgIC8vIEFsd2F5cyByZXBsYWNlIHBhdGggd2l0aCBcIi9cIiAoZXZlbiBpZiBpbnB1dCB1cmwgaGFkIG5vIHBhdGggYXQgYWxsLCBvciBoYWQgYSBkaWZmZXJlbnQgb25lKS5cclxuICAgIGF1dGhJbnRlcm5hbC5jb25maWcuZW11bGF0b3IgPSB7IHVybDogYCR7cHJvdG9jb2x9Ly8ke2hvc3R9JHtwb3J0U3RyfS9gIH07XHJcbiAgICBhdXRoSW50ZXJuYWwuc2V0dGluZ3MuYXBwVmVyaWZpY2F0aW9uRGlzYWJsZWRGb3JUZXN0aW5nID0gdHJ1ZTtcclxuICAgIGF1dGhJbnRlcm5hbC5lbXVsYXRvckNvbmZpZyA9IE9iamVjdC5mcmVlemUoe1xyXG4gICAgICAgIGhvc3QsXHJcbiAgICAgICAgcG9ydCxcclxuICAgICAgICBwcm90b2NvbDogcHJvdG9jb2wucmVwbGFjZSgnOicsICcnKSxcclxuICAgICAgICBvcHRpb25zOiBPYmplY3QuZnJlZXplKHsgZGlzYWJsZVdhcm5pbmdzIH0pXHJcbiAgICB9KTtcclxuICAgIGlmICghZGlzYWJsZVdhcm5pbmdzKSB7XHJcbiAgICAgICAgZW1pdEVtdWxhdG9yV2FybmluZygpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbCh1cmwpIHtcclxuICAgIGNvbnN0IHByb3RvY29sRW5kID0gdXJsLmluZGV4T2YoJzonKTtcclxuICAgIHJldHVybiBwcm90b2NvbEVuZCA8IDAgPyAnJyA6IHVybC5zdWJzdHIoMCwgcHJvdG9jb2xFbmQgKyAxKTtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0SG9zdEFuZFBvcnQodXJsKSB7XHJcbiAgICBjb25zdCBwcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbCh1cmwpO1xyXG4gICAgY29uc3QgYXV0aG9yaXR5ID0gLyhcXC9cXC8pPyhbXj8jL10rKS8uZXhlYyh1cmwuc3Vic3RyKHByb3RvY29sLmxlbmd0aCkpOyAvLyBCZXR3ZWVuIC8vIGFuZCAvLCA/IG9yICMuXHJcbiAgICBpZiAoIWF1dGhvcml0eSkge1xyXG4gICAgICAgIHJldHVybiB7IGhvc3Q6ICcnLCBwb3J0OiBudWxsIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBob3N0QW5kUG9ydCA9IGF1dGhvcml0eVsyXS5zcGxpdCgnQCcpLnBvcCgpIHx8ICcnOyAvLyBTdHJpcCBvdXQgXCJ1c2VybmFtZTpwYXNzd29yZEBcIi5cclxuICAgIGNvbnN0IGJyYWNrZXRlZElQdjYgPSAvXihcXFtbXlxcXV0rXFxdKSg6fCQpLy5leGVjKGhvc3RBbmRQb3J0KTtcclxuICAgIGlmIChicmFja2V0ZWRJUHY2KSB7XHJcbiAgICAgICAgY29uc3QgaG9zdCA9IGJyYWNrZXRlZElQdjZbMV07XHJcbiAgICAgICAgcmV0dXJuIHsgaG9zdCwgcG9ydDogcGFyc2VQb3J0KGhvc3RBbmRQb3J0LnN1YnN0cihob3N0Lmxlbmd0aCArIDEpKSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgW2hvc3QsIHBvcnRdID0gaG9zdEFuZFBvcnQuc3BsaXQoJzonKTtcclxuICAgICAgICByZXR1cm4geyBob3N0LCBwb3J0OiBwYXJzZVBvcnQocG9ydCkgfTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXJzZVBvcnQocG9ydFN0cikge1xyXG4gICAgaWYgKCFwb3J0U3RyKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwb3J0ID0gTnVtYmVyKHBvcnRTdHIpO1xyXG4gICAgaWYgKGlzTmFOKHBvcnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9ydDtcclxufVxyXG5mdW5jdGlvbiBlbWl0RW11bGF0b3JXYXJuaW5nKCkge1xyXG4gICAgZnVuY3Rpb24gYXR0YWNoQmFubmVyKCkge1xyXG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xyXG4gICAgICAgIGNvbnN0IHN0eSA9IGVsLnN0eWxlO1xyXG4gICAgICAgIGVsLmlubmVyVGV4dCA9XHJcbiAgICAgICAgICAgICdSdW5uaW5nIGluIGVtdWxhdG9yIG1vZGUuIERvIG5vdCB1c2Ugd2l0aCBwcm9kdWN0aW9uIGNyZWRlbnRpYWxzLic7XHJcbiAgICAgICAgc3R5LnBvc2l0aW9uID0gJ2ZpeGVkJztcclxuICAgICAgICBzdHkud2lkdGggPSAnMTAwJSc7XHJcbiAgICAgICAgc3R5LmJhY2tncm91bmRDb2xvciA9ICcjZmZmZmZmJztcclxuICAgICAgICBzdHkuYm9yZGVyID0gJy4xZW0gc29saWQgIzAwMDAwMCc7XHJcbiAgICAgICAgc3R5LmNvbG9yID0gJyNiNTAwMDAnO1xyXG4gICAgICAgIHN0eS5ib3R0b20gPSAnMHB4JztcclxuICAgICAgICBzdHkubGVmdCA9ICcwcHgnO1xyXG4gICAgICAgIHN0eS5tYXJnaW4gPSAnMHB4JztcclxuICAgICAgICBzdHkuekluZGV4ID0gJzEwMDAwJztcclxuICAgICAgICBzdHkudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnZmlyZWJhc2UtZW11bGF0b3Itd2FybmluZycpO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5pbmZvID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKCdXQVJOSU5HOiBZb3UgYXJlIHVzaW5nIHRoZSBBdXRoIEVtdWxhdG9yLCcgK1xyXG4gICAgICAgICAgICAnIHdoaWNoIGlzIGludGVuZGVkIGZvciBsb2NhbCB0ZXN0aW5nIG9ubHkuICBEbyBub3QgdXNlIHdpdGgnICtcclxuICAgICAgICAgICAgJyBwcm9kdWN0aW9uIGNyZWRlbnRpYWxzLicpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgYXR0YWNoQmFubmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGF0dGFjaEJhbm5lcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSW50ZXJmYWNlIHRoYXQgcmVwcmVzZW50cyB0aGUgY3JlZGVudGlhbHMgcmV0dXJuZWQgYnkgYW4ge0BsaW5rIEF1dGhQcm92aWRlcn0uXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIEltcGxlbWVudGF0aW9ucyBzcGVjaWZ5IHRoZSBkZXRhaWxzIGFib3V0IGVhY2ggYXV0aCBwcm92aWRlcidzIGNyZWRlbnRpYWwgcmVxdWlyZW1lbnRzLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBBdXRoQ3JlZGVudGlhbCB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIElEIGZvciB0aGUgY3JlZGVudGlhbC5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogRm9yIGV4YW1wbGUsICdmYWNlYm9vay5jb20nLCBvciAnZ29vZ2xlLmNvbScuXHJcbiAgICAgKi9cclxuICAgIHByb3ZpZGVySWQsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYXV0aGVudGljYXRpb24gc2lnbiBpbiBtZXRob2QgZm9yIHRoZSBjcmVkZW50aWFsLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBGb3IgZXhhbXBsZSwge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfUEFTU1dPUkQsIG9yXHJcbiAgICAgKiB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9MSU5LLiBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBzaWduLWluIG1ldGhvZFxyXG4gICAgICogaWRlbnRpZmllciBhcyByZXR1cm5lZCBpbiB7QGxpbmsgZmV0Y2hTaWduSW5NZXRob2RzRm9yRW1haWx9LlxyXG4gICAgICovXHJcbiAgICBzaWduSW5NZXRob2QpIHtcclxuICAgICAgICB0aGlzLnByb3ZpZGVySWQgPSBwcm92aWRlcklkO1xyXG4gICAgICAgIHRoaXMuc2lnbkluTWV0aG9kID0gc2lnbkluTWV0aG9kO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ25vdCBpbXBsZW1lbnRlZCcpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2dldElkVG9rZW5SZXNwb25zZShfYXV0aCkge1xyXG4gICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ25vdCBpbXBsZW1lbnRlZCcpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2xpbmtUb0lkVG9rZW4oX2F1dGgsIF9pZFRva2VuKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlYnVnRmFpbCgnbm90IGltcGxlbWVudGVkJyk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKF9hdXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlYnVnRmFpbCgnbm90IGltcGxlbWVudGVkJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcmVzZXRQYXNzd29yZChhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6cmVzZXRQYXNzd29yZFwiIC8qIEVuZHBvaW50LlJFU0VUX1BBU1NXT1JEICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUVtYWlsUGFzc3dvcmQoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnVwZGF0ZVwiIC8qIEVuZHBvaW50LlNFVF9BQ0NPVU5UX0lORk8gKi8sIHJlcXVlc3QpO1xyXG59XHJcbi8vIFVzZWQgZm9yIGxpbmtpbmcgYW4gZW1haWwvcGFzc3dvcmQgYWNjb3VudCB0byBhbiBleGlzdGluZyBpZFRva2VuLiBVc2VzIHRoZSBzYW1lIHJlcXVlc3QvcmVzcG9uc2VcclxuLy8gZm9ybWF0IGFzIHVwZGF0ZUVtYWlsUGFzc3dvcmQuXHJcbmFzeW5jIGZ1bmN0aW9uIGxpbmtFbWFpbFBhc3N3b3JkKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduVXBcIiAvKiBFbmRwb2ludC5TSUdOX1VQICovLCByZXF1ZXN0KTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBhcHBseUFjdGlvbkNvZGUkMShhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6dXBkYXRlXCIgLyogRW5kcG9pbnQuU0VUX0FDQ09VTlRfSU5GTyAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoUGFzc3dvcmQoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhQYXNzd29yZFwiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9QQVNTV09SRCAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBzZW5kT29iQ29kZShhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2VuZE9vYkNvZGVcIiAvKiBFbmRwb2ludC5TRU5EX09PQl9DT0RFICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHNlbmRFbWFpbFZlcmlmaWNhdGlvbiQxKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBzZW5kT29iQ29kZShhdXRoLCByZXF1ZXN0KTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBzZW5kUGFzc3dvcmRSZXNldEVtYWlsJDEoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIHNlbmRPb2JDb2RlKGF1dGgsIHJlcXVlc3QpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHNlbmRTaWduSW5MaW5rVG9FbWFpbCQxKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBzZW5kT29iQ29kZShhdXRoLCByZXF1ZXN0KTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlBbmRDaGFuZ2VFbWFpbChhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gc2VuZE9vYkNvZGUoYXV0aCwgcmVxdWVzdCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aEVtYWlsTGluayQxKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoRW1haWxMaW5rXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX0VNQUlMX0xJTksgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aEVtYWlsTGlua0ZvckxpbmtpbmcoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhFbWFpbExpbmtcIiAvKiBFbmRwb2ludC5TSUdOX0lOX1dJVEhfRU1BSUxfTElOSyAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSW50ZXJmYWNlIHRoYXQgcmVwcmVzZW50cyB0aGUgY3JlZGVudGlhbHMgcmV0dXJuZWQgYnkge0BsaW5rIEVtYWlsQXV0aFByb3ZpZGVyfSBmb3JcclxuICoge0BsaW5rIFByb3ZpZGVySWR9LlBBU1NXT1JEXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIENvdmVycyBib3RoIHtAbGluayBTaWduSW5NZXRob2R9LkVNQUlMX1BBU1NXT1JEIGFuZFxyXG4gKiB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9MSU5LLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBFbWFpbEF1dGhDcmVkZW50aWFsIGV4dGVuZHMgQXV0aENyZWRlbnRpYWwge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfZW1haWwsIFxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX3Bhc3N3b3JkLCBzaWduSW5NZXRob2QsIFxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX3RlbmFudElkID0gbnVsbCkge1xyXG4gICAgICAgIHN1cGVyKFwicGFzc3dvcmRcIiAvKiBQcm92aWRlcklkLlBBU1NXT1JEICovLCBzaWduSW5NZXRob2QpO1xyXG4gICAgICAgIHRoaXMuX2VtYWlsID0gX2VtYWlsO1xyXG4gICAgICAgIHRoaXMuX3Bhc3N3b3JkID0gX3Bhc3N3b3JkO1xyXG4gICAgICAgIHRoaXMuX3RlbmFudElkID0gX3RlbmFudElkO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgc3RhdGljIF9mcm9tRW1haWxBbmRQYXNzd29yZChlbWFpbCwgcGFzc3dvcmQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEVtYWlsQXV0aENyZWRlbnRpYWwoZW1haWwsIHBhc3N3b3JkLCBcInBhc3N3b3JkXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX1BBU1NXT1JEICovKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHN0YXRpYyBfZnJvbUVtYWlsQW5kQ29kZShlbWFpbCwgb29iQ29kZSwgdGVuYW50SWQgPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbWFpbEF1dGhDcmVkZW50aWFsKGVtYWlsLCBvb2JDb2RlLCBcImVtYWlsTGlua1wiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LICovLCB0ZW5hbnRJZCk7XHJcbiAgICB9XHJcbiAgICAvKioge0Bpbmhlcml0ZG9jIEF1dGhDcmVkZW50aWFsLnRvSlNPTn0gKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBlbWFpbDogdGhpcy5fZW1haWwsXHJcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLl9wYXNzd29yZCxcclxuICAgICAgICAgICAgc2lnbkluTWV0aG9kOiB0aGlzLnNpZ25Jbk1ldGhvZCxcclxuICAgICAgICAgICAgdGVuYW50SWQ6IHRoaXMuX3RlbmFudElkXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhdGljIG1ldGhvZCB0byBkZXNlcmlhbGl6ZSBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0IGludG8gYW4ge0BsaW5rICBBdXRoQ3JlZGVudGlhbH0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGpzb24gLSBFaXRoZXIgYG9iamVjdGAgb3IgdGhlIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuIFdoZW4gc3RyaW5nIGlzXHJcbiAgICAgKiBwcm92aWRlZCwgYEpTT04ucGFyc2VgIHdvdWxkIGJlIGNhbGxlZCBmaXJzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBJZiB0aGUgSlNPTiBpbnB1dCBkb2VzIG5vdCByZXByZXNlbnQgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSwgbnVsbCBpcyByZXR1cm5lZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICBjb25zdCBvYmogPSB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcclxuICAgICAgICBpZiAoKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5lbWFpbCkgJiYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5wYXNzd29yZCkpIHtcclxuICAgICAgICAgICAgaWYgKG9iai5zaWduSW5NZXRob2QgPT09IFwicGFzc3dvcmRcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfUEFTU1dPUkQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcm9tRW1haWxBbmRQYXNzd29yZChvYmouZW1haWwsIG9iai5wYXNzd29yZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob2JqLnNpZ25Jbk1ldGhvZCA9PT0gXCJlbWFpbExpbmtcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfTElOSyAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zyb21FbWFpbEFuZENvZGUob2JqLmVtYWlsLCBvYmoucGFzc3dvcmQsIG9iai50ZW5hbnRJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBhc3luYyBfZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGgpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuc2lnbkluTWV0aG9kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwYXNzd29yZFwiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9QQVNTV09SRCAqLzpcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZW1haWw6IHRoaXMuX2VtYWlsLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLl9wYXNzd29yZCxcclxuICAgICAgICAgICAgICAgICAgICBjbGllbnRUeXBlOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlY2FwdGNoYUZsb3coYXV0aCwgcmVxdWVzdCwgXCJzaWduSW5XaXRoUGFzc3dvcmRcIiAvKiBSZWNhcHRjaGFBY3Rpb25OYW1lLlNJR05fSU5fV0lUSF9QQVNTV09SRCAqLywgc2lnbkluV2l0aFBhc3N3b3JkKTtcclxuICAgICAgICAgICAgY2FzZSBcImVtYWlsTGlua1wiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhFbWFpbExpbmskMShhdXRoLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW1haWw6IHRoaXMuX2VtYWlsLFxyXG4gICAgICAgICAgICAgICAgICAgIG9vYkNvZGU6IHRoaXMuX3Bhc3N3b3JkXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIF9mYWlsKGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBhc3luYyBfbGlua1RvSWRUb2tlbihhdXRoLCBpZFRva2VuKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnNpZ25Jbk1ldGhvZCkge1xyXG4gICAgICAgICAgICBjYXNlIFwicGFzc3dvcmRcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfUEFTU1dPUkQgKi86XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkVG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZW1haWw6IHRoaXMuX2VtYWlsLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLl9wYXNzd29yZCxcclxuICAgICAgICAgICAgICAgICAgICBjbGllbnRUeXBlOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlY2FwdGNoYUZsb3coYXV0aCwgcmVxdWVzdCwgXCJzaWduVXBQYXNzd29yZFwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuU0lHTl9VUF9QQVNTV09SRCAqLywgbGlua0VtYWlsUGFzc3dvcmQpO1xyXG4gICAgICAgICAgICBjYXNlIFwiZW1haWxMaW5rXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX0xJTksgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbkluV2l0aEVtYWlsTGlua0ZvckxpbmtpbmcoYXV0aCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkVG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgZW1haWw6IHRoaXMuX2VtYWlsLFxyXG4gICAgICAgICAgICAgICAgICAgIG9vYkNvZGU6IHRoaXMuX3Bhc3N3b3JkXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIF9mYWlsKGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGgpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhJZHBcIiAvKiBFbmRwb2ludC5TSUdOX0lOX1dJVEhfSURQICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IElEUF9SRVFVRVNUX1VSSSQxID0gJ2h0dHA6Ly9sb2NhbGhvc3QnO1xyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgT0F1dGggY3JlZGVudGlhbHMgcmV0dXJuZWQgYnkgYW4ge0BsaW5rIE9BdXRoUHJvdmlkZXJ9LlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBJbXBsZW1lbnRhdGlvbnMgc3BlY2lmeSB0aGUgZGV0YWlscyBhYm91dCBlYWNoIGF1dGggcHJvdmlkZXIncyBjcmVkZW50aWFsIHJlcXVpcmVtZW50cy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgT0F1dGhDcmVkZW50aWFsIGV4dGVuZHMgQXV0aENyZWRlbnRpYWwge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdUb2tlbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgX2Zyb21QYXJhbXMocGFyYW1zKSB7XHJcbiAgICAgICAgY29uc3QgY3JlZCA9IG5ldyBPQXV0aENyZWRlbnRpYWwocGFyYW1zLnByb3ZpZGVySWQsIHBhcmFtcy5zaWduSW5NZXRob2QpO1xyXG4gICAgICAgIGlmIChwYXJhbXMuaWRUb2tlbiB8fCBwYXJhbXMuYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgLy8gT0F1dGggMiBhbmQgZWl0aGVyIElEIHRva2VuIG9yIGFjY2VzcyB0b2tlbi5cclxuICAgICAgICAgICAgaWYgKHBhcmFtcy5pZFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICBjcmVkLmlkVG9rZW4gPSBwYXJhbXMuaWRUb2tlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocGFyYW1zLmFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgICBjcmVkLmFjY2Vzc1Rva2VuID0gcGFyYW1zLmFjY2Vzc1Rva2VuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEFkZCBub25jZSBpZiBhdmFpbGFibGUgYW5kIG5vIHBlbmRpbmdUb2tlbiBpcyBwcmVzZW50LlxyXG4gICAgICAgICAgICBpZiAocGFyYW1zLm5vbmNlICYmICFwYXJhbXMucGVuZGluZ1Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgICBjcmVkLm5vbmNlID0gcGFyYW1zLm5vbmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXJhbXMucGVuZGluZ1Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgICBjcmVkLnBlbmRpbmdUb2tlbiA9IHBhcmFtcy5wZW5kaW5nVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFyYW1zLm9hdXRoVG9rZW4gJiYgcGFyYW1zLm9hdXRoVG9rZW5TZWNyZXQpIHtcclxuICAgICAgICAgICAgLy8gT0F1dGggMSBhbmQgT0F1dGggdG9rZW4gd2l0aCB0b2tlbiBzZWNyZXRcclxuICAgICAgICAgICAgY3JlZC5hY2Nlc3NUb2tlbiA9IHBhcmFtcy5vYXV0aFRva2VuO1xyXG4gICAgICAgICAgICBjcmVkLnNlY3JldCA9IHBhcmFtcy5vYXV0aFRva2VuU2VjcmV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX2ZhaWwoXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3JlZDtcclxuICAgIH1cclxuICAgIC8qKiB7QGluaGVyaXRkb2MgQXV0aENyZWRlbnRpYWwudG9KU09OfSAgKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZFRva2VuOiB0aGlzLmlkVG9rZW4sXHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuLFxyXG4gICAgICAgICAgICBzZWNyZXQ6IHRoaXMuc2VjcmV0LFxyXG4gICAgICAgICAgICBub25jZTogdGhpcy5ub25jZSxcclxuICAgICAgICAgICAgcGVuZGluZ1Rva2VuOiB0aGlzLnBlbmRpbmdUb2tlbixcclxuICAgICAgICAgICAgcHJvdmlkZXJJZDogdGhpcy5wcm92aWRlcklkLFxyXG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IHRoaXMuc2lnbkluTWV0aG9kXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhdGljIG1ldGhvZCB0byBkZXNlcmlhbGl6ZSBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0IGludG8gYW5cclxuICAgICAqIHtAbGluayAgQXV0aENyZWRlbnRpYWx9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBqc29uIC0gSW5wdXQgY2FuIGJlIGVpdGhlciBPYmplY3Qgb3IgdGhlIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuXHJcbiAgICAgKiBXaGVuIHN0cmluZyBpcyBwcm92aWRlZCwgSlNPTi5wYXJzZSB3b3VsZCBiZSBjYWxsZWQgZmlyc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgSWYgdGhlIEpTT04gaW5wdXQgZG9lcyBub3QgcmVwcmVzZW50IGFuIHtAbGluayAgQXV0aENyZWRlbnRpYWx9LCBudWxsIGlzIHJldHVybmVkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uO1xyXG4gICAgICAgIGNvbnN0IHsgcHJvdmlkZXJJZCwgc2lnbkluTWV0aG9kIH0gPSBvYmosIHJlc3QgPSBfX3Jlc3Qob2JqLCBbXCJwcm92aWRlcklkXCIsIFwic2lnbkluTWV0aG9kXCJdKTtcclxuICAgICAgICBpZiAoIXByb3ZpZGVySWQgfHwgIXNpZ25Jbk1ldGhvZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY3JlZCA9IG5ldyBPQXV0aENyZWRlbnRpYWwocHJvdmlkZXJJZCwgc2lnbkluTWV0aG9kKTtcclxuICAgICAgICBjcmVkLmlkVG9rZW4gPSByZXN0LmlkVG9rZW4gfHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIGNyZWQuYWNjZXNzVG9rZW4gPSByZXN0LmFjY2Vzc1Rva2VuIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICBjcmVkLnNlY3JldCA9IHJlc3Quc2VjcmV0O1xyXG4gICAgICAgIGNyZWQubm9uY2UgPSByZXN0Lm5vbmNlO1xyXG4gICAgICAgIGNyZWQucGVuZGluZ1Rva2VuID0gcmVzdC5wZW5kaW5nVG9rZW4gfHwgbnVsbDtcclxuICAgICAgICByZXR1cm4gY3JlZDtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aCkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xyXG4gICAgICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2xpbmtUb0lkVG9rZW4oYXV0aCwgaWRUb2tlbikge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xyXG4gICAgICAgIHJlcXVlc3QuaWRUb2tlbiA9IGlkVG9rZW47XHJcbiAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGgpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5idWlsZFJlcXVlc3QoKTtcclxuICAgICAgICByZXF1ZXN0LmF1dG9DcmVhdGUgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIGJ1aWxkUmVxdWVzdCgpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICByZXF1ZXN0VXJpOiBJRFBfUkVRVUVTVF9VUkkkMSxcclxuICAgICAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdUb2tlbikge1xyXG4gICAgICAgICAgICByZXF1ZXN0LnBlbmRpbmdUb2tlbiA9IHRoaXMucGVuZGluZ1Rva2VuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcG9zdEJvZHkgPSB7fTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaWRUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgcG9zdEJvZHlbJ2lkX3Rva2VuJ10gPSB0aGlzLmlkVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHBvc3RCb2R5WydhY2Nlc3NfdG9rZW4nXSA9IHRoaXMuYWNjZXNzVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuc2VjcmV0KSB7XHJcbiAgICAgICAgICAgICAgICBwb3N0Qm9keVsnb2F1dGhfdG9rZW5fc2VjcmV0J10gPSB0aGlzLnNlY3JldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwb3N0Qm9keVsncHJvdmlkZXJJZCddID0gdGhpcy5wcm92aWRlcklkO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ub25jZSAmJiAhdGhpcy5wZW5kaW5nVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHBvc3RCb2R5Wydub25jZSddID0gdGhpcy5ub25jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXF1ZXN0LnBvc3RCb2R5ID0gcXVlcnlzdHJpbmcocG9zdEJvZHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoUGhvbmVOdW1iZXIkMShhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aFBob25lTnVtYmVyXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX1BIT05FX05VTUJFUiAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBsaW5rV2l0aFBob25lTnVtYmVyJDEoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoUGhvbmVOdW1iZXJcIiAvKiBFbmRwb2ludC5TSUdOX0lOX1dJVEhfUEhPTkVfTlVNQkVSICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xyXG4gICAgaWYgKHJlc3BvbnNlLnRlbXBvcmFyeVByb29mKSB7XHJcbiAgICAgICAgdGhyb3cgX21ha2VUYWdnZWRFcnJvcihhdXRoLCBcImFjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLk5FRURfQ09ORklSTUFUSU9OICovLCByZXNwb25zZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzcG9uc2U7XHJcbn1cclxuY29uc3QgVkVSSUZZX1BIT05FX05VTUJFUl9GT1JfRVhJU1RJTkdfRVJST1JfTUFQXyA9IHtcclxuICAgIFtcIlVTRVJfTk9UX0ZPVU5EXCIgLyogU2VydmVyRXJyb3IuVVNFUl9OT1RfRk9VTkQgKi9dOiBcInVzZXItbm90LWZvdW5kXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RFTEVURUQgKi9cclxufTtcclxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5UGhvbmVOdW1iZXJGb3JFeGlzdGluZyhhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICBjb25zdCBhcGlSZXF1ZXN0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgeyBvcGVyYXRpb246ICdSRUFVVEgnIH0pO1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhQaG9uZU51bWJlclwiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9QSE9ORV9OVU1CRVIgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCBhcGlSZXF1ZXN0KSwgVkVSSUZZX1BIT05FX05VTUJFUl9GT1JfRVhJU1RJTkdfRVJST1JfTUFQXyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIGNyZWRlbnRpYWxzIHJldHVybmVkIGJ5IHtAbGluayBQaG9uZUF1dGhQcm92aWRlcn0uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIFBob25lQXV0aENyZWRlbnRpYWwgZXh0ZW5kcyBBdXRoQ3JlZGVudGlhbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcclxuICAgICAgICBzdXBlcihcInBob25lXCIgLyogUHJvdmlkZXJJZC5QSE9ORSAqLywgXCJwaG9uZVwiIC8qIFNpZ25Jbk1ldGhvZC5QSE9ORSAqLyk7XHJcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgX2Zyb21WZXJpZmljYXRpb24odmVyaWZpY2F0aW9uSWQsIHZlcmlmaWNhdGlvbkNvZGUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBob25lQXV0aENyZWRlbnRpYWwoeyB2ZXJpZmljYXRpb25JZCwgdmVyaWZpY2F0aW9uQ29kZSB9KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHN0YXRpYyBfZnJvbVRva2VuUmVzcG9uc2UocGhvbmVOdW1iZXIsIHRlbXBvcmFyeVByb29mKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQaG9uZUF1dGhDcmVkZW50aWFsKHsgcGhvbmVOdW1iZXIsIHRlbXBvcmFyeVByb29mIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2dldElkVG9rZW5SZXNwb25zZShhdXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhQaG9uZU51bWJlciQxKGF1dGgsIHRoaXMuX21ha2VWZXJpZmljYXRpb25SZXF1ZXN0KCkpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2xpbmtUb0lkVG9rZW4oYXV0aCwgaWRUb2tlbikge1xyXG4gICAgICAgIHJldHVybiBsaW5rV2l0aFBob25lTnVtYmVyJDEoYXV0aCwgT2JqZWN0LmFzc2lnbih7IGlkVG9rZW4gfSwgdGhpcy5fbWFrZVZlcmlmaWNhdGlvblJlcXVlc3QoKSkpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihhdXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHZlcmlmeVBob25lTnVtYmVyRm9yRXhpc3RpbmcoYXV0aCwgdGhpcy5fbWFrZVZlcmlmaWNhdGlvblJlcXVlc3QoKSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfbWFrZVZlcmlmaWNhdGlvblJlcXVlc3QoKSB7XHJcbiAgICAgICAgY29uc3QgeyB0ZW1wb3JhcnlQcm9vZiwgcGhvbmVOdW1iZXIsIHZlcmlmaWNhdGlvbklkLCB2ZXJpZmljYXRpb25Db2RlIH0gPSB0aGlzLnBhcmFtcztcclxuICAgICAgICBpZiAodGVtcG9yYXJ5UHJvb2YgJiYgcGhvbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdGVtcG9yYXJ5UHJvb2YsIHBob25lTnVtYmVyIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNlc3Npb25JbmZvOiB2ZXJpZmljYXRpb25JZCxcclxuICAgICAgICAgICAgY29kZTogdmVyaWZpY2F0aW9uQ29kZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKioge0Bpbmhlcml0ZG9jIEF1dGhDcmVkZW50aWFsLnRvSlNPTn0gKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCBvYmogPSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IHRoaXMucHJvdmlkZXJJZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLnBob25lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIG9iai5waG9uZU51bWJlciA9IHRoaXMucGFyYW1zLnBob25lTnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wYXJhbXMudGVtcG9yYXJ5UHJvb2YpIHtcclxuICAgICAgICAgICAgb2JqLnRlbXBvcmFyeVByb29mID0gdGhpcy5wYXJhbXMudGVtcG9yYXJ5UHJvb2Y7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy52ZXJpZmljYXRpb25Db2RlKSB7XHJcbiAgICAgICAgICAgIG9iai52ZXJpZmljYXRpb25Db2RlID0gdGhpcy5wYXJhbXMudmVyaWZpY2F0aW9uQ29kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLnZlcmlmaWNhdGlvbklkKSB7XHJcbiAgICAgICAgICAgIG9iai52ZXJpZmljYXRpb25JZCA9IHRoaXMucGFyYW1zLnZlcmlmaWNhdGlvbklkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gICAgLyoqIEdlbmVyYXRlcyBhIHBob25lIGNyZWRlbnRpYWwgYmFzZWQgb24gYSBwbGFpbiBvYmplY3Qgb3IgYSBKU09OIHN0cmluZy4gKi9cclxuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZShqc29uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyB2ZXJpZmljYXRpb25JZCwgdmVyaWZpY2F0aW9uQ29kZSwgcGhvbmVOdW1iZXIsIHRlbXBvcmFyeVByb29mIH0gPSBqc29uO1xyXG4gICAgICAgIGlmICghdmVyaWZpY2F0aW9uQ29kZSAmJlxyXG4gICAgICAgICAgICAhdmVyaWZpY2F0aW9uSWQgJiZcclxuICAgICAgICAgICAgIXBob25lTnVtYmVyICYmXHJcbiAgICAgICAgICAgICF0ZW1wb3JhcnlQcm9vZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQaG9uZUF1dGhDcmVkZW50aWFsKHtcclxuICAgICAgICAgICAgdmVyaWZpY2F0aW9uSWQsXHJcbiAgICAgICAgICAgIHZlcmlmaWNhdGlvbkNvZGUsXHJcbiAgICAgICAgICAgIHBob25lTnVtYmVyLFxyXG4gICAgICAgICAgICB0ZW1wb3JhcnlQcm9vZlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBNYXBzIHRoZSBtb2RlIHN0cmluZyBpbiBhY3Rpb24gY29kZSBVUkwgdG8gQWN0aW9uIENvZGUgSW5mbyBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBtb2RlXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZU1vZGUobW9kZSkge1xyXG4gICAgc3dpdGNoIChtb2RlKSB7XHJcbiAgICAgICAgY2FzZSAncmVjb3ZlckVtYWlsJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiUkVDT1ZFUl9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uUkVDT1ZFUl9FTUFJTCAqLztcclxuICAgICAgICBjYXNlICdyZXNldFBhc3N3b3JkJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiUEFTU1dPUkRfUkVTRVRcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlBBU1NXT1JEX1JFU0VUICovO1xyXG4gICAgICAgIGNhc2UgJ3NpZ25Jbic6XHJcbiAgICAgICAgICAgIHJldHVybiBcIkVNQUlMX1NJR05JTlwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uRU1BSUxfU0lHTklOICovO1xyXG4gICAgICAgIGNhc2UgJ3ZlcmlmeUVtYWlsJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiVkVSSUZZX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfRU1BSUwgKi87XHJcbiAgICAgICAgY2FzZSAndmVyaWZ5QW5kQ2hhbmdlRW1haWwnOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJWRVJJRllfQU5EX0NIQU5HRV9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwgKi87XHJcbiAgICAgICAgY2FzZSAncmV2ZXJ0U2Vjb25kRmFjdG9yQWRkaXRpb24nOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJSRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTlwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT04gKi87XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0byBwYXJzZSBGREwgbGlua3NcclxuICpcclxuICogQHBhcmFtIHVybFxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VEZWVwTGluayh1cmwpIHtcclxuICAgIGNvbnN0IGxpbmsgPSBxdWVyeXN0cmluZ0RlY29kZShleHRyYWN0UXVlcnlzdHJpbmcodXJsKSlbJ2xpbmsnXTtcclxuICAgIC8vIERvdWJsZSBsaW5rIGNhc2UgKGF1dG9tYXRpYyByZWRpcmVjdCkuXHJcbiAgICBjb25zdCBkb3VibGVEZWVwTGluayA9IGxpbmtcclxuICAgICAgICA/IHF1ZXJ5c3RyaW5nRGVjb2RlKGV4dHJhY3RRdWVyeXN0cmluZyhsaW5rKSlbJ2RlZXBfbGlua19pZCddXHJcbiAgICAgICAgOiBudWxsO1xyXG4gICAgLy8gaU9TIGN1c3RvbSBzY2hlbWUgbGlua3MuXHJcbiAgICBjb25zdCBpT1NEZWVwTGluayA9IHF1ZXJ5c3RyaW5nRGVjb2RlKGV4dHJhY3RRdWVyeXN0cmluZyh1cmwpKVsnZGVlcF9saW5rX2lkJ107XHJcbiAgICBjb25zdCBpT1NEb3VibGVEZWVwTGluayA9IGlPU0RlZXBMaW5rXHJcbiAgICAgICAgPyBxdWVyeXN0cmluZ0RlY29kZShleHRyYWN0UXVlcnlzdHJpbmcoaU9TRGVlcExpbmspKVsnbGluayddXHJcbiAgICAgICAgOiBudWxsO1xyXG4gICAgcmV0dXJuIGlPU0RvdWJsZURlZXBMaW5rIHx8IGlPU0RlZXBMaW5rIHx8IGRvdWJsZURlZXBMaW5rIHx8IGxpbmsgfHwgdXJsO1xyXG59XHJcbi8qKlxyXG4gKiBBIHV0aWxpdHkgY2xhc3MgdG8gcGFyc2UgZW1haWwgYWN0aW9uIFVSTHMgc3VjaCBhcyBwYXNzd29yZCByZXNldCwgZW1haWwgdmVyaWZpY2F0aW9uLFxyXG4gKiBlbWFpbCBsaW5rIHNpZ24gaW4sIGV0Yy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgQWN0aW9uQ29kZVVSTCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBhY3Rpb25MaW5rIC0gVGhlIGxpbmsgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBVUkwuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUge0BsaW5rIEFjdGlvbkNvZGVVUkx9IG9iamVjdCwgb3IgbnVsbCBpZiB0aGUgbGluayBpcyBpbnZhbGlkLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihhY3Rpb25MaW5rKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XHJcbiAgICAgICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gcXVlcnlzdHJpbmdEZWNvZGUoZXh0cmFjdFF1ZXJ5c3RyaW5nKGFjdGlvbkxpbmspKTtcclxuICAgICAgICBjb25zdCBhcGlLZXkgPSAoX2EgPSBzZWFyY2hQYXJhbXNbXCJhcGlLZXlcIiAvKiBRdWVyeUZpZWxkLkFQSV9LRVkgKi9dKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xyXG4gICAgICAgIGNvbnN0IGNvZGUgPSAoX2IgPSBzZWFyY2hQYXJhbXNbXCJvb2JDb2RlXCIgLyogUXVlcnlGaWVsZC5DT0RFICovXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcclxuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBwYXJzZU1vZGUoKF9jID0gc2VhcmNoUGFyYW1zW1wibW9kZVwiIC8qIFF1ZXJ5RmllbGQuTU9ERSAqL10pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGwpO1xyXG4gICAgICAgIC8vIFZhbGlkYXRlIEFQSSBrZXksIGNvZGUgYW5kIG1vZGUuXHJcbiAgICAgICAgX2Fzc2VydChhcGlLZXkgJiYgY29kZSAmJiBvcGVyYXRpb24sIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcclxuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcclxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgIHRoaXMuY29udGludWVVcmwgPSAoX2QgPSBzZWFyY2hQYXJhbXNbXCJjb250aW51ZVVybFwiIC8qIFF1ZXJ5RmllbGQuQ09OVElOVUVfVVJMICovXSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbnVsbDtcclxuICAgICAgICB0aGlzLmxhbmd1YWdlQ29kZSA9IChfZSA9IHNlYXJjaFBhcmFtc1tcImxhbmd1YWdlQ29kZVwiIC8qIFF1ZXJ5RmllbGQuTEFOR1VBR0VfQ09ERSAqL10pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IG51bGw7XHJcbiAgICAgICAgdGhpcy50ZW5hbnRJZCA9IChfZiA9IHNlYXJjaFBhcmFtc1tcInRlbmFudElkXCIgLyogUXVlcnlGaWVsZC5URU5BTlRfSUQgKi9dKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgdGhlIGVtYWlsIGFjdGlvbiBsaW5rIHN0cmluZyBhbmQgcmV0dXJucyBhbiB7QGxpbmsgQWN0aW9uQ29kZVVSTH0gaWYgdGhlIGxpbmsgaXMgdmFsaWQsXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJucyBudWxsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsaW5rICAtIFRoZSBlbWFpbCBhY3Rpb24gbGluayBzdHJpbmcuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUge0BsaW5rIEFjdGlvbkNvZGVVUkx9IG9iamVjdCwgb3IgbnVsbCBpZiB0aGUgbGluayBpcyBpbnZhbGlkLlxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHBhcnNlTGluayhsaW5rKSB7XHJcbiAgICAgICAgY29uc3QgYWN0aW9uTGluayA9IHBhcnNlRGVlcExpbmsobGluayk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb25Db2RlVVJMKGFjdGlvbkxpbmspO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBQYXJzZXMgdGhlIGVtYWlsIGFjdGlvbiBsaW5rIHN0cmluZyBhbmQgcmV0dXJucyBhbiB7QGxpbmsgQWN0aW9uQ29kZVVSTH0gaWZcclxuICogdGhlIGxpbmsgaXMgdmFsaWQsIG90aGVyd2lzZSByZXR1cm5zIG51bGwuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlQWN0aW9uQ29kZVVSTChsaW5rKSB7XHJcbiAgICByZXR1cm4gQWN0aW9uQ29kZVVSTC5wYXJzZUxpbmsobGluayk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIHtAbGluayBFbWFpbEF1dGhDcmVkZW50aWFsfS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgRW1haWxBdXRoUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uUEFTU1dPUkQsIGV2ZW4gZm9yIGVtYWlsIGxpbmsuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wcm92aWRlcklkID0gRW1haWxBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemUgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSB1c2luZyBhbiBlbWFpbCBhbmQgcGFzc3dvcmQuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAqIGNvbnN0IGF1dGhDcmVkZW50aWFsID0gRW1haWxBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChlbWFpbCwgcGFzc3dvcmQpO1xyXG4gICAgICogY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChhdXRoLCBhdXRoQ3JlZGVudGlhbCk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICogY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZChhdXRoLCBlbWFpbCwgcGFzc3dvcmQpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVtYWlsIC0gRW1haWwgYWRkcmVzcy5cclxuICAgICAqIEBwYXJhbSBwYXNzd29yZCAtIFVzZXIgYWNjb3VudCBwYXNzd29yZC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBhdXRoIHByb3ZpZGVyIGNyZWRlbnRpYWwuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsKGVtYWlsLCBwYXNzd29yZCkge1xyXG4gICAgICAgIHJldHVybiBFbWFpbEF1dGhDcmVkZW50aWFsLl9mcm9tRW1haWxBbmRQYXNzd29yZChlbWFpbCwgcGFzc3dvcmQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0gdXNpbmcgYW4gZW1haWwgYW5kIGFuIGVtYWlsIGxpbmsgYWZ0ZXIgYSBzaWduIGluIHdpdGhcclxuICAgICAqIGVtYWlsIGxpbmsgb3BlcmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgKiBjb25zdCBhdXRoQ3JlZGVudGlhbCA9IEVtYWlsQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxXaXRoTGluayhhdXRoLCBlbWFpbCwgZW1haWxMaW5rKTtcclxuICAgICAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgc2lnbkluV2l0aENyZWRlbnRpYWwoYXV0aCwgYXV0aENyZWRlbnRpYWwpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAqIGF3YWl0IHNlbmRTaWduSW5MaW5rVG9FbWFpbChhdXRoLCBlbWFpbCk7XHJcbiAgICAgKiAvLyBPYnRhaW4gZW1haWxMaW5rIGZyb20gdXNlci5cclxuICAgICAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgc2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCBlbWFpbCwgZW1haWxMaW5rKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZSB1c2VkIHRvIHZlcmlmeSB0aGUgbGluay5cclxuICAgICAqIEBwYXJhbSBlbWFpbCAtIEVtYWlsIGFkZHJlc3MuXHJcbiAgICAgKiBAcGFyYW0gZW1haWxMaW5rIC0gU2lnbi1pbiBlbWFpbCBsaW5rLlxyXG4gICAgICogQHJldHVybnMgLSBUaGUgYXV0aCBwcm92aWRlciBjcmVkZW50aWFsLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbFdpdGhMaW5rKGVtYWlsLCBlbWFpbExpbmspIHtcclxuICAgICAgICBjb25zdCBhY3Rpb25Db2RlVXJsID0gQWN0aW9uQ29kZVVSTC5wYXJzZUxpbmsoZW1haWxMaW5rKTtcclxuICAgICAgICBfYXNzZXJ0KGFjdGlvbkNvZGVVcmwsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcclxuICAgICAgICByZXR1cm4gRW1haWxBdXRoQ3JlZGVudGlhbC5fZnJvbUVtYWlsQW5kQ29kZShlbWFpbCwgYWN0aW9uQ29kZVVybC5jb2RlLCBhY3Rpb25Db2RlVXJsLnRlbmFudElkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uUEFTU1dPUkQsIGV2ZW4gZm9yIGVtYWlsIGxpbmsuXHJcbiAqL1xyXG5FbWFpbEF1dGhQcm92aWRlci5QUk9WSURFUl9JRCA9IFwicGFzc3dvcmRcIiAvKiBQcm92aWRlcklkLlBBU1NXT1JEICovO1xyXG4vKipcclxuICogQWx3YXlzIHNldCB0byB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9QQVNTV09SRC5cclxuICovXHJcbkVtYWlsQXV0aFByb3ZpZGVyLkVNQUlMX1BBU1NXT1JEX1NJR05fSU5fTUVUSE9EID0gXCJwYXNzd29yZFwiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9QQVNTV09SRCAqLztcclxuLyoqXHJcbiAqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfTElOSy5cclxuICovXHJcbkVtYWlsQXV0aFByb3ZpZGVyLkVNQUlMX0xJTktfU0lHTl9JTl9NRVRIT0QgPSBcImVtYWlsTGlua1wiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LICovO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBGZWRlcmF0ZWQgcHJvdmlkZXJzIChPQXV0aCAoaW5jbHVkaW5nIE9JREMpLCBTQU1MKS5cclxuICpcclxuICogVGhpcyBjbGFzcyBpcyBub3QgbWVhbnQgdG8gYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgZ2VuZXJpYyBPQXV0aCBwcm92aWRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByb3ZpZGVySWQgLSBQcm92aWRlciBmb3Igd2hpY2ggY3JlZGVudGlhbHMgc2hvdWxkIGJlIGdlbmVyYXRlZC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXJJZCkge1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJJZCA9IHByb3ZpZGVySWQ7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdExhbmd1YWdlQ29kZSA9IG51bGw7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMuY3VzdG9tUGFyYW1ldGVycyA9IHt9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGxhbmd1YWdlIGdvZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlQ29kZSAtIGxhbmd1YWdlIGNvZGVcclxuICAgICAqL1xyXG4gICAgc2V0RGVmYXVsdExhbmd1YWdlKGxhbmd1YWdlQ29kZSkge1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdExhbmd1YWdlQ29kZSA9IGxhbmd1YWdlQ29kZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgT0F1dGggY3VzdG9tIHBhcmFtZXRlcnMgdG8gcGFzcyBpbiBhbiBPQXV0aCByZXF1ZXN0IGZvciBwb3B1cCBhbmQgcmVkaXJlY3Qgc2lnbi1pblxyXG4gICAgICogb3BlcmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICogRm9yIGEgZGV0YWlsZWQgbGlzdCwgY2hlY2sgdGhlIHJlc2VydmVkIHJlcXVpcmVkIE9BdXRoIDIuMCBwYXJhbWV0ZXJzIHN1Y2ggYXMgYGNsaWVudF9pZGAsXHJcbiAgICAgKiBgcmVkaXJlY3RfdXJpYCwgYHNjb3BlYCwgYHJlc3BvbnNlX3R5cGVgLCBhbmQgYHN0YXRlYCBhcmUgbm90IGFsbG93ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3VzdG9tT0F1dGhQYXJhbWV0ZXJzIC0gVGhlIGN1c3RvbSBPQXV0aCBwYXJhbWV0ZXJzIHRvIHBhc3MgaW4gdGhlIE9BdXRoIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIHNldEN1c3RvbVBhcmFtZXRlcnMoY3VzdG9tT0F1dGhQYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgdGhpcy5jdXN0b21QYXJhbWV0ZXJzID0gY3VzdG9tT0F1dGhQYXJhbWV0ZXJzO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBsaXN0IG9mIHtAbGluayBDdXN0b21QYXJhbWV0ZXJzfS5cclxuICAgICAqL1xyXG4gICAgZ2V0Q3VzdG9tUGFyYW1ldGVycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21QYXJhbWV0ZXJzO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDb21tb24gY29kZSB0byBhbGwgT0F1dGggcHJvdmlkZXJzLiBUaGlzIGlzIHNlcGFyYXRlIGZyb20gdGhlXHJcbiAqIHtAbGluayBPQXV0aFByb3ZpZGVyfSBzbyB0aGF0IGNoaWxkIHByb3ZpZGVycyAobGlrZVxyXG4gKiB7QGxpbmsgR29vZ2xlQXV0aFByb3ZpZGVyfSkgZG9uJ3QgaW5oZXJpdCB0aGUgYGNyZWRlbnRpYWxgIGluc3RhbmNlIG1ldGhvZC5cclxuICogSW5zdGVhZCwgdGhleSByZWx5IG9uIGEgc3RhdGljIGBjcmVkZW50aWFsYCBtZXRob2QuXHJcbiAqL1xyXG5jbGFzcyBCYXNlT0F1dGhQcm92aWRlciBleHRlbmRzIEZlZGVyYXRlZEF1dGhQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLnNjb3BlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYW4gT0F1dGggc2NvcGUgdG8gdGhlIGNyZWRlbnRpYWwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNjb3BlIC0gUHJvdmlkZXIgT0F1dGggc2NvcGUgdG8gYWRkLlxyXG4gICAgICovXHJcbiAgICBhZGRTY29wZShzY29wZSkge1xyXG4gICAgICAgIC8vIElmIG5vdCBhbHJlYWR5IGFkZGVkLCBhZGQgc2NvcGUgdG8gbGlzdC5cclxuICAgICAgICBpZiAoIXRoaXMuc2NvcGVzLmluY2x1ZGVzKHNjb3BlKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNjb3Blcy5wdXNoKHNjb3BlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGxpc3Qgb2YgT0F1dGggc2NvcGVzLlxyXG4gICAgICovXHJcbiAgICBnZXRTY29wZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLnNjb3Blc107XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGdlbmVyaWMge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxyXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBPQXV0aFByb3ZpZGVyKCdnb29nbGUuY29tJyk7XHJcbiAqIC8vIFN0YXJ0IGEgc2lnbiBpbiBwcm9jZXNzIGZvciBhbiB1bmF1dGhlbnRpY2F0ZWQgdXNlci5cclxuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3Byb2ZpbGUnKTtcclxuICogcHJvdmlkZXIuYWRkU2NvcGUoJ2VtYWlsJyk7XHJcbiAqIGF3YWl0IHNpZ25JbldpdGhSZWRpcmVjdChhdXRoLCBwcm92aWRlcik7XHJcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxyXG4gKlxyXG4gKiAvLyBBZnRlciByZXR1cm5pbmcgZnJvbSB0aGUgcmVkaXJlY3Qgd2hlbiB5b3VyIGFwcCBpbml0aWFsaXplcyB5b3UgY2FuIG9idGFpbiB0aGUgcmVzdWx0XHJcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xyXG4gKiBpZiAocmVzdWx0KSB7XHJcbiAqICAgLy8gVGhpcyBpcyB0aGUgc2lnbmVkLWluIHVzZXJcclxuICogICBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XHJcbiAqICAgLy8gVGhpcyBnaXZlcyB5b3UgYSBPQXV0aCBBY2Nlc3MgVG9rZW4gZm9yIHRoZSBwcm92aWRlci5cclxuICogICBjb25zdCBjcmVkZW50aWFsID0gcHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQoYXV0aCwgcmVzdWx0KTtcclxuICogICBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gU2lnbiBpbiB1c2luZyBhIHBvcHVwLlxyXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBPQXV0aFByb3ZpZGVyKCdnb29nbGUuY29tJyk7XHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdwcm9maWxlJyk7XHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdlbWFpbCcpO1xyXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xyXG4gKlxyXG4gKiAvLyBUaGUgc2lnbmVkLWluIHVzZXIgaW5mby5cclxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xyXG4gKiAvLyBUaGlzIGdpdmVzIHlvdSBhIE9BdXRoIEFjY2VzcyBUb2tlbiBmb3IgdGhlIHByb3ZpZGVyLlxyXG4gKiBjb25zdCBjcmVkZW50aWFsID0gcHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQoYXV0aCwgcmVzdWx0KTtcclxuICogY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xyXG4gKiBgYGBcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgT0F1dGhQcm92aWRlciBleHRlbmRzIEJhc2VPQXV0aFByb3ZpZGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEgSlNPTiBzdHJpbmcgb3IgYSBwbGFpbiBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ganNvbiAtIEEgcGxhaW4gb2JqZWN0IG9yIGEgSlNPTiBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgY29uc3Qgb2JqID0gdHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb247XHJcbiAgICAgICAgX2Fzc2VydCgncHJvdmlkZXJJZCcgaW4gb2JqICYmICdzaWduSW5NZXRob2QnIGluIG9iaiwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xyXG4gICAgICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMob2JqKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSBnZW5lcmljIE9BdXRoIHByb3ZpZGVyJ3MgYWNjZXNzIHRva2VuIG9yIElEIHRva2VuLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBUaGUgcmF3IG5vbmNlIGlzIHJlcXVpcmVkIHdoZW4gYW4gSUQgdG9rZW4gd2l0aCBhIG5vbmNlIGZpZWxkIGlzIHByb3ZpZGVkLiBUaGUgU0hBLTI1NiBoYXNoIG9mXHJcbiAgICAgKiB0aGUgcmF3IG5vbmNlIG11c3QgbWF0Y2ggdGhlIG5vbmNlIGZpZWxkIGluIHRoZSBJRCB0b2tlbi5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICogLy8gYGdvb2dsZVVzZXJgIGZyb20gdGhlIG9uc3VjY2VzcyBHb29nbGUgU2lnbiBJbiBjYWxsYmFjay5cclxuICAgICAqIC8vIEluaXRpYWxpemUgYSBnZW5lcmF0ZSBPQXV0aCBwcm92aWRlciB3aXRoIGEgYGdvb2dsZS5jb21gIHByb3ZpZGVySWQuXHJcbiAgICAgKiBjb25zdCBwcm92aWRlciA9IG5ldyBPQXV0aFByb3ZpZGVyKCdnb29nbGUuY29tJyk7XHJcbiAgICAgKiBjb25zdCBjcmVkZW50aWFsID0gcHJvdmlkZXIuY3JlZGVudGlhbCh7XHJcbiAgICAgKiAgIGlkVG9rZW46IGdvb2dsZVVzZXIuZ2V0QXV0aFJlc3BvbnNlKCkuaWRfdG9rZW4sXHJcbiAgICAgKiB9KTtcclxuICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhDcmVkZW50aWFsKGNyZWRlbnRpYWwpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIEVpdGhlciB0aGUgb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyB0aGUgSUQgdG9rZW4sIGFjY2VzcyB0b2tlbiBhbmQgcmF3IG5vbmNlXHJcbiAgICAgKiBvciB0aGUgSUQgdG9rZW4gc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBjcmVkZW50aWFsKHBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVkZW50aWFsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgeyBub25jZTogcGFyYW1zLnJhd05vbmNlIH0pKTtcclxuICAgIH1cclxuICAgIC8qKiBBbiBpbnRlcm5hbCBjcmVkZW50aWFsIG1ldGhvZCB0aGF0IGFjY2VwdHMgbW9yZSBwZXJtaXNzaXZlIG9wdGlvbnMgKi9cclxuICAgIF9jcmVkZW50aWFsKHBhcmFtcykge1xyXG4gICAgICAgIF9hc3NlcnQocGFyYW1zLmlkVG9rZW4gfHwgcGFyYW1zLmFjY2Vzc1Rva2VuLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XHJcbiAgICAgICAgLy8gRm9yIE9BdXRoQ3JlZGVudGlhbCwgc2lnbiBpbiBtZXRob2QgaXMgc2FtZSBhcyBwcm92aWRlcklkLlxyXG4gICAgICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IHByb3ZpZGVySWQ6IHRoaXMucHJvdmlkZXJJZCwgc2lnbkluTWV0aG9kOiB0aGlzLnByb3ZpZGVySWQgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKSB7XHJcbiAgICAgICAgcmV0dXJuIE9BdXRoUHJvdmlkZXIub2F1dGhDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh1c2VyQ3JlZGVudGlhbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXHJcbiAgICAgKiB0aHJvd24gZHVyaW5nIGEgc2lnbi1pbiwgbGluaywgb3IgcmVhdXRoZW50aWNhdGUgb3BlcmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbUVycm9yKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIE9BdXRoUHJvdmlkZXIub2F1dGhDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCgoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG9hdXRoQ3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoeyBfdG9rZW5SZXNwb25zZTogdG9rZW5SZXNwb25zZSB9KSB7XHJcbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IG9hdXRoSWRUb2tlbiwgb2F1dGhBY2Nlc3NUb2tlbiwgb2F1dGhUb2tlblNlY3JldCwgcGVuZGluZ1Rva2VuLCBub25jZSwgcHJvdmlkZXJJZCB9ID0gdG9rZW5SZXNwb25zZTtcclxuICAgICAgICBpZiAoIW9hdXRoQWNjZXNzVG9rZW4gJiZcclxuICAgICAgICAgICAgIW9hdXRoVG9rZW5TZWNyZXQgJiZcclxuICAgICAgICAgICAgIW9hdXRoSWRUb2tlbiAmJlxyXG4gICAgICAgICAgICAhcGVuZGluZ1Rva2VuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXByb3ZpZGVySWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgT0F1dGhQcm92aWRlcihwcm92aWRlcklkKS5fY3JlZGVudGlhbCh7XHJcbiAgICAgICAgICAgICAgICBpZFRva2VuOiBvYXV0aElkVG9rZW4sXHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbjogb2F1dGhBY2Nlc3NUb2tlbixcclxuICAgICAgICAgICAgICAgIG5vbmNlLFxyXG4gICAgICAgICAgICAgICAgcGVuZGluZ1Rva2VuXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGFuIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZvciB7QGxpbmsgUHJvdmlkZXJJZH0uRkFDRUJPT0suXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxyXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBGYWNlYm9va0F1dGhQcm92aWRlcigpO1xyXG4gKiAvLyBTdGFydCBhIHNpZ24gaW4gcHJvY2VzcyBmb3IgYW4gdW5hdXRoZW50aWNhdGVkIHVzZXIuXHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCd1c2VyX2JpcnRoZGF5Jyk7XHJcbiAqIGF3YWl0IHNpZ25JbldpdGhSZWRpcmVjdChhdXRoLCBwcm92aWRlcik7XHJcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxyXG4gKlxyXG4gKiAvLyBBZnRlciByZXR1cm5pbmcgZnJvbSB0aGUgcmVkaXJlY3Qgd2hlbiB5b3VyIGFwcCBpbml0aWFsaXplcyB5b3UgY2FuIG9idGFpbiB0aGUgcmVzdWx0XHJcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xyXG4gKiBpZiAocmVzdWx0KSB7XHJcbiAqICAgLy8gVGhpcyBpcyB0aGUgc2lnbmVkLWluIHVzZXJcclxuICogICBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XHJcbiAqICAgLy8gVGhpcyBnaXZlcyB5b3UgYSBGYWNlYm9vayBBY2Nlc3MgVG9rZW4uXHJcbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IEZhY2Vib29rQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XHJcbiAqICAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSBwb3B1cC5cclxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgRmFjZWJvb2tBdXRoUHJvdmlkZXIoKTtcclxuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3VzZXJfYmlydGhkYXknKTtcclxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHByb3ZpZGVyKTtcclxuICpcclxuICogLy8gVGhlIHNpZ25lZC1pbiB1c2VyIGluZm8uXHJcbiAqIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcclxuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBGYWNlYm9vayBBY2Nlc3MgVG9rZW4uXHJcbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xyXG4gKiBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBGYWNlYm9va0F1dGhQcm92aWRlciBleHRlbmRzIEJhc2VPQXV0aFByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKFwiZmFjZWJvb2suY29tXCIgLyogUHJvdmlkZXJJZC5GQUNFQk9PSyAqLyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjcmVkZW50aWFsIGZvciBGYWNlYm9vay5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICogLy8gYGV2ZW50YCBmcm9tIHRoZSBGYWNlYm9vayBhdXRoLmF1dGhSZXNwb25zZUNoYW5nZSBjYWxsYmFjay5cclxuICAgICAqIGNvbnN0IGNyZWRlbnRpYWwgPSBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsKGV2ZW50LmF1dGhSZXNwb25zZS5hY2Nlc3NUb2tlbik7XHJcbiAgICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChjcmVkZW50aWFsKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiAtIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWwoYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKHtcclxuICAgICAgICAgICAgcHJvdmlkZXJJZDogRmFjZWJvb2tBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQsXHJcbiAgICAgICAgICAgIHNpZ25Jbk1ldGhvZDogRmFjZWJvb2tBdXRoUHJvdmlkZXIuRkFDRUJPT0tfU0lHTl9JTl9NRVRIT0QsXHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIFVzZXJDcmVkZW50aWFsfS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQodXNlckNyZWRlbnRpYWwpIHtcclxuICAgICAgICByZXR1cm4gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QodXNlckNyZWRlbnRpYWwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xyXG4gICAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCgoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHsgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2UgfSkge1xyXG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZSB8fCAhKCdvYXV0aEFjY2Vzc1Rva2VuJyBpbiB0b2tlblJlc3BvbnNlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlLm9hdXRoQWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsKHRva2VuUmVzcG9uc2Uub2F1dGhBY2Nlc3NUb2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRkFDRUJPT0suICovXHJcbkZhY2Vib29rQXV0aFByb3ZpZGVyLkZBQ0VCT09LX1NJR05fSU5fTUVUSE9EID0gXCJmYWNlYm9vay5jb21cIiAvKiBTaWduSW5NZXRob2QuRkFDRUJPT0sgKi87XHJcbi8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBQcm92aWRlcklkfS5GQUNFQk9PSy4gKi9cclxuRmFjZWJvb2tBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQgPSBcImZhY2Vib29rLmNvbVwiIC8qIFByb3ZpZGVySWQuRkFDRUJPT0sgKi87XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBhbiB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmb3Ige0BsaW5rIFByb3ZpZGVySWR9LkdPT0dMRS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcmVkaXJlY3QuXHJcbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEdvb2dsZUF1dGhQcm92aWRlcigpO1xyXG4gKiAvLyBTdGFydCBhIHNpZ24gaW4gcHJvY2VzcyBmb3IgYW4gdW5hdXRoZW50aWNhdGVkIHVzZXIuXHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdwcm9maWxlJyk7XHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdlbWFpbCcpO1xyXG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xyXG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcclxuICpcclxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxyXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcclxuICogaWYgKHJlc3VsdCkge1xyXG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXHJcbiAqICAgY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xyXG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgR29vZ2xlIEFjY2VzcyBUb2tlbi5cclxuICogICBjb25zdCBjcmVkZW50aWFsID0gR29vZ2xlQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XHJcbiAqICAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSBwb3B1cC5cclxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgR29vZ2xlQXV0aFByb3ZpZGVyKCk7XHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdwcm9maWxlJyk7XHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdlbWFpbCcpO1xyXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xyXG4gKlxyXG4gKiAvLyBUaGUgc2lnbmVkLWluIHVzZXIgaW5mby5cclxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xyXG4gKiAvLyBUaGlzIGdpdmVzIHlvdSBhIEdvb2dsZSBBY2Nlc3MgVG9rZW4uXHJcbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcclxuICogY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xyXG4gKiBgYGBcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgR29vZ2xlQXV0aFByb3ZpZGVyIGV4dGVuZHMgQmFzZU9BdXRoUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoXCJnb29nbGUuY29tXCIgLyogUHJvdmlkZXJJZC5HT09HTEUgKi8pO1xyXG4gICAgICAgIHRoaXMuYWRkU2NvcGUoJ3Byb2ZpbGUnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNyZWRlbnRpYWwgZm9yIEdvb2dsZS4gQXQgbGVhc3Qgb25lIG9mIElEIHRva2VuIGFuZCBhY2Nlc3MgdG9rZW4gaXMgcmVxdWlyZWQuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAqIC8vIFxcYGdvb2dsZVVzZXJcXGAgZnJvbSB0aGUgb25zdWNjZXNzIEdvb2dsZSBTaWduIEluIGNhbGxiYWNrLlxyXG4gICAgICogY29uc3QgY3JlZGVudGlhbCA9IEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsKGdvb2dsZVVzZXIuZ2V0QXV0aFJlc3BvbnNlKCkuaWRfdG9rZW4pO1xyXG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aENyZWRlbnRpYWwoY3JlZGVudGlhbCk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWRUb2tlbiAtIEdvb2dsZSBJRCB0b2tlbi5cclxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiAtIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsKGlkVG9rZW4sIGFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgcmV0dXJuIE9BdXRoQ3JlZGVudGlhbC5fZnJvbVBhcmFtcyh7XHJcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IEdvb2dsZUF1dGhQcm92aWRlci5QUk9WSURFUl9JRCxcclxuICAgICAgICAgICAgc2lnbkluTWV0aG9kOiBHb29nbGVBdXRoUHJvdmlkZXIuR09PR0xFX1NJR05fSU5fTUVUSE9ELFxyXG4gICAgICAgICAgICBpZFRva2VuLFxyXG4gICAgICAgICAgICBhY2Nlc3NUb2tlblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKSB7XHJcbiAgICAgICAgcmV0dXJuIEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh1c2VyQ3JlZGVudGlhbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXHJcbiAgICAgKiB0aHJvd24gZHVyaW5nIGEgc2lnbi1pbiwgbGluaywgb3IgcmVhdXRoZW50aWNhdGUgb3BlcmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbUVycm9yKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCgoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHsgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2UgfSkge1xyXG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBvYXV0aElkVG9rZW4sIG9hdXRoQWNjZXNzVG9rZW4gfSA9IHRva2VuUmVzcG9uc2U7XHJcbiAgICAgICAgaWYgKCFvYXV0aElkVG9rZW4gJiYgIW9hdXRoQWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBhbiBvYXV0aCAxIGNyZWRlbnRpYWwgb3IgYSBwaG9uZSBjcmVkZW50aWFsXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gR29vZ2xlQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwob2F1dGhJZFRva2VuLCBvYXV0aEFjY2Vzc1Rva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKiogQWx3YXlzIHNldCB0byB7QGxpbmsgU2lnbkluTWV0aG9kfS5HT09HTEUuICovXHJcbkdvb2dsZUF1dGhQcm92aWRlci5HT09HTEVfU0lHTl9JTl9NRVRIT0QgPSBcImdvb2dsZS5jb21cIiAvKiBTaWduSW5NZXRob2QuR09PR0xFICovO1xyXG4vKiogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uR09PR0xFLiAqL1xyXG5Hb29nbGVBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQgPSBcImdvb2dsZS5jb21cIiAvKiBQcm92aWRlcklkLkdPT0dMRSAqLztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGFuIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZvciB7QGxpbmsgUHJvdmlkZXJJZH0uR0lUSFVCLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBHaXRIdWIgcmVxdWlyZXMgYW4gT0F1dGggMi4wIHJlZGlyZWN0LCBzbyB5b3UgY2FuIGVpdGhlciBoYW5kbGUgdGhlIHJlZGlyZWN0IGRpcmVjdGx5LCBvciB1c2VcclxuICogdGhlIHtAbGluayBzaWduSW5XaXRoUG9wdXB9IGhhbmRsZXI6XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxyXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBHaXRodWJBdXRoUHJvdmlkZXIoKTtcclxuICogLy8gU3RhcnQgYSBzaWduIGluIHByb2Nlc3MgZm9yIGFuIHVuYXV0aGVudGljYXRlZCB1c2VyLlxyXG4gKiBwcm92aWRlci5hZGRTY29wZSgncmVwbycpO1xyXG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xyXG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcclxuICpcclxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxyXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcclxuICogaWYgKHJlc3VsdCkge1xyXG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXHJcbiAqICAgY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xyXG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgR2l0aHViIEFjY2VzcyBUb2tlbi5cclxuICogICBjb25zdCBjcmVkZW50aWFsID0gR2l0aHViQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XHJcbiAqICAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSBwb3B1cC5cclxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgR2l0aHViQXV0aFByb3ZpZGVyKCk7XHJcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdyZXBvJyk7XHJcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhQb3B1cChhdXRoLCBwcm92aWRlcik7XHJcbiAqXHJcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxyXG4gKiBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XHJcbiAqIC8vIFRoaXMgZ2l2ZXMgeW91IGEgR2l0aHViIEFjY2VzcyBUb2tlbi5cclxuICogY29uc3QgY3JlZGVudGlhbCA9IEdpdGh1YkF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xyXG4gKiBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XHJcbiAqIGBgYFxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBHaXRodWJBdXRoUHJvdmlkZXIgZXh0ZW5kcyBCYXNlT0F1dGhQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihcImdpdGh1Yi5jb21cIiAvKiBQcm92aWRlcklkLkdJVEhVQiAqLyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjcmVkZW50aWFsIGZvciBHaXRodWIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjY2Vzc1Rva2VuIC0gR2l0aHViIGFjY2VzcyB0b2tlbi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWwoYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKHtcclxuICAgICAgICAgICAgcHJvdmlkZXJJZDogR2l0aHViQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lELFxyXG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IEdpdGh1YkF1dGhQcm92aWRlci5HSVRIVUJfU0lHTl9JTl9NRVRIT0QsXHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIFVzZXJDcmVkZW50aWFsfS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQodXNlckNyZWRlbnRpYWwpIHtcclxuICAgICAgICByZXR1cm4gR2l0aHViQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHVzZXJDcmVkZW50aWFsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgQXV0aEVycm9yfSB3aGljaCB3YXNcclxuICAgICAqIHRocm93biBkdXJpbmcgYSBzaWduLWluLCBsaW5rLCBvciByZWF1dGhlbnRpY2F0ZSBvcGVyYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gR2l0aHViQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KChlcnJvci5jdXN0b21EYXRhIHx8IHt9KSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoeyBfdG9rZW5SZXNwb25zZTogdG9rZW5SZXNwb25zZSB9KSB7XHJcbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlIHx8ICEoJ29hdXRoQWNjZXNzVG9rZW4nIGluIHRva2VuUmVzcG9uc2UpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRva2VuUmVzcG9uc2Uub2F1dGhBY2Nlc3NUb2tlbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIEdpdGh1YkF1dGhQcm92aWRlci5jcmVkZW50aWFsKHRva2VuUmVzcG9uc2Uub2F1dGhBY2Nlc3NUb2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uR0lUSFVCLiAqL1xyXG5HaXRodWJBdXRoUHJvdmlkZXIuR0lUSFVCX1NJR05fSU5fTUVUSE9EID0gXCJnaXRodWIuY29tXCIgLyogU2lnbkluTWV0aG9kLkdJVEhVQiAqLztcclxuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LkdJVEhVQi4gKi9cclxuR2l0aHViQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lEID0gXCJnaXRodWIuY29tXCIgLyogUHJvdmlkZXJJZC5HSVRIVUIgKi87XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IElEUF9SRVFVRVNUX1VSSSA9ICdodHRwOi8vbG9jYWxob3N0JztcclxuLyoqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIFNBTUxBdXRoQ3JlZGVudGlhbCBleHRlbmRzIEF1dGhDcmVkZW50aWFsIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVySWQsIHBlbmRpbmdUb2tlbikge1xyXG4gICAgICAgIHN1cGVyKHByb3ZpZGVySWQsIHByb3ZpZGVySWQpO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1Rva2VuID0gcGVuZGluZ1Rva2VuO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX2dldElkVG9rZW5SZXNwb25zZShhdXRoKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYnVpbGRSZXF1ZXN0KCk7XHJcbiAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfbGlua1RvSWRUb2tlbihhdXRoLCBpZFRva2VuKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYnVpbGRSZXF1ZXN0KCk7XHJcbiAgICAgICAgcmVxdWVzdC5pZFRva2VuID0gaWRUb2tlbjtcclxuICAgICAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIF9nZXRSZWF1dGhlbnRpY2F0aW9uUmVzb2x2ZXIoYXV0aCkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xyXG4gICAgICAgIHJlcXVlc3QuYXV0b0NyZWF0ZSA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpO1xyXG4gICAgfVxyXG4gICAgLyoqIHtAaW5oZXJpdGRvYyBBdXRoQ3JlZGVudGlhbC50b0pTT059ICAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNpZ25Jbk1ldGhvZDogdGhpcy5zaWduSW5NZXRob2QsXHJcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IHRoaXMucHJvdmlkZXJJZCxcclxuICAgICAgICAgICAgcGVuZGluZ1Rva2VuOiB0aGlzLnBlbmRpbmdUb2tlblxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXRpYyBtZXRob2QgdG8gZGVzZXJpYWxpemUgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdCBpbnRvIGFuXHJcbiAgICAgKiB7QGxpbmsgIEF1dGhDcmVkZW50aWFsfS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ganNvbiAtIElucHV0IGNhbiBiZSBlaXRoZXIgT2JqZWN0IG9yIHRoZSBzdHJpbmdpZmllZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICogV2hlbiBzdHJpbmcgaXMgcHJvdmlkZWQsIEpTT04ucGFyc2Ugd291bGQgYmUgY2FsbGVkIGZpcnN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIElmIHRoZSBKU09OIGlucHV0IGRvZXMgbm90IHJlcHJlc2VudCBhbiB7QGxpbmsgIEF1dGhDcmVkZW50aWFsfSwgbnVsbCBpcyByZXR1cm5lZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICBjb25zdCBvYmogPSB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcclxuICAgICAgICBjb25zdCB7IHByb3ZpZGVySWQsIHNpZ25Jbk1ldGhvZCwgcGVuZGluZ1Rva2VuIH0gPSBvYmo7XHJcbiAgICAgICAgaWYgKCFwcm92aWRlcklkIHx8XHJcbiAgICAgICAgICAgICFzaWduSW5NZXRob2QgfHxcclxuICAgICAgICAgICAgIXBlbmRpbmdUb2tlbiB8fFxyXG4gICAgICAgICAgICBwcm92aWRlcklkICE9PSBzaWduSW5NZXRob2QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgU0FNTEF1dGhDcmVkZW50aWFsKHByb3ZpZGVySWQsIHBlbmRpbmdUb2tlbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBzdGF0aWMgbWV0aG9kIHRvIGF2b2lkIGV4cG9zaW5nIHRoZSBjb25zdHJ1Y3RvciB0byBlbmQgdXNlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBfY3JlYXRlKHByb3ZpZGVySWQsIHBlbmRpbmdUb2tlbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgU0FNTEF1dGhDcmVkZW50aWFsKHByb3ZpZGVySWQsIHBlbmRpbmdUb2tlbik7XHJcbiAgICB9XHJcbiAgICBidWlsZFJlcXVlc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmVxdWVzdFVyaTogSURQX1JFUVVFU1RfVVJJLFxyXG4gICAgICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZSxcclxuICAgICAgICAgICAgcGVuZGluZ1Rva2VuOiB0aGlzLnBlbmRpbmdUb2tlblxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgU0FNTF9QUk9WSURFUl9QUkVGSVggPSAnc2FtbC4nO1xyXG4vKipcclxuICogQW4ge0BsaW5rIEF1dGhQcm92aWRlcn0gZm9yIFNBTUwuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIFNBTUxBdXRoUHJvdmlkZXIgZXh0ZW5kcyBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3Rvci4gVGhlIHByb3ZpZGVySWQgbXVzdCBzdGFydCB3aXRoIFwic2FtbC5cIlxyXG4gICAgICogQHBhcmFtIHByb3ZpZGVySWQgLSBTQU1MIHByb3ZpZGVyIElELlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcklkKSB7XHJcbiAgICAgICAgX2Fzc2VydChwcm92aWRlcklkLnN0YXJ0c1dpdGgoU0FNTF9QUk9WSURFUl9QUkVGSVgpLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XHJcbiAgICAgICAgc3VwZXIocHJvdmlkZXJJZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhbiB7QGxpbmsgQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgVXNlckNyZWRlbnRpYWx9IGFmdGVyIGFcclxuICAgICAqIHN1Y2Nlc3NmdWwgU0FNTCBmbG93IGNvbXBsZXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmVtYXJrc1xyXG4gICAgICpcclxuICAgICAqIEZvciBleGFtcGxlLCB0byBnZXQgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSwgeW91IGNvdWxkIHdyaXRlIHRoZVxyXG4gICAgICogZm9sbG93aW5nIGNvZGU6XHJcbiAgICAgKlxyXG4gICAgICogYGBganNcclxuICAgICAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHNhbWxQcm92aWRlcik7XHJcbiAgICAgKiBjb25zdCBjcmVkZW50aWFsID0gU0FNTEF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdCh1c2VyQ3JlZGVudGlhbCk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQodXNlckNyZWRlbnRpYWwpIHtcclxuICAgICAgICByZXR1cm4gU0FNTEF1dGhQcm92aWRlci5zYW1sQ3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QodXNlckNyZWRlbnRpYWwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xyXG4gICAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBTQU1MQXV0aFByb3ZpZGVyLnNhbWxDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCgoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0gZnJvbSBhIEpTT04gc3RyaW5nIG9yIGEgcGxhaW4gb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIGpzb24gLSBBIHBsYWluIG9iamVjdCBvciBhIEpTT04gc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWwgPSBTQU1MQXV0aENyZWRlbnRpYWwuZnJvbUpTT04oanNvbik7XHJcbiAgICAgICAgX2Fzc2VydChjcmVkZW50aWFsLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XHJcbiAgICAgICAgcmV0dXJuIGNyZWRlbnRpYWw7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc2FtbENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHsgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2UgfSkge1xyXG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBwZW5kaW5nVG9rZW4sIHByb3ZpZGVySWQgfSA9IHRva2VuUmVzcG9uc2U7XHJcbiAgICAgICAgaWYgKCFwZW5kaW5nVG9rZW4gfHwgIXByb3ZpZGVySWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTQU1MQXV0aENyZWRlbnRpYWwuX2NyZWF0ZShwcm92aWRlcklkLCBwZW5kaW5nVG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGFuIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZvciB7QGxpbmsgUHJvdmlkZXJJZH0uVFdJVFRFUi5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcmVkaXJlY3QuXHJcbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IFR3aXR0ZXJBdXRoUHJvdmlkZXIoKTtcclxuICogLy8gU3RhcnQgYSBzaWduIGluIHByb2Nlc3MgZm9yIGFuIHVuYXV0aGVudGljYXRlZCB1c2VyLlxyXG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xyXG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcclxuICpcclxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxyXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcclxuICogaWYgKHJlc3VsdCkge1xyXG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXHJcbiAqICAgY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xyXG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgVHdpdHRlciBBY2Nlc3MgVG9rZW4gYW5kIFNlY3JldC5cclxuICogICBjb25zdCBjcmVkZW50aWFsID0gVHdpdHRlckF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xyXG4gKiAgIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcclxuICogICBjb25zdCBzZWNyZXQgPSBjcmVkZW50aWFsLnNlY3JldDtcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcG9wdXAuXHJcbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IFR3aXR0ZXJBdXRoUHJvdmlkZXIoKTtcclxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHByb3ZpZGVyKTtcclxuICpcclxuICogLy8gVGhlIHNpZ25lZC1pbiB1c2VyIGluZm8uXHJcbiAqIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcclxuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBUd2l0dGVyIEFjY2VzcyBUb2tlbiBhbmQgU2VjcmV0LlxyXG4gKiBjb25zdCBjcmVkZW50aWFsID0gVHdpdHRlckF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xyXG4gKiBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XHJcbiAqIGNvbnN0IHNlY3JldCA9IGNyZWRlbnRpYWwuc2VjcmV0O1xyXG4gKiBgYGBcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgVHdpdHRlckF1dGhQcm92aWRlciBleHRlbmRzIEJhc2VPQXV0aFByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKFwidHdpdHRlci5jb21cIiAvKiBQcm92aWRlcklkLlRXSVRURVIgKi8pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY3JlZGVudGlhbCBmb3IgVHdpdHRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSBUd2l0dGVyIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBwYXJhbSBzZWNyZXQgLSBUd2l0dGVyIHNlY3JldC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWwodG9rZW4sIHNlY3JldCkge1xyXG4gICAgICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMoe1xyXG4gICAgICAgICAgICBwcm92aWRlcklkOiBUd2l0dGVyQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lELFxyXG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IFR3aXR0ZXJBdXRoUHJvdmlkZXIuVFdJVFRFUl9TSUdOX0lOX01FVEhPRCxcclxuICAgICAgICAgICAgb2F1dGhUb2tlbjogdG9rZW4sXHJcbiAgICAgICAgICAgIG9hdXRoVG9rZW5TZWNyZXQ6IHNlY3JldFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKSB7XHJcbiAgICAgICAgcmV0dXJuIFR3aXR0ZXJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QodXNlckNyZWRlbnRpYWwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xyXG4gICAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBUd2l0dGVyQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KChlcnJvci5jdXN0b21EYXRhIHx8IHt9KSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoeyBfdG9rZW5SZXNwb25zZTogdG9rZW5SZXNwb25zZSB9KSB7XHJcbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IG9hdXRoQWNjZXNzVG9rZW4sIG9hdXRoVG9rZW5TZWNyZXQgfSA9IHRva2VuUmVzcG9uc2U7XHJcbiAgICAgICAgaWYgKCFvYXV0aEFjY2Vzc1Rva2VuIHx8ICFvYXV0aFRva2VuU2VjcmV0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gVHdpdHRlckF1dGhQcm92aWRlci5jcmVkZW50aWFsKG9hdXRoQWNjZXNzVG9rZW4sIG9hdXRoVG9rZW5TZWNyZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBTaWduSW5NZXRob2R9LlRXSVRURVIuICovXHJcblR3aXR0ZXJBdXRoUHJvdmlkZXIuVFdJVFRFUl9TSUdOX0lOX01FVEhPRCA9IFwidHdpdHRlci5jb21cIiAvKiBTaWduSW5NZXRob2QuVFdJVFRFUiAqLztcclxuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LlRXSVRURVIuICovXHJcblR3aXR0ZXJBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQgPSBcInR3aXR0ZXIuY29tXCIgLyogUHJvdmlkZXJJZC5UV0lUVEVSICovO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzaWduVXAoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25VcFwiIC8qIEVuZHBvaW50LlNJR05fVVAgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgVXNlckNyZWRlbnRpYWxJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xyXG4gICAgICAgIHRoaXMudXNlciA9IHBhcmFtcy51c2VyO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJJZCA9IHBhcmFtcy5wcm92aWRlcklkO1xyXG4gICAgICAgIHRoaXMuX3Rva2VuUmVzcG9uc2UgPSBwYXJhbXMuX3Rva2VuUmVzcG9uc2U7XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25UeXBlID0gcGFyYW1zLm9wZXJhdGlvblR5cGU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aCwgb3BlcmF0aW9uVHlwZSwgaWRUb2tlblJlc3BvbnNlLCBpc0Fub255bW91cyA9IGZhbHNlKSB7XHJcbiAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IFVzZXJJbXBsLl9mcm9tSWRUb2tlblJlc3BvbnNlKGF1dGgsIGlkVG9rZW5SZXNwb25zZSwgaXNBbm9ueW1vdXMpO1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVySWQgPSBwcm92aWRlcklkRm9yUmVzcG9uc2UoaWRUb2tlblJlc3BvbnNlKTtcclxuICAgICAgICBjb25zdCB1c2VyQ3JlZCA9IG5ldyBVc2VyQ3JlZGVudGlhbEltcGwoe1xyXG4gICAgICAgICAgICB1c2VyLFxyXG4gICAgICAgICAgICBwcm92aWRlcklkLFxyXG4gICAgICAgICAgICBfdG9rZW5SZXNwb25zZTogaWRUb2tlblJlc3BvbnNlLFxyXG4gICAgICAgICAgICBvcGVyYXRpb25UeXBlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHVzZXJDcmVkO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIF9mb3JPcGVyYXRpb24odXNlciwgb3BlcmF0aW9uVHlwZSwgcmVzcG9uc2UpIHtcclxuICAgICAgICBhd2FpdCB1c2VyLl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShyZXNwb25zZSwgLyogcmVsb2FkICovIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVySWQgPSBwcm92aWRlcklkRm9yUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVXNlckNyZWRlbnRpYWxJbXBsKHtcclxuICAgICAgICAgICAgdXNlcixcclxuICAgICAgICAgICAgcHJvdmlkZXJJZCxcclxuICAgICAgICAgICAgX3Rva2VuUmVzcG9uc2U6IHJlc3BvbnNlLFxyXG4gICAgICAgICAgICBvcGVyYXRpb25UeXBlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcHJvdmlkZXJJZEZvclJlc3BvbnNlKHJlc3BvbnNlKSB7XHJcbiAgICBpZiAocmVzcG9uc2UucHJvdmlkZXJJZCkge1xyXG4gICAgICAgIHJldHVybiByZXNwb25zZS5wcm92aWRlcklkO1xyXG4gICAgfVxyXG4gICAgaWYgKCdwaG9uZU51bWJlcicgaW4gcmVzcG9uc2UpIHtcclxuICAgICAgICByZXR1cm4gXCJwaG9uZVwiIC8qIFByb3ZpZGVySWQuUEhPTkUgKi87XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQXN5bmNocm9ub3VzbHkgc2lnbnMgaW4gYXMgYW4gYW5vbnltb3VzIHVzZXIuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIElmIHRoZXJlIGlzIGFscmVhZHkgYW4gYW5vbnltb3VzIHVzZXIgc2lnbmVkIGluLCB0aGF0IHVzZXIgd2lsbCBiZSByZXR1cm5lZDsgb3RoZXJ3aXNlLCBhXHJcbiAqIG5ldyBhbm9ueW1vdXMgdXNlciBpZGVudGl0eSB3aWxsIGJlIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxyXG4gKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcclxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbkFub255bW91c2x5KGF1dGgpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcChhdXRoLmFwcCkpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xyXG4gICAgYXdhaXQgYXV0aEludGVybmFsLl9pbml0aWFsaXphdGlvblByb21pc2U7XHJcbiAgICBpZiAoKF9hID0gYXV0aEludGVybmFsLmN1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNBbm9ueW1vdXMpIHtcclxuICAgICAgICAvLyBJZiBhbiBhbm9ueW1vdXMgdXNlciBpcyBhbHJlYWR5IHNpZ25lZCBpbiwgbm8gbmVlZCB0byBzaWduIHRoZW0gaW4gYWdhaW4uXHJcbiAgICAgICAgcmV0dXJuIG5ldyBVc2VyQ3JlZGVudGlhbEltcGwoe1xyXG4gICAgICAgICAgICB1c2VyOiBhdXRoSW50ZXJuYWwuY3VycmVudFVzZXIsXHJcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IG51bGwsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvblR5cGU6IFwic2lnbkluXCIgLyogT3BlcmF0aW9uVHlwZS5TSUdOX0lOICovXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNpZ25VcChhdXRoSW50ZXJuYWwsIHtcclxuICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IFVzZXJDcmVkZW50aWFsSW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoSW50ZXJuYWwsIFwic2lnbkluXCIgLyogT3BlcmF0aW9uVHlwZS5TSUdOX0lOICovLCByZXNwb25zZSwgdHJ1ZSk7XHJcbiAgICBhd2FpdCBhdXRoSW50ZXJuYWwuX3VwZGF0ZUN1cnJlbnRVc2VyKHVzZXJDcmVkZW50aWFsLnVzZXIpO1xyXG4gICAgcmV0dXJuIHVzZXJDcmVkZW50aWFsO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIE11bHRpRmFjdG9yRXJyb3IgZXh0ZW5kcyBGaXJlYmFzZUVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGF1dGgsIGVycm9yLCBvcGVyYXRpb25UeXBlLCB1c2VyKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHN1cGVyKGVycm9yLmNvZGUsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uVHlwZSA9IG9wZXJhdGlvblR5cGU7XHJcbiAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQtd2lraS9ibG9iL21hc3Rlci9CcmVha2luZy1DaGFuZ2VzLm1kI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29ya1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBNdWx0aUZhY3RvckVycm9yLnByb3RvdHlwZSk7XHJcbiAgICAgICAgdGhpcy5jdXN0b21EYXRhID0ge1xyXG4gICAgICAgICAgICBhcHBOYW1lOiBhdXRoLm5hbWUsXHJcbiAgICAgICAgICAgIHRlbmFudElkOiAoX2EgPSBhdXRoLnRlbmFudElkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIF9zZXJ2ZXJSZXNwb25zZTogZXJyb3IuY3VzdG9tRGF0YS5fc2VydmVyUmVzcG9uc2UsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvblR5cGVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9mcm9tRXJyb3JBbmRPcGVyYXRpb24oYXV0aCwgZXJyb3IsIG9wZXJhdGlvblR5cGUsIHVzZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE11bHRpRmFjdG9yRXJyb3IoYXV0aCwgZXJyb3IsIG9wZXJhdGlvblR5cGUsIHVzZXIpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIF9wcm9jZXNzQ3JlZGVudGlhbFNhdmluZ01mYUNvbnRleHRJZk5lY2Vzc2FyeShhdXRoLCBvcGVyYXRpb25UeXBlLCBjcmVkZW50aWFsLCB1c2VyKSB7XHJcbiAgICBjb25zdCBpZFRva2VuUHJvdmlkZXIgPSBvcGVyYXRpb25UeXBlID09PSBcInJlYXV0aGVudGljYXRlXCIgLyogT3BlcmF0aW9uVHlwZS5SRUFVVEhFTlRJQ0FURSAqL1xyXG4gICAgICAgID8gY3JlZGVudGlhbC5fZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGgpXHJcbiAgICAgICAgOiBjcmVkZW50aWFsLl9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aCk7XHJcbiAgICByZXR1cm4gaWRUb2tlblByb3ZpZGVyLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gYGF1dGgvJHtcIm11bHRpLWZhY3Rvci1hdXRoLXJlcXVpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5NRkFfUkVRVUlSRUQgKi99YCkge1xyXG4gICAgICAgICAgICB0aHJvdyBNdWx0aUZhY3RvckVycm9yLl9mcm9tRXJyb3JBbmRPcGVyYXRpb24oYXV0aCwgZXJyb3IsIG9wZXJhdGlvblR5cGUsIHVzZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUYWtlcyBhIHNldCBvZiBVc2VySW5mbyBwcm92aWRlciBkYXRhIGFuZCBjb252ZXJ0cyBpdCB0byBhIHNldCBvZiBuYW1lc1xyXG4gKi9cclxuZnVuY3Rpb24gcHJvdmlkZXJEYXRhQXNOYW1lcyhwcm92aWRlckRhdGEpIHtcclxuICAgIHJldHVybiBuZXcgU2V0KHByb3ZpZGVyRGF0YVxyXG4gICAgICAgIC5tYXAoKHsgcHJvdmlkZXJJZCB9KSA9PiBwcm92aWRlcklkKVxyXG4gICAgICAgIC5maWx0ZXIocGlkID0+ICEhcGlkKSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFVubGlua3MgYSBwcm92aWRlciBmcm9tIGEgdXNlciBhY2NvdW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxyXG4gKiBAcGFyYW0gcHJvdmlkZXJJZCAtIFRoZSBwcm92aWRlciB0byB1bmxpbmsuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHVubGluayh1c2VyLCBwcm92aWRlcklkKSB7XHJcbiAgICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XHJcbiAgICBhd2FpdCBfYXNzZXJ0TGlua2VkU3RhdHVzKHRydWUsIHVzZXJJbnRlcm5hbCwgcHJvdmlkZXJJZCk7XHJcbiAgICBjb25zdCB7IHByb3ZpZGVyVXNlckluZm8gfSA9IGF3YWl0IGRlbGV0ZUxpbmtlZEFjY291bnRzKHVzZXJJbnRlcm5hbC5hdXRoLCB7XHJcbiAgICAgICAgaWRUb2tlbjogYXdhaXQgdXNlckludGVybmFsLmdldElkVG9rZW4oKSxcclxuICAgICAgICBkZWxldGVQcm92aWRlcjogW3Byb3ZpZGVySWRdXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHByb3ZpZGVyc0xlZnQgPSBwcm92aWRlckRhdGFBc05hbWVzKHByb3ZpZGVyVXNlckluZm8gfHwgW10pO1xyXG4gICAgdXNlckludGVybmFsLnByb3ZpZGVyRGF0YSA9IHVzZXJJbnRlcm5hbC5wcm92aWRlckRhdGEuZmlsdGVyKHBkID0+IHByb3ZpZGVyc0xlZnQuaGFzKHBkLnByb3ZpZGVySWQpKTtcclxuICAgIGlmICghcHJvdmlkZXJzTGVmdC5oYXMoXCJwaG9uZVwiIC8qIFByb3ZpZGVySWQuUEhPTkUgKi8pKSB7XHJcbiAgICAgICAgdXNlckludGVybmFsLnBob25lTnVtYmVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIGF3YWl0IHVzZXJJbnRlcm5hbC5hdXRoLl9wZXJzaXN0VXNlcklmQ3VycmVudCh1c2VySW50ZXJuYWwpO1xyXG4gICAgcmV0dXJuIHVzZXJJbnRlcm5hbDtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBfbGluayh1c2VyLCBjcmVkZW50aWFsLCBieXBhc3NBdXRoU3RhdGUgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh1c2VyLCBjcmVkZW50aWFsLl9saW5rVG9JZFRva2VuKHVzZXIuYXV0aCwgYXdhaXQgdXNlci5nZXRJZFRva2VuKCkpLCBieXBhc3NBdXRoU3RhdGUpO1xyXG4gICAgcmV0dXJuIFVzZXJDcmVkZW50aWFsSW1wbC5fZm9yT3BlcmF0aW9uKHVzZXIsIFwibGlua1wiIC8qIE9wZXJhdGlvblR5cGUuTElOSyAqLywgcmVzcG9uc2UpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIF9hc3NlcnRMaW5rZWRTdGF0dXMoZXhwZWN0ZWQsIHVzZXIsIHByb3ZpZGVyKSB7XHJcbiAgICBhd2FpdCBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VyKTtcclxuICAgIGNvbnN0IHByb3ZpZGVySWRzID0gcHJvdmlkZXJEYXRhQXNOYW1lcyh1c2VyLnByb3ZpZGVyRGF0YSk7XHJcbiAgICBjb25zdCBjb2RlID0gZXhwZWN0ZWQgPT09IGZhbHNlXHJcbiAgICAgICAgPyBcInByb3ZpZGVyLWFscmVhZHktbGlua2VkXCIgLyogQXV0aEVycm9yQ29kZS5QUk9WSURFUl9BTFJFQURZX0xJTktFRCAqL1xyXG4gICAgICAgIDogXCJuby1zdWNoLXByb3ZpZGVyXCIgLyogQXV0aEVycm9yQ29kZS5OT19TVUNIX1BST1ZJREVSICovO1xyXG4gICAgX2Fzc2VydChwcm92aWRlcklkcy5oYXMocHJvdmlkZXIpID09PSBleHBlY3RlZCwgdXNlci5hdXRoLCBjb2RlKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBfcmVhdXRoZW50aWNhdGUodXNlciwgY3JlZGVudGlhbCwgYnlwYXNzQXV0aFN0YXRlID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHsgYXV0aCB9ID0gdXNlcjtcclxuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcChhdXRoLmFwcCkpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3BlcmF0aW9uVHlwZSA9IFwicmVhdXRoZW50aWNhdGVcIiAvKiBPcGVyYXRpb25UeXBlLlJFQVVUSEVOVElDQVRFICovO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKHVzZXIsIF9wcm9jZXNzQ3JlZGVudGlhbFNhdmluZ01mYUNvbnRleHRJZk5lY2Vzc2FyeShhdXRoLCBvcGVyYXRpb25UeXBlLCBjcmVkZW50aWFsLCB1c2VyKSwgYnlwYXNzQXV0aFN0YXRlKTtcclxuICAgICAgICBfYXNzZXJ0KHJlc3BvbnNlLmlkVG9rZW4sIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICBjb25zdCBwYXJzZWQgPSBfcGFyc2VUb2tlbihyZXNwb25zZS5pZFRva2VuKTtcclxuICAgICAgICBfYXNzZXJ0KHBhcnNlZCwgYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIGNvbnN0IHsgc3ViOiBsb2NhbElkIH0gPSBwYXJzZWQ7XHJcbiAgICAgICAgX2Fzc2VydCh1c2VyLnVpZCA9PT0gbG9jYWxJZCwgYXV0aCwgXCJ1c2VyLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX01JU01BVENIICovKTtcclxuICAgICAgICByZXR1cm4gVXNlckNyZWRlbnRpYWxJbXBsLl9mb3JPcGVyYXRpb24odXNlciwgb3BlcmF0aW9uVHlwZSwgcmVzcG9uc2UpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBDb252ZXJ0IHVzZXIgZGVsZXRlZCBlcnJvciBpbnRvIHVzZXIgbWlzbWF0Y2hcclxuICAgICAgICBpZiAoKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5jb2RlKSA9PT0gYGF1dGgvJHtcInVzZXItbm90LWZvdW5kXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RFTEVURUQgKi99YCkge1xyXG4gICAgICAgICAgICBfZmFpbChhdXRoLCBcInVzZXItbWlzbWF0Y2hcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfTUlTTUFUQ0ggKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIF9zaWduSW5XaXRoQ3JlZGVudGlhbChhdXRoLCBjcmVkZW50aWFsLCBieXBhc3NBdXRoU3RhdGUgPSBmYWxzZSkge1xyXG4gICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKGF1dGguYXBwKSkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcihhdXRoKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvcGVyYXRpb25UeXBlID0gXCJzaWduSW5cIiAvKiBPcGVyYXRpb25UeXBlLlNJR05fSU4gKi87XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9wcm9jZXNzQ3JlZGVudGlhbFNhdmluZ01mYUNvbnRleHRJZk5lY2Vzc2FyeShhdXRoLCBvcGVyYXRpb25UeXBlLCBjcmVkZW50aWFsKTtcclxuICAgIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgVXNlckNyZWRlbnRpYWxJbXBsLl9mcm9tSWRUb2tlblJlc3BvbnNlKGF1dGgsIG9wZXJhdGlvblR5cGUsIHJlc3BvbnNlKTtcclxuICAgIGlmICghYnlwYXNzQXV0aFN0YXRlKSB7XHJcbiAgICAgICAgYXdhaXQgYXV0aC5fdXBkYXRlQ3VycmVudFVzZXIodXNlckNyZWRlbnRpYWwudXNlcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXNlckNyZWRlbnRpYWw7XHJcbn1cclxuLyoqXHJcbiAqIEFzeW5jaHJvbm91c2x5IHNpZ25zIGluIHdpdGggdGhlIGdpdmVuIGNyZWRlbnRpYWxzLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBBbiB7QGxpbmsgQXV0aFByb3ZpZGVyfSBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY3JlZGVudGlhbC5cclxuICpcclxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXHJcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gY3JlZGVudGlhbCAtIFRoZSBhdXRoIGNyZWRlbnRpYWwuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhDcmVkZW50aWFsKGF1dGgsIGNyZWRlbnRpYWwpIHtcclxuICAgIHJldHVybiBfc2lnbkluV2l0aENyZWRlbnRpYWwoX2Nhc3RBdXRoKGF1dGgpLCBjcmVkZW50aWFsKTtcclxufVxyXG4vKipcclxuICogTGlua3MgdGhlIHVzZXIgYWNjb3VudCB3aXRoIHRoZSBnaXZlbiBjcmVkZW50aWFscy5cclxuICpcclxuICogQHJlbWFya3NcclxuICogQW4ge0BsaW5rIEF1dGhQcm92aWRlcn0gY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNyZWRlbnRpYWwuXHJcbiAqXHJcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXHJcbiAqIEBwYXJhbSBjcmVkZW50aWFsIC0gVGhlIGF1dGggY3JlZGVudGlhbC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gbGlua1dpdGhDcmVkZW50aWFsKHVzZXIsIGNyZWRlbnRpYWwpIHtcclxuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKTtcclxuICAgIGF3YWl0IF9hc3NlcnRMaW5rZWRTdGF0dXMoZmFsc2UsIHVzZXJJbnRlcm5hbCwgY3JlZGVudGlhbC5wcm92aWRlcklkKTtcclxuICAgIHJldHVybiBfbGluayh1c2VySW50ZXJuYWwsIGNyZWRlbnRpYWwpO1xyXG59XHJcbi8qKlxyXG4gKiBSZS1hdXRoZW50aWNhdGVzIGEgdXNlciB1c2luZyBhIGZyZXNoIGNyZWRlbnRpYWwuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFVzZSBiZWZvcmUgb3BlcmF0aW9ucyBzdWNoIGFzIHtAbGluayB1cGRhdGVQYXNzd29yZH0gdGhhdCByZXF1aXJlIHRva2VucyBmcm9tIHJlY2VudCBzaWduLWluXHJcbiAqIGF0dGVtcHRzLiBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byByZWNvdmVyIGZyb20gYSBgQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOYCBlcnJvclxyXG4gKiBvciBhIGBUT0tFTl9FWFBJUkVEYCBlcnJvci5cclxuICpcclxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBvbiBhbnkge0BsaW5rIFVzZXJ9IHNpZ25lZCBpbiBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzXHJcbiAqIGNyZWF0ZWQgd2l0aCBhIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cclxuICpcclxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cclxuICogQHBhcmFtIGNyZWRlbnRpYWwgLSBUaGUgYXV0aCBjcmVkZW50aWFsLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsKHVzZXIsIGNyZWRlbnRpYWwpIHtcclxuICAgIHJldHVybiBfcmVhdXRoZW50aWNhdGUoZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpLCBjcmVkZW50aWFsKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoQ3VzdG9tVG9rZW4kMShhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aEN1c3RvbVRva2VuXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX0NVU1RPTV9UT0tFTiAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQXN5bmNocm9ub3VzbHkgc2lnbnMgaW4gdXNpbmcgYSBjdXN0b20gdG9rZW4uXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIEN1c3RvbSB0b2tlbnMgYXJlIHVzZWQgdG8gaW50ZWdyYXRlIEZpcmViYXNlIEF1dGggd2l0aCBleGlzdGluZyBhdXRoIHN5c3RlbXMsIGFuZCBtdXN0XHJcbiAqIGJlIGdlbmVyYXRlZCBieSBhbiBhdXRoIGJhY2tlbmQgdXNpbmcgdGhlXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9yZWZlcmVuY2UvYWRtaW4vbm9kZS9hZG1pbi5hdXRoLkF1dGgjY3JlYXRlY3VzdG9tdG9rZW4gfCBjcmVhdGVDdXN0b21Ub2tlbn1cclxuICogbWV0aG9kIGluIHRoZSB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvYXV0aC9hZG1pbiB8IEFkbWluIFNES30gLlxyXG4gKlxyXG4gKiBGYWlscyB3aXRoIGFuIGVycm9yIGlmIHRoZSB0b2tlbiBpcyBpbnZhbGlkLCBleHBpcmVkLCBvciBub3QgYWNjZXB0ZWQgYnkgdGhlIEZpcmViYXNlIEF1dGggc2VydmljZS5cclxuICpcclxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXHJcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gY3VzdG9tVG9rZW4gLSBUaGUgY3VzdG9tIHRva2VuIHRvIHNpZ24gaW4gd2l0aC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aEN1c3RvbVRva2VuKGF1dGgsIGN1c3RvbVRva2VuKSB7XHJcbiAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAoYXV0aC5hcHApKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKGF1dGgpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2lnbkluV2l0aEN1c3RvbVRva2VuJDEoYXV0aEludGVybmFsLCB7XHJcbiAgICAgICAgdG9rZW46IGN1c3RvbVRva2VuLFxyXG4gICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGNyZWQgPSBhd2FpdCBVc2VyQ3JlZGVudGlhbEltcGwuX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aEludGVybmFsLCBcInNpZ25JblwiIC8qIE9wZXJhdGlvblR5cGUuU0lHTl9JTiAqLywgcmVzcG9uc2UpO1xyXG4gICAgYXdhaXQgYXV0aEludGVybmFsLl91cGRhdGVDdXJyZW50VXNlcihjcmVkLnVzZXIpO1xyXG4gICAgcmV0dXJuIGNyZWQ7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgTXVsdGlGYWN0b3JJbmZvSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3JJZCwgcmVzcG9uc2UpIHtcclxuICAgICAgICB0aGlzLmZhY3RvcklkID0gZmFjdG9ySWQ7XHJcbiAgICAgICAgdGhpcy51aWQgPSByZXNwb25zZS5tZmFFbnJvbGxtZW50SWQ7XHJcbiAgICAgICAgdGhpcy5lbnJvbGxtZW50VGltZSA9IG5ldyBEYXRlKHJlc3BvbnNlLmVucm9sbGVkQXQpLnRvVVRDU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5TmFtZSA9IHJlc3BvbnNlLmRpc3BsYXlOYW1lO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9mcm9tU2VydmVyUmVzcG9uc2UoYXV0aCwgZW5yb2xsbWVudCkge1xyXG4gICAgICAgIGlmICgncGhvbmVJbmZvJyBpbiBlbnJvbGxtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQaG9uZU11bHRpRmFjdG9ySW5mb0ltcGwuX2Zyb21TZXJ2ZXJSZXNwb25zZShhdXRoLCBlbnJvbGxtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ3RvdHBJbmZvJyBpbiBlbnJvbGxtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUb3RwTXVsdGlGYWN0b3JJbmZvSW1wbC5fZnJvbVNlcnZlclJlc3BvbnNlKGF1dGgsIGVucm9sbG1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX2ZhaWwoYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFBob25lTXVsdGlGYWN0b3JJbmZvSW1wbCBleHRlbmRzIE11bHRpRmFjdG9ySW5mb0ltcGwge1xyXG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcclxuICAgICAgICBzdXBlcihcInBob25lXCIgLyogRmFjdG9ySWQuUEhPTkUgKi8sIHJlc3BvbnNlKTtcclxuICAgICAgICB0aGlzLnBob25lTnVtYmVyID0gcmVzcG9uc2UucGhvbmVJbmZvO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9mcm9tU2VydmVyUmVzcG9uc2UoX2F1dGgsIGVucm9sbG1lbnQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBob25lTXVsdGlGYWN0b3JJbmZvSW1wbChlbnJvbGxtZW50KTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBUb3RwTXVsdGlGYWN0b3JJbmZvSW1wbCBleHRlbmRzIE11bHRpRmFjdG9ySW5mb0ltcGwge1xyXG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcclxuICAgICAgICBzdXBlcihcInRvdHBcIiAvKiBGYWN0b3JJZC5UT1RQICovLCByZXNwb25zZSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2Zyb21TZXJ2ZXJSZXNwb25zZShfYXV0aCwgZW5yb2xsbWVudCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVG90cE11bHRpRmFjdG9ySW5mb0ltcGwoZW5yb2xsbWVudCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdChhdXRoLCByZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcclxuICAgIHZhciBfYTtcclxuICAgIF9hc3NlcnQoKChfYSA9IGFjdGlvbkNvZGVTZXR0aW5ncy51cmwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpID4gMCwgYXV0aCwgXCJpbnZhbGlkLWNvbnRpbnVlLXVyaVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DT05USU5VRV9VUkkgKi8pO1xyXG4gICAgX2Fzc2VydCh0eXBlb2YgYWN0aW9uQ29kZVNldHRpbmdzLmR5bmFtaWNMaW5rRG9tYWluID09PSAndW5kZWZpbmVkJyB8fFxyXG4gICAgICAgIGFjdGlvbkNvZGVTZXR0aW5ncy5keW5hbWljTGlua0RvbWFpbi5sZW5ndGggPiAwLCBhdXRoLCBcImludmFsaWQtZHluYW1pYy1saW5rLWRvbWFpblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9EWU5BTUlDX0xJTktfRE9NQUlOICovKTtcclxuICAgIHJlcXVlc3QuY29udGludWVVcmwgPSBhY3Rpb25Db2RlU2V0dGluZ3MudXJsO1xyXG4gICAgcmVxdWVzdC5keW5hbWljTGlua0RvbWFpbiA9IGFjdGlvbkNvZGVTZXR0aW5ncy5keW5hbWljTGlua0RvbWFpbjtcclxuICAgIHJlcXVlc3QuY2FuSGFuZGxlQ29kZUluQXBwID0gYWN0aW9uQ29kZVNldHRpbmdzLmhhbmRsZUNvZGVJbkFwcDtcclxuICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MuaU9TKSB7XHJcbiAgICAgICAgX2Fzc2VydChhY3Rpb25Db2RlU2V0dGluZ3MuaU9TLmJ1bmRsZUlkLmxlbmd0aCA+IDAsIGF1dGgsIFwibWlzc2luZy1pb3MtYnVuZGxlLWlkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0lPU19CVU5ETEVfSUQgKi8pO1xyXG4gICAgICAgIHJlcXVlc3QuaU9TQnVuZGxlSWQgPSBhY3Rpb25Db2RlU2V0dGluZ3MuaU9TLmJ1bmRsZUlkO1xyXG4gICAgfVxyXG4gICAgaWYgKGFjdGlvbkNvZGVTZXR0aW5ncy5hbmRyb2lkKSB7XHJcbiAgICAgICAgX2Fzc2VydChhY3Rpb25Db2RlU2V0dGluZ3MuYW5kcm9pZC5wYWNrYWdlTmFtZS5sZW5ndGggPiAwLCBhdXRoLCBcIm1pc3NpbmctYW5kcm9pZC1wa2ctbmFtZVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRSAqLyk7XHJcbiAgICAgICAgcmVxdWVzdC5hbmRyb2lkSW5zdGFsbEFwcCA9IGFjdGlvbkNvZGVTZXR0aW5ncy5hbmRyb2lkLmluc3RhbGxBcHA7XHJcbiAgICAgICAgcmVxdWVzdC5hbmRyb2lkTWluaW11bVZlcnNpb25Db2RlID1cclxuICAgICAgICAgICAgYWN0aW9uQ29kZVNldHRpbmdzLmFuZHJvaWQubWluaW11bVZlcnNpb247XHJcbiAgICAgICAgcmVxdWVzdC5hbmRyb2lkUGFja2FnZU5hbWUgPSBhY3Rpb25Db2RlU2V0dGluZ3MuYW5kcm9pZC5wYWNrYWdlTmFtZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVXBkYXRlcyB0aGUgcGFzc3dvcmQgcG9saWN5IGNhY2hlZCBpbiB0aGUge0BsaW5rIEF1dGh9IGluc3RhbmNlIGlmIGEgcG9saWN5IGlzIGFscmVhZHlcclxuICogY2FjaGVkIGZvciB0aGUgcHJvamVjdCBvciB0ZW5hbnQuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFdlIG9ubHkgZmV0Y2ggdGhlIHBhc3N3b3JkIHBvbGljeSBpZiB0aGUgcGFzc3dvcmQgZGlkIG5vdCBtZWV0IHBvbGljeSByZXF1aXJlbWVudHMgYW5kXHJcbiAqIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHBvbGljeSBjYWNoZWQuIEEgZGV2ZWxvcGVyIG11c3QgY2FsbCB2YWxpZGF0ZVBhc3N3b3JkIGF0IGxlYXN0XHJcbiAqIG9uY2UgZm9yIHRoZSBjYWNoZSB0byBiZSBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHJlY2FjaGVQYXNzd29yZFBvbGljeShhdXRoKSB7XHJcbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XHJcbiAgICBpZiAoYXV0aEludGVybmFsLl9nZXRQYXNzd29yZFBvbGljeUludGVybmFsKCkpIHtcclxuICAgICAgICBhd2FpdCBhdXRoSW50ZXJuYWwuX3VwZGF0ZVBhc3N3b3JkUG9saWN5KCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNlbmRzIGEgcGFzc3dvcmQgcmVzZXQgZW1haWwgdG8gdGhlIGdpdmVuIGVtYWlsIGFkZHJlc3MuIFRoaXMgbWV0aG9kIGRvZXMgbm90IHRocm93IGFuIGVycm9yIHdoZW5cclxuICogdGhlcmUncyBubyB1c2VyIGFjY291bnQgd2l0aCB0aGUgZ2l2ZW4gZW1haWwgYWRkcmVzcyBhbmRcclxuICoge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pZGVudGl0eS1wbGF0Zm9ybS9kb2NzL2FkbWluL2VtYWlsLWVudW1lcmF0aW9uLXByb3RlY3Rpb24gfCBFbWFpbCBFbnVtZXJhdGlvbiBQcm90ZWN0aW9ufVxyXG4gKiBpcyBlbmFibGVkLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUbyBjb21wbGV0ZSB0aGUgcGFzc3dvcmQgcmVzZXQsIGNhbGwge0BsaW5rIGNvbmZpcm1QYXNzd29yZFJlc2V0fSB3aXRoIHRoZSBjb2RlIHN1cHBsaWVkIGluXHJcbiAqIHRoZSBlbWFpbCBzZW50IHRvIHRoZSB1c2VyLCBhbG9uZyB3aXRoIHRoZSBuZXcgcGFzc3dvcmQgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIGNvbnN0IGFjdGlvbkNvZGVTZXR0aW5ncyA9IHtcclxuICogICB1cmw6ICdodHRwczovL3d3dy5leGFtcGxlLmNvbS8/ZW1haWw9dXNlckBleGFtcGxlLmNvbScsXHJcbiAqICAgaU9TOiB7XHJcbiAqICAgICAgYnVuZGxlSWQ6ICdjb20uZXhhbXBsZS5pb3MnXHJcbiAqICAgfSxcclxuICogICBhbmRyb2lkOiB7XHJcbiAqICAgICBwYWNrYWdlTmFtZTogJ2NvbS5leGFtcGxlLmFuZHJvaWQnLFxyXG4gKiAgICAgaW5zdGFsbEFwcDogdHJ1ZSxcclxuICogICAgIG1pbmltdW1WZXJzaW9uOiAnMTInXHJcbiAqICAgfSxcclxuICogICBoYW5kbGVDb2RlSW5BcHA6IHRydWVcclxuICogfTtcclxuICogYXdhaXQgc2VuZFBhc3N3b3JkUmVzZXRFbWFpbChhdXRoLCAndXNlckBleGFtcGxlLmNvbScsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XHJcbiAqIC8vIE9idGFpbiBjb2RlIGZyb20gdXNlci5cclxuICogYXdhaXQgY29uZmlybVBhc3N3b3JkUmVzZXQoJ3VzZXJAZXhhbXBsZS5jb20nLCBjb2RlKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxyXG4gKiBAcGFyYW0gYWN0aW9uQ29kZVNldHRpbmdzIC0gVGhlIHtAbGluayBBY3Rpb25Db2RlU2V0dGluZ3N9LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzZW5kUGFzc3dvcmRSZXNldEVtYWlsKGF1dGgsIGVtYWlsLCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcclxuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgcmVxdWVzdFR5cGU6IFwiUEFTU1dPUkRfUkVTRVRcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlBBU1NXT1JEX1JFU0VUICovLFxyXG4gICAgICAgIGVtYWlsLFxyXG4gICAgICAgIGNsaWVudFR5cGU6IFwiQ0xJRU5UX1RZUEVfV0VCXCIgLyogUmVjYXB0Y2hhQ2xpZW50VHlwZS5XRUIgKi9cclxuICAgIH07XHJcbiAgICBpZiAoYWN0aW9uQ29kZVNldHRpbmdzKSB7XHJcbiAgICAgICAgX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdChhdXRoSW50ZXJuYWwsIHJlcXVlc3QsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XHJcbiAgICB9XHJcbiAgICBhd2FpdCBoYW5kbGVSZWNhcHRjaGFGbG93KGF1dGhJbnRlcm5hbCwgcmVxdWVzdCwgXCJnZXRPb2JDb2RlXCIgLyogUmVjYXB0Y2hhQWN0aW9uTmFtZS5HRVRfT09CX0NPREUgKi8sIHNlbmRQYXNzd29yZFJlc2V0RW1haWwkMSk7XHJcbn1cclxuLyoqXHJcbiAqIENvbXBsZXRlcyB0aGUgcGFzc3dvcmQgcmVzZXQgcHJvY2VzcywgZ2l2ZW4gYSBjb25maXJtYXRpb24gY29kZSBhbmQgbmV3IHBhc3N3b3JkLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBvb2JDb2RlIC0gQSBjb25maXJtYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyLlxyXG4gKiBAcGFyYW0gbmV3UGFzc3dvcmQgLSBUaGUgbmV3IHBhc3N3b3JkLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBjb25maXJtUGFzc3dvcmRSZXNldChhdXRoLCBvb2JDb2RlLCBuZXdQYXNzd29yZCkge1xyXG4gICAgYXdhaXQgcmVzZXRQYXNzd29yZChnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksIHtcclxuICAgICAgICBvb2JDb2RlLFxyXG4gICAgICAgIG5ld1Bhc3N3b3JkXHJcbiAgICB9KVxyXG4gICAgICAgIC5jYXRjaChhc3luYyAoZXJyb3IpID0+IHtcclxuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT1cclxuICAgICAgICAgICAgYGF1dGgvJHtcInBhc3N3b3JkLWRvZXMtbm90LW1lZXQtcmVxdWlyZW1lbnRzXCIgLyogQXV0aEVycm9yQ29kZS5QQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UUyAqL31gKSB7XHJcbiAgICAgICAgICAgIHZvaWQgcmVjYWNoZVBhc3N3b3JkUG9saWN5KGF1dGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH0pO1xyXG4gICAgLy8gRG8gbm90IHJldHVybiB0aGUgZW1haWwuXHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyIGJ5IGVtYWlsIG9yIG90aGVyIG91dC1vZi1iYW5kIG1lY2hhbmlzbS5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gb29iQ29kZSAtIEEgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlci5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gYXBwbHlBY3Rpb25Db2RlKGF1dGgsIG9vYkNvZGUpIHtcclxuICAgIGF3YWl0IGFwcGx5QWN0aW9uQ29kZSQxKGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKSwgeyBvb2JDb2RlIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgYSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyIGJ5IGVtYWlsIG9yIG90aGVyIG91dC1vZi1iYW5kIG1lY2hhbmlzbS5cclxuICpcclxuICogQHJldHVybnMgbWV0YWRhdGEgYWJvdXQgdGhlIGNvZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIG9vYkNvZGUgLSBBIHZlcmlmaWNhdGlvbiBjb2RlIHNlbnQgdG8gdGhlIHVzZXIuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNoZWNrQWN0aW9uQ29kZShhdXRoLCBvb2JDb2RlKSB7XHJcbiAgICBjb25zdCBhdXRoTW9kdWxhciA9IGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzZXRQYXNzd29yZChhdXRoTW9kdWxhciwgeyBvb2JDb2RlIH0pO1xyXG4gICAgLy8gRW1haWwgY291bGQgYmUgZW1wdHkgb25seSBpZiB0aGUgcmVxdWVzdCB0eXBlIGlzIEVNQUlMX1NJR05JTiBvclxyXG4gICAgLy8gVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwuXHJcbiAgICAvLyBOZXcgZW1haWwgc2hvdWxkIG5vdCBiZSBlbXB0eSBpZiB0aGUgcmVxdWVzdCB0eXBlIGlzXHJcbiAgICAvLyBWRVJJRllfQU5EX0NIQU5HRV9FTUFJTC5cclxuICAgIC8vIE11bHRpLWZhY3RvciBpbmZvIGNvdWxkIG5vdCBiZSBlbXB0eSBpZiB0aGUgcmVxdWVzdCB0eXBlIGlzXHJcbiAgICAvLyBSRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTi5cclxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHJlc3BvbnNlLnJlcXVlc3RUeXBlO1xyXG4gICAgX2Fzc2VydChvcGVyYXRpb24sIGF1dGhNb2R1bGFyLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xyXG4gICAgICAgIGNhc2UgXCJFTUFJTF9TSUdOSU5cIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLkVNQUlMX1NJR05JTiAqLzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfQU5EX0NIQU5HRV9FTUFJTCAqLzpcclxuICAgICAgICAgICAgX2Fzc2VydChyZXNwb25zZS5uZXdFbWFpbCwgYXV0aE1vZHVsYXIsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIlJFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5SRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTiAqLzpcclxuICAgICAgICAgICAgX2Fzc2VydChyZXNwb25zZS5tZmFJbmZvLCBhdXRoTW9kdWxhciwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIC8vIGZhbGwgdGhyb3VnaFxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIF9hc3NlcnQocmVzcG9uc2UuZW1haWwsIGF1dGhNb2R1bGFyLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XHJcbiAgICB9XHJcbiAgICAvLyBUaGUgbXVsdGktZmFjdG9yIGluZm8gZm9yIHJldmVydCBzZWNvbmQgZmFjdG9yIGFkZGl0aW9uXHJcbiAgICBsZXQgbXVsdGlGYWN0b3JJbmZvID0gbnVsbDtcclxuICAgIGlmIChyZXNwb25zZS5tZmFJbmZvKSB7XHJcbiAgICAgICAgbXVsdGlGYWN0b3JJbmZvID0gTXVsdGlGYWN0b3JJbmZvSW1wbC5fZnJvbVNlcnZlclJlc3BvbnNlKF9jYXN0QXV0aChhdXRoTW9kdWxhciksIHJlc3BvbnNlLm1mYUluZm8pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgIGVtYWlsOiAocmVzcG9uc2UucmVxdWVzdFR5cGUgPT09IFwiVkVSSUZZX0FORF9DSEFOR0VfRU1BSUxcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMICovXHJcbiAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLm5ld0VtYWlsXHJcbiAgICAgICAgICAgICAgICA6IHJlc3BvbnNlLmVtYWlsKSB8fCBudWxsLFxyXG4gICAgICAgICAgICBwcmV2aW91c0VtYWlsOiAocmVzcG9uc2UucmVxdWVzdFR5cGUgPT09IFwiVkVSSUZZX0FORF9DSEFOR0VfRU1BSUxcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMICovXHJcbiAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLmVtYWlsXHJcbiAgICAgICAgICAgICAgICA6IHJlc3BvbnNlLm5ld0VtYWlsKSB8fCBudWxsLFxyXG4gICAgICAgICAgICBtdWx0aUZhY3RvckluZm9cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9wZXJhdGlvblxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGEgcGFzc3dvcmQgcmVzZXQgY29kZSBzZW50IHRvIHRoZSB1c2VyIGJ5IGVtYWlsIG9yIG90aGVyIG91dC1vZi1iYW5kIG1lY2hhbmlzbS5cclxuICpcclxuICogQHJldHVybnMgdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzIGlmIHZhbGlkLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBjb2RlIC0gQSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlQYXNzd29yZFJlc2V0Q29kZShhdXRoLCBjb2RlKSB7XHJcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGNoZWNrQWN0aW9uQ29kZShnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksIGNvZGUpO1xyXG4gICAgLy8gRW1haWwgc2hvdWxkIGFsd2F5cyBiZSBwcmVzZW50IHNpbmNlIGEgY29kZSB3YXMgc2VudCB0byBpdFxyXG4gICAgcmV0dXJuIGRhdGEuZW1haWw7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdXNlciBhY2NvdW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGVtYWlsIGFkZHJlc3MgYW5kIHBhc3N3b3JkLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBPbiBzdWNjZXNzZnVsIGNyZWF0aW9uIG9mIHRoZSB1c2VyIGFjY291bnQsIHRoaXMgdXNlciB3aWxsIGFsc28gYmUgc2lnbmVkIGluIHRvIHlvdXIgYXBwbGljYXRpb24uXHJcbiAqXHJcbiAqIFVzZXIgYWNjb3VudCBjcmVhdGlvbiBjYW4gZmFpbCBpZiB0aGUgYWNjb3VudCBhbHJlYWR5IGV4aXN0cyBvciB0aGUgcGFzc3dvcmQgaXMgaW52YWxpZC5cclxuICpcclxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBvbiB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXHJcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cclxuICpcclxuICogTm90ZTogVGhlIGVtYWlsIGFkZHJlc3MgYWN0cyBhcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdXNlciBhbmQgZW5hYmxlcyBhbiBlbWFpbC1iYXNlZFxyXG4gKiBwYXNzd29yZCByZXNldC4gVGhpcyBmdW5jdGlvbiB3aWxsIGNyZWF0ZSBhIG5ldyB1c2VyIGFjY291bnQgYW5kIHNldCB0aGUgaW5pdGlhbCB1c2VyIHBhc3N3b3JkLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cclxuICogQHBhcmFtIHBhc3N3b3JkIC0gVGhlIHVzZXIncyBjaG9zZW4gcGFzc3dvcmQuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZChhdXRoLCBlbWFpbCwgcGFzc3dvcmQpIHtcclxuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcChhdXRoLmFwcCkpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xyXG4gICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZSxcclxuICAgICAgICBlbWFpbCxcclxuICAgICAgICBwYXNzd29yZCxcclxuICAgICAgICBjbGllbnRUeXBlOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovXHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2lnblVwUmVzcG9uc2UgPSBoYW5kbGVSZWNhcHRjaGFGbG93KGF1dGhJbnRlcm5hbCwgcmVxdWVzdCwgXCJzaWduVXBQYXNzd29yZFwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuU0lHTl9VUF9QQVNTV09SRCAqLywgc2lnblVwKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2lnblVwUmVzcG9uc2UuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSBgYXV0aC8ke1wicGFzc3dvcmQtZG9lcy1ub3QtbWVldC1yZXF1aXJlbWVudHNcIiAvKiBBdXRoRXJyb3JDb2RlLlBBU1NXT1JEX0RPRVNfTk9UX01FRVRfUkVRVUlSRU1FTlRTICovfWApIHtcclxuICAgICAgICAgICAgdm9pZCByZWNhY2hlUGFzc3dvcmRQb2xpY3koYXV0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IFVzZXJDcmVkZW50aWFsSW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoSW50ZXJuYWwsIFwic2lnbkluXCIgLyogT3BlcmF0aW9uVHlwZS5TSUdOX0lOICovLCByZXNwb25zZSk7XHJcbiAgICBhd2FpdCBhdXRoSW50ZXJuYWwuX3VwZGF0ZUN1cnJlbnRVc2VyKHVzZXJDcmVkZW50aWFsLnVzZXIpO1xyXG4gICAgcmV0dXJuIHVzZXJDcmVkZW50aWFsO1xyXG59XHJcbi8qKlxyXG4gKiBBc3luY2hyb25vdXNseSBzaWducyBpbiB1c2luZyBhbiBlbWFpbCBhbmQgcGFzc3dvcmQuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIEZhaWxzIHdpdGggYW4gZXJyb3IgaWYgdGhlIGVtYWlsIGFkZHJlc3MgYW5kIHBhc3N3b3JkIGRvIG5vdCBtYXRjaC4gV2hlblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2lkZW50aXR5LXBsYXRmb3JtL2RvY3MvYWRtaW4vZW1haWwtZW51bWVyYXRpb24tcHJvdGVjdGlvbiB8IEVtYWlsIEVudW1lcmF0aW9uIFByb3RlY3Rpb259XHJcbiAqIGlzIGVuYWJsZWQsIHRoaXMgbWV0aG9kIGZhaWxzIHdpdGggXCJhdXRoL2ludmFsaWQtY3JlZGVudGlhbFwiIGluIGNhc2Ugb2YgYW4gaW52YWxpZFxyXG4gKiBlbWFpbC9wYXNzd29yZC5cclxuICpcclxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBvbiB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXHJcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cclxuICpcclxuICogTm90ZTogVGhlIHVzZXIncyBwYXNzd29yZCBpcyBOT1QgdGhlIHBhc3N3b3JkIHVzZWQgdG8gYWNjZXNzIHRoZSB1c2VyJ3MgZW1haWwgYWNjb3VudC4gVGhlXHJcbiAqIGVtYWlsIGFkZHJlc3Mgc2VydmVzIGFzIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB1c2VyLCBhbmQgdGhlIHBhc3N3b3JkIGlzIHVzZWQgdG8gYWNjZXNzXHJcbiAqIHRoZSB1c2VyJ3MgYWNjb3VudCBpbiB5b3VyIEZpcmViYXNlIHByb2plY3QuIFNlZSBhbHNvOiB7QGxpbmsgY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkfS5cclxuICpcclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gZW1haWwgLSBUaGUgdXNlcnMgZW1haWwgYWRkcmVzcy5cclxuICogQHBhcmFtIHBhc3N3b3JkIC0gVGhlIHVzZXJzIHBhc3N3b3JkLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZChhdXRoLCBlbWFpbCwgcGFzc3dvcmQpIHtcclxuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcChhdXRoLmFwcCkpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNpZ25JbldpdGhDcmVkZW50aWFsKGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKSwgRW1haWxBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChlbWFpbCwgcGFzc3dvcmQpKS5jYXRjaChhc3luYyAoZXJyb3IpID0+IHtcclxuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gYGF1dGgvJHtcInBhc3N3b3JkLWRvZXMtbm90LW1lZXQtcmVxdWlyZW1lbnRzXCIgLyogQXV0aEVycm9yQ29kZS5QQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UUyAqL31gKSB7XHJcbiAgICAgICAgICAgIHZvaWQgcmVjYWNoZVBhc3N3b3JkUG9saWN5KGF1dGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBTZW5kcyBhIHNpZ24taW4gZW1haWwgbGluayB0byB0aGUgdXNlciB3aXRoIHRoZSBzcGVjaWZpZWQgZW1haWwuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoZSBzaWduLWluIG9wZXJhdGlvbiBoYXMgdG8gYWx3YXlzIGJlIGNvbXBsZXRlZCBpbiB0aGUgYXBwIHVubGlrZSBvdGhlciBvdXQgb2YgYmFuZCBlbWFpbFxyXG4gKiBhY3Rpb25zIChwYXNzd29yZCByZXNldCBhbmQgZW1haWwgdmVyaWZpY2F0aW9ucykuIFRoaXMgaXMgYmVjYXVzZSwgYXQgdGhlIGVuZCBvZiB0aGUgZmxvdyxcclxuICogdGhlIHVzZXIgaXMgZXhwZWN0ZWQgdG8gYmUgc2lnbmVkIGluIGFuZCB0aGVpciBBdXRoIHN0YXRlIHBlcnNpc3RlZCB3aXRoaW4gdGhlIGFwcC5cclxuICpcclxuICogVG8gY29tcGxldGUgc2lnbiBpbiB3aXRoIHRoZSBlbWFpbCBsaW5rLCBjYWxsIHtAbGluayBzaWduSW5XaXRoRW1haWxMaW5rfSB3aXRoIHRoZSBlbWFpbFxyXG4gKiBhZGRyZXNzIGFuZCB0aGUgZW1haWwgbGluayBzdXBwbGllZCBpbiB0aGUgZW1haWwgc2VudCB0byB0aGUgdXNlci5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiBjb25zdCBhY3Rpb25Db2RlU2V0dGluZ3MgPSB7XHJcbiAqICAgdXJsOiAnaHR0cHM6Ly93d3cuZXhhbXBsZS5jb20vP2VtYWlsPXVzZXJAZXhhbXBsZS5jb20nLFxyXG4gKiAgIGlPUzoge1xyXG4gKiAgICAgIGJ1bmRsZUlkOiAnY29tLmV4YW1wbGUuaW9zJ1xyXG4gKiAgIH0sXHJcbiAqICAgYW5kcm9pZDoge1xyXG4gKiAgICAgcGFja2FnZU5hbWU6ICdjb20uZXhhbXBsZS5hbmRyb2lkJyxcclxuICogICAgIGluc3RhbGxBcHA6IHRydWUsXHJcbiAqICAgICBtaW5pbXVtVmVyc2lvbjogJzEyJ1xyXG4gKiAgIH0sXHJcbiAqICAgaGFuZGxlQ29kZUluQXBwOiB0cnVlXHJcbiAqIH07XHJcbiAqIGF3YWl0IHNlbmRTaWduSW5MaW5rVG9FbWFpbChhdXRoLCAndXNlckBleGFtcGxlLmNvbScsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XHJcbiAqIC8vIE9idGFpbiBlbWFpbExpbmsgZnJvbSB0aGUgdXNlci5cclxuICogaWYoaXNTaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsIGVtYWlsTGluaykpIHtcclxuICogICBhd2FpdCBzaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsICd1c2VyQGV4YW1wbGUuY29tJywgZW1haWxMaW5rKTtcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIGF1dGhJbnRlcm5hbCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cclxuICogQHBhcmFtIGFjdGlvbkNvZGVTZXR0aW5ncyAtIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVNldHRpbmdzfS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc2VuZFNpZ25JbkxpbmtUb0VtYWlsKGF1dGgsIGVtYWlsLCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcclxuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgcmVxdWVzdFR5cGU6IFwiRU1BSUxfU0lHTklOXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5FTUFJTF9TSUdOSU4gKi8sXHJcbiAgICAgICAgZW1haWwsXHJcbiAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqL1xyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIHNldEFjdGlvbkNvZGVTZXR0aW5ncyhyZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcclxuICAgICAgICBfYXNzZXJ0KGFjdGlvbkNvZGVTZXR0aW5ncy5oYW5kbGVDb2RlSW5BcHAsIGF1dGhJbnRlcm5hbCwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xyXG4gICAgICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdChhdXRoSW50ZXJuYWwsIHJlcXVlc3QsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0QWN0aW9uQ29kZVNldHRpbmdzKHJlcXVlc3QsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XHJcbiAgICBhd2FpdCBoYW5kbGVSZWNhcHRjaGFGbG93KGF1dGhJbnRlcm5hbCwgcmVxdWVzdCwgXCJnZXRPb2JDb2RlXCIgLyogUmVjYXB0Y2hhQWN0aW9uTmFtZS5HRVRfT09CX0NPREUgKi8sIHNlbmRTaWduSW5MaW5rVG9FbWFpbCQxKTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIGFuIGluY29taW5nIGxpbmsgaXMgYSBzaWduLWluIHdpdGggZW1haWwgbGluayBzdWl0YWJsZSBmb3Ige0BsaW5rIHNpZ25JbldpdGhFbWFpbExpbmt9LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBlbWFpbExpbmsgLSBUaGUgbGluayBzZW50IHRvIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gaXNTaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsIGVtYWlsTGluaykge1xyXG4gICAgY29uc3QgYWN0aW9uQ29kZVVybCA9IEFjdGlvbkNvZGVVUkwucGFyc2VMaW5rKGVtYWlsTGluayk7XHJcbiAgICByZXR1cm4gKGFjdGlvbkNvZGVVcmwgPT09IG51bGwgfHwgYWN0aW9uQ29kZVVybCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9uQ29kZVVybC5vcGVyYXRpb24pID09PSBcIkVNQUlMX1NJR05JTlwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uRU1BSUxfU0lHTklOICovO1xyXG59XHJcbi8qKlxyXG4gKiBBc3luY2hyb25vdXNseSBzaWducyBpbiB1c2luZyBhbiBlbWFpbCBhbmQgc2lnbi1pbiBlbWFpbCBsaW5rLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBJZiBubyBsaW5rIGlzIHBhc3NlZCwgdGhlIGxpbmsgaXMgaW5mZXJyZWQgZnJvbSB0aGUgY3VycmVudCBVUkwuXHJcbiAqXHJcbiAqIEZhaWxzIHdpdGggYW4gZXJyb3IgaWYgdGhlIGVtYWlsIGFkZHJlc3MgaXMgaW52YWxpZCBvciBPVFAgaW4gZW1haWwgbGluayBleHBpcmVzLlxyXG4gKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcclxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxyXG4gKlxyXG4gKiBOb3RlOiBDb25maXJtIHRoZSBsaW5rIGlzIGEgc2lnbi1pbiBlbWFpbCBsaW5rIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kIGZpcmViYXNlLmF1dGguQXV0aC5pc1NpZ25JbldpdGhFbWFpbExpbmsuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogY29uc3QgYWN0aW9uQ29kZVNldHRpbmdzID0ge1xyXG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcclxuICogICBpT1M6IHtcclxuICogICAgICBidW5kbGVJZDogJ2NvbS5leGFtcGxlLmlvcydcclxuICogICB9LFxyXG4gKiAgIGFuZHJvaWQ6IHtcclxuICogICAgIHBhY2thZ2VOYW1lOiAnY29tLmV4YW1wbGUuYW5kcm9pZCcsXHJcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxyXG4gKiAgICAgbWluaW11bVZlcnNpb246ICcxMidcclxuICogICB9LFxyXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxyXG4gKiB9O1xyXG4gKiBhd2FpdCBzZW5kU2lnbkluTGlua1RvRW1haWwoYXV0aCwgJ3VzZXJAZXhhbXBsZS5jb20nLCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xyXG4gKiAvLyBPYnRhaW4gZW1haWxMaW5rIGZyb20gdGhlIHVzZXIuXHJcbiAqIGlmKGlzU2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCBlbWFpbExpbmspKSB7XHJcbiAqICAgYXdhaXQgc2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCAndXNlckBleGFtcGxlLmNvbScsIGVtYWlsTGluayk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxyXG4gKiBAcGFyYW0gZW1haWxMaW5rIC0gVGhlIGxpbmsgc2VudCB0byB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgZW1haWwsIGVtYWlsTGluaykge1xyXG4gICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKGF1dGguYXBwKSkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcihhdXRoKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhdXRoTW9kdWxhciA9IGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKTtcclxuICAgIGNvbnN0IGNyZWRlbnRpYWwgPSBFbWFpbEF1dGhQcm92aWRlci5jcmVkZW50aWFsV2l0aExpbmsoZW1haWwsIGVtYWlsTGluayB8fCBfZ2V0Q3VycmVudFVybCgpKTtcclxuICAgIC8vIENoZWNrIGlmIHRoZSB0ZW5hbnQgSUQgaW4gdGhlIGVtYWlsIGxpbmsgbWF0Y2hlcyB0aGUgdGVuYW50IElEIG9uIEF1dGhcclxuICAgIC8vIGluc3RhbmNlLlxyXG4gICAgX2Fzc2VydChjcmVkZW50aWFsLl90ZW5hbnRJZCA9PT0gKGF1dGhNb2R1bGFyLnRlbmFudElkIHx8IG51bGwpLCBhdXRoTW9kdWxhciwgXCJ0ZW5hbnQtaWQtbWlzbWF0Y2hcIiAvKiBBdXRoRXJyb3JDb2RlLlRFTkFOVF9JRF9NSVNNQVRDSCAqLyk7XHJcbiAgICByZXR1cm4gc2lnbkluV2l0aENyZWRlbnRpYWwoYXV0aE1vZHVsYXIsIGNyZWRlbnRpYWwpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUF1dGhVcmkoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOmNyZWF0ZUF1dGhVcmlcIiAvKiBFbmRwb2ludC5DUkVBVEVfQVVUSF9VUkkgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEdldHMgdGhlIGxpc3Qgb2YgcG9zc2libGUgc2lnbiBpbiBtZXRob2RzIGZvciB0aGUgZ2l2ZW4gZW1haWwgYWRkcmVzcy4gVGhpcyBtZXRob2QgcmV0dXJucyBhblxyXG4gKiBlbXB0eSBsaXN0IHdoZW5cclxuICoge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pZGVudGl0eS1wbGF0Zm9ybS9kb2NzL2FkbWluL2VtYWlsLWVudW1lcmF0aW9uLXByb3RlY3Rpb24gfCBFbWFpbCBFbnVtZXJhdGlvbiBQcm90ZWN0aW9ufVxyXG4gKiBpcyBlbmFibGVkLCBpcnJlc3BlY3RpdmUgb2YgdGhlIG51bWJlciBvZiBhdXRoZW50aWNhdGlvbiBtZXRob2RzIGF2YWlsYWJsZSBmb3IgdGhlIGdpdmVuIGVtYWlsLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGlzIGlzIHVzZWZ1bCB0byBkaWZmZXJlbnRpYXRlIG1ldGhvZHMgb2Ygc2lnbi1pbiBmb3IgdGhlIHNhbWUgcHJvdmlkZXIsIGVnLlxyXG4gKiB7QGxpbmsgRW1haWxBdXRoUHJvdmlkZXJ9IHdoaWNoIGhhcyAyIG1ldGhvZHMgb2Ygc2lnbi1pbixcclxuICoge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfUEFTU1dPUkQgYW5kXHJcbiAqIHtAbGluayBTaWduSW5NZXRob2R9LkVNQUlMX0xJTksuXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxyXG4gKlxyXG4gKiBEZXByZWNhdGVkLiBNaWdyYXRpbmcgb2ZmIG9mIHRoaXMgbWV0aG9kIGlzIHJlY29tbWVuZGVkIGFzIGEgc2VjdXJpdHkgYmVzdC1wcmFjdGljZS5cclxuICogTGVhcm4gbW9yZSBpbiB0aGUgSWRlbnRpdHkgUGxhdGZvcm0gZG9jdW1lbnRhdGlvbiBmb3JcclxuICoge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pZGVudGl0eS1wbGF0Zm9ybS9kb2NzL2FkbWluL2VtYWlsLWVudW1lcmF0aW9uLXByb3RlY3Rpb24gfCBFbWFpbCBFbnVtZXJhdGlvbiBQcm90ZWN0aW9ufS5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hTaWduSW5NZXRob2RzRm9yRW1haWwoYXV0aCwgZW1haWwpIHtcclxuICAgIC8vIGNyZWF0ZUF1dGhVcmkgcmV0dXJucyBhbiBlcnJvciBpZiBjb250aW51ZSBVUkkgaXMgbm90IGh0dHAgb3IgaHR0cHMuXHJcbiAgICAvLyBGb3IgZW52aXJvbm1lbnRzIGxpa2UgQ29yZG92YSwgQ2hyb21lIGV4dGVuc2lvbnMsIG5hdGl2ZSBmcmFtZXdvcmtzLCBmaWxlXHJcbiAgICAvLyBzeXN0ZW1zLCBldGMsIHVzZSBodHRwOi8vbG9jYWxob3N0IGFzIGNvbnRpbnVlIFVSTC5cclxuICAgIGNvbnN0IGNvbnRpbnVlVXJpID0gX2lzSHR0cE9ySHR0cHMoKSA/IF9nZXRDdXJyZW50VXJsKCkgOiAnaHR0cDovL2xvY2FsaG9zdCc7XHJcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgIGlkZW50aWZpZXI6IGVtYWlsLFxyXG4gICAgICAgIGNvbnRpbnVlVXJpXHJcbiAgICB9O1xyXG4gICAgY29uc3QgeyBzaWduaW5NZXRob2RzIH0gPSBhd2FpdCBjcmVhdGVBdXRoVXJpKGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKSwgcmVxdWVzdCk7XHJcbiAgICByZXR1cm4gc2lnbmluTWV0aG9kcyB8fCBbXTtcclxufVxyXG4vKipcclxuICogU2VuZHMgYSB2ZXJpZmljYXRpb24gZW1haWwgdG8gYSB1c2VyLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGUgdmVyaWZpY2F0aW9uIHByb2Nlc3MgaXMgY29tcGxldGVkIGJ5IGNhbGxpbmcge0BsaW5rIGFwcGx5QWN0aW9uQ29kZX0uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogY29uc3QgYWN0aW9uQ29kZVNldHRpbmdzID0ge1xyXG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcclxuICogICBpT1M6IHtcclxuICogICAgICBidW5kbGVJZDogJ2NvbS5leGFtcGxlLmlvcydcclxuICogICB9LFxyXG4gKiAgIGFuZHJvaWQ6IHtcclxuICogICAgIHBhY2thZ2VOYW1lOiAnY29tLmV4YW1wbGUuYW5kcm9pZCcsXHJcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxyXG4gKiAgICAgbWluaW11bVZlcnNpb246ICcxMidcclxuICogICB9LFxyXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxyXG4gKiB9O1xyXG4gKiBhd2FpdCBzZW5kRW1haWxWZXJpZmljYXRpb24odXNlciwgYWN0aW9uQ29kZVNldHRpbmdzKTtcclxuICogLy8gT2J0YWluIGNvZGUgZnJvbSB0aGUgdXNlci5cclxuICogYXdhaXQgYXBwbHlBY3Rpb25Db2RlKGF1dGgsIGNvZGUpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cclxuICogQHBhcmFtIGFjdGlvbkNvZGVTZXR0aW5ncyAtIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVNldHRpbmdzfS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc2VuZEVtYWlsVmVyaWZpY2F0aW9uKHVzZXIsIGFjdGlvbkNvZGVTZXR0aW5ncykge1xyXG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xyXG4gICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xyXG4gICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICByZXF1ZXN0VHlwZTogXCJWRVJJRllfRU1BSUxcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9FTUFJTCAqLyxcclxuICAgICAgICBpZFRva2VuXHJcbiAgICB9O1xyXG4gICAgaWYgKGFjdGlvbkNvZGVTZXR0aW5ncykge1xyXG4gICAgICAgIF9zZXRBY3Rpb25Db2RlU2V0dGluZ3NPblJlcXVlc3QodXNlckludGVybmFsLmF1dGgsIHJlcXVlc3QsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGVtYWlsIH0gPSBhd2FpdCBzZW5kRW1haWxWZXJpZmljYXRpb24kMSh1c2VySW50ZXJuYWwuYXV0aCwgcmVxdWVzdCk7XHJcbiAgICBpZiAoZW1haWwgIT09IHVzZXIuZW1haWwpIHtcclxuICAgICAgICBhd2FpdCB1c2VyLnJlbG9hZCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTZW5kcyBhIHZlcmlmaWNhdGlvbiBlbWFpbCB0byBhIG5ldyBlbWFpbCBhZGRyZXNzLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGUgdXNlcidzIGVtYWlsIHdpbGwgYmUgdXBkYXRlZCB0byB0aGUgbmV3IG9uZSBhZnRlciBiZWluZyB2ZXJpZmllZC5cclxuICpcclxuICogSWYgeW91IGhhdmUgYSBjdXN0b20gZW1haWwgYWN0aW9uIGhhbmRsZXIsIHlvdSBjYW4gY29tcGxldGUgdGhlIHZlcmlmaWNhdGlvbiBwcm9jZXNzIGJ5IGNhbGxpbmdcclxuICoge0BsaW5rIGFwcGx5QWN0aW9uQ29kZX0uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogY29uc3QgYWN0aW9uQ29kZVNldHRpbmdzID0ge1xyXG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcclxuICogICBpT1M6IHtcclxuICogICAgICBidW5kbGVJZDogJ2NvbS5leGFtcGxlLmlvcydcclxuICogICB9LFxyXG4gKiAgIGFuZHJvaWQ6IHtcclxuICogICAgIHBhY2thZ2VOYW1lOiAnY29tLmV4YW1wbGUuYW5kcm9pZCcsXHJcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxyXG4gKiAgICAgbWluaW11bVZlcnNpb246ICcxMidcclxuICogICB9LFxyXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxyXG4gKiB9O1xyXG4gKiBhd2FpdCB2ZXJpZnlCZWZvcmVVcGRhdGVFbWFpbCh1c2VyLCAnbmV3ZW1haWxAZXhhbXBsZS5jb20nLCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xyXG4gKiAvLyBPYnRhaW4gY29kZSBmcm9tIHRoZSB1c2VyLlxyXG4gKiBhd2FpdCBhcHBseUFjdGlvbkNvZGUoYXV0aCwgY29kZSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxyXG4gKiBAcGFyYW0gbmV3RW1haWwgLSBUaGUgbmV3IGVtYWlsIGFkZHJlc3MgdG8gYmUgdmVyaWZpZWQgYmVmb3JlIHVwZGF0ZS5cclxuICogQHBhcmFtIGFjdGlvbkNvZGVTZXR0aW5ncyAtIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVNldHRpbmdzfS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5QmVmb3JlVXBkYXRlRW1haWwodXNlciwgbmV3RW1haWwsIGFjdGlvbkNvZGVTZXR0aW5ncykge1xyXG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xyXG4gICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xyXG4gICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICByZXF1ZXN0VHlwZTogXCJWRVJJRllfQU5EX0NIQU5HRV9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwgKi8sXHJcbiAgICAgICAgaWRUb2tlbixcclxuICAgICAgICBuZXdFbWFpbFxyXG4gICAgfTtcclxuICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MpIHtcclxuICAgICAgICBfc2V0QWN0aW9uQ29kZVNldHRpbmdzT25SZXF1ZXN0KHVzZXJJbnRlcm5hbC5hdXRoLCByZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBlbWFpbCB9ID0gYXdhaXQgdmVyaWZ5QW5kQ2hhbmdlRW1haWwodXNlckludGVybmFsLmF1dGgsIHJlcXVlc3QpO1xyXG4gICAgaWYgKGVtYWlsICE9PSB1c2VyLmVtYWlsKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIGxvY2FsIGNvcHkgb2YgdGhlIGVtYWlsIG9uIHVzZXIgaXMgb3V0ZGF0ZWQsIHJlbG9hZCB0aGVcclxuICAgICAgICAvLyB1c2VyLlxyXG4gICAgICAgIGF3YWl0IHVzZXIucmVsb2FkKCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlUHJvZmlsZSQxKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czp1cGRhdGVcIiAvKiBFbmRwb2ludC5TRVRfQUNDT1VOVF9JTkZPICovLCByZXF1ZXN0KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVXBkYXRlcyBhIHVzZXIncyBwcm9maWxlIGRhdGEuXHJcbiAqXHJcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXHJcbiAqIEBwYXJhbSBwcm9maWxlIC0gVGhlIHByb2ZpbGUncyBgZGlzcGxheU5hbWVgIGFuZCBgcGhvdG9VUkxgIHRvIHVwZGF0ZS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlUHJvZmlsZSh1c2VyLCB7IGRpc3BsYXlOYW1lLCBwaG90b1VSTDogcGhvdG9VcmwgfSkge1xyXG4gICAgaWYgKGRpc3BsYXlOYW1lID09PSB1bmRlZmluZWQgJiYgcGhvdG9VcmwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKTtcclxuICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB1c2VySW50ZXJuYWwuZ2V0SWRUb2tlbigpO1xyXG4gICAgY29uc3QgcHJvZmlsZVJlcXVlc3QgPSB7XHJcbiAgICAgICAgaWRUb2tlbixcclxuICAgICAgICBkaXNwbGF5TmFtZSxcclxuICAgICAgICBwaG90b1VybCxcclxuICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodXNlckludGVybmFsLCB1cGRhdGVQcm9maWxlJDEodXNlckludGVybmFsLmF1dGgsIHByb2ZpbGVSZXF1ZXN0KSk7XHJcbiAgICB1c2VySW50ZXJuYWwuZGlzcGxheU5hbWUgPSByZXNwb25zZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xyXG4gICAgdXNlckludGVybmFsLnBob3RvVVJMID0gcmVzcG9uc2UucGhvdG9VcmwgfHwgbnVsbDtcclxuICAgIC8vIFVwZGF0ZSB0aGUgcGFzc3dvcmQgcHJvdmlkZXIgYXMgd2VsbFxyXG4gICAgY29uc3QgcGFzc3dvcmRQcm92aWRlciA9IHVzZXJJbnRlcm5hbC5wcm92aWRlckRhdGEuZmluZCgoeyBwcm92aWRlcklkIH0pID0+IHByb3ZpZGVySWQgPT09IFwicGFzc3dvcmRcIiAvKiBQcm92aWRlcklkLlBBU1NXT1JEICovKTtcclxuICAgIGlmIChwYXNzd29yZFByb3ZpZGVyKSB7XHJcbiAgICAgICAgcGFzc3dvcmRQcm92aWRlci5kaXNwbGF5TmFtZSA9IHVzZXJJbnRlcm5hbC5kaXNwbGF5TmFtZTtcclxuICAgICAgICBwYXNzd29yZFByb3ZpZGVyLnBob3RvVVJMID0gdXNlckludGVybmFsLnBob3RvVVJMO1xyXG4gICAgfVxyXG4gICAgYXdhaXQgdXNlckludGVybmFsLl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShyZXNwb25zZSk7XHJcbn1cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBBbiBlbWFpbCB3aWxsIGJlIHNlbnQgdG8gdGhlIG9yaWdpbmFsIGVtYWlsIGFkZHJlc3MgKGlmIGl0IHdhcyBzZXQpIHRoYXQgYWxsb3dzIHRvIHJldm9rZSB0aGVcclxuICogZW1haWwgYWRkcmVzcyBjaGFuZ2UsIGluIG9yZGVyIHRvIHByb3RlY3QgdGhlbSBmcm9tIGFjY291bnQgaGlqYWNraW5nLlxyXG4gKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIG9uIGFueSB7QGxpbmsgVXNlcn0gc2lnbmVkIGluIGJ5IHtAbGluayBBdXRofSBpbnN0YW5jZXNcclxuICogY3JlYXRlZCB3aXRoIGEge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxyXG4gKlxyXG4gKiBJbXBvcnRhbnQ6IHRoaXMgaXMgYSBzZWN1cml0eSBzZW5zaXRpdmUgb3BlcmF0aW9uIHRoYXQgcmVxdWlyZXMgdGhlIHVzZXIgdG8gaGF2ZSByZWNlbnRseSBzaWduZWRcclxuICogaW4uIElmIHRoaXMgcmVxdWlyZW1lbnQgaXNuJ3QgbWV0LCBhc2sgdGhlIHVzZXIgdG8gYXV0aGVudGljYXRlIGFnYWluIGFuZCB0aGVuIGNhbGxcclxuICoge0BsaW5rIHJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWx9LlxyXG4gKlxyXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxyXG4gKiBAcGFyYW0gbmV3RW1haWwgLSBUaGUgbmV3IGVtYWlsIGFkZHJlc3MuXHJcbiAqXHJcbiAqIFRocm93cyBcImF1dGgvb3BlcmF0aW9uLW5vdC1hbGxvd2VkXCIgZXJyb3Igd2hlblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2lkZW50aXR5LXBsYXRmb3JtL2RvY3MvYWRtaW4vZW1haWwtZW51bWVyYXRpb24tcHJvdGVjdGlvbiB8IEVtYWlsIEVudW1lcmF0aW9uIFByb3RlY3Rpb259XHJcbiAqIGlzIGVuYWJsZWQuXHJcbiAqIERlcHJlY2F0ZWQgLSBVc2Uge0BsaW5rIHZlcmlmeUJlZm9yZVVwZGF0ZUVtYWlsfSBpbnN0ZWFkLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVFbWFpbCh1c2VyLCBuZXdFbWFpbCkge1xyXG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xyXG4gICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKHVzZXJJbnRlcm5hbC5hdXRoLmFwcCkpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IodXNlckludGVybmFsLmF1dGgpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1cGRhdGVFbWFpbE9yUGFzc3dvcmQodXNlckludGVybmFsLCBuZXdFbWFpbCwgbnVsbCk7XHJcbn1cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdGhlIHVzZXIncyBwYXNzd29yZC5cclxuICpcclxuICogQHJlbWFya3NcclxuICogSW1wb3J0YW50OiB0aGlzIGlzIGEgc2VjdXJpdHkgc2Vuc2l0aXZlIG9wZXJhdGlvbiB0aGF0IHJlcXVpcmVzIHRoZSB1c2VyIHRvIGhhdmUgcmVjZW50bHkgc2lnbmVkXHJcbiAqIGluLiBJZiB0aGlzIHJlcXVpcmVtZW50IGlzbid0IG1ldCwgYXNrIHRoZSB1c2VyIHRvIGF1dGhlbnRpY2F0ZSBhZ2FpbiBhbmQgdGhlbiBjYWxsXHJcbiAqIHtAbGluayByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsfS5cclxuICpcclxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cclxuICogQHBhcmFtIG5ld1Bhc3N3b3JkIC0gVGhlIG5ldyBwYXNzd29yZC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlUGFzc3dvcmQodXNlciwgbmV3UGFzc3dvcmQpIHtcclxuICAgIHJldHVybiB1cGRhdGVFbWFpbE9yUGFzc3dvcmQoZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpLCBudWxsLCBuZXdQYXNzd29yZCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlRW1haWxPclBhc3N3b3JkKHVzZXIsIGVtYWlsLCBwYXNzd29yZCkge1xyXG4gICAgY29uc3QgeyBhdXRoIH0gPSB1c2VyO1xyXG4gICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xyXG4gICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICBpZFRva2VuLFxyXG4gICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlXHJcbiAgICB9O1xyXG4gICAgaWYgKGVtYWlsKSB7XHJcbiAgICAgICAgcmVxdWVzdC5lbWFpbCA9IGVtYWlsO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhc3N3b3JkKSB7XHJcbiAgICAgICAgcmVxdWVzdC5wYXNzd29yZCA9IHBhc3N3b3JkO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh1c2VyLCB1cGRhdGVFbWFpbFBhc3N3b3JkKGF1dGgsIHJlcXVlc3QpKTtcclxuICAgIGF3YWl0IHVzZXIuX3VwZGF0ZVRva2Vuc0lmTmVjZXNzYXJ5KHJlc3BvbnNlLCAvKiByZWxvYWQgKi8gdHJ1ZSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFBhcnNlIHRoZSBgQWRkaXRpb25hbFVzZXJJbmZvYCBmcm9tIHRoZSBJRCB0b2tlbiByZXNwb25zZS5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIF9mcm9tSWRUb2tlblJlc3BvbnNlKGlkVG9rZW5SZXNwb25zZSkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIGlmICghaWRUb2tlblJlc3BvbnNlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHByb3ZpZGVySWQgfSA9IGlkVG9rZW5SZXNwb25zZTtcclxuICAgIGNvbnN0IHByb2ZpbGUgPSBpZFRva2VuUmVzcG9uc2UucmF3VXNlckluZm9cclxuICAgICAgICA/IEpTT04ucGFyc2UoaWRUb2tlblJlc3BvbnNlLnJhd1VzZXJJbmZvKVxyXG4gICAgICAgIDoge307XHJcbiAgICBjb25zdCBpc05ld1VzZXIgPSBpZFRva2VuUmVzcG9uc2UuaXNOZXdVc2VyIHx8XHJcbiAgICAgICAgaWRUb2tlblJlc3BvbnNlLmtpbmQgPT09IFwiaWRlbnRpdHl0b29sa2l0I1NpZ251cE5ld1VzZXJSZXNwb25zZVwiIC8qIElkVG9rZW5SZXNwb25zZUtpbmQuU2lnbnVwTmV3VXNlciAqLztcclxuICAgIGlmICghcHJvdmlkZXJJZCAmJiAoaWRUb2tlblJlc3BvbnNlID09PSBudWxsIHx8IGlkVG9rZW5SZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaWRUb2tlblJlc3BvbnNlLmlkVG9rZW4pKSB7XHJcbiAgICAgICAgY29uc3Qgc2lnbkluUHJvdmlkZXIgPSAoX2IgPSAoX2EgPSBfcGFyc2VUb2tlbihpZFRva2VuUmVzcG9uc2UuaWRUb2tlbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maXJlYmFzZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWydzaWduX2luX3Byb3ZpZGVyJ107XHJcbiAgICAgICAgaWYgKHNpZ25JblByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkUHJvdmlkZXJJZCA9IHNpZ25JblByb3ZpZGVyICE9PSBcImFub255bW91c1wiIC8qIFByb3ZpZGVySWQuQU5PTllNT1VTICovICYmXHJcbiAgICAgICAgICAgICAgICBzaWduSW5Qcm92aWRlciAhPT0gXCJjdXN0b21cIiAvKiBQcm92aWRlcklkLkNVU1RPTSAqL1xyXG4gICAgICAgICAgICAgICAgPyBzaWduSW5Qcm92aWRlclxyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgICAgICAvLyBVc2VzIGdlbmVyaWMgY2xhc3MgaW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBsZWdhY3kgU0RLLlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBmaWx0ZXJlZFByb3ZpZGVySWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghcHJvdmlkZXJJZCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChwcm92aWRlcklkKSB7XHJcbiAgICAgICAgY2FzZSBcImZhY2Vib29rLmNvbVwiIC8qIFByb3ZpZGVySWQuRkFDRUJPT0sgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFjZWJvb2tBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBwcm9maWxlKTtcclxuICAgICAgICBjYXNlIFwiZ2l0aHViLmNvbVwiIC8qIFByb3ZpZGVySWQuR0lUSFVCICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEdpdGh1YkFkZGl0aW9uYWxVc2VySW5mbyhpc05ld1VzZXIsIHByb2ZpbGUpO1xyXG4gICAgICAgIGNhc2UgXCJnb29nbGUuY29tXCIgLyogUHJvdmlkZXJJZC5HT09HTEUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgR29vZ2xlQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgcHJvZmlsZSk7XHJcbiAgICAgICAgY2FzZSBcInR3aXR0ZXIuY29tXCIgLyogUHJvdmlkZXJJZC5UV0lUVEVSICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFR3aXR0ZXJBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBwcm9maWxlLCBpZFRva2VuUmVzcG9uc2Uuc2NyZWVuTmFtZSB8fCBudWxsKTtcclxuICAgICAgICBjYXNlIFwiY3VzdG9tXCIgLyogUHJvdmlkZXJJZC5DVVNUT00gKi86XHJcbiAgICAgICAgY2FzZSBcImFub255bW91c1wiIC8qIFByb3ZpZGVySWQuQU5PTllNT1VTICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBudWxsKTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBwcm92aWRlcklkLCBwcm9maWxlKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvIHtcclxuICAgIGNvbnN0cnVjdG9yKGlzTmV3VXNlciwgcHJvdmlkZXJJZCwgcHJvZmlsZSA9IHt9KSB7XHJcbiAgICAgICAgdGhpcy5pc05ld1VzZXIgPSBpc05ld1VzZXI7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcklkID0gcHJvdmlkZXJJZDtcclxuICAgICAgICB0aGlzLnByb2ZpbGUgPSBwcm9maWxlO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEZlZGVyYXRlZEFkZGl0aW9uYWxVc2VySW5mb1dpdGhVc2VybmFtZSBleHRlbmRzIEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8ge1xyXG4gICAgY29uc3RydWN0b3IoaXNOZXdVc2VyLCBwcm92aWRlcklkLCBwcm9maWxlLCB1c2VybmFtZSkge1xyXG4gICAgICAgIHN1cGVyKGlzTmV3VXNlciwgcHJvdmlkZXJJZCwgcHJvZmlsZSk7XHJcbiAgICAgICAgdGhpcy51c2VybmFtZSA9IHVzZXJuYW1lO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEZhY2Vib29rQWRkaXRpb25hbFVzZXJJbmZvIGV4dGVuZHMgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihpc05ld1VzZXIsIHByb2ZpbGUpIHtcclxuICAgICAgICBzdXBlcihpc05ld1VzZXIsIFwiZmFjZWJvb2suY29tXCIgLyogUHJvdmlkZXJJZC5GQUNFQk9PSyAqLywgcHJvZmlsZSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgR2l0aHViQWRkaXRpb25hbFVzZXJJbmZvIGV4dGVuZHMgRmVkZXJhdGVkQWRkaXRpb25hbFVzZXJJbmZvV2l0aFVzZXJuYW1lIHtcclxuICAgIGNvbnN0cnVjdG9yKGlzTmV3VXNlciwgcHJvZmlsZSkge1xyXG4gICAgICAgIHN1cGVyKGlzTmV3VXNlciwgXCJnaXRodWIuY29tXCIgLyogUHJvdmlkZXJJZC5HSVRIVUIgKi8sIHByb2ZpbGUsIHR5cGVvZiAocHJvZmlsZSA9PT0gbnVsbCB8fCBwcm9maWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9maWxlLmxvZ2luKSA9PT0gJ3N0cmluZycgPyBwcm9maWxlID09PSBudWxsIHx8IHByb2ZpbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2ZpbGUubG9naW4gOiBudWxsKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBHb29nbGVBZGRpdGlvbmFsVXNlckluZm8gZXh0ZW5kcyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvIHtcclxuICAgIGNvbnN0cnVjdG9yKGlzTmV3VXNlciwgcHJvZmlsZSkge1xyXG4gICAgICAgIHN1cGVyKGlzTmV3VXNlciwgXCJnb29nbGUuY29tXCIgLyogUHJvdmlkZXJJZC5HT09HTEUgKi8sIHByb2ZpbGUpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFR3aXR0ZXJBZGRpdGlvbmFsVXNlckluZm8gZXh0ZW5kcyBGZWRlcmF0ZWRBZGRpdGlvbmFsVXNlckluZm9XaXRoVXNlcm5hbWUge1xyXG4gICAgY29uc3RydWN0b3IoaXNOZXdVc2VyLCBwcm9maWxlLCBzY3JlZW5OYW1lKSB7XHJcbiAgICAgICAgc3VwZXIoaXNOZXdVc2VyLCBcInR3aXR0ZXIuY29tXCIgLyogUHJvdmlkZXJJZC5UV0lUVEVSICovLCBwcm9maWxlLCBzY3JlZW5OYW1lKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXh0cmFjdHMgcHJvdmlkZXIgc3BlY2lmaWMge0BsaW5rIEFkZGl0aW9uYWxVc2VySW5mb30gZm9yIHRoZSBnaXZlbiBjcmVkZW50aWFsLlxyXG4gKlxyXG4gKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBZGRpdGlvbmFsVXNlckluZm8odXNlckNyZWRlbnRpYWwpIHtcclxuICAgIGNvbnN0IHsgdXNlciwgX3Rva2VuUmVzcG9uc2UgfSA9IHVzZXJDcmVkZW50aWFsO1xyXG4gICAgaWYgKHVzZXIuaXNBbm9ueW1vdXMgJiYgIV90b2tlblJlc3BvbnNlKSB7XHJcbiAgICAgICAgLy8gSGFuZGxlIHRoZSBzcGVjaWFsIGNhc2Ugd2hlcmUgc2lnbkluQW5vbnltb3VzbHkoKSBnZXRzIGNhbGxlZCB0d2ljZS5cclxuICAgICAgICAvLyBObyBuZXR3b3JrIGNhbGwgaXMgbWFkZSBzbyB0aGVyZSdzIG5vdGhpbmcgdG8gYWN0dWFsbHkgZmlsbCB0aGlzIGluXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJvdmlkZXJJZDogbnVsbCxcclxuICAgICAgICAgICAgaXNOZXdVc2VyOiBmYWxzZSxcclxuICAgICAgICAgICAgcHJvZmlsZTogbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2Zyb21JZFRva2VuUmVzcG9uc2UoX3Rva2VuUmVzcG9uc2UpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIE5vbi1vcHRpb25hbCBhdXRoIG1ldGhvZHMuXHJcbi8qKlxyXG4gKiBDaGFuZ2VzIHRoZSB0eXBlIG9mIHBlcnNpc3RlbmNlIG9uIHRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UgZm9yIHRoZSBjdXJyZW50bHkgc2F2ZWRcclxuICogYEF1dGhgIHNlc3Npb24gYW5kIGFwcGxpZXMgdGhpcyB0eXBlIG9mIHBlcnNpc3RlbmNlIGZvciBmdXR1cmUgc2lnbi1pbiByZXF1ZXN0cywgaW5jbHVkaW5nXHJcbiAqIHNpZ24taW4gd2l0aCByZWRpcmVjdCByZXF1ZXN0cy5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhpcyBtYWtlcyBpdCBlYXN5IGZvciBhIHVzZXIgc2lnbmluZyBpbiB0byBzcGVjaWZ5IHdoZXRoZXIgdGhlaXIgc2Vzc2lvbiBzaG91bGQgYmVcclxuICogcmVtZW1iZXJlZCBvciBub3QuIEl0IGFsc28gbWFrZXMgaXQgZWFzaWVyIHRvIG5ldmVyIHBlcnNpc3QgdGhlIGBBdXRoYCBzdGF0ZSBmb3IgYXBwbGljYXRpb25zXHJcbiAqIHRoYXQgYXJlIHNoYXJlZCBieSBvdGhlciB1c2VycyBvciBoYXZlIHNlbnNpdGl2ZSBkYXRhLlxyXG4gKlxyXG4gKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB3b3JrIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudCBvciB3aXRoIHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcclxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIHNldFBlcnNpc3RlbmNlKGF1dGgsIGJyb3dzZXJTZXNzaW9uUGVyc2lzdGVuY2UpO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gcGVyc2lzdGVuY2UgLSBUaGUge0BsaW5rIFBlcnNpc3RlbmNlfSB0byB1c2UuXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgcGVyc2lzdGVuY2UgY2hhbmdlIGhhcyBjb21wbGV0ZWRcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0UGVyc2lzdGVuY2UoYXV0aCwgcGVyc2lzdGVuY2UpIHtcclxuICAgIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkuc2V0UGVyc2lzdGVuY2UocGVyc2lzdGVuY2UpO1xyXG59XHJcbi8qKlxyXG4gKiBMb2FkcyB0aGUgcmVDQVBUQ0hBIGNvbmZpZ3VyYXRpb24gaW50byB0aGUgYEF1dGhgIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGlzIHdpbGwgbG9hZCB0aGUgcmVDQVBUQ0hBIGNvbmZpZywgd2hpY2ggaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHJlQ0FQVENIQVxyXG4gKiB2ZXJpZmljYXRpb24gZmxvdyBzaG91bGQgYmUgdHJpZ2dlcmVkIGZvciBlYWNoIGF1dGggcHJvdmlkZXIsIGludG8gdGhlXHJcbiAqIGN1cnJlbnQgQXV0aCBzZXNzaW9uLlxyXG4gKlxyXG4gKiBJZiBpbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnKCkgaXMgbm90IGludm9rZWQsIHRoZSBhdXRoIGZsb3cgd2lsbCBhbHdheXMgc3RhcnRcclxuICogd2l0aG91dCByZUNBUFRDSEEgdmVyaWZpY2F0aW9uLiBJZiB0aGUgcHJvdmlkZXIgaXMgY29uZmlndXJlZCB0byByZXF1aXJlIHJlQ0FQVENIQVxyXG4gKiB2ZXJpZmljYXRpb24sIHRoZSBTREsgd2lsbCB0cmFuc3BhcmVudGx5IGxvYWQgdGhlIHJlQ0FQVENIQSBjb25maWcgYW5kIHJlc3RhcnQgdGhlXHJcbiAqIGF1dGggZmxvd3MuXHJcbiAqXHJcbiAqIFRodXMsIGJ5IGNhbGxpbmcgdGhpcyBvcHRpb25hbCBtZXRob2QsIHlvdSB3aWxsIHJlZHVjZSB0aGUgbGF0ZW5jeSBvZiBmdXR1cmUgYXV0aCBmbG93cy5cclxuICogTG9hZGluZyB0aGUgcmVDQVBUQ0hBIGNvbmZpZyBlYXJseSB3aWxsIGFsc28gZW5oYW5jZSB0aGUgc2lnbmFsIGNvbGxlY3RlZCBieSByZUNBUFRDSEEuXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHdvcmsgaW4gYSBOb2RlLmpzIGVudmlyb25tZW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIGluaXRpYWxpemVSZWNhcHRjaGFDb25maWcoYXV0aCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGluaXRpYWxpemVSZWNhcHRjaGFDb25maWcoYXV0aCkge1xyXG4gICAgcmV0dXJuIF9pbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnKGF1dGgpO1xyXG59XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgdGhlIHBhc3N3b3JkIGFnYWluc3QgdGhlIHBhc3N3b3JkIHBvbGljeSBjb25maWd1cmVkIGZvciB0aGUgcHJvamVjdCBvciB0ZW5hbnQuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIElmIG5vIHRlbmFudCBJRCBpcyBzZXQgb24gdGhlIGBBdXRoYCBpbnN0YW5jZSwgdGhlbiB0aGlzIG1ldGhvZCB3aWxsIHVzZSB0aGUgcGFzc3dvcmRcclxuICogcG9saWN5IGNvbmZpZ3VyZWQgZm9yIHRoZSBwcm9qZWN0LiBPdGhlcndpc2UsIHRoaXMgbWV0aG9kIHdpbGwgdXNlIHRoZSBwb2xpY3kgY29uZmlndXJlZFxyXG4gKiBmb3IgdGhlIHRlbmFudC4gSWYgYSBwYXNzd29yZCBwb2xpY3kgaGFzIG5vdCBiZWVuIGNvbmZpZ3VyZWQsIHRoZW4gdGhlIGRlZmF1bHQgcG9saWN5XHJcbiAqIGNvbmZpZ3VyZWQgZm9yIGFsbCBwcm9qZWN0cyB3aWxsIGJlIHVzZWQuXHJcbiAqXHJcbiAqIElmIGFuIGF1dGggZmxvdyBmYWlscyBiZWNhdXNlIGEgc3VibWl0dGVkIHBhc3N3b3JkIGRvZXMgbm90IG1lZXQgdGhlIHBhc3N3b3JkIHBvbGljeVxyXG4gKiByZXF1aXJlbWVudHMgYW5kIHRoaXMgbWV0aG9kIGhhcyBwcmV2aW91c2x5IGJlZW4gY2FsbGVkLCB0aGVuIHRoaXMgbWV0aG9kIHdpbGwgdXNlIHRoZVxyXG4gKiBtb3N0IHJlY2VudCBwb2xpY3kgYXZhaWxhYmxlIHdoZW4gY2FsbGVkIGFnYWluLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIHZhbGlkYXRlUGFzc3dvcmQoYXV0aCwgJ3NvbWUtcGFzc3dvcmQnKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgdG8gdmFsaWRhdGUuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlUGFzc3dvcmQoYXV0aCwgcGFzc3dvcmQpIHtcclxuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcclxuICAgIHJldHVybiBhdXRoSW50ZXJuYWwudmFsaWRhdGVQYXNzd29yZChwYXNzd29yZCk7XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgYW4gb2JzZXJ2ZXIgZm9yIGNoYW5nZXMgdG8gdGhlIHNpZ25lZC1pbiB1c2VyJ3MgSUQgdG9rZW4uXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoaXMgaW5jbHVkZXMgc2lnbi1pbiwgc2lnbi1vdXQsIGFuZCB0b2tlbiByZWZyZXNoIGV2ZW50cy5cclxuICogVGhpcyB3aWxsIG5vdCBiZSB0cmlnZ2VyZWQgYXV0b21hdGljYWxseSB1cG9uIElEIHRva2VuIGV4cGlyYXRpb24uIFVzZSB7QGxpbmsgVXNlci5nZXRJZFRva2VufSB0byByZWZyZXNoIHRoZSBJRCB0b2tlbi5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gbmV4dE9yT2JzZXJ2ZXIgLSBjYWxsYmFjayB0cmlnZ2VyZWQgb24gY2hhbmdlLlxyXG4gKiBAcGFyYW0gZXJyb3IgLSBEZXByZWNhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5ldmVyIHRyaWdnZXJlZC4gRXJyb3JzXHJcbiAqIG9uIHNpZ25pbmcgaW4vb3V0IGNhbiBiZSBjYXVnaHQgaW4gcHJvbWlzZXMgcmV0dXJuZWQgZnJvbVxyXG4gKiBzaWduLWluL3NpZ24tb3V0IGZ1bmN0aW9ucy5cclxuICogQHBhcmFtIGNvbXBsZXRlZCAtIERlcHJlY2F0ZWQuIFRoaXMgY2FsbGJhY2sgaXMgbmV2ZXIgdHJpZ2dlcmVkLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBvbklkVG9rZW5DaGFuZ2VkKGF1dGgsIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XHJcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLm9uSWRUb2tlbkNoYW5nZWQobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGRzIGEgYmxvY2tpbmcgY2FsbGJhY2sgdGhhdCBydW5zIGJlZm9yZSBhbiBhdXRoIHN0YXRlIGNoYW5nZVxyXG4gKiBzZXRzIGEgbmV3IHVzZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIGNhbGxiYWNrIC0gY2FsbGJhY2sgdHJpZ2dlcmVkIGJlZm9yZSBuZXcgdXNlciB2YWx1ZSBpcyBzZXQuXHJcbiAqICAgSWYgdGhpcyB0aHJvd3MsIGl0IGJsb2NrcyB0aGUgdXNlciBmcm9tIGJlaW5nIHNldC5cclxuICogQHBhcmFtIG9uQWJvcnQgLSBjYWxsYmFjayB0cmlnZ2VyZWQgaWYgYSBsYXRlciBgYmVmb3JlQXV0aFN0YXRlQ2hhbmdlZCgpYFxyXG4gKiAgIGNhbGxiYWNrIHRocm93cywgYWxsb3dpbmcgeW91IHRvIHVuZG8gYW55IHNpZGUgZWZmZWN0cy5cclxuICovXHJcbmZ1bmN0aW9uIGJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQoYXV0aCwgY2FsbGJhY2ssIG9uQWJvcnQpIHtcclxuICAgIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkuYmVmb3JlQXV0aFN0YXRlQ2hhbmdlZChjYWxsYmFjaywgb25BYm9ydCk7XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgYW4gb2JzZXJ2ZXIgZm9yIGNoYW5nZXMgdG8gdGhlIHVzZXIncyBzaWduLWluIHN0YXRlLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUbyBrZWVwIHRoZSBvbGQgYmVoYXZpb3IsIHNlZSB7QGxpbmsgb25JZFRva2VuQ2hhbmdlZH0uXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIG5leHRPck9ic2VydmVyIC0gY2FsbGJhY2sgdHJpZ2dlcmVkIG9uIGNoYW5nZS5cclxuICogQHBhcmFtIGVycm9yIC0gRGVwcmVjYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBuZXZlciB0cmlnZ2VyZWQuIEVycm9yc1xyXG4gKiBvbiBzaWduaW5nIGluL291dCBjYW4gYmUgY2F1Z2h0IGluIHByb21pc2VzIHJldHVybmVkIGZyb21cclxuICogc2lnbi1pbi9zaWduLW91dCBmdW5jdGlvbnMuXHJcbiAqIEBwYXJhbSBjb21wbGV0ZWQgLSBEZXByZWNhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5ldmVyIHRyaWdnZXJlZC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gb25BdXRoU3RhdGVDaGFuZ2VkKGF1dGgsIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XHJcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLm9uQXV0aFN0YXRlQ2hhbmdlZChuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCk7XHJcbn1cclxuLyoqXHJcbiAqIFNldHMgdGhlIGN1cnJlbnQgbGFuZ3VhZ2UgdG8gdGhlIGRlZmF1bHQgZGV2aWNlL2Jyb3dzZXIgcHJlZmVyZW5jZS5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VEZXZpY2VMYW5ndWFnZShhdXRoKSB7XHJcbiAgICBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkudXNlRGV2aWNlTGFuZ3VhZ2UoKTtcclxufVxyXG4vKipcclxuICogQXN5bmNocm9ub3VzbHkgc2V0cyB0aGUgcHJvdmlkZWQgdXNlciBhcyB7QGxpbmsgQXV0aC5jdXJyZW50VXNlcn0gb24gdGhlXHJcbiAqIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICpcclxuICogQHJlbWFya3NcclxuICogQSBuZXcgaW5zdGFuY2UgY29weSBvZiB0aGUgdXNlciBwcm92aWRlZCB3aWxsIGJlIG1hZGUgYW5kIHNldCBhcyBjdXJyZW50VXNlci5cclxuICpcclxuICogVGhpcyB3aWxsIHRyaWdnZXIge0BsaW5rIG9uQXV0aFN0YXRlQ2hhbmdlZH0gYW5kIHtAbGluayBvbklkVG9rZW5DaGFuZ2VkfSBsaXN0ZW5lcnNcclxuICogbGlrZSBvdGhlciBzaWduIGluIG1ldGhvZHMuXHJcbiAqXHJcbiAqIFRoZSBvcGVyYXRpb24gZmFpbHMgd2l0aCBhbiBlcnJvciBpZiB0aGUgdXNlciB0byBiZSB1cGRhdGVkIGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnQgRmlyZWJhc2VcclxuICogcHJvamVjdC5cclxuICpcclxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXHJcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gdXNlciAtIFRoZSBuZXcge0BsaW5rIFVzZXJ9LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVDdXJyZW50VXNlcihhdXRoLCB1c2VyKSB7XHJcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLnVwZGF0ZUN1cnJlbnRVc2VyKHVzZXIpO1xyXG59XHJcbi8qKlxyXG4gKiBTaWducyBvdXQgdGhlIGN1cnJlbnQgdXNlci5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXHJcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cclxuICpcclxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBzaWduT3V0KGF1dGgpIHtcclxuICAgIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkuc2lnbk91dCgpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXZva2VzIHRoZSBnaXZlbiBhY2Nlc3MgdG9rZW4uIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIEFwcGxlIE9BdXRoIGFjY2VzcyB0b2tlbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHRva2VuIC0gVGhlIEFwcGxlIE9BdXRoIGFjY2VzcyB0b2tlbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gcmV2b2tlQWNjZXNzVG9rZW4oYXV0aCwgdG9rZW4pIHtcclxuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcclxuICAgIHJldHVybiBhdXRoSW50ZXJuYWwucmV2b2tlQWNjZXNzVG9rZW4odG9rZW4pO1xyXG59XHJcbi8qKlxyXG4gKiBEZWxldGVzIGFuZCBzaWducyBvdXQgdGhlIHVzZXIuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIEltcG9ydGFudDogdGhpcyBpcyBhIHNlY3VyaXR5LXNlbnNpdGl2ZSBvcGVyYXRpb24gdGhhdCByZXF1aXJlcyB0aGUgdXNlciB0byBoYXZlIHJlY2VudGx5XHJcbiAqIHNpZ25lZCBpbi4gSWYgdGhpcyByZXF1aXJlbWVudCBpc24ndCBtZXQsIGFzayB0aGUgdXNlciB0byBhdXRoZW50aWNhdGUgYWdhaW4gYW5kIHRoZW4gY2FsbFxyXG4gKiB7QGxpbmsgcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbH0uXHJcbiAqXHJcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVVzZXIodXNlcikge1xyXG4gICAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKS5kZWxldGUoKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBNdWx0aUZhY3RvclNlc3Npb25JbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGNyZWRlbnRpYWwsIHVzZXIpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuY3JlZGVudGlhbCA9IGNyZWRlbnRpYWw7XHJcbiAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfZnJvbUlkdG9rZW4oaWRUb2tlbiwgdXNlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlGYWN0b3JTZXNzaW9uSW1wbChcImVucm9sbFwiIC8qIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuRU5ST0xMICovLCBpZFRva2VuLCB1c2VyKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfZnJvbU1mYVBlbmRpbmdDcmVkZW50aWFsKG1mYVBlbmRpbmdDcmVkZW50aWFsKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNdWx0aUZhY3RvclNlc3Npb25JbXBsKFwic2lnbmluXCIgLyogTXVsdGlGYWN0b3JTZXNzaW9uVHlwZS5TSUdOX0lOICovLCBtZmFQZW5kaW5nQ3JlZGVudGlhbCk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy50eXBlID09PSBcImVucm9sbFwiIC8qIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuRU5ST0xMICovXHJcbiAgICAgICAgICAgID8gJ2lkVG9rZW4nXHJcbiAgICAgICAgICAgIDogJ3BlbmRpbmdDcmVkZW50aWFsJztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtdWx0aUZhY3RvclNlc3Npb246IHtcclxuICAgICAgICAgICAgICAgIFtrZXldOiB0aGlzLmNyZWRlbnRpYWxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUpTT04ob2JqKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLm11bHRpRmFjdG9yU2Vzc2lvbikge1xyXG4gICAgICAgICAgICBpZiAoKF9hID0gb2JqLm11bHRpRmFjdG9yU2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBlbmRpbmdDcmVkZW50aWFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTXVsdGlGYWN0b3JTZXNzaW9uSW1wbC5fZnJvbU1mYVBlbmRpbmdDcmVkZW50aWFsKG9iai5tdWx0aUZhY3RvclNlc3Npb24ucGVuZGluZ0NyZWRlbnRpYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChfYiA9IG9iai5tdWx0aUZhY3RvclNlc3Npb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pZFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTXVsdGlGYWN0b3JTZXNzaW9uSW1wbC5fZnJvbUlkdG9rZW4ob2JqLm11bHRpRmFjdG9yU2Vzc2lvbi5pZFRva2VuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBNdWx0aUZhY3RvclJlc29sdmVySW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXNzaW9uLCBoaW50cywgc2lnbkluUmVzb2x2ZXIpIHtcclxuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xyXG4gICAgICAgIHRoaXMuaGludHMgPSBoaW50cztcclxuICAgICAgICB0aGlzLnNpZ25JblJlc29sdmVyID0gc2lnbkluUmVzb2x2ZXI7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgX2Zyb21FcnJvcihhdXRoRXh0ZXJuLCBlcnJvcikge1xyXG4gICAgICAgIGNvbnN0IGF1dGggPSBfY2FzdEF1dGgoYXV0aEV4dGVybik7XHJcbiAgICAgICAgY29uc3Qgc2VydmVyUmVzcG9uc2UgPSBlcnJvci5jdXN0b21EYXRhLl9zZXJ2ZXJSZXNwb25zZTtcclxuICAgICAgICBjb25zdCBoaW50cyA9IChzZXJ2ZXJSZXNwb25zZS5tZmFJbmZvIHx8IFtdKS5tYXAoZW5yb2xsbWVudCA9PiBNdWx0aUZhY3RvckluZm9JbXBsLl9mcm9tU2VydmVyUmVzcG9uc2UoYXV0aCwgZW5yb2xsbWVudCkpO1xyXG4gICAgICAgIF9hc3NlcnQoc2VydmVyUmVzcG9uc2UubWZhUGVuZGluZ0NyZWRlbnRpYWwsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICBjb25zdCBzZXNzaW9uID0gTXVsdGlGYWN0b3JTZXNzaW9uSW1wbC5fZnJvbU1mYVBlbmRpbmdDcmVkZW50aWFsKHNlcnZlclJlc3BvbnNlLm1mYVBlbmRpbmdDcmVkZW50aWFsKTtcclxuICAgICAgICByZXR1cm4gbmV3IE11bHRpRmFjdG9yUmVzb2x2ZXJJbXBsKHNlc3Npb24sIGhpbnRzLCBhc3luYyAoYXNzZXJ0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1mYVJlc3BvbnNlID0gYXdhaXQgYXNzZXJ0aW9uLl9wcm9jZXNzKGF1dGgsIHNlc3Npb24pO1xyXG4gICAgICAgICAgICAvLyBDbGVhciBvdXQgdGhlIHVubmVlZGVkIGZpZWxkcyBmcm9tIHRoZSBvbGQgbG9naW4gcmVzcG9uc2VcclxuICAgICAgICAgICAgZGVsZXRlIHNlcnZlclJlc3BvbnNlLm1mYUluZm87XHJcbiAgICAgICAgICAgIGRlbGV0ZSBzZXJ2ZXJSZXNwb25zZS5tZmFQZW5kaW5nQ3JlZGVudGlhbDtcclxuICAgICAgICAgICAgLy8gVXNlIGluIHRoZSBuZXcgdG9rZW4gJiByZWZyZXNoIHRva2VuIGluIHRoZSBvbGQgcmVzcG9uc2VcclxuICAgICAgICAgICAgY29uc3QgaWRUb2tlblJlc3BvbnNlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZXJ2ZXJSZXNwb25zZSksIHsgaWRUb2tlbjogbWZhUmVzcG9uc2UuaWRUb2tlbiwgcmVmcmVzaFRva2VuOiBtZmFSZXNwb25zZS5yZWZyZXNoVG9rZW4gfSk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHdlIHNob3VsZCBjb2xsYXBzZSB0aGlzIHN3aXRjaCBzdGF0ZW1lbnQgaW50byBVc2VyQ3JlZGVudGlhbEltcGwuX2Zvck9wZXJhdGlvbiBhbmQgaGF2ZSBpdCBzdXBwb3J0IHRoZSBTSUdOX0lOIGNhc2VcclxuICAgICAgICAgICAgc3dpdGNoIChlcnJvci5vcGVyYXRpb25UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwic2lnbkluXCIgLyogT3BlcmF0aW9uVHlwZS5TSUdOX0lOICovOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgVXNlckNyZWRlbnRpYWxJbXBsLl9mcm9tSWRUb2tlblJlc3BvbnNlKGF1dGgsIGVycm9yLm9wZXJhdGlvblR5cGUsIGlkVG9rZW5SZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgYXV0aC5fdXBkYXRlQ3VycmVudFVzZXIodXNlckNyZWRlbnRpYWwudXNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJDcmVkZW50aWFsO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInJlYXV0aGVudGljYXRlXCIgLyogT3BlcmF0aW9uVHlwZS5SRUFVVEhFTlRJQ0FURSAqLzpcclxuICAgICAgICAgICAgICAgICAgICBfYXNzZXJ0KGVycm9yLnVzZXIsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXNlckNyZWRlbnRpYWxJbXBsLl9mb3JPcGVyYXRpb24oZXJyb3IudXNlciwgZXJyb3Iub3BlcmF0aW9uVHlwZSwgaWRUb2tlblJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgX2ZhaWwoYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyByZXNvbHZlU2lnbkluKGFzc2VydGlvbkV4dGVybikge1xyXG4gICAgICAgIGNvbnN0IGFzc2VydGlvbiA9IGFzc2VydGlvbkV4dGVybjtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaWduSW5SZXNvbHZlcihhc3NlcnRpb24pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBQcm92aWRlcyBhIHtAbGluayBNdWx0aUZhY3RvclJlc29sdmVyfSBzdWl0YWJsZSBmb3IgY29tcGxldGlvbiBvZiBhXHJcbiAqIG11bHRpLWZhY3RvciBmbG93LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSB7QGxpbmsgTXVsdGlGYWN0b3JFcnJvcn0gcmFpc2VkIGR1cmluZyBhIHNpZ24taW4sIG9yXHJcbiAqIHJlYXV0aGVudGljYXRpb24gb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNdWx0aUZhY3RvclJlc29sdmVyKGF1dGgsIGVycm9yKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBhdXRoTW9kdWxhciA9IGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKTtcclxuICAgIGNvbnN0IGVycm9ySW50ZXJuYWwgPSBlcnJvcjtcclxuICAgIF9hc3NlcnQoZXJyb3IuY3VzdG9tRGF0YS5vcGVyYXRpb25UeXBlLCBhdXRoTW9kdWxhciwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xyXG4gICAgX2Fzc2VydCgoX2EgPSBlcnJvckludGVybmFsLmN1c3RvbURhdGEuX3NlcnZlclJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWZhUGVuZGluZ0NyZWRlbnRpYWwsIGF1dGhNb2R1bGFyLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XHJcbiAgICByZXR1cm4gTXVsdGlGYWN0b3JSZXNvbHZlckltcGwuX2Zyb21FcnJvcihhdXRoTW9kdWxhciwgZXJyb3JJbnRlcm5hbCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3RhcnRFbnJvbGxUb3RwTWZhKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92Mi9hY2NvdW50cy9tZmFFbnJvbGxtZW50OnN0YXJ0XCIgLyogRW5kcG9pbnQuU1RBUlRfTUZBX0VOUk9MTE1FTlQgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cclxuZnVuY3Rpb24gZmluYWxpemVFbnJvbGxUb3RwTWZhKGF1dGgsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92Mi9hY2NvdW50cy9tZmFFbnJvbGxtZW50OmZpbmFsaXplXCIgLyogRW5kcG9pbnQuRklOQUxJWkVfTUZBX0VOUk9MTE1FTlQgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cclxuZnVuY3Rpb24gd2l0aGRyYXdNZmEoYXV0aCwgcmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YyL2FjY291bnRzL21mYUVucm9sbG1lbnQ6d2l0aGRyYXdcIiAvKiBFbmRwb2ludC5XSVRIRFJBV19NRkEgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cblxuY2xhc3MgTXVsdGlGYWN0b3JVc2VySW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih1c2VyKSB7XHJcbiAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcclxuICAgICAgICB0aGlzLmVucm9sbGVkRmFjdG9ycyA9IFtdO1xyXG4gICAgICAgIHVzZXIuX29uUmVsb2FkKHVzZXJJbmZvID0+IHtcclxuICAgICAgICAgICAgaWYgKHVzZXJJbmZvLm1mYUluZm8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5yb2xsZWRGYWN0b3JzID0gdXNlckluZm8ubWZhSW5mby5tYXAoZW5yb2xsbWVudCA9PiBNdWx0aUZhY3RvckluZm9JbXBsLl9mcm9tU2VydmVyUmVzcG9uc2UodXNlci5hdXRoLCBlbnJvbGxtZW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfZnJvbVVzZXIodXNlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlGYWN0b3JVc2VySW1wbCh1c2VyKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldFNlc3Npb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIE11bHRpRmFjdG9yU2Vzc2lvbkltcGwuX2Zyb21JZHRva2VuKGF3YWl0IHRoaXMudXNlci5nZXRJZFRva2VuKCksIHRoaXMudXNlcik7XHJcbiAgICB9XHJcbiAgICBhc3luYyBlbnJvbGwoYXNzZXJ0aW9uRXh0ZXJuLCBkaXNwbGF5TmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGFzc2VydGlvbiA9IGFzc2VydGlvbkV4dGVybjtcclxuICAgICAgICBjb25zdCBzZXNzaW9uID0gKGF3YWl0IHRoaXMuZ2V0U2Vzc2lvbigpKTtcclxuICAgICAgICBjb25zdCBmaW5hbGl6ZU1mYVJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodGhpcy51c2VyLCBhc3NlcnRpb24uX3Byb2Nlc3ModGhpcy51c2VyLmF1dGgsIHNlc3Npb24sIGRpc3BsYXlOYW1lKSk7XHJcbiAgICAgICAgLy8gTmV3IHRva2VucyB3aWxsIGJlIGlzc3VlZCBhZnRlciBlbnJvbGxtZW50IG9mIHRoZSBuZXcgc2Vjb25kIGZhY3RvcnMuXHJcbiAgICAgICAgLy8gVGhleSBuZWVkIHRvIGJlIHVwZGF0ZWQgb24gdGhlIHVzZXIuXHJcbiAgICAgICAgYXdhaXQgdGhpcy51c2VyLl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShmaW5hbGl6ZU1mYVJlc3BvbnNlKTtcclxuICAgICAgICAvLyBUaGUgdXNlciBuZWVkcyB0byBiZSByZWxvYWRlZCB0byBnZXQgdGhlIG5ldyBtdWx0aS1mYWN0b3IgaW5mb3JtYXRpb25cclxuICAgICAgICAvLyBmcm9tIHNlcnZlci4gVVNFUl9SRUxPQURFRCBldmVudCB3aWxsIGJlIHRyaWdnZXJlZCBhbmQgYGVucm9sbGVkRmFjdG9yc2BcclxuICAgICAgICAvLyB3aWxsIGJlIHVwZGF0ZWQuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXNlci5yZWxvYWQoKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHVuZW5yb2xsKGluZm9PclVpZCkge1xyXG4gICAgICAgIGNvbnN0IG1mYUVucm9sbG1lbnRJZCA9IHR5cGVvZiBpbmZvT3JVaWQgPT09ICdzdHJpbmcnID8gaW5mb09yVWlkIDogaW5mb09yVWlkLnVpZDtcclxuICAgICAgICBjb25zdCBpZFRva2VuID0gYXdhaXQgdGhpcy51c2VyLmdldElkVG9rZW4oKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBpZFRva2VuUmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh0aGlzLnVzZXIsIHdpdGhkcmF3TWZhKHRoaXMudXNlci5hdXRoLCB7XHJcbiAgICAgICAgICAgICAgICBpZFRva2VuLFxyXG4gICAgICAgICAgICAgICAgbWZhRW5yb2xsbWVudElkXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZWNvbmQgZmFjdG9yIGZyb20gdGhlIHVzZXIncyBsaXN0LlxyXG4gICAgICAgICAgICB0aGlzLmVucm9sbGVkRmFjdG9ycyA9IHRoaXMuZW5yb2xsZWRGYWN0b3JzLmZpbHRlcigoeyB1aWQgfSkgPT4gdWlkICE9PSBtZmFFbnJvbGxtZW50SWQpO1xyXG4gICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gd2hldGhlciB0aGUgYmFja2VuZCBkZWNpZGVkIHRvIHJldm9rZSB0aGUgdXNlcidzIHNlc3Npb24sXHJcbiAgICAgICAgICAgIC8vIHRoZSB0b2tlblJlc3BvbnNlIG1heSBiZSBlbXB0eS4gSWYgdGhlIHRva2VucyB3ZXJlIG5vdCB1cGRhdGVkIChhbmQgdGhleVxyXG4gICAgICAgICAgICAvLyBhcmUgbm93IGludmFsaWQpLCByZWxvYWRpbmcgdGhlIHVzZXIgd2lsbCBkaXNjb3ZlciB0aGlzIGFuZCBpbnZhbGlkYXRlXHJcbiAgICAgICAgICAgIC8vIHRoZSB1c2VyJ3Mgc3RhdGUgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudXNlci5fdXBkYXRlVG9rZW5zSWZOZWNlc3NhcnkoaWRUb2tlblJlc3BvbnNlKTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy51c2VyLnJlbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBtdWx0aUZhY3RvclVzZXJDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XHJcbi8qKlxyXG4gKiBUaGUge0BsaW5rIE11bHRpRmFjdG9yVXNlcn0gY29ycmVzcG9uZGluZyB0byB0aGUgdXNlci5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhpcyBpcyB1c2VkIHRvIGFjY2VzcyBhbGwgbXVsdGktZmFjdG9yIHByb3BlcnRpZXMgYW5kIG9wZXJhdGlvbnMgcmVsYXRlZCB0byB0aGUgdXNlci5cclxuICpcclxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gbXVsdGlGYWN0b3IodXNlcikge1xyXG4gICAgY29uc3QgdXNlck1vZHVsYXIgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XHJcbiAgICBpZiAoIW11bHRpRmFjdG9yVXNlckNhY2hlLmhhcyh1c2VyTW9kdWxhcikpIHtcclxuICAgICAgICBtdWx0aUZhY3RvclVzZXJDYWNoZS5zZXQodXNlck1vZHVsYXIsIE11bHRpRmFjdG9yVXNlckltcGwuX2Zyb21Vc2VyKHVzZXJNb2R1bGFyKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbXVsdGlGYWN0b3JVc2VyQ2FjaGUuZ2V0KHVzZXJNb2R1bGFyKTtcclxufVxuXG52YXIgbmFtZSA9IFwiQGZpcmViYXNlL2F1dGhcIjtcbnZhciB2ZXJzaW9uID0gXCIxLjcuM1wiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBBdXRoSW50ZXJvcCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhdXRoKSB7XHJcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcclxuICAgICAgICB0aGlzLmludGVybmFsTGlzdGVuZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0VWlkKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLmFzc2VydEF1dGhDb25maWd1cmVkKCk7XHJcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLmF1dGguY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51aWQpIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRUb2tlbihmb3JjZVJlZnJlc2gpIHtcclxuICAgICAgICB0aGlzLmFzc2VydEF1dGhDb25maWd1cmVkKCk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5hdXRoLl9pbml0aWFsaXphdGlvblByb21pc2U7XHJcbiAgICAgICAgaWYgKCF0aGlzLmF1dGguY3VycmVudFVzZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gYXdhaXQgdGhpcy5hdXRoLmN1cnJlbnRVc2VyLmdldElkVG9rZW4oZm9yY2VSZWZyZXNoKTtcclxuICAgICAgICByZXR1cm4geyBhY2Nlc3NUb2tlbiB9O1xyXG4gICAgfVxyXG4gICAgYWRkQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLmFzc2VydEF1dGhDb25maWd1cmVkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxMaXN0ZW5lcnMuaGFzKGxpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5hdXRoLm9uSWRUb2tlbkNoYW5nZWQodXNlciA9PiB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyKCh1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIuc3RzVG9rZW5NYW5hZ2VyLmFjY2Vzc1Rva2VuKSB8fCBudWxsKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmludGVybmFsTGlzdGVuZXJzLnNldChsaXN0ZW5lciwgdW5zdWJzY3JpYmUpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlUHJvYWN0aXZlUmVmcmVzaCgpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLmFzc2VydEF1dGhDb25maWd1cmVkKCk7XHJcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLmludGVybmFsTGlzdGVuZXJzLmdldChsaXN0ZW5lcik7XHJcbiAgICAgICAgaWYgKCF1bnN1YnNjcmliZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcclxuICAgICAgICB1bnN1YnNjcmliZSgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlUHJvYWN0aXZlUmVmcmVzaCgpO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0QXV0aENvbmZpZ3VyZWQoKSB7XHJcbiAgICAgICAgX2Fzc2VydCh0aGlzLmF1dGguX2luaXRpYWxpemF0aW9uUHJvbWlzZSwgXCJkZXBlbmRlbnQtc2RrLWluaXRpYWxpemVkLWJlZm9yZS1hdXRoXCIgLyogQXV0aEVycm9yQ29kZS5ERVBFTkRFTlRfU0RLX0lOSVRfQkVGT1JFX0FVVEggKi8pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUHJvYWN0aXZlUmVmcmVzaCgpIHtcclxuICAgICAgICBpZiAodGhpcy5pbnRlcm5hbExpc3RlbmVycy5zaXplID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmF1dGguX3N0YXJ0UHJvYWN0aXZlUmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5hdXRoLl9zdG9wUHJvYWN0aXZlUmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRWZXJzaW9uRm9yUGxhdGZvcm0oY2xpZW50UGxhdGZvcm0pIHtcclxuICAgIHN3aXRjaCAoY2xpZW50UGxhdGZvcm0pIHtcclxuICAgICAgICBjYXNlIFwiTm9kZVwiIC8qIENsaWVudFBsYXRmb3JtLk5PREUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAnbm9kZSc7XHJcbiAgICAgICAgY2FzZSBcIlJlYWN0TmF0aXZlXCIgLyogQ2xpZW50UGxhdGZvcm0uUkVBQ1RfTkFUSVZFICovOlxyXG4gICAgICAgICAgICByZXR1cm4gJ3JuJztcclxuICAgICAgICBjYXNlIFwiV29ya2VyXCIgLyogQ2xpZW50UGxhdGZvcm0uV09SS0VSICovOlxyXG4gICAgICAgICAgICByZXR1cm4gJ3dlYndvcmtlcic7XHJcbiAgICAgICAgY2FzZSBcIkNvcmRvdmFcIiAvKiBDbGllbnRQbGF0Zm9ybS5DT1JET1ZBICovOlxyXG4gICAgICAgICAgICByZXR1cm4gJ2NvcmRvdmEnO1xyXG4gICAgICAgIGNhc2UgXCJXZWJFeHRlbnNpb25cIiAvKiBDbGllbnRQbGF0Zm9ybS5XRUJfRVhURU5TSU9OICovOlxyXG4gICAgICAgICAgICByZXR1cm4gJ3dlYi1leHRlbnNpb24nO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5mdW5jdGlvbiByZWdpc3RlckF1dGgoY2xpZW50UGxhdGZvcm0pIHtcclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KFwiYXV0aFwiIC8qIF9Db21wb25lbnROYW1lLkFVVEggKi8sIChjb250YWluZXIsIHsgb3B0aW9uczogZGVwcyB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgYXBwID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICBjb25zdCBoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2hlYXJ0YmVhdCcpO1xyXG4gICAgICAgIGNvbnN0IGFwcENoZWNrU2VydmljZVByb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAtY2hlY2staW50ZXJuYWwnKTtcclxuICAgICAgICBjb25zdCB7IGFwaUtleSwgYXV0aERvbWFpbiB9ID0gYXBwLm9wdGlvbnM7XHJcbiAgICAgICAgX2Fzc2VydChhcGlLZXkgJiYgIWFwaUtleS5pbmNsdWRlcygnOicpLCBcImludmFsaWQtYXBpLWtleVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BUElfS0VZICovLCB7IGFwcE5hbWU6IGFwcC5uYW1lIH0pO1xyXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcclxuICAgICAgICAgICAgYXBpS2V5LFxyXG4gICAgICAgICAgICBhdXRoRG9tYWluLFxyXG4gICAgICAgICAgICBjbGllbnRQbGF0Zm9ybSxcclxuICAgICAgICAgICAgYXBpSG9zdDogXCJpZGVudGl0eXRvb2xraXQuZ29vZ2xlYXBpcy5jb21cIiAvKiBEZWZhdWx0Q29uZmlnLkFQSV9IT1NUICovLFxyXG4gICAgICAgICAgICB0b2tlbkFwaUhvc3Q6IFwic2VjdXJldG9rZW4uZ29vZ2xlYXBpcy5jb21cIiAvKiBEZWZhdWx0Q29uZmlnLlRPS0VOX0FQSV9IT1NUICovLFxyXG4gICAgICAgICAgICBhcGlTY2hlbWU6IFwiaHR0cHNcIiAvKiBEZWZhdWx0Q29uZmlnLkFQSV9TQ0hFTUUgKi8sXHJcbiAgICAgICAgICAgIHNka0NsaWVudFZlcnNpb246IF9nZXRDbGllbnRWZXJzaW9uKGNsaWVudFBsYXRmb3JtKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgYXV0aEluc3RhbmNlID0gbmV3IEF1dGhJbXBsKGFwcCwgaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyLCBhcHBDaGVja1NlcnZpY2VQcm92aWRlciwgY29uZmlnKTtcclxuICAgICAgICBfaW5pdGlhbGl6ZUF1dGhJbnN0YW5jZShhdXRoSW5zdGFuY2UsIGRlcHMpO1xyXG4gICAgICAgIHJldHVybiBhdXRoSW5zdGFuY2U7XHJcbiAgICB9LCBcIlBVQkxJQ1wiIC8qIENvbXBvbmVudFR5cGUuUFVCTElDICovKVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEF1dGggY2FuIG9ubHkgYmUgaW5pdGlhbGl6ZWQgYnkgZXhwbGljaXRseSBjYWxsaW5nIGdldEF1dGgoKSBvciBpbml0aWFsaXplQXV0aCgpXHJcbiAgICAgICAgICogRm9yIHdoeSB3ZSBkbyB0aGlzLCBTZWUgZ28vZmlyZWJhc2UtbmV4dC1hdXRoLWluaXRcclxuICAgICAgICAgKi9cclxuICAgICAgICAuc2V0SW5zdGFudGlhdGlvbk1vZGUoXCJFWFBMSUNJVFwiIC8qIEluc3RhbnRpYXRpb25Nb2RlLkVYUExJQ0lUICovKVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJlY2F1c2UgYWxsIGZpcmViYXNlIHByb2R1Y3RzIHRoYXQgZGVwZW5kIG9uIGF1dGggZGVwZW5kIG9uIGF1dGgtaW50ZXJuYWwgZGlyZWN0bHksXHJcbiAgICAgICAgICogd2UgbmVlZCB0byBpbml0aWFsaXplIGF1dGgtaW50ZXJuYWwgYWZ0ZXIgYXV0aCBpcyBpbml0aWFsaXplZCB0byBtYWtlIGl0IGF2YWlsYWJsZSB0byBvdGhlciBmaXJlYmFzZSBwcm9kdWN0cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICAuc2V0SW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2soKGNvbnRhaW5lciwgX2luc3RhbmNlSWRlbnRpZmllciwgX2luc3RhbmNlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgYXV0aEludGVybmFsUHJvdmlkZXIgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoXCJhdXRoLWludGVybmFsXCIgLyogX0NvbXBvbmVudE5hbWUuQVVUSF9JTlRFUk5BTCAqLyk7XHJcbiAgICAgICAgYXV0aEludGVybmFsUHJvdmlkZXIuaW5pdGlhbGl6ZSgpO1xyXG4gICAgfSkpO1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoXCJhdXRoLWludGVybmFsXCIgLyogX0NvbXBvbmVudE5hbWUuQVVUSF9JTlRFUk5BTCAqLywgY29udGFpbmVyID0+IHtcclxuICAgICAgICBjb25zdCBhdXRoID0gX2Nhc3RBdXRoKGNvbnRhaW5lci5nZXRQcm92aWRlcihcImF1dGhcIiAvKiBfQ29tcG9uZW50TmFtZS5BVVRIICovKS5nZXRJbW1lZGlhdGUoKSk7XHJcbiAgICAgICAgcmV0dXJuIChhdXRoID0+IG5ldyBBdXRoSW50ZXJvcChhdXRoKSkoYXV0aCk7XHJcbiAgICB9LCBcIlBSSVZBVEVcIiAvKiBDb21wb25lbnRUeXBlLlBSSVZBVEUgKi8pLnNldEluc3RhbnRpYXRpb25Nb2RlKFwiRVhQTElDSVRcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FWFBMSUNJVCAqLykpO1xyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sIGdldFZlcnNpb25Gb3JQbGF0Zm9ybShjbGllbnRQbGF0Zm9ybSkpO1xyXG4gICAgLy8gQlVJTERfVEFSR0VUIHdpbGwgYmUgcmVwbGFjZWQgYnkgdmFsdWVzIGxpa2UgZXNtNSwgZXNtMjAxNywgY2pzNSwgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uLCAnZXNtMjAxNycpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIEluaXRpYWxpemUgdGhlIGZldGNoIHBvbHlmaWxsLCB0aGUgdHlwZXMgYXJlIHNsaWdodGx5IG9mZiBzbyBqdXN0IGNhc3QgYW5kIGhvcGUgZm9yIHRoZSBiZXN0XHJcbkZldGNoUHJvdmlkZXIuaW5pdGlhbGl6ZShmZXRjaCQxLCBIZWFkZXJzJDEsIFJlc3BvbnNlJDEpO1xyXG4vLyBGaXJzdCwgd2Ugc2V0IHVwIHRoZSB2YXJpb3VzIHBsYXRmb3JtLXNwZWNpZmljIGZlYXR1cmVzIGZvciBOb2RlIChyZWdpc3RlclxyXG4vLyB0aGUgdmVyc2lvbiBhbmQgZGVjbGFyZSB0aGUgTm9kZSBnZXRBdXRoIGZ1bmN0aW9uKVxyXG5mdW5jdGlvbiBnZXRBdXRoKGFwcCA9IGdldEFwcCgpKSB7XHJcbiAgICBjb25zdCBwcm92aWRlciA9IF9nZXRQcm92aWRlcihhcHAsICdhdXRoJyk7XHJcbiAgICBpZiAocHJvdmlkZXIuaXNJbml0aWFsaXplZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYXV0aCA9IGluaXRpYWxpemVBdXRoKGFwcCk7XHJcbiAgICBjb25zdCBhdXRoRW11bGF0b3JIb3N0ID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCgnYXV0aCcpO1xyXG4gICAgaWYgKGF1dGhFbXVsYXRvckhvc3QpIHtcclxuICAgICAgICBjb25uZWN0QXV0aEVtdWxhdG9yKGF1dGgsIGBodHRwOi8vJHthdXRoRW11bGF0b3JIb3N0fWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGF1dGg7XHJcbn1cclxucmVnaXN0ZXJBdXRoKFwiTm9kZVwiIC8qIENsaWVudFBsYXRmb3JtLk5PREUgKi8pO1xyXG4vLyBUaGUgcmVzdCBvZiB0aGlzIGZpbGUgY29udGFpbnMgbm8tb3BzIGFuZCBlcnJvcnMgZm9yIGJyb3dzZXItc3BlY2lmaWNcclxuLy8gbWV0aG9kcy4gV2Uga2VlcCB0aGUgYnJvd3NlciBhbmQgTm9kZSBlbnRyeSBwb2ludHMgdGhlIHNhbWUsIGJ1dCBmZWF0dXJlc1xyXG4vLyB0aGF0IG9ubHkgd29yayBpbiBicm93c2VycyBhcmUgc2V0IHRvIGVpdGhlciBkbyBub3RoaW5nIChzZXRQZXJzaXN0ZW5jZSkgb3JcclxuLy8gdG8gcmVqZWN0IHdpdGggYW4gYXV0aC9vcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50IGVycm9yLlxyXG4vLyBUaGUgYmVsb3cgZXhwb3J0cyBhcmUgcHVsbGVkIGludG8gdGhlIG1haW4gZW50cnkgcG9pbnQgYnkgYSByb2xsdXAgYWxpYXNcclxuLy8gcGx1Z2luIChvdmVyd3JpdGluZyB0aGUgZGVmYXVsdCBicm93c2VyIGltcG9ydHMpLlxyXG4vKiogYXV0aC9vcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50ICovXHJcbmNvbnN0IE5PVF9BVkFJTEFCTEVfRVJST1IgPSBfY3JlYXRlRXJyb3IoXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIgLyogQXV0aEVycm9yQ29kZS5PUEVSQVRJT05fTk9UX1NVUFBPUlRFRCAqLyk7XHJcbi8qKiBSZWplY3Qgd2l0aCBhdXRoL29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQgKi9cclxuYXN5bmMgZnVuY3Rpb24gZmFpbCgpIHtcclxuICAgIHRocm93IE5PVF9BVkFJTEFCTEVfRVJST1I7XHJcbn1cclxuLyoqXHJcbiAqIEEgY2xhc3Mgd2hpY2ggd2lsbCB0aHJvdyB3aXRoXHJcbiAqIGF1dGgvb3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudCBpZiBpbnN0YW50aWF0ZWRcclxuICovXHJcbmNsYXNzIEZhaWxDbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aHJvdyBOT1RfQVZBSUxBQkxFX0VSUk9SO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGJyb3dzZXJMb2NhbFBlcnNpc3RlbmNlID0gaW5NZW1vcnlQZXJzaXN0ZW5jZTtcclxuY29uc3QgYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSA9IGluTWVtb3J5UGVyc2lzdGVuY2U7XHJcbmNvbnN0IGluZGV4ZWREQkxvY2FsUGVyc2lzdGVuY2UgPSBpbk1lbW9yeVBlcnNpc3RlbmNlO1xyXG5jb25zdCBicm93c2VyUG9wdXBSZWRpcmVjdFJlc29sdmVyID0gTk9UX0FWQUlMQUJMRV9FUlJPUjtcclxuY29uc3QgUGhvbmVBdXRoUHJvdmlkZXIgPSBGYWlsQ2xhc3M7XHJcbmNvbnN0IHNpZ25JbldpdGhQaG9uZU51bWJlciA9IGZhaWw7XHJcbmNvbnN0IGxpbmtXaXRoUGhvbmVOdW1iZXIgPSBmYWlsO1xyXG5jb25zdCByZWF1dGhlbnRpY2F0ZVdpdGhQaG9uZU51bWJlciA9IGZhaWw7XHJcbmNvbnN0IHVwZGF0ZVBob25lTnVtYmVyID0gZmFpbDtcclxuY29uc3Qgc2lnbkluV2l0aFBvcHVwID0gZmFpbDtcclxuY29uc3QgbGlua1dpdGhQb3B1cCA9IGZhaWw7XHJcbmNvbnN0IHJlYXV0aGVudGljYXRlV2l0aFBvcHVwID0gZmFpbDtcclxuY29uc3Qgc2lnbkluV2l0aFJlZGlyZWN0ID0gZmFpbDtcclxuY29uc3QgbGlua1dpdGhSZWRpcmVjdCA9IGZhaWw7XHJcbmNvbnN0IHJlYXV0aGVudGljYXRlV2l0aFJlZGlyZWN0ID0gZmFpbDtcclxuY29uc3QgZ2V0UmVkaXJlY3RSZXN1bHQgPSBmYWlsO1xyXG5jb25zdCBSZWNhcHRjaGFWZXJpZmllciA9IEZhaWxDbGFzcztcclxuY2xhc3MgUGhvbmVNdWx0aUZhY3RvckdlbmVyYXRvciB7XHJcbiAgICBzdGF0aWMgYXNzZXJ0aW9uKCkge1xyXG4gICAgICAgIHRocm93IE5PVF9BVkFJTEFCTEVfRVJST1I7XHJcbiAgICB9XHJcbn1cclxuLy8gU2V0IHBlcnNpc3RlbmNlIHNob3VsZCBuby1vcCBpbnN0ZWFkIG9mIGZhaWwuIENoYW5naW5nIHRoZSBwcm90b3R5cGUgd2lsbFxyXG4vLyBtYWtlIHN1cmUgYm90aCBzZXRQZXJzaXN0ZW5jZShhdXRoLCBwZXJzaXN0ZW5jZSkgYW5kXHJcbi8vIGF1dGguc2V0UGVyc2lzdGVuY2UocGVyc2lzdGVuY2UpIGFyZSBjb3ZlcmVkLlxyXG5BdXRoSW1wbC5wcm90b3R5cGUuc2V0UGVyc2lzdGVuY2UgPSBhc3luYyAoKSA9PiB7IH07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGZpbmFsaXplU2lnbkluVG90cE1mYShhdXRoLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjIvYWNjb3VudHMvbWZhU2lnbkluOmZpbmFsaXplXCIgLyogRW5kcG9pbnQuRklOQUxJWkVfTUZBX1NJR05fSU4gKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XHJcbn1cblxuY2xhc3MgTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGZhY3RvcklkKSB7XHJcbiAgICAgICAgdGhpcy5mYWN0b3JJZCA9IGZhY3RvcklkO1xyXG4gICAgfVxyXG4gICAgX3Byb2Nlc3MoYXV0aCwgc2Vzc2lvbiwgZGlzcGxheU5hbWUpIHtcclxuICAgICAgICBzd2l0Y2ggKHNlc3Npb24udHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiZW5yb2xsXCIgLyogTXVsdGlGYWN0b3JTZXNzaW9uVHlwZS5FTlJPTEwgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVFbnJvbGwoYXV0aCwgc2Vzc2lvbi5jcmVkZW50aWFsLCBkaXNwbGF5TmFtZSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzaWduaW5cIiAvKiBNdWx0aUZhY3RvclNlc3Npb25UeXBlLlNJR05fSU4gKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVTaWduSW4oYXV0aCwgc2Vzc2lvbi5jcmVkZW50aWFsKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ3VuZXhwZWN0ZWQgTXVsdGlGYWN0b3JTZXNzaW9uVHlwZScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgYSB7QGxpbmsgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9ufS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgVG90cE11bHRpRmFjdG9yR2VuZXJhdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMgYSB7QGxpbmsgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9ufSB0byBjb25maXJtIG93bmVyc2hpcCBvZlxyXG4gICAgICogdGhlIFRPVFAgKHRpbWUtYmFzZWQgb25lLXRpbWUgcGFzc3dvcmQpIHNlY29uZCBmYWN0b3IuXHJcbiAgICAgKiBUaGlzIGFzc2VydGlvbiBpcyB1c2VkIHRvIGNvbXBsZXRlIGVucm9sbG1lbnQgaW4gVE9UUCBzZWNvbmQgZmFjdG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzZWNyZXQgQSB7QGxpbmsgVG90cFNlY3JldH0gY29udGFpbmluZyB0aGUgc2hhcmVkIHNlY3JldCBrZXkgYW5kIG90aGVyIFRPVFAgcGFyYW1ldGVycy5cclxuICAgICAqIEBwYXJhbSBvbmVUaW1lUGFzc3dvcmQgT25lLXRpbWUgcGFzc3dvcmQgZnJvbSBUT1RQIEFwcC5cclxuICAgICAqIEByZXR1cm5zIEEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0gd2hpY2ggY2FuIGJlIHVzZWQgd2l0aFxyXG4gICAgICoge0BsaW5rIE11bHRpRmFjdG9yVXNlci5lbnJvbGx9LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXNzZXJ0aW9uRm9yRW5yb2xsbWVudChzZWNyZXQsIG9uZVRpbWVQYXNzd29yZCkge1xyXG4gICAgICAgIHJldHVybiBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsLl9mcm9tU2VjcmV0KHNlY3JldCwgb25lVGltZVBhc3N3b3JkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMgYSB7QGxpbmsgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9ufSB0byBjb25maXJtIG93bmVyc2hpcCBvZiB0aGUgVE9UUCBzZWNvbmQgZmFjdG9yLlxyXG4gICAgICogVGhpcyBhc3NlcnRpb24gaXMgdXNlZCB0byBjb21wbGV0ZSBzaWduSW4gd2l0aCBUT1RQIGFzIHRoZSBzZWNvbmQgZmFjdG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbnJvbGxtZW50SWQgaWRlbnRpZmllcyB0aGUgZW5yb2xsZWQgVE9UUCBzZWNvbmQgZmFjdG9yLlxyXG4gICAgICogQHBhcmFtIG9uZVRpbWVQYXNzd29yZCBPbmUtdGltZSBwYXNzd29yZCBmcm9tIFRPVFAgQXBwLlxyXG4gICAgICogQHJldHVybnMgQSB7QGxpbmsgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9ufSB3aGljaCBjYW4gYmUgdXNlZCB3aXRoXHJcbiAgICAgKiB7QGxpbmsgTXVsdGlGYWN0b3JSZXNvbHZlci5yZXNvbHZlU2lnbklufS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFzc2VydGlvbkZvclNpZ25JbihlbnJvbGxtZW50SWQsIG9uZVRpbWVQYXNzd29yZCkge1xyXG4gICAgICAgIHJldHVybiBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsLl9mcm9tRW5yb2xsbWVudElkKGVucm9sbG1lbnRJZCwgb25lVGltZVBhc3N3b3JkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdG8ge0BsaW5rIFRvdHBTZWNyZXR9IHdoaWNoIGNvbnRhaW5zIHRoZSBUT1RQIHNoYXJlZCBzZWNyZXQga2V5IGFuZCBvdGhlciBwYXJhbWV0ZXJzLlxyXG4gICAgICogQ3JlYXRlcyBhIFRPVFAgc2VjcmV0IGFzIHBhcnQgb2YgZW5yb2xsaW5nIGEgVE9UUCBzZWNvbmQgZmFjdG9yLlxyXG4gICAgICogVXNlZCBmb3IgZ2VuZXJhdGluZyBhIFFSIGNvZGUgVVJMIG9yIGlucHV0dGluZyBpbnRvIGEgVE9UUCBhcHAuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBhdXRoIGluc3RhbmNlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHVzZXIgaW4gdGhlIG11bHRpRmFjdG9yU2Vzc2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2Vzc2lvbiBUaGUge0BsaW5rIE11bHRpRmFjdG9yU2Vzc2lvbn0gdGhhdCB0aGUgdXNlciBpcyBwYXJ0IG9mLlxyXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRvIHtAbGluayBUb3RwU2VjcmV0fS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlU2VjcmV0KHNlc3Npb24pIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgbWZhU2Vzc2lvbiA9IHNlc3Npb247XHJcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgKChfYSA9IG1mYVNlc3Npb24udXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dGgpICE9PSAndW5kZWZpbmVkJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc3RhcnRFbnJvbGxUb3RwTWZhKG1mYVNlc3Npb24udXNlci5hdXRoLCB7XHJcbiAgICAgICAgICAgIGlkVG9rZW46IG1mYVNlc3Npb24uY3JlZGVudGlhbCxcclxuICAgICAgICAgICAgdG90cEVucm9sbG1lbnRJbmZvOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBUb3RwU2VjcmV0Ll9mcm9tU3RhcnRUb3RwTWZhRW5yb2xsbWVudFJlc3BvbnNlKHJlc3BvbnNlLCBtZmFTZXNzaW9uLnVzZXIuYXV0aCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBUT1RQIHNlY29uZCBmYWN0b3I6IGB0b3RwYC5cclxuICovXHJcblRvdHBNdWx0aUZhY3RvckdlbmVyYXRvci5GQUNUT1JfSUQgPSBcInRvdHBcIiAvKiBGYWN0b3JJZC5UT1RQICovO1xyXG5jbGFzcyBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIGV4dGVuZHMgTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKG90cCwgZW5yb2xsbWVudElkLCBzZWNyZXQpIHtcclxuICAgICAgICBzdXBlcihcInRvdHBcIiAvKiBGYWN0b3JJZC5UT1RQICovKTtcclxuICAgICAgICB0aGlzLm90cCA9IG90cDtcclxuICAgICAgICB0aGlzLmVucm9sbG1lbnRJZCA9IGVucm9sbG1lbnRJZDtcclxuICAgICAgICB0aGlzLnNlY3JldCA9IHNlY3JldDtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHN0YXRpYyBfZnJvbVNlY3JldChzZWNyZXQsIG90cCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbChvdHAsIHVuZGVmaW5lZCwgc2VjcmV0KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHN0YXRpYyBfZnJvbUVucm9sbG1lbnRJZChlbnJvbGxtZW50SWQsIG90cCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbChvdHAsIGVucm9sbG1lbnRJZCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBhc3luYyBfZmluYWxpemVFbnJvbGwoYXV0aCwgaWRUb2tlbiwgZGlzcGxheU5hbWUpIHtcclxuICAgICAgICBfYXNzZXJ0KHR5cGVvZiB0aGlzLnNlY3JldCAhPT0gJ3VuZGVmaW5lZCcsIGF1dGgsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcclxuICAgICAgICByZXR1cm4gZmluYWxpemVFbnJvbGxUb3RwTWZhKGF1dGgsIHtcclxuICAgICAgICAgICAgaWRUb2tlbixcclxuICAgICAgICAgICAgZGlzcGxheU5hbWUsXHJcbiAgICAgICAgICAgIHRvdHBWZXJpZmljYXRpb25JbmZvOiB0aGlzLnNlY3JldC5fbWFrZVRvdHBWZXJpZmljYXRpb25JbmZvKHRoaXMub3RwKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgYXN5bmMgX2ZpbmFsaXplU2lnbkluKGF1dGgsIG1mYVBlbmRpbmdDcmVkZW50aWFsKSB7XHJcbiAgICAgICAgX2Fzc2VydCh0aGlzLmVucm9sbG1lbnRJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3RwICE9PSB1bmRlZmluZWQsIGF1dGgsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcclxuICAgICAgICBjb25zdCB0b3RwVmVyaWZpY2F0aW9uSW5mbyA9IHsgdmVyaWZpY2F0aW9uQ29kZTogdGhpcy5vdHAgfTtcclxuICAgICAgICByZXR1cm4gZmluYWxpemVTaWduSW5Ub3RwTWZhKGF1dGgsIHtcclxuICAgICAgICAgICAgbWZhUGVuZGluZ0NyZWRlbnRpYWwsXHJcbiAgICAgICAgICAgIG1mYUVucm9sbG1lbnRJZDogdGhpcy5lbnJvbGxtZW50SWQsXHJcbiAgICAgICAgICAgIHRvdHBWZXJpZmljYXRpb25JbmZvXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0uXHJcbiAqXHJcbiAqIFN0b3JlcyB0aGUgc2hhcmVkIHNlY3JldCBrZXkgYW5kIG90aGVyIHBhcmFtZXRlcnMgdG8gZ2VuZXJhdGUgdGltZS1iYXNlZCBPVFBzLlxyXG4gKiBJbXBsZW1lbnRzIG1ldGhvZHMgdG8gcmV0cmlldmUgdGhlIHNoYXJlZCBzZWNyZXQga2V5IGFuZCBnZW5lcmF0ZSBhIFFSIGNvZGUgVVJMLlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBUb3RwU2VjcmV0IHtcclxuICAgIC8vIFRoZSBwdWJsaWMgbWVtYmVycyBhcmUgZGVjbGFyZWQgb3V0c2lkZSB0aGUgY29uc3RydWN0b3Igc28gdGhlIGRvY3MgY2FuIGJlIGdlbmVyYXRlZC5cclxuICAgIGNvbnN0cnVjdG9yKHNlY3JldEtleSwgaGFzaGluZ0FsZ29yaXRobSwgY29kZUxlbmd0aCwgY29kZUludGVydmFsU2Vjb25kcywgZW5yb2xsbWVudENvbXBsZXRpb25EZWFkbGluZSwgc2Vzc2lvbkluZm8sIGF1dGgpIHtcclxuICAgICAgICB0aGlzLnNlc3Npb25JbmZvID0gc2Vzc2lvbkluZm87XHJcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcclxuICAgICAgICB0aGlzLnNlY3JldEtleSA9IHNlY3JldEtleTtcclxuICAgICAgICB0aGlzLmhhc2hpbmdBbGdvcml0aG0gPSBoYXNoaW5nQWxnb3JpdGhtO1xyXG4gICAgICAgIHRoaXMuY29kZUxlbmd0aCA9IGNvZGVMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5jb2RlSW50ZXJ2YWxTZWNvbmRzID0gY29kZUludGVydmFsU2Vjb25kcztcclxuICAgICAgICB0aGlzLmVucm9sbG1lbnRDb21wbGV0aW9uRGVhZGxpbmUgPSBlbnJvbGxtZW50Q29tcGxldGlvbkRlYWRsaW5lO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgc3RhdGljIF9mcm9tU3RhcnRUb3RwTWZhRW5yb2xsbWVudFJlc3BvbnNlKHJlc3BvbnNlLCBhdXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUb3RwU2VjcmV0KHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby5zaGFyZWRTZWNyZXRLZXksIHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby5oYXNoaW5nQWxnb3JpdGhtLCByZXNwb25zZS50b3RwU2Vzc2lvbkluZm8udmVyaWZpY2F0aW9uQ29kZUxlbmd0aCwgcmVzcG9uc2UudG90cFNlc3Npb25JbmZvLnBlcmlvZFNlYywgbmV3IERhdGUocmVzcG9uc2UudG90cFNlc3Npb25JbmZvLmZpbmFsaXplRW5yb2xsbWVudFRpbWUpLnRvVVRDU3RyaW5nKCksIHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby5zZXNzaW9uSW5mbywgYXV0aCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfbWFrZVRvdHBWZXJpZmljYXRpb25JbmZvKG90cCkge1xyXG4gICAgICAgIHJldHVybiB7IHNlc3Npb25JbmZvOiB0aGlzLnNlc3Npb25JbmZvLCB2ZXJpZmljYXRpb25Db2RlOiBvdHAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIFFSIGNvZGUgVVJMIGFzIGRlc2NyaWJlZCBpblxyXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9nb29nbGUtYXV0aGVudGljYXRvci93aWtpL0tleS1VcmktRm9ybWF0XHJcbiAgICAgKiBUaGlzIGNhbiBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIgYXMgYSBRUiBjb2RlIHRvIGJlIHNjYW5uZWQgaW50byBhIFRPVFAgYXBwIGxpa2UgR29vZ2xlIEF1dGhlbnRpY2F0b3IuXHJcbiAgICAgKiBJZiB0aGUgb3B0aW9uYWwgcGFyYW1ldGVycyBhcmUgdW5zcGVjaWZpZWQsIGFuIGFjY291bnROYW1lIG9mIDx1c2VyRW1haWw+IGFuZCBpc3N1ZXIgb2YgPGZpcmViYXNlQXBwTmFtZT4gYXJlIHVzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjY291bnROYW1lIHRoZSBuYW1lIG9mIHRoZSBhY2NvdW50L2FwcCBhbG9uZyB3aXRoIGEgdXNlciBpZGVudGlmaWVyLlxyXG4gICAgICogQHBhcmFtIGlzc3VlciBpc3N1ZXIgb2YgdGhlIFRPVFAgKGxpa2VseSB0aGUgYXBwIG5hbWUpLlxyXG4gICAgICogQHJldHVybnMgQSBRUiBjb2RlIFVSTCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGdlbmVyYXRlUXJDb2RlVXJsKGFjY291bnROYW1lLCBpc3N1ZXIpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgbGV0IHVzZURlZmF1bHRzID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKF9pc0VtcHR5U3RyaW5nKGFjY291bnROYW1lKSB8fCBfaXNFbXB0eVN0cmluZyhpc3N1ZXIpKSB7XHJcbiAgICAgICAgICAgIHVzZURlZmF1bHRzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVzZURlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgIGlmIChfaXNFbXB0eVN0cmluZyhhY2NvdW50TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY291bnROYW1lID0gKChfYSA9IHRoaXMuYXV0aC5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtYWlsKSB8fCAndW5rbm93bnVzZXInO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChfaXNFbXB0eVN0cmluZyhpc3N1ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBpc3N1ZXIgPSB0aGlzLmF1dGgubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYG90cGF1dGg6Ly90b3RwLyR7aXNzdWVyfToke2FjY291bnROYW1lfT9zZWNyZXQ9JHt0aGlzLnNlY3JldEtleX0maXNzdWVyPSR7aXNzdWVyfSZhbGdvcml0aG09JHt0aGlzLmhhc2hpbmdBbGdvcml0aG19JmRpZ2l0cz0ke3RoaXMuY29kZUxlbmd0aH1gO1xyXG4gICAgfVxyXG59XHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZnVuY3Rpb24gX2lzRW1wdHlTdHJpbmcoaW5wdXQpIHtcclxuICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnIHx8IChpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXQubGVuZ3RoKSA9PT0gMDtcclxufVxuXG5leHBvcnQgeyBUd2l0dGVyQXV0aFByb3ZpZGVyIGFzICQsIEFjdGlvbkNvZGVPcGVyYXRpb24gYXMgQSwgdXBkYXRlQ3VycmVudFVzZXIgYXMgQiwgc2lnbk91dCBhcyBDLCByZXZva2VBY2Nlc3NUb2tlbiBhcyBELCBkZWxldGVVc2VyIGFzIEUsIEZhY3RvcklkIGFzIEYsIGRlYnVnRXJyb3JNYXAgYXMgRywgcHJvZEVycm9yTWFwIGFzIEgsIEFVVEhfRVJST1JfQ09ERVNfTUFQX0RPX05PVF9VU0VfSU5URVJOQUxMWSBhcyBJLCBpbml0aWFsaXplQXV0aCBhcyBKLCBjb25uZWN0QXV0aEVtdWxhdG9yIGFzIEssIEF1dGhDcmVkZW50aWFsIGFzIEwsIEVtYWlsQXV0aENyZWRlbnRpYWwgYXMgTSwgT0F1dGhDcmVkZW50aWFsIGFzIE4sIE9wZXJhdGlvblR5cGUgYXMgTywgUGhvbmVBdXRoUHJvdmlkZXIgYXMgUCwgUGhvbmVBdXRoQ3JlZGVudGlhbCBhcyBRLCBSZWNhcHRjaGFWZXJpZmllciBhcyBSLCBTaWduSW5NZXRob2QgYXMgUywgVG90cE11bHRpRmFjdG9yR2VuZXJhdG9yIGFzIFQsIGluTWVtb3J5UGVyc2lzdGVuY2UgYXMgVSwgRW1haWxBdXRoUHJvdmlkZXIgYXMgViwgRmFjZWJvb2tBdXRoUHJvdmlkZXIgYXMgVywgR29vZ2xlQXV0aFByb3ZpZGVyIGFzIFgsIEdpdGh1YkF1dGhQcm92aWRlciBhcyBZLCBPQXV0aFByb3ZpZGVyIGFzIFosIFNBTUxBdXRoUHJvdmlkZXIgYXMgXywgYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSBhcyBhLCBzaWduSW5Bbm9ueW1vdXNseSBhcyBhMCwgc2lnbkluV2l0aENyZWRlbnRpYWwgYXMgYTEsIGxpbmtXaXRoQ3JlZGVudGlhbCBhcyBhMiwgcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbCBhcyBhMywgc2lnbkluV2l0aEN1c3RvbVRva2VuIGFzIGE0LCBzZW5kUGFzc3dvcmRSZXNldEVtYWlsIGFzIGE1LCBjb25maXJtUGFzc3dvcmRSZXNldCBhcyBhNiwgYXBwbHlBY3Rpb25Db2RlIGFzIGE3LCBjaGVja0FjdGlvbkNvZGUgYXMgYTgsIHZlcmlmeVBhc3N3b3JkUmVzZXRDb2RlIGFzIGE5LCBfZmFpbCBhcyBhQSwgZGVidWdBc3NlcnQgYXMgYUIsIF9wZXJzaXN0ZW5jZUtleU5hbWUgYXMgYUMsIF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yIGFzIGFELCBfY2FzdEF1dGggYXMgYUUsIEZlZGVyYXRlZEF1dGhQcm92aWRlciBhcyBhRiwgQmFzZU9BdXRoUHJvdmlkZXIgYXMgYUcsIF9lbXVsYXRvclVybCBhcyBhSCwgX3BlcmZvcm1BcGlSZXF1ZXN0IGFzIGFJLCBfaXNJT1MgYXMgYUosIF9pc0FuZHJvaWQgYXMgYUssIF9pc0lPUzdPcjggYXMgYUwsIF9jcmVhdGVFcnJvciBhcyBhTSwgX2lzSWZyYW1lIGFzIGFOLCBfaXNNb2JpbGVCcm93c2VyIGFzIGFPLCBfaXNJRTEwIGFzIGFQLCBfaXNTYWZhcmkgYXMgYVEsIFVzZXJJbXBsIGFzIGFSLCBBdXRoSW1wbCBhcyBhUywgX2dldENsaWVudFZlcnNpb24gYXMgYVQsIEZldGNoUHJvdmlkZXIgYXMgYVUsIFNBTUxBdXRoQ3JlZGVudGlhbCBhcyBhViwgY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkIGFzIGFhLCBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZCBhcyBhYiwgc2VuZFNpZ25JbkxpbmtUb0VtYWlsIGFzIGFjLCBpc1NpZ25JbldpdGhFbWFpbExpbmsgYXMgYWQsIHNpZ25JbldpdGhFbWFpbExpbmsgYXMgYWUsIGZldGNoU2lnbkluTWV0aG9kc0ZvckVtYWlsIGFzIGFmLCBzZW5kRW1haWxWZXJpZmljYXRpb24gYXMgYWcsIHZlcmlmeUJlZm9yZVVwZGF0ZUVtYWlsIGFzIGFoLCBBY3Rpb25Db2RlVVJMIGFzIGFpLCBwYXJzZUFjdGlvbkNvZGVVUkwgYXMgYWosIHVwZGF0ZVByb2ZpbGUgYXMgYWssIHVwZGF0ZUVtYWlsIGFzIGFsLCB1cGRhdGVQYXNzd29yZCBhcyBhbSwgZ2V0SWRUb2tlbiBhcyBhbiwgZ2V0SWRUb2tlblJlc3VsdCBhcyBhbywgdW5saW5rIGFzIGFwLCBnZXRBZGRpdGlvbmFsVXNlckluZm8gYXMgYXEsIHJlbG9hZCBhcyBhciwgZ2V0TXVsdGlGYWN0b3JSZXNvbHZlciBhcyBhcywgbXVsdGlGYWN0b3IgYXMgYXQsIF9nZXRJbnN0YW5jZSBhcyBhdSwgX2Fzc2VydCBhcyBhdiwgX3NpZ25JbldpdGhDcmVkZW50aWFsIGFzIGF3LCBfcmVhdXRoZW50aWNhdGUgYXMgYXgsIF9saW5rIGFzIGF5LCBzaWduSW5XaXRoSWRwIGFzIGF6LCBicm93c2VyTG9jYWxQZXJzaXN0ZW5jZSBhcyBiLCBzaWduSW5XaXRoUG9wdXAgYXMgYywgbGlua1dpdGhQb3B1cCBhcyBkLCByZWF1dGhlbnRpY2F0ZVdpdGhQb3B1cCBhcyBlLCBzaWduSW5XaXRoUmVkaXJlY3QgYXMgZiwgbGlua1dpdGhSZWRpcmVjdCBhcyBnLCByZWF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdCBhcyBoLCBpbmRleGVkREJMb2NhbFBlcnNpc3RlbmNlIGFzIGksIGdldFJlZGlyZWN0UmVzdWx0IGFzIGosIGJyb3dzZXJQb3B1cFJlZGlyZWN0UmVzb2x2ZXIgYXMgaywgbGlua1dpdGhQaG9uZU51bWJlciBhcyBsLCBQaG9uZU11bHRpRmFjdG9yR2VuZXJhdG9yIGFzIG0sIFRvdHBTZWNyZXQgYXMgbiwgZ2V0QXV0aCBhcyBvLCBQcm92aWRlcklkIGFzIHAsIHNldFBlcnNpc3RlbmNlIGFzIHEsIHJlYXV0aGVudGljYXRlV2l0aFBob25lTnVtYmVyIGFzIHIsIHNpZ25JbldpdGhQaG9uZU51bWJlciBhcyBzLCBpbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnIGFzIHQsIHVwZGF0ZVBob25lTnVtYmVyIGFzIHUsIHZhbGlkYXRlUGFzc3dvcmQgYXMgdiwgb25JZFRva2VuQ2hhbmdlZCBhcyB3LCBiZWZvcmVBdXRoU3RhdGVDaGFuZ2VkIGFzIHgsIG9uQXV0aFN0YXRlQ2hhbmdlZCBhcyB5LCB1c2VEZXZpY2VMYW5ndWFnZSBhcyB6IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b3RwLWQ4MjFhYzI4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIlNES19WRVJTSU9OIiwiX2lzRmlyZWJhc2VTZXJ2ZXJBcHAiLCJfZ2V0UHJvdmlkZXIiLCJfcmVnaXN0ZXJDb21wb25lbnQiLCJyZWdpc3RlclZlcnNpb24iLCJnZXRBcHAiLCJFcnJvckZhY3RvcnkiLCJpc0Jyb3dzZXJFeHRlbnNpb24iLCJpc01vYmlsZUNvcmRvdmEiLCJpc1JlYWN0TmF0aXZlIiwiRmlyZWJhc2VFcnJvciIsInF1ZXJ5c3RyaW5nIiwiZ2V0TW9kdWxhckluc3RhbmNlIiwiYmFzZTY0RGVjb2RlIiwiZ2V0VUEiLCJpc0lFIiwiY3JlYXRlU3Vic2NyaWJlIiwiZGVlcEVxdWFsIiwicXVlcnlzdHJpbmdEZWNvZGUiLCJleHRyYWN0UXVlcnlzdHJpbmciLCJnZXREZWZhdWx0RW11bGF0b3JIb3N0IiwiX19yZXN0IiwiQ29tcG9uZW50IiwiZmV0Y2giLCJmZXRjaCQxIiwiSGVhZGVycyIsIkhlYWRlcnMkMSIsIlJlc3BvbnNlIiwiUmVzcG9uc2UkMSIsIkxvZ2dlciIsIkxvZ0xldmVsIiwiRmFjdG9ySWQiLCJQSE9ORSIsIlRPVFAiLCJQcm92aWRlcklkIiwiRkFDRUJPT0siLCJHSVRIVUIiLCJHT09HTEUiLCJQQVNTV09SRCIsIlRXSVRURVIiLCJTaWduSW5NZXRob2QiLCJFTUFJTF9MSU5LIiwiRU1BSUxfUEFTU1dPUkQiLCJPcGVyYXRpb25UeXBlIiwiTElOSyIsIlJFQVVUSEVOVElDQVRFIiwiU0lHTl9JTiIsIkFjdGlvbkNvZGVPcGVyYXRpb24iLCJFTUFJTF9TSUdOSU4iLCJQQVNTV09SRF9SRVNFVCIsIlJFQ09WRVJfRU1BSUwiLCJSRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTiIsIlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMIiwiVkVSSUZZX0VNQUlMIiwiX2RlYnVnRXJyb3JNYXAiLCJfcHJvZEVycm9yTWFwIiwiZGVidWdFcnJvck1hcCIsInByb2RFcnJvck1hcCIsIl9ERUZBVUxUX0FVVEhfRVJST1JfRkFDVE9SWSIsIkFVVEhfRVJST1JfQ09ERVNfTUFQX0RPX05PVF9VU0VfSU5URVJOQUxMWSIsIkFETUlOX09OTFlfT1BFUkFUSU9OIiwiQVJHVU1FTlRfRVJST1IiLCJBUFBfTk9UX0FVVEhPUklaRUQiLCJBUFBfTk9UX0lOU1RBTExFRCIsIkNBUFRDSEFfQ0hFQ0tfRkFJTEVEIiwiQ09ERV9FWFBJUkVEIiwiQ09SRE9WQV9OT1RfUkVBRFkiLCJDT1JTX1VOU1VQUE9SVEVEIiwiQ1JFREVOVElBTF9BTFJFQURZX0lOX1VTRSIsIkNSRURFTlRJQUxfTUlTTUFUQ0giLCJDUkVERU5USUFMX1RPT19PTERfTE9HSU5fQUdBSU4iLCJERVBFTkRFTlRfU0RLX0lOSVRfQkVGT1JFX0FVVEgiLCJEWU5BTUlDX0xJTktfTk9UX0FDVElWQVRFRCIsIkVNQUlMX0NIQU5HRV9ORUVEU19WRVJJRklDQVRJT04iLCJFTUFJTF9FWElTVFMiLCJFTVVMQVRPUl9DT05GSUdfRkFJTEVEIiwiRVhQSVJFRF9PT0JfQ09ERSIsIkVYUElSRURfUE9QVVBfUkVRVUVTVCIsIklOVEVSTkFMX0VSUk9SIiwiSU5WQUxJRF9BUElfS0VZIiwiSU5WQUxJRF9BUFBfQ1JFREVOVElBTCIsIklOVkFMSURfQVBQX0lEIiwiSU5WQUxJRF9BVVRIIiwiSU5WQUxJRF9BVVRIX0VWRU5UIiwiSU5WQUxJRF9DRVJUX0hBU0giLCJJTlZBTElEX0NPREUiLCJJTlZBTElEX0NPTlRJTlVFX1VSSSIsIklOVkFMSURfQ09SRE9WQV9DT05GSUdVUkFUSU9OIiwiSU5WQUxJRF9DVVNUT01fVE9LRU4iLCJJTlZBTElEX0RZTkFNSUNfTElOS19ET01BSU4iLCJJTlZBTElEX0VNQUlMIiwiSU5WQUxJRF9FTVVMQVRPUl9TQ0hFTUUiLCJJTlZBTElEX0lEUF9SRVNQT05TRSIsIklOVkFMSURfTE9HSU5fQ1JFREVOVElBTFMiLCJJTlZBTElEX01FU1NBR0VfUEFZTE9BRCIsIklOVkFMSURfTUZBX1NFU1NJT04iLCJJTlZBTElEX09BVVRIX0NMSUVOVF9JRCIsIklOVkFMSURfT0FVVEhfUFJPVklERVIiLCJJTlZBTElEX09PQl9DT0RFIiwiSU5WQUxJRF9PUklHSU4iLCJJTlZBTElEX1BBU1NXT1JEIiwiSU5WQUxJRF9QRVJTSVNURU5DRSIsIklOVkFMSURfUEhPTkVfTlVNQkVSIiwiSU5WQUxJRF9QUk9WSURFUl9JRCIsIklOVkFMSURfUkVDSVBJRU5UX0VNQUlMIiwiSU5WQUxJRF9TRU5ERVIiLCJJTlZBTElEX1NFU1NJT05fSU5GTyIsIklOVkFMSURfVEVOQU5UX0lEIiwiTUZBX0lORk9fTk9UX0ZPVU5EIiwiTUZBX1JFUVVJUkVEIiwiTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRSIsIk1JU1NJTkdfQVBQX0NSRURFTlRJQUwiLCJNSVNTSU5HX0FVVEhfRE9NQUlOIiwiTUlTU0lOR19DT0RFIiwiTUlTU0lOR19DT05USU5VRV9VUkkiLCJNSVNTSU5HX0lGUkFNRV9TVEFSVCIsIk1JU1NJTkdfSU9TX0JVTkRMRV9JRCIsIk1JU1NJTkdfT1JfSU5WQUxJRF9OT05DRSIsIk1JU1NJTkdfTUZBX0lORk8iLCJNSVNTSU5HX01GQV9TRVNTSU9OIiwiTUlTU0lOR19QSE9ORV9OVU1CRVIiLCJNSVNTSU5HX1NFU1NJT05fSU5GTyIsIk1PRFVMRV9ERVNUUk9ZRUQiLCJORUVEX0NPTkZJUk1BVElPTiIsIk5FVFdPUktfUkVRVUVTVF9GQUlMRUQiLCJOVUxMX1VTRVIiLCJOT19BVVRIX0VWRU5UIiwiTk9fU1VDSF9QUk9WSURFUiIsIk9QRVJBVElPTl9OT1RfQUxMT1dFRCIsIk9QRVJBVElPTl9OT1RfU1VQUE9SVEVEIiwiUE9QVVBfQkxPQ0tFRCIsIlBPUFVQX0NMT1NFRF9CWV9VU0VSIiwiUFJPVklERVJfQUxSRUFEWV9MSU5LRUQiLCJRVU9UQV9FWENFRURFRCIsIlJFRElSRUNUX0NBTkNFTExFRF9CWV9VU0VSIiwiUkVESVJFQ1RfT1BFUkFUSU9OX1BFTkRJTkciLCJSRUpFQ1RFRF9DUkVERU5USUFMIiwiU0VDT05EX0ZBQ1RPUl9BTFJFQURZX0VOUk9MTEVEIiwiU0VDT05EX0ZBQ1RPUl9MSU1JVF9FWENFRURFRCIsIlRFTkFOVF9JRF9NSVNNQVRDSCIsIlRJTUVPVVQiLCJUT0tFTl9FWFBJUkVEIiwiVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSIiwiVU5BVVRIT1JJWkVEX0RPTUFJTiIsIlVOU1VQUE9SVEVEX0ZJUlNUX0ZBQ1RPUiIsIlVOU1VQUE9SVEVEX1BFUlNJU1RFTkNFIiwiVU5TVVBQT1JURURfVEVOQU5UX09QRVJBVElPTiIsIlVOVkVSSUZJRURfRU1BSUwiLCJVU0VSX0NBTkNFTExFRCIsIlVTRVJfREVMRVRFRCIsIlVTRVJfRElTQUJMRUQiLCJVU0VSX01JU01BVENIIiwiVVNFUl9TSUdORURfT1VUIiwiV0VBS19QQVNTV09SRCIsIldFQl9TVE9SQUdFX1VOU1VQUE9SVEVEIiwiQUxSRUFEWV9JTklUSUFMSVpFRCIsIlJFQ0FQVENIQV9OT1RfRU5BQkxFRCIsIk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOIiwiSU5WQUxJRF9SRUNBUFRDSEFfVE9LRU4iLCJJTlZBTElEX1JFQ0FQVENIQV9BQ1RJT04iLCJNSVNTSU5HX0NMSUVOVF9UWVBFIiwiTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTiIsIklOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT04iLCJJTlZBTElEX1JFUV9UWVBFIiwibG9nQ2xpZW50IiwiX2xvZ1dhcm4iLCJtc2ciLCJhcmdzIiwibG9nTGV2ZWwiLCJXQVJOIiwid2FybiIsIl9sb2dFcnJvciIsIkVSUk9SIiwiZXJyb3IiLCJfZmFpbCIsImF1dGhPckNvZGUiLCJyZXN0IiwiY3JlYXRlRXJyb3JJbnRlcm5hbCIsIl9jcmVhdGVFcnJvciIsIl9lcnJvcldpdGhDdXN0b21NZXNzYWdlIiwiYXV0aCIsImNvZGUiLCJtZXNzYWdlIiwiZXJyb3JNYXAiLCJPYmplY3QiLCJhc3NpZ24iLCJmYWN0b3J5IiwiY3JlYXRlIiwiYXBwTmFtZSIsIm5hbWUiLCJfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvciIsImZ1bGxQYXJhbXMiLCJzbGljZSIsIl9lcnJvckZhY3RvcnkiLCJfYXNzZXJ0IiwiYXNzZXJ0aW9uIiwiZGVidWdGYWlsIiwiZmFpbHVyZSIsIkVycm9yIiwiZGVidWdBc3NlcnQiLCJfZ2V0Q3VycmVudFVybCIsIl9hIiwic2VsZiIsImxvY2F0aW9uIiwiaHJlZiIsIl9pc0h0dHBPckh0dHBzIiwiX2dldEN1cnJlbnRTY2hlbWUiLCJwcm90b2NvbCIsIl9pc09ubGluZSIsIm5hdmlnYXRvciIsIm9uTGluZSIsIl9nZXRVc2VyTGFuZ3VhZ2UiLCJuYXZpZ2F0b3JMYW5ndWFnZSIsImxhbmd1YWdlcyIsImxhbmd1YWdlIiwiRGVsYXkiLCJjb25zdHJ1Y3RvciIsInNob3J0RGVsYXkiLCJsb25nRGVsYXkiLCJpc01vYmlsZSIsImdldCIsIk1hdGgiLCJtaW4iLCJfZW11bGF0b3JVcmwiLCJjb25maWciLCJwYXRoIiwiZW11bGF0b3IiLCJ1cmwiLCJzdGFydHNXaXRoIiwiRmV0Y2hQcm92aWRlciIsImluaXRpYWxpemUiLCJmZXRjaEltcGwiLCJoZWFkZXJzSW1wbCIsInJlc3BvbnNlSW1wbCIsImdsb2JhbFRoaXMiLCJoZWFkZXJzIiwicmVzcG9uc2UiLCJTRVJWRVJfRVJST1JfTUFQIiwiREVGQVVMVF9BUElfVElNRU9VVF9NUyIsIl9hZGRUaWRJZk5lY2Vzc2FyeSIsInJlcXVlc3QiLCJ0ZW5hbnRJZCIsIl9wZXJmb3JtQXBpUmVxdWVzdCIsIm1ldGhvZCIsImN1c3RvbUVycm9yTWFwIiwiX3BlcmZvcm1GZXRjaFdpdGhFcnJvckhhbmRsaW5nIiwiYm9keSIsInBhcmFtcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJxdWVyeSIsImtleSIsImFwaUtleSIsIl9nZXRBZGRpdGlvbmFsSGVhZGVycyIsImxhbmd1YWdlQ29kZSIsIl9nZXRGaW5hbFRhcmdldCIsImFwaUhvc3QiLCJyZWZlcnJlclBvbGljeSIsImZldGNoRm4iLCJfY2FuSW5pdEVtdWxhdG9yIiwibmV0d29ya1RpbWVvdXQiLCJOZXR3b3JrVGltZW91dCIsIlByb21pc2UiLCJyYWNlIiwicHJvbWlzZSIsImNsZWFyTmV0d29ya1RpbWVvdXQiLCJqc29uIiwiX21ha2VUYWdnZWRFcnJvciIsIm9rIiwiZXJyb3JNZXNzYWdlIiwic2VydmVyRXJyb3JDb2RlIiwic2VydmVyRXJyb3JNZXNzYWdlIiwic3BsaXQiLCJhdXRoRXJyb3IiLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2UiLCJlIiwiU3RyaW5nIiwiX3BlcmZvcm1TaWduSW5SZXF1ZXN0Iiwic2VydmVyUmVzcG9uc2UiLCJfc2VydmVyUmVzcG9uc2UiLCJob3N0IiwiYmFzZSIsImFwaVNjaGVtZSIsIl9wYXJzZUVuZm9yY2VtZW50U3RhdGUiLCJlbmZvcmNlbWVudFN0YXRlU3RyIiwidGltZXIiLCJfIiwicmVqZWN0Iiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsImVycm9yUGFyYW1zIiwiZW1haWwiLCJwaG9uZU51bWJlciIsImN1c3RvbURhdGEiLCJfdG9rZW5SZXNwb25zZSIsImlzRW50ZXJwcmlzZSIsImdyZWNhcHRjaGEiLCJ1bmRlZmluZWQiLCJlbnRlcnByaXNlIiwiUmVjYXB0Y2hhQ29uZmlnIiwic2l0ZUtleSIsInJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUiLCJyZWNhcHRjaGFLZXkiLCJnZXRQcm92aWRlckVuZm9yY2VtZW50U3RhdGUiLCJwcm92aWRlclN0ciIsImxlbmd0aCIsInByb3ZpZGVyIiwiZW5mb3JjZW1lbnRTdGF0ZSIsImlzUHJvdmlkZXJFbmFibGVkIiwiZ2V0UmVjYXB0Y2hhQ29uZmlnIiwiZGVsZXRlQWNjb3VudCIsImRlbGV0ZUxpbmtlZEFjY291bnRzIiwiZ2V0QWNjb3VudEluZm8iLCJ1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmciLCJ1dGNUaW1lc3RhbXAiLCJkYXRlIiwiRGF0ZSIsIk51bWJlciIsImlzTmFOIiwiZ2V0VGltZSIsInRvVVRDU3RyaW5nIiwiZ2V0SWRUb2tlbiIsInVzZXIiLCJmb3JjZVJlZnJlc2giLCJnZXRJZFRva2VuUmVzdWx0IiwidXNlckludGVybmFsIiwidG9rZW4iLCJjbGFpbXMiLCJfcGFyc2VUb2tlbiIsImV4cCIsImF1dGhfdGltZSIsImlhdCIsImZpcmViYXNlIiwic2lnbkluUHJvdmlkZXIiLCJhdXRoVGltZSIsInNlY29uZHNTdHJpbmdUb01pbGxpc2Vjb25kcyIsImlzc3VlZEF0VGltZSIsImV4cGlyYXRpb25UaW1lIiwic2lnbkluU2Vjb25kRmFjdG9yIiwic2Vjb25kcyIsImFsZ29yaXRobSIsInBheWxvYWQiLCJzaWduYXR1cmUiLCJkZWNvZGVkIiwicGFyc2UiLCJ0b1N0cmluZyIsIl90b2tlbkV4cGlyZXNJbiIsInBhcnNlZFRva2VuIiwiX2xvZ291dElmSW52YWxpZGF0ZWQiLCJieXBhc3NBdXRoU3RhdGUiLCJpc1VzZXJJbnZhbGlkYXRlZCIsImN1cnJlbnRVc2VyIiwic2lnbk91dCIsIlByb2FjdGl2ZVJlZnJlc2giLCJpc1J1bm5pbmciLCJ0aW1lcklkIiwiZXJyb3JCYWNrb2ZmIiwiX3N0YXJ0Iiwic2NoZWR1bGUiLCJfc3RvcCIsImdldEludGVydmFsIiwid2FzRXJyb3IiLCJpbnRlcnZhbCIsImV4cFRpbWUiLCJzdHNUb2tlbk1hbmFnZXIiLCJub3ciLCJtYXgiLCJpdGVyYXRpb24iLCJVc2VyTWV0YWRhdGEiLCJjcmVhdGVkQXQiLCJsYXN0TG9naW5BdCIsIl9pbml0aWFsaXplVGltZSIsImxhc3RTaWduSW5UaW1lIiwiY3JlYXRpb25UaW1lIiwiX2NvcHkiLCJtZXRhZGF0YSIsInRvSlNPTiIsIl9yZWxvYWRXaXRob3V0U2F2aW5nIiwiaWRUb2tlbiIsInVzZXJzIiwiY29yZUFjY291bnQiLCJfbm90aWZ5UmVsb2FkTGlzdGVuZXIiLCJuZXdQcm92aWRlckRhdGEiLCJwcm92aWRlclVzZXJJbmZvIiwiZXh0cmFjdFByb3ZpZGVyRGF0YSIsInByb3ZpZGVyRGF0YSIsIm1lcmdlUHJvdmlkZXJEYXRhIiwib2xkSXNBbm9ueW1vdXMiLCJpc0Fub255bW91cyIsIm5ld0lzQW5vbnltb3VzIiwicGFzc3dvcmRIYXNoIiwidXBkYXRlcyIsInVpZCIsImxvY2FsSWQiLCJkaXNwbGF5TmFtZSIsInBob3RvVVJMIiwicGhvdG9VcmwiLCJlbWFpbFZlcmlmaWVkIiwicmVsb2FkIiwiX3BlcnNpc3RVc2VySWZDdXJyZW50IiwiX25vdGlmeUxpc3RlbmVyc0lmQ3VycmVudCIsIm9yaWdpbmFsIiwibmV3RGF0YSIsImRlZHVwZWQiLCJmaWx0ZXIiLCJvIiwic29tZSIsIm4iLCJwcm92aWRlcklkIiwicHJvdmlkZXJzIiwibWFwIiwicmF3SWQiLCJyZXF1ZXN0U3RzVG9rZW4iLCJyZWZyZXNoVG9rZW4iLCJ0b2tlbkFwaUhvc3QiLCJhY2Nlc3NUb2tlbiIsImFjY2Vzc190b2tlbiIsImV4cGlyZXNJbiIsImV4cGlyZXNfaW4iLCJyZWZyZXNoX3Rva2VuIiwicmV2b2tlVG9rZW4iLCJTdHNUb2tlbk1hbmFnZXIiLCJpc0V4cGlyZWQiLCJ1cGRhdGVGcm9tU2VydmVyUmVzcG9uc2UiLCJ1cGRhdGVUb2tlbnNBbmRFeHBpcmF0aW9uIiwidXBkYXRlRnJvbUlkVG9rZW4iLCJnZXRUb2tlbiIsInJlZnJlc2giLCJjbGVhclJlZnJlc2hUb2tlbiIsIm9sZFRva2VuIiwiZXhwaXJlc0luU2VjIiwiZnJvbUpTT04iLCJvYmplY3QiLCJtYW5hZ2VyIiwiX2Fzc2lnbiIsIl9jbG9uZSIsIl9wZXJmb3JtUmVmcmVzaCIsImFzc2VydFN0cmluZ09yVW5kZWZpbmVkIiwiVXNlckltcGwiLCJvcHQiLCJwcm9hY3RpdmVSZWZyZXNoIiwicmVsb2FkVXNlckluZm8iLCJyZWxvYWRMaXN0ZW5lciIsInVzZXJJbmZvIiwibmV3VXNlciIsIl9vblJlbG9hZCIsImNhbGxiYWNrIiwiX3N0YXJ0UHJvYWN0aXZlUmVmcmVzaCIsIl9zdG9wUHJvYWN0aXZlUmVmcmVzaCIsIl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeSIsInRva2Vuc1JlZnJlc2hlZCIsImRlbGV0ZSIsImFwcCIsIl9yZWRpcmVjdEV2ZW50SWQiLCJfZnJvbUpTT04iLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJfaCIsInBsYWluT2JqZWN0VG9rZW5NYW5hZ2VyIiwiQXJyYXkiLCJpc0FycmF5IiwiX2Zyb21JZFRva2VuUmVzcG9uc2UiLCJpZFRva2VuUmVzcG9uc2UiLCJfZnJvbUdldEFjY291bnRJbmZvUmVzcG9uc2UiLCJpbnN0YW5jZUNhY2hlIiwiTWFwIiwiX2dldEluc3RhbmNlIiwiY2xzIiwiRnVuY3Rpb24iLCJpbnN0YW5jZSIsInNldCIsIkluTWVtb3J5UGVyc2lzdGVuY2UiLCJ0eXBlIiwic3RvcmFnZSIsIl9pc0F2YWlsYWJsZSIsIl9zZXQiLCJ2YWx1ZSIsIl9nZXQiLCJfcmVtb3ZlIiwiX2FkZExpc3RlbmVyIiwiX2tleSIsIl9saXN0ZW5lciIsIl9yZW1vdmVMaXN0ZW5lciIsImluTWVtb3J5UGVyc2lzdGVuY2UiLCJfcGVyc2lzdGVuY2VLZXlOYW1lIiwiUGVyc2lzdGVuY2VVc2VyTWFuYWdlciIsInBlcnNpc3RlbmNlIiwidXNlcktleSIsImZ1bGxVc2VyS2V5IiwiZnVsbFBlcnNpc3RlbmNlS2V5IiwiYm91bmRFdmVudEhhbmRsZXIiLCJfb25TdG9yYWdlRXZlbnQiLCJiaW5kIiwic2V0Q3VycmVudFVzZXIiLCJnZXRDdXJyZW50VXNlciIsImJsb2IiLCJyZW1vdmVDdXJyZW50VXNlciIsInNhdmVQZXJzaXN0ZW5jZUZvclJlZGlyZWN0Iiwic2V0UGVyc2lzdGVuY2UiLCJuZXdQZXJzaXN0ZW5jZSIsInBlcnNpc3RlbmNlSGllcmFyY2h5IiwiYXZhaWxhYmxlUGVyc2lzdGVuY2VzIiwiYWxsIiwic2VsZWN0ZWRQZXJzaXN0ZW5jZSIsInVzZXJUb01pZ3JhdGUiLCJtaWdyYXRpb25IaWVyYXJjaHkiLCJwIiwiX3Nob3VsZEFsbG93TWlncmF0aW9uIiwiX2dldEJyb3dzZXJOYW1lIiwidXNlckFnZW50IiwidWEiLCJpbmNsdWRlcyIsIl9pc0lFTW9iaWxlIiwiX2lzRmlyZWZveCIsIl9pc0JsYWNrQmVycnkiLCJfaXNXZWJPUyIsIl9pc1NhZmFyaSIsIl9pc0Nocm9tZUlPUyIsIl9pc0FuZHJvaWQiLCJyZSIsIm1hdGNoZXMiLCJtYXRjaCIsInRlc3QiLCJfaXNJT1MiLCJfaXNJT1M3T3I4IiwiX2lzSUUxMCIsImRvY3VtZW50IiwiZG9jdW1lbnRNb2RlIiwiX2lzTW9iaWxlQnJvd3NlciIsIl9pc0lmcmFtZSIsIndpbmRvdyIsInRvcCIsIl9nZXRDbGllbnRWZXJzaW9uIiwiY2xpZW50UGxhdGZvcm0iLCJmcmFtZXdvcmtzIiwicmVwb3J0ZWRQbGF0Zm9ybSIsInJlcG9ydGVkRnJhbWV3b3JrcyIsImpvaW4iLCJBdXRoTWlkZGxld2FyZVF1ZXVlIiwicXVldWUiLCJwdXNoQ2FsbGJhY2siLCJvbkFib3J0Iiwid3JhcHBlZENhbGxiYWNrIiwicmVzb2x2ZSIsInJlc3VsdCIsInB1c2giLCJpbmRleCIsInJ1bk1pZGRsZXdhcmUiLCJuZXh0VXNlciIsIm9uQWJvcnRTdGFjayIsImJlZm9yZVN0YXRlQ2FsbGJhY2siLCJyZXZlcnNlIiwib3JpZ2luYWxNZXNzYWdlIiwiX2dldFBhc3N3b3JkUG9saWN5IiwiTUlOSU1VTV9NSU5fUEFTU1dPUkRfTEVOR1RIIiwiUGFzc3dvcmRQb2xpY3lJbXBsIiwicmVzcG9uc2VPcHRpb25zIiwiY3VzdG9tU3RyZW5ndGhPcHRpb25zIiwibWluUGFzc3dvcmRMZW5ndGgiLCJtYXhQYXNzd29yZExlbmd0aCIsImNvbnRhaW5zTG93ZXJjYXNlQ2hhcmFjdGVyIiwiY29udGFpbnNMb3dlcmNhc2VMZXR0ZXIiLCJjb250YWluc1VwcGVyY2FzZUNoYXJhY3RlciIsImNvbnRhaW5zVXBwZXJjYXNlTGV0dGVyIiwiY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyIiwiY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIiLCJhbGxvd2VkTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVycyIsImZvcmNlVXBncmFkZU9uU2lnbmluIiwic2NoZW1hVmVyc2lvbiIsInZhbGlkYXRlUGFzc3dvcmQiLCJwYXNzd29yZCIsInN0YXR1cyIsImlzVmFsaWQiLCJwYXNzd29yZFBvbGljeSIsInZhbGlkYXRlUGFzc3dvcmRMZW5ndGhPcHRpb25zIiwidmFsaWRhdGVQYXNzd29yZENoYXJhY3Rlck9wdGlvbnMiLCJtZWV0c01pblBhc3N3b3JkTGVuZ3RoIiwibWVldHNNYXhQYXNzd29yZExlbmd0aCIsInVwZGF0ZVBhc3N3b3JkQ2hhcmFjdGVyT3B0aW9uc1N0YXR1c2VzIiwicGFzc3dvcmRDaGFyIiwiaSIsImNoYXJBdCIsIkF1dGhJbXBsIiwiaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyIiwiYXBwQ2hlY2tTZXJ2aWNlUHJvdmlkZXIiLCJlbXVsYXRvckNvbmZpZyIsIm9wZXJhdGlvbnMiLCJhdXRoU3RhdGVTdWJzY3JpcHRpb24iLCJTdWJzY3JpcHRpb24iLCJpZFRva2VuU3Vic2NyaXB0aW9uIiwiYmVmb3JlU3RhdGVRdWV1ZSIsInJlZGlyZWN0VXNlciIsImlzUHJvYWN0aXZlUmVmcmVzaEVuYWJsZWQiLCJFWFBFQ1RFRF9QQVNTV09SRF9QT0xJQ1lfU0NIRU1BX1ZFUlNJT04iLCJfaXNJbml0aWFsaXplZCIsIl9kZWxldGVkIiwiX2luaXRpYWxpemF0aW9uUHJvbWlzZSIsIl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIiLCJfYWdlbnRSZWNhcHRjaGFDb25maWciLCJfdGVuYW50UmVjYXB0Y2hhQ29uZmlncyIsIl9wcm9qZWN0UGFzc3dvcmRQb2xpY3kiLCJfdGVuYW50UGFzc3dvcmRQb2xpY2llcyIsImxhc3ROb3RpZmllZFVpZCIsInNldHRpbmdzIiwiYXBwVmVyaWZpY2F0aW9uRGlzYWJsZWRGb3JUZXN0aW5nIiwiY2xpZW50VmVyc2lvbiIsInNka0NsaWVudFZlcnNpb24iLCJfaW5pdGlhbGl6ZVdpdGhQZXJzaXN0ZW5jZSIsInBvcHVwUmVkaXJlY3RSZXNvbHZlciIsInBlcnNpc3RlbmNlTWFuYWdlciIsIl9zaG91bGRJbml0UHJvYWN0aXZlbHkiLCJfaW5pdGlhbGl6ZSIsImluaXRpYWxpemVDdXJyZW50VXNlciIsImFzc2VydGVkUGVyc2lzdGVuY2UiLCJfY3VycmVudFVzZXIiLCJfdXBkYXRlQ3VycmVudFVzZXIiLCJpbml0aWFsaXplQ3VycmVudFVzZXJGcm9tSWRUb2tlbiIsImRpcmVjdGx5U2V0Q3VycmVudFVzZXIiLCJlcnIiLCJjb25zb2xlIiwiYXV0aElkVG9rZW4iLCJ0aGVuIiwicHJldmlvdXNseVN0b3JlZFVzZXIiLCJmdXR1cmVDdXJyZW50VXNlciIsIm5lZWRzVG9jaGVja01pZGRsZXdhcmUiLCJhdXRoRG9tYWluIiwiZ2V0T3JJbml0UmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIiLCJyZWRpcmVjdFVzZXJFdmVudElkIiwic3RvcmVkVXNlckV2ZW50SWQiLCJ0cnlSZWRpcmVjdFNpZ25JbiIsIl9vdmVycmlkZVJlZGlyZWN0UmVzdWx0IiwicmVsb2FkQW5kU2V0Q3VycmVudFVzZXJPckNsZWFyIiwicmVkaXJlY3RSZXNvbHZlciIsIl9jb21wbGV0ZVJlZGlyZWN0Rm4iLCJfc2V0UmVkaXJlY3RVc2VyIiwidXNlRGV2aWNlTGFuZ3VhZ2UiLCJfZGVsZXRlIiwidXBkYXRlQ3VycmVudFVzZXIiLCJ1c2VyRXh0ZXJuIiwic2tpcEJlZm9yZVN0YXRlQ2FsbGJhY2tzIiwibm90aWZ5QXV0aExpc3RlbmVycyIsInJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyIiwiX2dldFJlY2FwdGNoYUNvbmZpZyIsIl9nZXRQYXNzd29yZFBvbGljeUludGVybmFsIiwiX3VwZGF0ZVBhc3N3b3JkUG9saWN5IiwiX2dldFBlcnNpc3RlbmNlIiwiX3VwZGF0ZUVycm9yTWFwIiwib25BdXRoU3RhdGVDaGFuZ2VkIiwibmV4dE9yT2JzZXJ2ZXIiLCJjb21wbGV0ZWQiLCJyZWdpc3RlclN0YXRlTGlzdGVuZXIiLCJiZWZvcmVBdXRoU3RhdGVDaGFuZ2VkIiwib25JZFRva2VuQ2hhbmdlZCIsImF1dGhTdGF0ZVJlYWR5IiwidW5zdWJzY3JpYmUiLCJyZXZva2VBY2Nlc3NUb2tlbiIsInRva2VuVHlwZSIsInJlZGlyZWN0TWFuYWdlciIsInJlc29sdmVyIiwiX3JlZGlyZWN0UGVyc2lzdGVuY2UiLCJfcmVkaXJlY3RVc2VyRm9ySWQiLCJpZCIsIm5leHQiLCJjdXJyZW50VWlkIiwic3Vic2NyaXB0aW9uIiwiY2IiLCJpc1Vuc3Vic2NyaWJlZCIsImFkZE9ic2VydmVyIiwiYWN0aW9uIiwiX2xvZ0ZyYW1ld29yayIsImZyYW1ld29yayIsInNvcnQiLCJfZ2V0RnJhbWV3b3JrcyIsIm9wdGlvbnMiLCJhcHBJZCIsImhlYXJ0YmVhdHNIZWFkZXIiLCJnZXRJbW1lZGlhdGUiLCJvcHRpb25hbCIsImdldEhlYXJ0YmVhdHNIZWFkZXIiLCJhcHBDaGVja1Rva2VuIiwiX2dldEFwcENoZWNrVG9rZW4iLCJhcHBDaGVja1Rva2VuUmVzdWx0IiwiX2Nhc3RBdXRoIiwib2JzZXJ2ZXIiLCJleHRlcm5hbEpTUHJvdmlkZXIiLCJsb2FkSlMiLCJyZWNhcHRjaGFWMlNjcmlwdCIsInJlY2FwdGNoYUVudGVycHJpc2VTY3JpcHQiLCJnYXBpU2NyaXB0IiwiX2xvYWRKUyIsIl9yZWNhcHRjaGFFbnRlcnByaXNlU2NyaXB0VXJsIiwiUkVDQVBUQ0hBX0VOVEVSUFJJU0VfVkVSSUZJRVJfVFlQRSIsIkZBS0VfVE9LRU4iLCJSZWNhcHRjaGFFbnRlcnByaXNlVmVyaWZpZXIiLCJhdXRoRXh0ZXJuIiwidmVyaWZ5IiwicmV0cmlldmVTaXRlS2V5IiwiY2xpZW50VHlwZSIsInZlcnNpb24iLCJjYXRjaCIsInJldHJpZXZlUmVjYXB0Y2hhVG9rZW4iLCJyZWFkeSIsImV4ZWN1dGUiLCJpbmplY3RSZWNhcHRjaGFGaWVsZHMiLCJjYXB0Y2hhUmVzcCIsInZlcmlmaWVyIiwiY2FwdGNoYVJlc3BvbnNlIiwibmV3UmVxdWVzdCIsImhhbmRsZVJlY2FwdGNoYUZsb3ciLCJhdXRoSW5zdGFuY2UiLCJhY3Rpb25OYW1lIiwiYWN0aW9uTWV0aG9kIiwicmVxdWVzdFdpdGhSZWNhcHRjaGEiLCJsb2ciLCJfaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZyIsImF1dGhJbnRlcm5hbCIsImluaXRpYWxpemVBdXRoIiwiZGVwcyIsImlzSW5pdGlhbGl6ZWQiLCJpbml0aWFsT3B0aW9ucyIsImdldE9wdGlvbnMiLCJfaW5pdGlhbGl6ZUF1dGhJbnN0YW5jZSIsImhpZXJhcmNoeSIsImNvbm5lY3RBdXRoRW11bGF0b3IiLCJkaXNhYmxlV2FybmluZ3MiLCJleHRyYWN0UHJvdG9jb2wiLCJwb3J0IiwiZXh0cmFjdEhvc3RBbmRQb3J0IiwicG9ydFN0ciIsImZyZWV6ZSIsImVtaXRFbXVsYXRvcldhcm5pbmciLCJwcm90b2NvbEVuZCIsImluZGV4T2YiLCJzdWJzdHIiLCJhdXRob3JpdHkiLCJleGVjIiwiaG9zdEFuZFBvcnQiLCJwb3AiLCJicmFja2V0ZWRJUHY2IiwicGFyc2VQb3J0IiwiYXR0YWNoQmFubmVyIiwiZWwiLCJjcmVhdGVFbGVtZW50Iiwic3R5Iiwic3R5bGUiLCJpbm5lclRleHQiLCJwb3NpdGlvbiIsIndpZHRoIiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyIiwiY29sb3IiLCJib3R0b20iLCJsZWZ0IiwibWFyZ2luIiwiekluZGV4IiwidGV4dEFsaWduIiwiY2xhc3NMaXN0IiwiYWRkIiwiYXBwZW5kQ2hpbGQiLCJpbmZvIiwicmVhZHlTdGF0ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJBdXRoQ3JlZGVudGlhbCIsInNpZ25Jbk1ldGhvZCIsIl9nZXRJZFRva2VuUmVzcG9uc2UiLCJfYXV0aCIsIl9saW5rVG9JZFRva2VuIiwiX2lkVG9rZW4iLCJfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyIiwicmVzZXRQYXNzd29yZCIsInVwZGF0ZUVtYWlsUGFzc3dvcmQiLCJsaW5rRW1haWxQYXNzd29yZCIsImFwcGx5QWN0aW9uQ29kZSQxIiwic2lnbkluV2l0aFBhc3N3b3JkIiwic2VuZE9vYkNvZGUiLCJzZW5kRW1haWxWZXJpZmljYXRpb24kMSIsInNlbmRQYXNzd29yZFJlc2V0RW1haWwkMSIsInNlbmRTaWduSW5MaW5rVG9FbWFpbCQxIiwidmVyaWZ5QW5kQ2hhbmdlRW1haWwiLCJzaWduSW5XaXRoRW1haWxMaW5rJDEiLCJzaWduSW5XaXRoRW1haWxMaW5rRm9yTGlua2luZyIsIkVtYWlsQXV0aENyZWRlbnRpYWwiLCJfZW1haWwiLCJfcGFzc3dvcmQiLCJfdGVuYW50SWQiLCJfZnJvbUVtYWlsQW5kUGFzc3dvcmQiLCJfZnJvbUVtYWlsQW5kQ29kZSIsIm9vYkNvZGUiLCJvYmoiLCJyZXR1cm5TZWN1cmVUb2tlbiIsInNpZ25JbldpdGhJZHAiLCJJRFBfUkVRVUVTVF9VUkkkMSIsIk9BdXRoQ3JlZGVudGlhbCIsImFyZ3VtZW50cyIsInBlbmRpbmdUb2tlbiIsIl9mcm9tUGFyYW1zIiwiY3JlZCIsIm5vbmNlIiwib2F1dGhUb2tlbiIsIm9hdXRoVG9rZW5TZWNyZXQiLCJzZWNyZXQiLCJidWlsZFJlcXVlc3QiLCJhdXRvQ3JlYXRlIiwicmVxdWVzdFVyaSIsInBvc3RCb2R5Iiwic2lnbkluV2l0aFBob25lTnVtYmVyJDEiLCJsaW5rV2l0aFBob25lTnVtYmVyJDEiLCJ0ZW1wb3JhcnlQcm9vZiIsIlZFUklGWV9QSE9ORV9OVU1CRVJfRk9SX0VYSVNUSU5HX0VSUk9SX01BUF8iLCJ2ZXJpZnlQaG9uZU51bWJlckZvckV4aXN0aW5nIiwiYXBpUmVxdWVzdCIsIm9wZXJhdGlvbiIsIlBob25lQXV0aENyZWRlbnRpYWwiLCJfZnJvbVZlcmlmaWNhdGlvbiIsInZlcmlmaWNhdGlvbklkIiwidmVyaWZpY2F0aW9uQ29kZSIsIl9mcm9tVG9rZW5SZXNwb25zZSIsIl9tYWtlVmVyaWZpY2F0aW9uUmVxdWVzdCIsInNlc3Npb25JbmZvIiwicGFyc2VNb2RlIiwibW9kZSIsInBhcnNlRGVlcExpbmsiLCJsaW5rIiwiZG91YmxlRGVlcExpbmsiLCJpT1NEZWVwTGluayIsImlPU0RvdWJsZURlZXBMaW5rIiwiQWN0aW9uQ29kZVVSTCIsImFjdGlvbkxpbmsiLCJzZWFyY2hQYXJhbXMiLCJjb250aW51ZVVybCIsInBhcnNlTGluayIsInBhcnNlQWN0aW9uQ29kZVVSTCIsIkVtYWlsQXV0aFByb3ZpZGVyIiwiUFJPVklERVJfSUQiLCJjcmVkZW50aWFsIiwiY3JlZGVudGlhbFdpdGhMaW5rIiwiZW1haWxMaW5rIiwiYWN0aW9uQ29kZVVybCIsIkVNQUlMX1BBU1NXT1JEX1NJR05fSU5fTUVUSE9EIiwiRU1BSUxfTElOS19TSUdOX0lOX01FVEhPRCIsIkZlZGVyYXRlZEF1dGhQcm92aWRlciIsImRlZmF1bHRMYW5ndWFnZUNvZGUiLCJjdXN0b21QYXJhbWV0ZXJzIiwic2V0RGVmYXVsdExhbmd1YWdlIiwic2V0Q3VzdG9tUGFyYW1ldGVycyIsImN1c3RvbU9BdXRoUGFyYW1ldGVycyIsImdldEN1c3RvbVBhcmFtZXRlcnMiLCJCYXNlT0F1dGhQcm92aWRlciIsInNjb3BlcyIsImFkZFNjb3BlIiwic2NvcGUiLCJnZXRTY29wZXMiLCJPQXV0aFByb3ZpZGVyIiwiY3JlZGVudGlhbEZyb21KU09OIiwiX2NyZWRlbnRpYWwiLCJyYXdOb25jZSIsImNyZWRlbnRpYWxGcm9tUmVzdWx0IiwidXNlckNyZWRlbnRpYWwiLCJvYXV0aENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0IiwiY3JlZGVudGlhbEZyb21FcnJvciIsInRva2VuUmVzcG9uc2UiLCJvYXV0aElkVG9rZW4iLCJvYXV0aEFjY2Vzc1Rva2VuIiwiRmFjZWJvb2tBdXRoUHJvdmlkZXIiLCJGQUNFQk9PS19TSUdOX0lOX01FVEhPRCIsImNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0IiwiR29vZ2xlQXV0aFByb3ZpZGVyIiwiR09PR0xFX1NJR05fSU5fTUVUSE9EIiwiR2l0aHViQXV0aFByb3ZpZGVyIiwiR0lUSFVCX1NJR05fSU5fTUVUSE9EIiwiSURQX1JFUVVFU1RfVVJJIiwiU0FNTEF1dGhDcmVkZW50aWFsIiwiX2NyZWF0ZSIsIlNBTUxfUFJPVklERVJfUFJFRklYIiwiU0FNTEF1dGhQcm92aWRlciIsInNhbWxDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCIsIlR3aXR0ZXJBdXRoUHJvdmlkZXIiLCJUV0lUVEVSX1NJR05fSU5fTUVUSE9EIiwic2lnblVwIiwiVXNlckNyZWRlbnRpYWxJbXBsIiwib3BlcmF0aW9uVHlwZSIsInByb3ZpZGVySWRGb3JSZXNwb25zZSIsInVzZXJDcmVkIiwiX2Zvck9wZXJhdGlvbiIsInNpZ25JbkFub255bW91c2x5IiwiTXVsdGlGYWN0b3JFcnJvciIsInNldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwiX2Zyb21FcnJvckFuZE9wZXJhdGlvbiIsIl9wcm9jZXNzQ3JlZGVudGlhbFNhdmluZ01mYUNvbnRleHRJZk5lY2Vzc2FyeSIsImlkVG9rZW5Qcm92aWRlciIsInByb3ZpZGVyRGF0YUFzTmFtZXMiLCJTZXQiLCJwaWQiLCJ1bmxpbmsiLCJfYXNzZXJ0TGlua2VkU3RhdHVzIiwiZGVsZXRlUHJvdmlkZXIiLCJwcm92aWRlcnNMZWZ0IiwicGQiLCJoYXMiLCJfbGluayIsImV4cGVjdGVkIiwicHJvdmlkZXJJZHMiLCJfcmVhdXRoZW50aWNhdGUiLCJwYXJzZWQiLCJzdWIiLCJfc2lnbkluV2l0aENyZWRlbnRpYWwiLCJzaWduSW5XaXRoQ3JlZGVudGlhbCIsImxpbmtXaXRoQ3JlZGVudGlhbCIsInJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWwiLCJzaWduSW5XaXRoQ3VzdG9tVG9rZW4kMSIsInNpZ25JbldpdGhDdXN0b21Ub2tlbiIsImN1c3RvbVRva2VuIiwiTXVsdGlGYWN0b3JJbmZvSW1wbCIsImZhY3RvcklkIiwibWZhRW5yb2xsbWVudElkIiwiZW5yb2xsbWVudFRpbWUiLCJlbnJvbGxlZEF0IiwiX2Zyb21TZXJ2ZXJSZXNwb25zZSIsImVucm9sbG1lbnQiLCJQaG9uZU11bHRpRmFjdG9ySW5mb0ltcGwiLCJUb3RwTXVsdGlGYWN0b3JJbmZvSW1wbCIsInBob25lSW5mbyIsIl9zZXRBY3Rpb25Db2RlU2V0dGluZ3NPblJlcXVlc3QiLCJhY3Rpb25Db2RlU2V0dGluZ3MiLCJkeW5hbWljTGlua0RvbWFpbiIsImNhbkhhbmRsZUNvZGVJbkFwcCIsImhhbmRsZUNvZGVJbkFwcCIsImlPUyIsImJ1bmRsZUlkIiwiaU9TQnVuZGxlSWQiLCJhbmRyb2lkIiwicGFja2FnZU5hbWUiLCJhbmRyb2lkSW5zdGFsbEFwcCIsImluc3RhbGxBcHAiLCJhbmRyb2lkTWluaW11bVZlcnNpb25Db2RlIiwibWluaW11bVZlcnNpb24iLCJhbmRyb2lkUGFja2FnZU5hbWUiLCJyZWNhY2hlUGFzc3dvcmRQb2xpY3kiLCJzZW5kUGFzc3dvcmRSZXNldEVtYWlsIiwicmVxdWVzdFR5cGUiLCJjb25maXJtUGFzc3dvcmRSZXNldCIsIm5ld1Bhc3N3b3JkIiwiYXBwbHlBY3Rpb25Db2RlIiwiY2hlY2tBY3Rpb25Db2RlIiwiYXV0aE1vZHVsYXIiLCJuZXdFbWFpbCIsIm1mYUluZm8iLCJtdWx0aUZhY3RvckluZm8iLCJkYXRhIiwicHJldmlvdXNFbWFpbCIsInZlcmlmeVBhc3N3b3JkUmVzZXRDb2RlIiwiY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkIiwic2lnblVwUmVzcG9uc2UiLCJzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZCIsInNlbmRTaWduSW5MaW5rVG9FbWFpbCIsInNldEFjdGlvbkNvZGVTZXR0aW5ncyIsImlzU2lnbkluV2l0aEVtYWlsTGluayIsInNpZ25JbldpdGhFbWFpbExpbmsiLCJjcmVhdGVBdXRoVXJpIiwiZmV0Y2hTaWduSW5NZXRob2RzRm9yRW1haWwiLCJjb250aW51ZVVyaSIsImlkZW50aWZpZXIiLCJzaWduaW5NZXRob2RzIiwic2VuZEVtYWlsVmVyaWZpY2F0aW9uIiwidmVyaWZ5QmVmb3JlVXBkYXRlRW1haWwiLCJ1cGRhdGVQcm9maWxlJDEiLCJ1cGRhdGVQcm9maWxlIiwicHJvZmlsZVJlcXVlc3QiLCJwYXNzd29yZFByb3ZpZGVyIiwiZmluZCIsInVwZGF0ZUVtYWlsIiwidXBkYXRlRW1haWxPclBhc3N3b3JkIiwidXBkYXRlUGFzc3dvcmQiLCJwcm9maWxlIiwicmF3VXNlckluZm8iLCJpc05ld1VzZXIiLCJraW5kIiwiZmlsdGVyZWRQcm92aWRlcklkIiwiR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyIsIkZhY2Vib29rQWRkaXRpb25hbFVzZXJJbmZvIiwiR2l0aHViQWRkaXRpb25hbFVzZXJJbmZvIiwiR29vZ2xlQWRkaXRpb25hbFVzZXJJbmZvIiwiVHdpdHRlckFkZGl0aW9uYWxVc2VySW5mbyIsInNjcmVlbk5hbWUiLCJGZWRlcmF0ZWRBZGRpdGlvbmFsVXNlckluZm9XaXRoVXNlcm5hbWUiLCJ1c2VybmFtZSIsImxvZ2luIiwiZ2V0QWRkaXRpb25hbFVzZXJJbmZvIiwiaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZyIsImRlbGV0ZVVzZXIiLCJNdWx0aUZhY3RvclNlc3Npb25JbXBsIiwiX2Zyb21JZHRva2VuIiwiX2Zyb21NZmFQZW5kaW5nQ3JlZGVudGlhbCIsIm1mYVBlbmRpbmdDcmVkZW50aWFsIiwibXVsdGlGYWN0b3JTZXNzaW9uIiwicGVuZGluZ0NyZWRlbnRpYWwiLCJNdWx0aUZhY3RvclJlc29sdmVySW1wbCIsInNlc3Npb24iLCJoaW50cyIsInNpZ25JblJlc29sdmVyIiwiX2Zyb21FcnJvciIsIm1mYVJlc3BvbnNlIiwiX3Byb2Nlc3MiLCJyZXNvbHZlU2lnbkluIiwiYXNzZXJ0aW9uRXh0ZXJuIiwiZ2V0TXVsdGlGYWN0b3JSZXNvbHZlciIsImVycm9ySW50ZXJuYWwiLCJzdGFydEVucm9sbFRvdHBNZmEiLCJmaW5hbGl6ZUVucm9sbFRvdHBNZmEiLCJ3aXRoZHJhd01mYSIsIk11bHRpRmFjdG9yVXNlckltcGwiLCJlbnJvbGxlZEZhY3RvcnMiLCJfZnJvbVVzZXIiLCJnZXRTZXNzaW9uIiwiZW5yb2xsIiwiZmluYWxpemVNZmFSZXNwb25zZSIsInVuZW5yb2xsIiwiaW5mb09yVWlkIiwibXVsdGlGYWN0b3JVc2VyQ2FjaGUiLCJXZWFrTWFwIiwibXVsdGlGYWN0b3IiLCJ1c2VyTW9kdWxhciIsIkF1dGhJbnRlcm9wIiwiaW50ZXJuYWxMaXN0ZW5lcnMiLCJnZXRVaWQiLCJhc3NlcnRBdXRoQ29uZmlndXJlZCIsImFkZEF1dGhUb2tlbkxpc3RlbmVyIiwibGlzdGVuZXIiLCJ1cGRhdGVQcm9hY3RpdmVSZWZyZXNoIiwicmVtb3ZlQXV0aFRva2VuTGlzdGVuZXIiLCJzaXplIiwiZ2V0VmVyc2lvbkZvclBsYXRmb3JtIiwicmVnaXN0ZXJBdXRoIiwiY29udGFpbmVyIiwiZ2V0UHJvdmlkZXIiLCJzZXRJbnN0YW50aWF0aW9uTW9kZSIsInNldEluc3RhbmNlQ3JlYXRlZENhbGxiYWNrIiwiX2luc3RhbmNlSWRlbnRpZmllciIsIl9pbnN0YW5jZSIsImF1dGhJbnRlcm5hbFByb3ZpZGVyIiwiZ2V0QXV0aCIsImF1dGhFbXVsYXRvckhvc3QiLCJOT1RfQVZBSUxBQkxFX0VSUk9SIiwiZmFpbCIsIkZhaWxDbGFzcyIsImJyb3dzZXJMb2NhbFBlcnNpc3RlbmNlIiwiYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSIsImluZGV4ZWREQkxvY2FsUGVyc2lzdGVuY2UiLCJicm93c2VyUG9wdXBSZWRpcmVjdFJlc29sdmVyIiwiUGhvbmVBdXRoUHJvdmlkZXIiLCJzaWduSW5XaXRoUGhvbmVOdW1iZXIiLCJsaW5rV2l0aFBob25lTnVtYmVyIiwicmVhdXRoZW50aWNhdGVXaXRoUGhvbmVOdW1iZXIiLCJ1cGRhdGVQaG9uZU51bWJlciIsInNpZ25JbldpdGhQb3B1cCIsImxpbmtXaXRoUG9wdXAiLCJyZWF1dGhlbnRpY2F0ZVdpdGhQb3B1cCIsInNpZ25JbldpdGhSZWRpcmVjdCIsImxpbmtXaXRoUmVkaXJlY3QiLCJyZWF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdCIsImdldFJlZGlyZWN0UmVzdWx0IiwiUmVjYXB0Y2hhVmVyaWZpZXIiLCJQaG9uZU11bHRpRmFjdG9yR2VuZXJhdG9yIiwiZmluYWxpemVTaWduSW5Ub3RwTWZhIiwiTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIiwiX2ZpbmFsaXplRW5yb2xsIiwiX2ZpbmFsaXplU2lnbkluIiwiVG90cE11bHRpRmFjdG9yR2VuZXJhdG9yIiwiYXNzZXJ0aW9uRm9yRW5yb2xsbWVudCIsIm9uZVRpbWVQYXNzd29yZCIsIlRvdHBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwiLCJfZnJvbVNlY3JldCIsImFzc2VydGlvbkZvclNpZ25JbiIsImVucm9sbG1lbnRJZCIsIl9mcm9tRW5yb2xsbWVudElkIiwiZ2VuZXJhdGVTZWNyZXQiLCJtZmFTZXNzaW9uIiwidG90cEVucm9sbG1lbnRJbmZvIiwiVG90cFNlY3JldCIsIl9mcm9tU3RhcnRUb3RwTWZhRW5yb2xsbWVudFJlc3BvbnNlIiwiRkFDVE9SX0lEIiwib3RwIiwidG90cFZlcmlmaWNhdGlvbkluZm8iLCJfbWFrZVRvdHBWZXJpZmljYXRpb25JbmZvIiwic2VjcmV0S2V5IiwiaGFzaGluZ0FsZ29yaXRobSIsImNvZGVMZW5ndGgiLCJjb2RlSW50ZXJ2YWxTZWNvbmRzIiwiZW5yb2xsbWVudENvbXBsZXRpb25EZWFkbGluZSIsInRvdHBTZXNzaW9uSW5mbyIsInNoYXJlZFNlY3JldEtleSIsInZlcmlmaWNhdGlvbkNvZGVMZW5ndGgiLCJwZXJpb2RTZWMiLCJmaW5hbGl6ZUVucm9sbG1lbnRUaW1lIiwiZ2VuZXJhdGVRckNvZGVVcmwiLCJhY2NvdW50TmFtZSIsImlzc3VlciIsInVzZURlZmF1bHRzIiwiX2lzRW1wdHlTdHJpbmciLCJpbnB1dCIsIiQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiTiIsIk8iLCJQIiwiUSIsIlIiLCJTIiwiVCIsIlUiLCJWIiwiVyIsIlgiLCJZIiwiWiIsImEiLCJhMCIsImExIiwiYTIiLCJhMyIsImE0IiwiYTUiLCJhNiIsImE3IiwiYTgiLCJhOSIsImFBIiwiYUIiLCJhQyIsImFEIiwiYUUiLCJhRiIsImFHIiwiYUgiLCJhSSIsImFKIiwiYUsiLCJhTCIsImFNIiwiYU4iLCJhTyIsImFQIiwiYVEiLCJhUiIsImFTIiwiYVQiLCJhVSIsImFWIiwiYWEiLCJhYiIsImFjIiwiYWQiLCJhZSIsImFmIiwiYWciLCJhaCIsImFpIiwiYWoiLCJhayIsImFsIiwiYW0iLCJhbiIsImFvIiwiYXAiLCJhcSIsImFyIiwiYXMiLCJhdCIsImF1IiwiYXYiLCJhdyIsImF4IiwiYXkiLCJheiIsImIiLCJjIiwiZCIsImYiLCJnIiwiaCIsImoiLCJrIiwibCIsIm0iLCJxIiwiciIsInMiLCJ0IiwidSIsInYiLCJ3IiwieCIsInkiLCJ6Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/auth/dist/node-esm/totp-d821ac28.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/component/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: () => (/* binding */ Component),\n/* harmony export */   ComponentContainer: () => (/* binding */ ComponentContainer),\n/* harmony export */   Provider: () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */ class Component {\n    /**\r\n     *\r\n     * @param name The public service name, e.g. app, auth, firestore, database\r\n     * @param instanceFactory Service factory responsible for creating the public interface\r\n     * @param type whether the service provided by the component is public or private\r\n     */ constructor(name, instanceFactory, type){\n        this.name = name;\n        this.instanceFactory = instanceFactory;\n        this.type = type;\n        this.multipleInstances = false;\n        /**\r\n         * Properties to be added to the service namespace\r\n         */ this.serviceProps = {};\n        this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */ ;\n        this.onInstanceCreated = null;\n    }\n    setInstantiationMode(mode) {\n        this.instantiationMode = mode;\n        return this;\n    }\n    setMultipleInstances(multipleInstances) {\n        this.multipleInstances = multipleInstances;\n        return this;\n    }\n    setServiceProps(props) {\n        this.serviceProps = props;\n        return this;\n    }\n    setInstanceCreatedCallback(callback) {\n        this.onInstanceCreated = callback;\n        return this;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const DEFAULT_ENTRY_NAME = \"[DEFAULT]\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */ class Provider {\n    constructor(name, container){\n        this.name = name;\n        this.container = container;\n        this.component = null;\n        this.instances = new Map();\n        this.instancesDeferred = new Map();\n        this.instancesOptions = new Map();\n        this.onInitCallbacks = new Map();\n    }\n    /**\r\n     * @param identifier A provider can provide mulitple instances of a service\r\n     * if this.component.multipleInstances is true.\r\n     */ get(identifier) {\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\n            const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\n            if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n                // initialize the service if it can be auto-initialized\n                try {\n                    const instance = this.getOrInitializeService({\n                        instanceIdentifier: normalizedIdentifier\n                    });\n                    if (instance) {\n                        deferred.resolve(instance);\n                    }\n                } catch (e) {\n                // when the instance factory throws an exception during get(), it should not cause\n                // a fatal error. We just return the unresolved promise in this case.\n                }\n            }\n        }\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\n    }\n    getImmediate(options) {\n        var _a;\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n        if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n            try {\n                return this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n            } catch (e) {\n                if (optional) {\n                    return null;\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\n            if (optional) {\n                return null;\n            } else {\n                throw Error(`Service ${this.name} is not available`);\n            }\n        }\n    }\n    getComponent() {\n        return this.component;\n    }\n    setComponent(component) {\n        if (component.name !== this.name) {\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\n        }\n        if (this.component) {\n            throw Error(`Component for ${this.name} has already been provided`);\n        }\n        this.component = component;\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n        if (!this.shouldAutoInitialize()) {\n            return;\n        }\n        // if the service is eager, initialize the default instance\n        if (isComponentEager(component)) {\n            try {\n                this.getOrInitializeService({\n                    instanceIdentifier: DEFAULT_ENTRY_NAME\n                });\n            } catch (e) {\n            // when the instance factory for an eager Component throws an exception during the eager\n            // initialization, it should not cause a fatal error.\n            // TODO: Investigate if we need to make it configurable, because some component may want to cause\n            // a fatal error in this case?\n            }\n        }\n        // Create service instances for the pending promises and resolve them\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\n        // and all promises with resolve with it regardless of the identifier.\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()){\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            try {\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n                const instance = this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n                instanceDeferred.resolve(instance);\n            } catch (e) {\n            // when the instance factory throws an exception, it should not cause\n            // a fatal error. We just leave the promise unresolved.\n            }\n        }\n    }\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\n        this.instancesDeferred.delete(identifier);\n        this.instancesOptions.delete(identifier);\n        this.instances.delete(identifier);\n    }\n    // app.delete() will call this method on every provider to delete the services\n    // TODO: should we mark the provider as deleted?\n    async delete() {\n        const services = Array.from(this.instances.values());\n        await Promise.all([\n            ...services.filter((service)=>\"INTERNAL\" in service) // legacy services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map((service)=>service.INTERNAL.delete()),\n            ...services.filter((service)=>\"_delete\" in service) // modularized services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map((service)=>service._delete())\n        ]);\n    }\n    isComponentSet() {\n        return this.component != null;\n    }\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instances.has(identifier);\n    }\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instancesOptions.get(identifier) || {};\n    }\n    initialize(opts = {}) {\n        const { options = {} } = opts;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n        if (this.isInitialized(normalizedIdentifier)) {\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\n        }\n        if (!this.isComponentSet()) {\n            throw Error(`Component ${this.name} has not been registered yet`);\n        }\n        const instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier,\n            options\n        });\n        // resolve any pending promise waiting for the service instance\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()){\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\n                instanceDeferred.resolve(instance);\n            }\n        }\n        return instance;\n    }\n    /**\r\n     *\r\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n     *\r\n     * @param identifier An optional instance identifier\r\n     * @returns a function to unregister the callback\r\n     */ onInit(callback, identifier) {\n        var _a;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\n        existingCallbacks.add(callback);\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n        const existingInstance = this.instances.get(normalizedIdentifier);\n        if (existingInstance) {\n            callback(existingInstance, normalizedIdentifier);\n        }\n        return ()=>{\n            existingCallbacks.delete(callback);\n        };\n    }\n    /**\r\n     * Invoke onInit callbacks synchronously\r\n     * @param instance the service instance`\r\n     */ invokeOnInitCallbacks(instance, identifier) {\n        const callbacks = this.onInitCallbacks.get(identifier);\n        if (!callbacks) {\n            return;\n        }\n        for (const callback of callbacks){\n            try {\n                callback(instance, identifier);\n            } catch (_a) {\n            // ignore errors in the onInit callback\n            }\n        }\n    }\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\n        let instance = this.instances.get(instanceIdentifier);\n        if (!instance && this.component) {\n            instance = this.component.instanceFactory(this.container, {\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n                options\n            });\n            this.instances.set(instanceIdentifier, instance);\n            this.instancesOptions.set(instanceIdentifier, options);\n            /**\r\n             * Invoke onInit listeners.\r\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n             * while onInit listeners are registered by consumers of the provider.\r\n             */ this.invokeOnInitCallbacks(instance, instanceIdentifier);\n            /**\r\n             * Order is important\r\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n             * makes `isInitialized()` return true.\r\n             */ if (this.component.onInstanceCreated) {\n                try {\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n                } catch (_a) {\n                // ignore errors in the onInstanceCreatedCallback\n                }\n            }\n        }\n        return instance || null;\n    }\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\n        if (this.component) {\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n        } else {\n            return identifier; // assume multiple instances are supported before the component is provided.\n        }\n    }\n    shouldAutoInitialize() {\n        return !!this.component && this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */ ;\n    }\n}\n// undefined should be passed to the service factory for the default instance\nfunction normalizeIdentifierForFactory(identifier) {\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\nfunction isComponentEager(component) {\n    return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */ ;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */ class ComponentContainer {\n    constructor(name){\n        this.name = name;\n        this.providers = new Map();\n    }\n    /**\r\n     *\r\n     * @param component Component being added\r\n     * @param overwrite When a component with the same name has already been registered,\r\n     * if overwrite is true: overwrite the existing component with the new component and create a new\r\n     * provider with the new component. It can be useful in tests where you want to use different mocks\r\n     * for different tests.\r\n     * if overwrite is false: throw an exception\r\n     */ addComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\n        }\n        provider.setComponent(component);\n    }\n    addOrOverwriteComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            // delete the existing provider from the container, so we can register the new component\n            this.providers.delete(component.name);\n        }\n        this.addComponent(component);\n    }\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */ getProvider(name) {\n        if (this.providers.has(name)) {\n            return this.providers.get(name);\n        }\n        // create a Provider for a service that hasn't registered with Firebase\n        const provider = new Provider(name, this);\n        this.providers.set(name, provider);\n        return provider;\n    }\n    getProviders() {\n        return Array.from(this.providers.values());\n    }\n}\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEM7QUFFMUM7O0NBRUMsR0FDRCxNQUFNQztJQUNGOzs7OztLQUtDLEdBQ0RDLFlBQVlDLElBQUksRUFBRUMsZUFBZSxFQUFFQyxJQUFJLENBQUU7UUFDckMsSUFBSSxDQUFDRixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxlQUFlLEdBQUdBO1FBQ3ZCLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekI7O1NBRUMsR0FDRCxJQUFJLENBQUNDLFlBQVksR0FBRyxDQUFDO1FBQ3JCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUcsT0FBTywwQkFBMEI7UUFDMUQsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztJQUM3QjtJQUNBQyxxQkFBcUJDLElBQUksRUFBRTtRQUN2QixJQUFJLENBQUNILGlCQUFpQixHQUFHRztRQUN6QixPQUFPLElBQUk7SUFDZjtJQUNBQyxxQkFBcUJOLGlCQUFpQixFQUFFO1FBQ3BDLElBQUksQ0FBQ0EsaUJBQWlCLEdBQUdBO1FBQ3pCLE9BQU8sSUFBSTtJQUNmO0lBQ0FPLGdCQUFnQkMsS0FBSyxFQUFFO1FBQ25CLElBQUksQ0FBQ1AsWUFBWSxHQUFHTztRQUNwQixPQUFPLElBQUk7SUFDZjtJQUNBQywyQkFBMkJDLFFBQVEsRUFBRTtRQUNqQyxJQUFJLENBQUNQLGlCQUFpQixHQUFHTztRQUN6QixPQUFPLElBQUk7SUFDZjtBQUNKO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTUMscUJBQXFCO0FBRTNCOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEOzs7Q0FHQyxHQUNELE1BQU1DO0lBQ0ZoQixZQUFZQyxJQUFJLEVBQUVnQixTQUFTLENBQUU7UUFDekIsSUFBSSxDQUFDaEIsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ2dC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T0FBT0E7SUFDWDtJQUNBRyxlQUFlO1FBQ1gsT0FBTzlCLE1BQU1DLElBQUksQ0FBQyxJQUFJLENBQUN3QixTQUFTLENBQUN2QixNQUFNO0lBQzNDO0FBQ0o7QUFFbUQsQ0FDbkQseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJlZS1uZXh0anMtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9jb21wb25lbnQvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcz8yNDNjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERlZmVycmVkIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuXG4vKipcclxuICogQ29tcG9uZW50IGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiBgYXV0aGAsIGBhdXRoLWludGVybmFsYFxyXG4gKi9cclxuY2xhc3MgQ29tcG9uZW50IHtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBwdWJsaWMgc2VydmljZSBuYW1lLCBlLmcuIGFwcCwgYXV0aCwgZmlyZXN0b3JlLCBkYXRhYmFzZVxyXG4gICAgICogQHBhcmFtIGluc3RhbmNlRmFjdG9yeSBTZXJ2aWNlIGZhY3RvcnkgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoZSBwdWJsaWMgaW50ZXJmYWNlXHJcbiAgICAgKiBAcGFyYW0gdHlwZSB3aGV0aGVyIHRoZSBzZXJ2aWNlIHByb3ZpZGVkIGJ5IHRoZSBjb21wb25lbnQgaXMgcHVibGljIG9yIHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmFtZSwgaW5zdGFuY2VGYWN0b3J5LCB0eXBlKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlRmFjdG9yeSA9IGluc3RhbmNlRmFjdG9yeTtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMubXVsdGlwbGVJbnN0YW5jZXMgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9wZXJ0aWVzIHRvIGJlIGFkZGVkIHRvIHRoZSBzZXJ2aWNlIG5hbWVzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2VydmljZVByb3BzID0ge307XHJcbiAgICAgICAgdGhpcy5pbnN0YW50aWF0aW9uTW9kZSA9IFwiTEFaWVwiIC8qIEluc3RhbnRpYXRpb25Nb2RlLkxBWlkgKi87XHJcbiAgICAgICAgdGhpcy5vbkluc3RhbmNlQ3JlYXRlZCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBzZXRJbnN0YW50aWF0aW9uTW9kZShtb2RlKSB7XHJcbiAgICAgICAgdGhpcy5pbnN0YW50aWF0aW9uTW9kZSA9IG1vZGU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzZXRNdWx0aXBsZUluc3RhbmNlcyhtdWx0aXBsZUluc3RhbmNlcykge1xyXG4gICAgICAgIHRoaXMubXVsdGlwbGVJbnN0YW5jZXMgPSBtdWx0aXBsZUluc3RhbmNlcztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHNldFNlcnZpY2VQcm9wcyhwcm9wcykge1xyXG4gICAgICAgIHRoaXMuc2VydmljZVByb3BzID0gcHJvcHM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzZXRJbnN0YW5jZUNyZWF0ZWRDYWxsYmFjayhjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMub25JbnN0YW5jZUNyZWF0ZWQgPSBjYWxsYmFjaztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0VOVFJZX05BTUUgPSAnW0RFRkFVTFRdJztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGVyIGZvciBpbnN0YW5jZSBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gJ2F1dGgnLCAnYXV0aC1pbnRlcm5hbCdcclxuICogTmFtZVNlcnZpY2VNYXBwaW5nW1RdIGlzIGFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiB0aGUgaW5zdGFuY2VcclxuICovXHJcbmNsYXNzIFByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGNvbnRhaW5lcikge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNPcHRpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMub25Jbml0Q2FsbGJhY2tzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gaWRlbnRpZmllciBBIHByb3ZpZGVyIGNhbiBwcm92aWRlIG11bGl0cGxlIGluc3RhbmNlcyBvZiBhIHNlcnZpY2VcclxuICAgICAqIGlmIHRoaXMuY29tcG9uZW50Lm11bHRpcGxlSW5zdGFuY2VzIGlzIHRydWUuXHJcbiAgICAgKi9cclxuICAgIGdldChpZGVudGlmaWVyKSB7XHJcbiAgICAgICAgLy8gaWYgbXVsdGlwbGVJbnN0YW5jZXMgaXMgbm90IHN1cHBvcnRlZCwgdXNlIHRoZSBkZWZhdWx0IG5hbWVcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xyXG4gICAgICAgIGlmICghdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5oYXMobm9ybWFsaXplZElkZW50aWZpZXIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuc2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyLCBkZWZlcnJlZCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemUgdGhlIHNlcnZpY2UgaWYgaXQgY2FuIGJlIGF1dG8taW5pdGlhbGl6ZWRcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgaW5zdGFuY2UgZmFjdG9yeSB0aHJvd3MgYW4gZXhjZXB0aW9uIGR1cmluZyBnZXQoKSwgaXQgc2hvdWxkIG5vdCBjYXVzZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgZmF0YWwgZXJyb3IuIFdlIGp1c3QgcmV0dXJuIHRoZSB1bnJlc29sdmVkIHByb21pc2UgaW4gdGhpcyBjYXNlLlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmdldChub3JtYWxpemVkSWRlbnRpZmllcikucHJvbWlzZTtcclxuICAgIH1cclxuICAgIGdldEltbWVkaWF0ZShvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIC8vIGlmIG11bHRpcGxlSW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgZGVmYXVsdCBuYW1lXHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWRlbnRpZmllcik7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uYWwgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub3B0aW9uYWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpIHx8XHJcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQXV0b0luaXRpYWxpemUoKSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSW4gY2FzZSBhIGNvbXBvbmVudCBpcyBub3QgaW5pdGlhbGl6ZWQgYW5kIHNob3VsZC9jYW4gbm90IGJlIGF1dG8taW5pdGlhbGl6ZWQgYXQgdGhlIG1vbWVudCwgcmV0dXJuIG51bGwgaWYgdGhlIG9wdGlvbmFsIGZsYWcgaXMgc2V0LCBvciB0aHJvd1xyXG4gICAgICAgICAgICBpZiAob3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFNlcnZpY2UgJHt0aGlzLm5hbWV9IGlzIG5vdCBhdmFpbGFibGVgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldENvbXBvbmVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQ7XHJcbiAgICB9XHJcbiAgICBzZXRDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudC5uYW1lICE9PSB0aGlzLm5hbWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE1pc21hdGNoaW5nIENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBmb3IgUHJvdmlkZXIgJHt0aGlzLm5hbWV9LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYENvbXBvbmVudCBmb3IgJHt0aGlzLm5hbWV9IGhhcyBhbHJlYWR5IGJlZW4gcHJvdmlkZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgLy8gcmV0dXJuIGVhcmx5IHdpdGhvdXQgYXR0ZW1wdGluZyB0byBpbml0aWFsaXplIHRoZSBjb21wb25lbnQgaWYgdGhlIGNvbXBvbmVudCByZXF1aXJlcyBleHBsaWNpdCBpbml0aWFsaXphdGlvbiAoY2FsbGluZyBgUHJvdmlkZXIuaW5pdGlhbGl6ZSgpYClcclxuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkQXV0b0luaXRpYWxpemUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHRoZSBzZXJ2aWNlIGlzIGVhZ2VyLCBpbml0aWFsaXplIHRoZSBkZWZhdWx0IGluc3RhbmNlXHJcbiAgICAgICAgaWYgKGlzQ29tcG9uZW50RWFnZXIoY29tcG9uZW50KSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHsgaW5zdGFuY2VJZGVudGlmaWVyOiBERUZBVUxUX0VOVFJZX05BTUUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgZm9yIGFuIGVhZ2VyIENvbXBvbmVudCB0aHJvd3MgYW4gZXhjZXB0aW9uIGR1cmluZyB0aGUgZWFnZXJcclxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemF0aW9uLCBpdCBzaG91bGQgbm90IGNhdXNlIGEgZmF0YWwgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBpZiB3ZSBuZWVkIHRvIG1ha2UgaXQgY29uZmlndXJhYmxlLCBiZWNhdXNlIHNvbWUgY29tcG9uZW50IG1heSB3YW50IHRvIGNhdXNlXHJcbiAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yIGluIHRoaXMgY2FzZT9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDcmVhdGUgc2VydmljZSBpbnN0YW5jZXMgZm9yIHRoZSBwZW5kaW5nIHByb21pc2VzIGFuZCByZXNvbHZlIHRoZW1cclxuICAgICAgICAvLyBOT1RFOiBpZiB0aGlzLm11bHRpcGxlSW5zdGFuY2VzIGlzIGZhbHNlLCBvbmx5IHRoZSBkZWZhdWx0IGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZFxyXG4gICAgICAgIC8vIGFuZCBhbGwgcHJvbWlzZXMgd2l0aCByZXNvbHZlIHdpdGggaXQgcmVnYXJkbGVzcyBvZiB0aGUgaWRlbnRpZmllci5cclxuICAgICAgICBmb3IgKGNvbnN0IFtpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlRGVmZXJyZWRdIG9mIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIGBnZXRPckluaXRpYWxpemVTZXJ2aWNlKClgIHNob3VsZCBhbHdheXMgcmV0dXJuIGEgdmFsaWQgaW5zdGFuY2Ugc2luY2UgYSBjb21wb25lbnQgaXMgZ3VhcmFudGVlZC4gdXNlICEgdG8gbWFrZSB0eXBlc2NyaXB0IGhhcHB5LlxyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VEZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgaW5zdGFuY2UgZmFjdG9yeSB0aHJvd3MgYW4gZXhjZXB0aW9uLCBpdCBzaG91bGQgbm90IGNhdXNlXHJcbiAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yLiBXZSBqdXN0IGxlYXZlIHRoZSBwcm9taXNlIHVucmVzb2x2ZWQuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjbGVhckluc3RhbmNlKGlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcclxuICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmRlbGV0ZShpZGVudGlmaWVyKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuZGVsZXRlKGlkZW50aWZpZXIpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzLmRlbGV0ZShpZGVudGlmaWVyKTtcclxuICAgIH1cclxuICAgIC8vIGFwcC5kZWxldGUoKSB3aWxsIGNhbGwgdGhpcyBtZXRob2Qgb24gZXZlcnkgcHJvdmlkZXIgdG8gZGVsZXRlIHRoZSBzZXJ2aWNlc1xyXG4gICAgLy8gVE9ETzogc2hvdWxkIHdlIG1hcmsgdGhlIHByb3ZpZGVyIGFzIGRlbGV0ZWQ/XHJcbiAgICBhc3luYyBkZWxldGUoKSB7XHJcbiAgICAgICAgY29uc3Qgc2VydmljZXMgPSBBcnJheS5mcm9tKHRoaXMuaW5zdGFuY2VzLnZhbHVlcygpKTtcclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgIC4uLnNlcnZpY2VzXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHNlcnZpY2UgPT4gJ0lOVEVSTkFMJyBpbiBzZXJ2aWNlKSAvLyBsZWdhY3kgc2VydmljZXNcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICAubWFwKHNlcnZpY2UgPT4gc2VydmljZS5JTlRFUk5BTC5kZWxldGUoKSksXHJcbiAgICAgICAgICAgIC4uLnNlcnZpY2VzXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHNlcnZpY2UgPT4gJ19kZWxldGUnIGluIHNlcnZpY2UpIC8vIG1vZHVsYXJpemVkIHNlcnZpY2VzXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgLm1hcChzZXJ2aWNlID0+IHNlcnZpY2UuX2RlbGV0ZSgpKVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgaXNDb21wb25lbnRTZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50ICE9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpc0luaXRpYWxpemVkKGlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXMuaGFzKGlkZW50aWZpZXIpO1xyXG4gICAgfVxyXG4gICAgZ2V0T3B0aW9ucyhpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzT3B0aW9ucy5nZXQoaWRlbnRpZmllcikgfHwge307XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKG9wdHMgPSB7fSkge1xyXG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyA9IHt9IH0gPSBvcHRzO1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIob3B0cy5pbnN0YW5jZUlkZW50aWZpZXIpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGAke3RoaXMubmFtZX0oJHtub3JtYWxpemVkSWRlbnRpZmllcn0pIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29tcG9uZW50U2V0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYENvbXBvbmVudCAke3RoaXMubmFtZX0gaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQgeWV0YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcclxuICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllcixcclxuICAgICAgICAgICAgb3B0aW9uc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIHJlc29sdmUgYW55IHBlbmRpbmcgcHJvbWlzZSB3YWl0aW5nIGZvciB0aGUgc2VydmljZSBpbnN0YW5jZVxyXG4gICAgICAgIGZvciAoY29uc3QgW2luc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2VEZWZlcnJlZF0gb2YgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZERlZmVycmVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkSWRlbnRpZmllciA9PT0gbm9ybWFsaXplZERlZmVycmVkSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VEZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkICBhZnRlciB0aGUgcHJvdmlkZXIgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgYnkgY2FsbGluZyBwcm92aWRlci5pbml0aWFsaXplKCkuXHJcbiAgICAgKiBUaGUgZnVuY3Rpb24gaXMgaW52b2tlZCBTWU5DSFJPTk9VU0xZLCBzbyBpdCBzaG91bGQgbm90IGV4ZWN1dGUgYW55IGxvbmdydW5uaW5nIHRhc2tzIGluIG9yZGVyIHRvIG5vdCBibG9jayB0aGUgcHJvZ3JhbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWRlbnRpZmllciBBbiBvcHRpb25hbCBpbnN0YW5jZSBpZGVudGlmaWVyXHJcbiAgICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVucmVnaXN0ZXIgdGhlIGNhbGxiYWNrXHJcbiAgICAgKi9cclxuICAgIG9uSW5pdChjYWxsYmFjaywgaWRlbnRpZmllcikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FsbGJhY2tzID0gKF9hID0gdGhpcy5vbkluaXRDYWxsYmFja3MuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFNldCgpO1xyXG4gICAgICAgIGV4aXN0aW5nQ2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XHJcbiAgICAgICAgdGhpcy5vbkluaXRDYWxsYmFja3Muc2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyLCBleGlzdGluZ0NhbGxiYWNrcyk7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VzLmdldChub3JtYWxpemVkSWRlbnRpZmllcik7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soZXhpc3RpbmdJbnN0YW5jZSwgbm9ybWFsaXplZElkZW50aWZpZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBleGlzdGluZ0NhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2spO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZSBvbkluaXQgY2FsbGJhY2tzIHN5bmNocm9ub3VzbHlcclxuICAgICAqIEBwYXJhbSBpbnN0YW5jZSB0aGUgc2VydmljZSBpbnN0YW5jZWBcclxuICAgICAqL1xyXG4gICAgaW52b2tlT25Jbml0Q2FsbGJhY2tzKGluc3RhbmNlLCBpZGVudGlmaWVyKSB7XHJcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5vbkluaXRDYWxsYmFja3MuZ2V0KGlkZW50aWZpZXIpO1xyXG4gICAgICAgIGlmICghY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBjYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGluc3RhbmNlLCBpZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBlcnJvcnMgaW4gdGhlIG9uSW5pdCBjYWxsYmFja1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0T3JJbml0aWFsaXplU2VydmljZSh7IGluc3RhbmNlSWRlbnRpZmllciwgb3B0aW9ucyA9IHt9IH0pIHtcclxuICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlcy5nZXQoaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAoIWluc3RhbmNlICYmIHRoaXMuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlID0gdGhpcy5jb21wb25lbnQuaW5zdGFuY2VGYWN0b3J5KHRoaXMuY29udGFpbmVyLCB7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZUlkZW50aWZpZXJGb3JGYWN0b3J5KGluc3RhbmNlSWRlbnRpZmllciksXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlcy5zZXQoaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VzT3B0aW9ucy5zZXQoaW5zdGFuY2VJZGVudGlmaWVyLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEludm9rZSBvbkluaXQgbGlzdGVuZXJzLlxyXG4gICAgICAgICAgICAgKiBOb3RlIHRoaXMuY29tcG9uZW50Lm9uSW5zdGFuY2VDcmVhdGVkIGlzIGRpZmZlcmVudCwgd2hpY2ggaXMgdXNlZCBieSB0aGUgY29tcG9uZW50IGNyZWF0b3IsXHJcbiAgICAgICAgICAgICAqIHdoaWxlIG9uSW5pdCBsaXN0ZW5lcnMgYXJlIHJlZ2lzdGVyZWQgYnkgY29uc3VtZXJzIG9mIHRoZSBwcm92aWRlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuaW52b2tlT25Jbml0Q2FsbGJhY2tzKGluc3RhbmNlLCBpbnN0YW5jZUlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT3JkZXIgaXMgaW1wb3J0YW50XHJcbiAgICAgICAgICAgICAqIG9uSW5zdGFuY2VDcmVhdGVkKCkgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGlzLmluc3RhbmNlcy5zZXQoaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7IHdoaWNoXHJcbiAgICAgICAgICAgICAqIG1ha2VzIGBpc0luaXRpYWxpemVkKClgIHJldHVybiB0cnVlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50Lm9uSW5zdGFuY2VDcmVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Lm9uSW5zdGFuY2VDcmVhdGVkKHRoaXMuY29udGFpbmVyLCBpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBlcnJvcnMgaW4gdGhlIG9uSW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2tcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5zdGFuY2UgfHwgbnVsbDtcclxuICAgIH1cclxuICAgIG5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5tdWx0aXBsZUluc3RhbmNlcyA/IGlkZW50aWZpZXIgOiBERUZBVUxUX0VOVFJZX05BTUU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaWRlbnRpZmllcjsgLy8gYXNzdW1lIG11bHRpcGxlIGluc3RhbmNlcyBhcmUgc3VwcG9ydGVkIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHByb3ZpZGVkLlxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNob3VsZEF1dG9Jbml0aWFsaXplKCkge1xyXG4gICAgICAgIHJldHVybiAoISF0aGlzLmNvbXBvbmVudCAmJlxyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5pbnN0YW50aWF0aW9uTW9kZSAhPT0gXCJFWFBMSUNJVFwiIC8qIEluc3RhbnRpYXRpb25Nb2RlLkVYUExJQ0lUICovKTtcclxuICAgIH1cclxufVxyXG4vLyB1bmRlZmluZWQgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgc2VydmljZSBmYWN0b3J5IGZvciB0aGUgZGVmYXVsdCBpbnN0YW5jZVxyXG5mdW5jdGlvbiBub3JtYWxpemVJZGVudGlmaWVyRm9yRmFjdG9yeShpZGVudGlmaWVyKSB7XHJcbiAgICByZXR1cm4gaWRlbnRpZmllciA9PT0gREVGQVVMVF9FTlRSWV9OQU1FID8gdW5kZWZpbmVkIDogaWRlbnRpZmllcjtcclxufVxyXG5mdW5jdGlvbiBpc0NvbXBvbmVudEVhZ2VyKGNvbXBvbmVudCkge1xyXG4gICAgcmV0dXJuIGNvbXBvbmVudC5pbnN0YW50aWF0aW9uTW9kZSA9PT0gXCJFQUdFUlwiIC8qIEluc3RhbnRpYXRpb25Nb2RlLkVBR0VSICovO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDb21wb25lbnRDb250YWluZXIgdGhhdCBwcm92aWRlcyBQcm92aWRlcnMgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuIGBhdXRoYCwgYGF1dGgtaW50ZXJuYWxgXHJcbiAqL1xyXG5jbGFzcyBDb21wb25lbnRDb250YWluZXIge1xyXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IENvbXBvbmVudCBiZWluZyBhZGRlZFxyXG4gICAgICogQHBhcmFtIG92ZXJ3cml0ZSBXaGVuIGEgY29tcG9uZW50IHdpdGggdGhlIHNhbWUgbmFtZSBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQsXHJcbiAgICAgKiBpZiBvdmVyd3JpdGUgaXMgdHJ1ZTogb3ZlcndyaXRlIHRoZSBleGlzdGluZyBjb21wb25lbnQgd2l0aCB0aGUgbmV3IGNvbXBvbmVudCBhbmQgY3JlYXRlIGEgbmV3XHJcbiAgICAgKiBwcm92aWRlciB3aXRoIHRoZSBuZXcgY29tcG9uZW50LiBJdCBjYW4gYmUgdXNlZnVsIGluIHRlc3RzIHdoZXJlIHlvdSB3YW50IHRvIHVzZSBkaWZmZXJlbnQgbW9ja3NcclxuICAgICAqIGZvciBkaWZmZXJlbnQgdGVzdHMuXHJcbiAgICAgKiBpZiBvdmVyd3JpdGUgaXMgZmFsc2U6IHRocm93IGFuIGV4Y2VwdGlvblxyXG4gICAgICovXHJcbiAgICBhZGRDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKGNvbXBvbmVudC5uYW1lKTtcclxuICAgICAgICBpZiAocHJvdmlkZXIuaXNDb21wb25lbnRTZXQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgd2l0aCAke3RoaXMubmFtZX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvdmlkZXIuc2V0Q29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICBhZGRPck92ZXJ3cml0ZUNvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIoY29tcG9uZW50Lm5hbWUpO1xyXG4gICAgICAgIGlmIChwcm92aWRlci5pc0NvbXBvbmVudFNldCgpKSB7XHJcbiAgICAgICAgICAgIC8vIGRlbGV0ZSB0aGUgZXhpc3RpbmcgcHJvdmlkZXIgZnJvbSB0aGUgY29udGFpbmVyLCBzbyB3ZSBjYW4gcmVnaXN0ZXIgdGhlIG5ldyBjb21wb25lbnRcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuZGVsZXRlKGNvbXBvbmVudC5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogZ2V0UHJvdmlkZXIgcHJvdmlkZXMgYSB0eXBlIHNhZmUgaW50ZXJmYWNlIHdoZXJlIGl0IGNhbiBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgZmllbGQgbmFtZVxyXG4gICAgICogcHJlc2VudCBpbiBOYW1lU2VydmljZU1hcHBpbmcgaW50ZXJmYWNlLlxyXG4gICAgICpcclxuICAgICAqIEZpcmViYXNlIFNES3MgcHJvdmlkaW5nIHNlcnZpY2VzIHNob3VsZCBleHRlbmQgTmFtZVNlcnZpY2VNYXBwaW5nIGludGVyZmFjZSB0byByZWdpc3RlclxyXG4gICAgICogdGhlbXNlbHZlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0UHJvdmlkZXIobmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnByb3ZpZGVycy5oYXMobmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXJzLmdldChuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY3JlYXRlIGEgUHJvdmlkZXIgZm9yIGEgc2VydmljZSB0aGF0IGhhc24ndCByZWdpc3RlcmVkIHdpdGggRmlyZWJhc2VcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBQcm92aWRlcihuYW1lLCB0aGlzKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmFtZSwgcHJvdmlkZXIpO1xyXG4gICAgICAgIHJldHVybiBwcm92aWRlcjtcclxuICAgIH1cclxuICAgIGdldFByb3ZpZGVycygpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnByb3ZpZGVycy52YWx1ZXMoKSk7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRDb250YWluZXIsIFByb3ZpZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbIkRlZmVycmVkIiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJuYW1lIiwiaW5zdGFuY2VGYWN0b3J5IiwidHlwZSIsIm11bHRpcGxlSW5zdGFuY2VzIiwic2VydmljZVByb3BzIiwiaW5zdGFudGlhdGlvbk1vZGUiLCJvbkluc3RhbmNlQ3JlYXRlZCIsInNldEluc3RhbnRpYXRpb25Nb2RlIiwibW9kZSIsInNldE11bHRpcGxlSW5zdGFuY2VzIiwic2V0U2VydmljZVByb3BzIiwicHJvcHMiLCJzZXRJbnN0YW5jZUNyZWF0ZWRDYWxsYmFjayIsImNhbGxiYWNrIiwiREVGQVVMVF9FTlRSWV9OQU1FIiwiUHJvdmlkZXIiLCJjb250YWluZXIiLCJjb21wb25lbnQiLCJpbnN0YW5jZXMiLCJNYXAiLCJpbnN0YW5jZXNEZWZlcnJlZCIsImluc3RhbmNlc09wdGlvbnMiLCJvbkluaXRDYWxsYmFja3MiLCJnZXQiLCJpZGVudGlmaWVyIiwibm9ybWFsaXplZElkZW50aWZpZXIiLCJub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIiLCJoYXMiLCJkZWZlcnJlZCIsInNldCIsImlzSW5pdGlhbGl6ZWQiLCJzaG91bGRBdXRvSW5pdGlhbGl6ZSIsImluc3RhbmNlIiwiZ2V0T3JJbml0aWFsaXplU2VydmljZSIsImluc3RhbmNlSWRlbnRpZmllciIsInJlc29sdmUiLCJlIiwicHJvbWlzZSIsImdldEltbWVkaWF0ZSIsIm9wdGlvbnMiLCJfYSIsIm9wdGlvbmFsIiwiRXJyb3IiLCJnZXRDb21wb25lbnQiLCJzZXRDb21wb25lbnQiLCJpc0NvbXBvbmVudEVhZ2VyIiwiaW5zdGFuY2VEZWZlcnJlZCIsImVudHJpZXMiLCJjbGVhckluc3RhbmNlIiwiZGVsZXRlIiwic2VydmljZXMiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJQcm9taXNlIiwiYWxsIiwiZmlsdGVyIiwic2VydmljZSIsIm1hcCIsIklOVEVSTkFMIiwiX2RlbGV0ZSIsImlzQ29tcG9uZW50U2V0IiwiZ2V0T3B0aW9ucyIsImluaXRpYWxpemUiLCJvcHRzIiwibm9ybWFsaXplZERlZmVycmVkSWRlbnRpZmllciIsIm9uSW5pdCIsImV4aXN0aW5nQ2FsbGJhY2tzIiwiU2V0IiwiYWRkIiwiZXhpc3RpbmdJbnN0YW5jZSIsImludm9rZU9uSW5pdENhbGxiYWNrcyIsImNhbGxiYWNrcyIsIm5vcm1hbGl6ZUlkZW50aWZpZXJGb3JGYWN0b3J5IiwidW5kZWZpbmVkIiwiQ29tcG9uZW50Q29udGFpbmVyIiwicHJvdmlkZXJzIiwiYWRkQ29tcG9uZW50IiwicHJvdmlkZXIiLCJnZXRQcm92aWRlciIsImFkZE9yT3ZlcndyaXRlQ29tcG9uZW50IiwiZ2V0UHJvdmlkZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/database/dist/node-esm/index.node.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@firebase/database/dist/node-esm/index.node.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataSnapshot: () => (/* binding */ DataSnapshot),\n/* harmony export */   Database: () => (/* binding */ Database),\n/* harmony export */   OnDisconnect: () => (/* binding */ OnDisconnect),\n/* harmony export */   QueryConstraint: () => (/* binding */ QueryConstraint),\n/* harmony export */   TransactionResult: () => (/* binding */ TransactionResult),\n/* harmony export */   _QueryImpl: () => (/* binding */ QueryImpl),\n/* harmony export */   _QueryParams: () => (/* binding */ QueryParams),\n/* harmony export */   _ReferenceImpl: () => (/* binding */ ReferenceImpl),\n/* harmony export */   _TEST_ACCESS_forceRestClient: () => (/* binding */ forceRestClient),\n/* harmony export */   _TEST_ACCESS_hijackHash: () => (/* binding */ hijackHash),\n/* harmony export */   _initStandalone: () => (/* binding */ _initStandalone),\n/* harmony export */   _repoManagerDatabaseFromApp: () => (/* binding */ repoManagerDatabaseFromApp),\n/* harmony export */   _setSDKVersion: () => (/* binding */ setSDKVersion),\n/* harmony export */   _validatePathString: () => (/* binding */ validatePathString),\n/* harmony export */   _validateWritablePath: () => (/* binding */ validateWritablePath),\n/* harmony export */   child: () => (/* binding */ child),\n/* harmony export */   connectDatabaseEmulator: () => (/* binding */ connectDatabaseEmulator),\n/* harmony export */   enableLogging: () => (/* binding */ enableLogging),\n/* harmony export */   endAt: () => (/* binding */ endAt),\n/* harmony export */   endBefore: () => (/* binding */ endBefore),\n/* harmony export */   equalTo: () => (/* binding */ equalTo),\n/* harmony export */   forceLongPolling: () => (/* binding */ forceLongPolling),\n/* harmony export */   forceWebSockets: () => (/* binding */ forceWebSockets),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getDatabase: () => (/* binding */ getDatabase),\n/* harmony export */   goOffline: () => (/* binding */ goOffline),\n/* harmony export */   goOnline: () => (/* binding */ goOnline),\n/* harmony export */   increment: () => (/* binding */ increment),\n/* harmony export */   limitToFirst: () => (/* binding */ limitToFirst),\n/* harmony export */   limitToLast: () => (/* binding */ limitToLast),\n/* harmony export */   off: () => (/* binding */ off),\n/* harmony export */   onChildAdded: () => (/* binding */ onChildAdded),\n/* harmony export */   onChildChanged: () => (/* binding */ onChildChanged),\n/* harmony export */   onChildMoved: () => (/* binding */ onChildMoved),\n/* harmony export */   onChildRemoved: () => (/* binding */ onChildRemoved),\n/* harmony export */   onDisconnect: () => (/* binding */ onDisconnect),\n/* harmony export */   onValue: () => (/* binding */ onValue),\n/* harmony export */   orderByChild: () => (/* binding */ orderByChild),\n/* harmony export */   orderByKey: () => (/* binding */ orderByKey),\n/* harmony export */   orderByPriority: () => (/* binding */ orderByPriority),\n/* harmony export */   orderByValue: () => (/* binding */ orderByValue),\n/* harmony export */   push: () => (/* binding */ push),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   ref: () => (/* binding */ ref),\n/* harmony export */   refFromURL: () => (/* binding */ refFromURL),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   runTransaction: () => (/* binding */ runTransaction),\n/* harmony export */   serverTimestamp: () => (/* binding */ serverTimestamp),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setPriority: () => (/* binding */ setPriority),\n/* harmony export */   setWithPriority: () => (/* binding */ setWithPriority),\n/* harmony export */   startAfter: () => (/* binding */ startAfter),\n/* harmony export */   startAt: () => (/* binding */ startAt),\n/* harmony export */   update: () => (/* binding */ update)\n/* harmony export */ });\n/* harmony import */ var faye_websocket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! faye-websocket */ \"(ssr)/./node_modules/faye-websocket/lib/faye/websocket.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const PROTOCOL_VERSION = \"5\";\nconst VERSION_PARAM = \"v\";\nconst TRANSPORT_SESSION_PARAM = \"s\";\nconst REFERER_PARAM = \"r\";\nconst FORGE_REF = \"f\";\n// Matches console.firebase.google.com, firebase-console-*.corp.google.com and\n// firebase.corp.google.com\nconst FORGE_DOMAIN_RE = /(console\\.firebase|firebase-console-\\w+\\.corp|firebase\\.corp)\\.google\\.com/;\nconst LAST_SESSION_PARAM = \"ls\";\nconst APPLICATION_ID_PARAM = \"p\";\nconst APP_CHECK_TOKEN_PARAM = \"ac\";\nconst WEBSOCKET = \"websocket\";\nconst LONG_POLLING = \"long_polling\";\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Wraps a DOM Storage object and:\r\n * - automatically encode objects as JSON strings before storing them to allow us to store arbitrary types.\r\n * - prefixes names with \"firebase:\" to avoid collisions with app data.\r\n *\r\n * We automatically (see storage.js) create two such wrappers, one for sessionStorage,\r\n * and one for localStorage.\r\n *\r\n */ class DOMStorageWrapper {\n    /**\r\n     * @param domStorage_ - The underlying storage object (e.g. localStorage or sessionStorage)\r\n     */ constructor(domStorage_){\n        this.domStorage_ = domStorage_;\n        // Use a prefix to avoid collisions with other stuff saved by the app.\n        this.prefix_ = \"firebase:\";\n    }\n    /**\r\n     * @param key - The key to save the value under\r\n     * @param value - The value being stored, or null to remove the key.\r\n     */ set(key, value) {\n        if (value == null) {\n            this.domStorage_.removeItem(this.prefixedName_(key));\n        } else {\n            this.domStorage_.setItem(this.prefixedName_(key), (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(value));\n        }\n    }\n    /**\r\n     * @returns The value that was stored under this key, or null\r\n     */ get(key) {\n        const storedVal = this.domStorage_.getItem(this.prefixedName_(key));\n        if (storedVal == null) {\n            return null;\n        } else {\n            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.jsonEval)(storedVal);\n        }\n    }\n    remove(key) {\n        this.domStorage_.removeItem(this.prefixedName_(key));\n    }\n    prefixedName_(name) {\n        return this.prefix_ + name;\n    }\n    toString() {\n        return this.domStorage_.toString();\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An in-memory storage implementation that matches the API of DOMStorageWrapper\r\n * (TODO: create interface for both to implement).\r\n */ class MemoryStorage {\n    constructor(){\n        this.cache_ = {};\n        this.isInMemoryStorage = true;\n    }\n    set(key, value) {\n        if (value == null) {\n            delete this.cache_[key];\n        } else {\n            this.cache_[key] = value;\n        }\n    }\n    get(key) {\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(this.cache_, key)) {\n            return this.cache_[key];\n        }\n        return null;\n    }\n    remove(key) {\n        delete this.cache_[key];\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Helper to create a DOMStorageWrapper or else fall back to MemoryStorage.\r\n * TODO: Once MemoryStorage and DOMStorageWrapper have a shared interface this method annotation should change\r\n * to reflect this type\r\n *\r\n * @param domStorageName - Name of the underlying storage object\r\n *   (e.g. 'localStorage' or 'sessionStorage').\r\n * @returns Turning off type information until a common interface is defined.\r\n */ const createStoragefor = function(domStorageName) {\n    try {\n        // NOTE: just accessing \"localStorage\" or \"window['localStorage']\" may throw a security exception,\n        // so it must be inside the try/catch.\n        if (false) {}\n    } catch (e) {}\n    // Failed to create wrapper.  Just return in-memory storage.\n    // TODO: log?\n    return new MemoryStorage();\n};\n/** A storage object that lasts across sessions */ const PersistentStorage = createStoragefor(\"localStorage\");\n/** A storage object that only lasts one session */ const SessionStorage = createStoragefor(\"sessionStorage\");\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.Logger(\"@firebase/database\");\n/**\r\n * Returns a locally-unique ID (generated by just incrementing up from 0 each time its called).\r\n */ const LUIDGenerator = function() {\n    let id = 1;\n    return function() {\n        return id++;\n    };\n}();\n/**\r\n * Sha1 hash of the input string\r\n * @param str - The string to hash\r\n * @returns {!string} The resulting hash\r\n */ const sha1 = function(str) {\n    const utf8Bytes = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringToByteArray)(str);\n    const sha1 = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Sha1();\n    sha1.update(utf8Bytes);\n    const sha1Bytes = sha1.digest();\n    return _firebase_util__WEBPACK_IMPORTED_MODULE_1__.base64.encodeByteArray(sha1Bytes);\n};\nconst buildLogMessage_ = function(...varArgs) {\n    let message = \"\";\n    for(let i = 0; i < varArgs.length; i++){\n        const arg = varArgs[i];\n        if (Array.isArray(arg) || arg && typeof arg === \"object\" && // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        typeof arg.length === \"number\") {\n            message += buildLogMessage_.apply(null, arg);\n        } else if (typeof arg === \"object\") {\n            message += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(arg);\n        } else {\n            message += arg;\n        }\n        message += \" \";\n    }\n    return message;\n};\n/**\r\n * Use this for all debug messages in Firebase.\r\n */ let logger = null;\n/**\r\n * Flag to check for log availability on first log message\r\n */ let firstLog_ = true;\n/**\r\n * The implementation of Firebase.enableLogging (defined here to break dependencies)\r\n * @param logger_ - A flag to turn on logging, or a custom logger\r\n * @param persistent - Whether or not to persist logging settings across refreshes\r\n */ const enableLogging$1 = function(logger_, persistent) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!persistent || logger_ === true || logger_ === false, \"Can't turn on custom loggers persistently.\");\n    if (logger_ === true) {\n        logClient.logLevel = _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.VERBOSE;\n        logger = logClient.log.bind(logClient);\n        if (persistent) {\n            SessionStorage.set(\"logging_enabled\", true);\n        }\n    } else if (typeof logger_ === \"function\") {\n        logger = logger_;\n    } else {\n        logger = null;\n        SessionStorage.remove(\"logging_enabled\");\n    }\n};\nconst log = function(...varArgs) {\n    if (firstLog_ === true) {\n        firstLog_ = false;\n        if (logger === null && SessionStorage.get(\"logging_enabled\") === true) {\n            enableLogging$1(true);\n        }\n    }\n    if (logger) {\n        const message = buildLogMessage_.apply(null, varArgs);\n        logger(message);\n    }\n};\nconst logWrapper = function(prefix) {\n    return function(...varArgs) {\n        log(prefix, ...varArgs);\n    };\n};\nconst error = function(...varArgs) {\n    const message = \"FIREBASE INTERNAL ERROR: \" + buildLogMessage_(...varArgs);\n    logClient.error(message);\n};\nconst fatal = function(...varArgs) {\n    const message = `FIREBASE FATAL ERROR: ${buildLogMessage_(...varArgs)}`;\n    logClient.error(message);\n    throw new Error(message);\n};\nconst warn = function(...varArgs) {\n    const message = \"FIREBASE WARNING: \" + buildLogMessage_(...varArgs);\n    logClient.warn(message);\n};\n/**\r\n * Logs a warning if the containing page uses https. Called when a call to new Firebase\r\n * does not use https.\r\n */ const warnIfPageIsSecure = function() {\n    // Be very careful accessing browser globals. Who knows what may or may not exist.\n    if (false) {}\n};\n/**\r\n * Returns true if data is NaN, or +/- Infinity.\r\n */ const isInvalidJSONNumber = function(data) {\n    return typeof data === \"number\" && (data !== data || // NaN\n    data === Number.POSITIVE_INFINITY || data === Number.NEGATIVE_INFINITY);\n};\nconst executeWhenDOMReady = function(fn) {\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)() || document.readyState === \"complete\") {\n        fn();\n    } else {\n        // Modeled after jQuery. Try DOMContentLoaded and onreadystatechange (which\n        // fire before onload), but fall back to onload.\n        let called = false;\n        const wrappedFn = function() {\n            if (!document.body) {\n                setTimeout(wrappedFn, Math.floor(10));\n                return;\n            }\n            if (!called) {\n                called = true;\n                fn();\n            }\n        };\n        if (document.addEventListener) {\n            document.addEventListener(\"DOMContentLoaded\", wrappedFn, false);\n            // fallback to onload.\n            window.addEventListener(\"load\", wrappedFn, false);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } else if (document.attachEvent) {\n            // IE.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            document.attachEvent(\"onreadystatechange\", ()=>{\n                if (document.readyState === \"complete\") {\n                    wrappedFn();\n                }\n            });\n            // fallback to onload.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            window.attachEvent(\"onload\", wrappedFn);\n        // jQuery has an extra hack for IE that we could employ (based on\n        // http://javascript.nwbox.com/IEContentLoaded/) But it looks really old.\n        // I'm hoping we don't need it.\n        }\n    }\n};\n/**\r\n * Minimum key name. Invalid for actual data, used as a marker to sort before any valid names\r\n */ const MIN_NAME = \"[MIN_NAME]\";\n/**\r\n * Maximum key name. Invalid for actual data, used as a marker to sort above any valid names\r\n */ const MAX_NAME = \"[MAX_NAME]\";\n/**\r\n * Compares valid Firebase key names, plus min and max name\r\n */ const nameCompare = function(a, b) {\n    if (a === b) {\n        return 0;\n    } else if (a === MIN_NAME || b === MAX_NAME) {\n        return -1;\n    } else if (b === MIN_NAME || a === MAX_NAME) {\n        return 1;\n    } else {\n        const aAsInt = tryParseInt(a), bAsInt = tryParseInt(b);\n        if (aAsInt !== null) {\n            if (bAsInt !== null) {\n                return aAsInt - bAsInt === 0 ? a.length - b.length : aAsInt - bAsInt;\n            } else {\n                return -1;\n            }\n        } else if (bAsInt !== null) {\n            return 1;\n        } else {\n            return a < b ? -1 : 1;\n        }\n    }\n};\n/**\r\n * @returns {!number} comparison result.\r\n */ const stringCompare = function(a, b) {\n    if (a === b) {\n        return 0;\n    } else if (a < b) {\n        return -1;\n    } else {\n        return 1;\n    }\n};\nconst requireKey = function(key, obj) {\n    if (obj && key in obj) {\n        return obj[key];\n    } else {\n        throw new Error(\"Missing required key (\" + key + \") in object: \" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(obj));\n    }\n};\nconst ObjectToUniqueKey = function(obj) {\n    if (typeof obj !== \"object\" || obj === null) {\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(obj);\n    }\n    const keys = [];\n    // eslint-disable-next-line guard-for-in\n    for(const k in obj){\n        keys.push(k);\n    }\n    // Export as json, but with the keys sorted.\n    keys.sort();\n    let key = \"{\";\n    for(let i = 0; i < keys.length; i++){\n        if (i !== 0) {\n            key += \",\";\n        }\n        key += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(keys[i]);\n        key += \":\";\n        key += ObjectToUniqueKey(obj[keys[i]]);\n    }\n    key += \"}\";\n    return key;\n};\n/**\r\n * Splits a string into a number of smaller segments of maximum size\r\n * @param str - The string\r\n * @param segsize - The maximum number of chars in the string.\r\n * @returns The string, split into appropriately-sized chunks\r\n */ const splitStringBySize = function(str, segsize) {\n    const len = str.length;\n    if (len <= segsize) {\n        return [\n            str\n        ];\n    }\n    const dataSegs = [];\n    for(let c = 0; c < len; c += segsize){\n        if (c + segsize > len) {\n            dataSegs.push(str.substring(c, len));\n        } else {\n            dataSegs.push(str.substring(c, c + segsize));\n        }\n    }\n    return dataSegs;\n};\n/**\r\n * Apply a function to each (key, value) pair in an object or\r\n * apply a function to each (index, value) pair in an array\r\n * @param obj - The object or array to iterate over\r\n * @param fn - The function to apply\r\n */ function each(obj, fn) {\n    for(const key in obj){\n        if (obj.hasOwnProperty(key)) {\n            fn(key, obj[key]);\n        }\n    }\n}\n/**\r\n * Borrowed from http://hg.secondlife.com/llsd/src/tip/js/typedarray.js (MIT License)\r\n * I made one modification at the end and removed the NaN / Infinity\r\n * handling (since it seemed broken [caused an overflow] and we don't need it).  See MJL comments.\r\n * @param v - A double\r\n *\r\n */ const doubleToIEEE754String = function(v) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!isInvalidJSONNumber(v), \"Invalid JSON number\"); // MJL\n    const ebits = 11, fbits = 52;\n    const bias = (1 << ebits - 1) - 1;\n    let s, e, f, ln, i;\n    // Compute sign, exponent, fraction\n    // Skip NaN / Infinity handling --MJL.\n    if (v === 0) {\n        e = 0;\n        f = 0;\n        s = 1 / v === -Infinity ? 1 : 0;\n    } else {\n        s = v < 0;\n        v = Math.abs(v);\n        if (v >= Math.pow(2, 1 - bias)) {\n            // Normalized\n            ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);\n            e = ln + bias;\n            f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));\n        } else {\n            // Denormalized\n            e = 0;\n            f = Math.round(v / Math.pow(2, 1 - bias - fbits));\n        }\n    }\n    // Pack sign, exponent, fraction\n    const bits = [];\n    for(i = fbits; i; i -= 1){\n        bits.push(f % 2 ? 1 : 0);\n        f = Math.floor(f / 2);\n    }\n    for(i = ebits; i; i -= 1){\n        bits.push(e % 2 ? 1 : 0);\n        e = Math.floor(e / 2);\n    }\n    bits.push(s ? 1 : 0);\n    bits.reverse();\n    const str = bits.join(\"\");\n    // Return the data as a hex string. --MJL\n    let hexByteString = \"\";\n    for(i = 0; i < 64; i += 8){\n        let hexByte = parseInt(str.substr(i, 8), 2).toString(16);\n        if (hexByte.length === 1) {\n            hexByte = \"0\" + hexByte;\n        }\n        hexByteString = hexByteString + hexByte;\n    }\n    return hexByteString.toLowerCase();\n};\n/**\r\n * Used to detect if we're in a Chrome content script (which executes in an\r\n * isolated environment where long-polling doesn't work).\r\n */ const isChromeExtensionContentScript = function() {\n    return !!( false && 0);\n};\n/**\r\n * Used to detect if we're in a Windows 8 Store app.\r\n */ const isWindowsStoreApp = function() {\n    // Check for the presence of a couple WinRT globals\n    return typeof Windows === \"object\" && typeof Windows.UI === \"object\";\n};\n/**\r\n * Converts a server error code to a Javascript Error\r\n */ function errorForServerCode(code, query) {\n    let reason = \"Unknown Error\";\n    if (code === \"too_big\") {\n        reason = \"The data requested exceeds the maximum size \" + \"that can be accessed with a single request.\";\n    } else if (code === \"permission_denied\") {\n        reason = \"Client doesn't have permission to access the desired data.\";\n    } else if (code === \"unavailable\") {\n        reason = \"The service is unavailable\";\n    }\n    const error = new Error(code + \" at \" + query._path.toString() + \": \" + reason);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    error.code = code.toUpperCase();\n    return error;\n}\n/**\r\n * Used to test for integer-looking strings\r\n */ const INTEGER_REGEXP_ = new RegExp(\"^-?(0*)\\\\d{1,10}$\");\n/**\r\n * For use in keys, the minimum possible 32-bit integer.\r\n */ const INTEGER_32_MIN = -2147483648;\n/**\r\n * For use in kyes, the maximum possible 32-bit integer.\r\n */ const INTEGER_32_MAX = 2147483647;\n/**\r\n * If the string contains a 32-bit integer, return it.  Else return null.\r\n */ const tryParseInt = function(str) {\n    if (INTEGER_REGEXP_.test(str)) {\n        const intVal = Number(str);\n        if (intVal >= INTEGER_32_MIN && intVal <= INTEGER_32_MAX) {\n            return intVal;\n        }\n    }\n    return null;\n};\n/**\r\n * Helper to run some code but catch any exceptions and re-throw them later.\r\n * Useful for preventing user callbacks from breaking internal code.\r\n *\r\n * Re-throwing the exception from a setTimeout is a little evil, but it's very\r\n * convenient (we don't have to try to figure out when is a safe point to\r\n * re-throw it), and the behavior seems reasonable:\r\n *\r\n * * If you aren't pausing on exceptions, you get an error in the console with\r\n *   the correct stack trace.\r\n * * If you're pausing on all exceptions, the debugger will pause on your\r\n *   exception and then again when we rethrow it.\r\n * * If you're only pausing on uncaught exceptions, the debugger will only pause\r\n *   on us re-throwing it.\r\n *\r\n * @param fn - The code to guard.\r\n */ const exceptionGuard = function(fn) {\n    try {\n        fn();\n    } catch (e) {\n        // Re-throw exception when it's safe.\n        setTimeout(()=>{\n            // It used to be that \"throw e\" would result in a good console error with\n            // relevant context, but as of Chrome 39, you just get the firebase.js\n            // file/line number where we re-throw it, which is useless. So we log\n            // e.stack explicitly.\n            const stack = e.stack || \"\";\n            warn(\"Exception was thrown by user callback.\", stack);\n            throw e;\n        }, Math.floor(0));\n    }\n};\n/**\r\n * @returns {boolean} true if we think we're currently being crawled.\r\n */ const beingCrawled = function() {\n    const userAgent =  false || \"\";\n    // For now we whitelist the most popular crawlers.  We should refine this to be the set of crawlers we\n    // believe to support JavaScript/AJAX rendering.\n    // NOTE: Google Webmaster Tools doesn't really belong, but their \"This is how a visitor to your website\n    // would have seen the page\" is flaky if we don't treat it as a crawler.\n    return userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0;\n};\n/**\r\n * Same as setTimeout() except on Node.JS it will /not/ prevent the process from exiting.\r\n *\r\n * It is removed with clearTimeout() as normal.\r\n *\r\n * @param fn - Function to run.\r\n * @param time - Milliseconds to wait before running.\r\n * @returns The setTimeout() return value.\r\n */ const setTimeoutNonBlocking = function(fn, time) {\n    const timeout = setTimeout(fn, time);\n    // Note: at the time of this comment, unrefTimer is under the unstable set of APIs. Run with --unstable to enable the API.\n    if (typeof timeout === \"number\" && // @ts-ignore Is only defined in Deno environments.\n    typeof Deno !== \"undefined\" && // @ts-ignore Deno and unrefTimer are only defined in Deno environments.\n    Deno[\"unrefTimer\"]) {\n        // @ts-ignore Deno and unrefTimer are only defined in Deno environments.\n        Deno.unrefTimer(timeout);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } else if (typeof timeout === \"object\" && timeout[\"unref\"]) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        timeout[\"unref\"]();\n    }\n    return timeout;\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A class that holds metadata about a Repo object\r\n */ class RepoInfo {\n    /**\r\n     * @param host - Hostname portion of the url for the repo\r\n     * @param secure - Whether or not this repo is accessed over ssl\r\n     * @param namespace - The namespace represented by the repo\r\n     * @param webSocketOnly - Whether to prefer websockets over all other transports (used by Nest).\r\n     * @param nodeAdmin - Whether this instance uses Admin SDK credentials\r\n     * @param persistenceKey - Override the default session persistence storage key\r\n     */ constructor(host, secure, namespace, webSocketOnly, nodeAdmin = false, persistenceKey = \"\", includeNamespaceInQueryParams = false, isUsingEmulator = false){\n        this.secure = secure;\n        this.namespace = namespace;\n        this.webSocketOnly = webSocketOnly;\n        this.nodeAdmin = nodeAdmin;\n        this.persistenceKey = persistenceKey;\n        this.includeNamespaceInQueryParams = includeNamespaceInQueryParams;\n        this.isUsingEmulator = isUsingEmulator;\n        this._host = host.toLowerCase();\n        this._domain = this._host.substr(this._host.indexOf(\".\") + 1);\n        this.internalHost = PersistentStorage.get(\"host:\" + host) || this._host;\n    }\n    isCacheableHost() {\n        return this.internalHost.substr(0, 2) === \"s-\";\n    }\n    isCustomHost() {\n        return this._domain !== \"firebaseio.com\" && this._domain !== \"firebaseio-demo.com\";\n    }\n    get host() {\n        return this._host;\n    }\n    set host(newHost) {\n        if (newHost !== this.internalHost) {\n            this.internalHost = newHost;\n            if (this.isCacheableHost()) {\n                PersistentStorage.set(\"host:\" + this._host, this.internalHost);\n            }\n        }\n    }\n    toString() {\n        let str = this.toURLString();\n        if (this.persistenceKey) {\n            str += \"<\" + this.persistenceKey + \">\";\n        }\n        return str;\n    }\n    toURLString() {\n        const protocol = this.secure ? \"https://\" : \"http://\";\n        const query = this.includeNamespaceInQueryParams ? `?ns=${this.namespace}` : \"\";\n        return `${protocol}${this.host}/${query}`;\n    }\n}\nfunction repoInfoNeedsQueryParam(repoInfo) {\n    return repoInfo.host !== repoInfo.internalHost || repoInfo.isCustomHost() || repoInfo.includeNamespaceInQueryParams;\n}\n/**\r\n * Returns the websocket URL for this repo\r\n * @param repoInfo - RepoInfo object\r\n * @param type - of connection\r\n * @param params - list\r\n * @returns The URL for this repo\r\n */ function repoInfoConnectionURL(repoInfo, type, params) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof type === \"string\", \"typeof type must == string\");\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof params === \"object\", \"typeof params must == object\");\n    let connURL;\n    if (type === WEBSOCKET) {\n        connURL = (repoInfo.secure ? \"wss://\" : \"ws://\") + repoInfo.internalHost + \"/.ws?\";\n    } else if (type === LONG_POLLING) {\n        connURL = (repoInfo.secure ? \"https://\" : \"http://\") + repoInfo.internalHost + \"/.lp?\";\n    } else {\n        throw new Error(\"Unknown connection type: \" + type);\n    }\n    if (repoInfoNeedsQueryParam(repoInfo)) {\n        params[\"ns\"] = repoInfo.namespace;\n    }\n    const pairs = [];\n    each(params, (key, value)=>{\n        pairs.push(key + \"=\" + value);\n    });\n    return connURL + pairs.join(\"&\");\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Tracks a collection of stats.\r\n */ class StatsCollection {\n    constructor(){\n        this.counters_ = {};\n    }\n    incrementCounter(name, amount = 1) {\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(this.counters_, name)) {\n            this.counters_[name] = 0;\n        }\n        this.counters_[name] += amount;\n    }\n    get() {\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepCopy)(this.counters_);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const collections = {};\nconst reporters = {};\nfunction statsManagerGetCollection(repoInfo) {\n    const hashString = repoInfo.toString();\n    if (!collections[hashString]) {\n        collections[hashString] = new StatsCollection();\n    }\n    return collections[hashString];\n}\nfunction statsManagerGetOrCreateReporter(repoInfo, creatorFunction) {\n    const hashString = repoInfo.toString();\n    if (!reporters[hashString]) {\n        reporters[hashString] = creatorFunction();\n    }\n    return reporters[hashString];\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /** The semver (www.semver.org) version of the SDK. */ let SDK_VERSION = \"\";\n/**\r\n * SDK_VERSION should be set before any database instance is created\r\n * @internal\r\n */ function setSDKVersion(version) {\n    SDK_VERSION = version;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const WEBSOCKET_MAX_FRAME_SIZE = 16384;\nconst WEBSOCKET_KEEPALIVE_INTERVAL = 45000;\nlet WebSocketImpl = null;\nif (typeof MozWebSocket !== \"undefined\") {\n    WebSocketImpl = MozWebSocket;\n} else if (typeof WebSocket !== \"undefined\") {\n    WebSocketImpl = WebSocket;\n}\nfunction setWebSocketImpl(impl) {\n    WebSocketImpl = impl;\n}\n/**\r\n * Create a new websocket connection with the given callbacks.\r\n */ class WebSocketConnection {\n    /**\r\n     * @param connId identifier for this transport\r\n     * @param repoInfo The info for the websocket endpoint.\r\n     * @param applicationId The Firebase App ID for this project.\r\n     * @param appCheckToken The App Check Token for this client.\r\n     * @param authToken The Auth Token for this client.\r\n     * @param transportSessionId Optional transportSessionId if this is connecting\r\n     * to an existing transport session\r\n     * @param lastSessionId Optional lastSessionId if there was a previous\r\n     * connection\r\n     */ constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId){\n        this.connId = connId;\n        this.applicationId = applicationId;\n        this.appCheckToken = appCheckToken;\n        this.authToken = authToken;\n        this.keepaliveTimer = null;\n        this.frames = null;\n        this.totalFrames = 0;\n        this.bytesSent = 0;\n        this.bytesReceived = 0;\n        this.log_ = logWrapper(this.connId);\n        this.stats_ = statsManagerGetCollection(repoInfo);\n        this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken, applicationId);\n        this.nodeAdmin = repoInfo.nodeAdmin;\n    }\n    /**\r\n     * @param repoInfo - The info for the websocket endpoint.\r\n     * @param transportSessionId - Optional transportSessionId if this is connecting to an existing transport\r\n     *                                         session\r\n     * @param lastSessionId - Optional lastSessionId if there was a previous connection\r\n     * @returns connection url\r\n     */ static connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken, applicationId) {\n        const urlParams = {};\n        urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)() && typeof location !== \"undefined\" && location.hostname && FORGE_DOMAIN_RE.test(location.hostname)) {\n            urlParams[REFERER_PARAM] = FORGE_REF;\n        }\n        if (transportSessionId) {\n            urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;\n        }\n        if (lastSessionId) {\n            urlParams[LAST_SESSION_PARAM] = lastSessionId;\n        }\n        if (appCheckToken) {\n            urlParams[APP_CHECK_TOKEN_PARAM] = appCheckToken;\n        }\n        if (applicationId) {\n            urlParams[APPLICATION_ID_PARAM] = applicationId;\n        }\n        return repoInfoConnectionURL(repoInfo, WEBSOCKET, urlParams);\n    }\n    /**\r\n     * @param onMessage - Callback when messages arrive\r\n     * @param onDisconnect - Callback with connection lost.\r\n     */ open(onMessage, onDisconnect) {\n        this.onDisconnect = onDisconnect;\n        this.onMessage = onMessage;\n        this.log_(\"Websocket connecting to \" + this.connURL);\n        this.everConnected_ = false;\n        // Assume failure until proven otherwise.\n        PersistentStorage.set(\"previous_websocket_failure\", true);\n        try {\n            let options;\n            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n                const device = this.nodeAdmin ? \"AdminNode\" : \"Node\";\n                // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>\n                options = {\n                    headers: {\n                        \"User-Agent\": `Firebase/${PROTOCOL_VERSION}/${SDK_VERSION}/${process.platform}/${device}`,\n                        \"X-Firebase-GMPID\": this.applicationId || \"\"\n                    }\n                };\n                // If using Node with admin creds, AppCheck-related checks are unnecessary.\n                // Note that we send the credentials here even if they aren't admin credentials, which is\n                // not a problem.\n                // Note that this header is just used to bypass appcheck, and the token should still be sent\n                // through the websocket connection once it is established.\n                if (this.authToken) {\n                    options.headers[\"Authorization\"] = `Bearer ${this.authToken}`;\n                }\n                if (this.appCheckToken) {\n                    options.headers[\"X-Firebase-AppCheck\"] = this.appCheckToken;\n                }\n                // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.\n                const env = process[\"env\"];\n                const proxy = this.connURL.indexOf(\"wss://\") === 0 ? env[\"HTTPS_PROXY\"] || env[\"https_proxy\"] : env[\"HTTP_PROXY\"] || env[\"http_proxy\"];\n                if (proxy) {\n                    options[\"proxy\"] = {\n                        origin: proxy\n                    };\n                }\n            }\n            this.mySock = new WebSocketImpl(this.connURL, [], options);\n        } catch (e) {\n            this.log_(\"Error instantiating WebSocket.\");\n            const error = e.message || e.data;\n            if (error) {\n                this.log_(error);\n            }\n            this.onClosed_();\n            return;\n        }\n        this.mySock.onopen = ()=>{\n            this.log_(\"Websocket connected.\");\n            this.everConnected_ = true;\n        };\n        this.mySock.onclose = ()=>{\n            this.log_(\"Websocket connection was disconnected.\");\n            this.mySock = null;\n            this.onClosed_();\n        };\n        this.mySock.onmessage = (m)=>{\n            this.handleIncomingFrame(m);\n        };\n        this.mySock.onerror = (e)=>{\n            this.log_(\"WebSocket error.  Closing connection.\");\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const error = e.message || e.data;\n            if (error) {\n                this.log_(error);\n            }\n            this.onClosed_();\n        };\n    }\n    /**\r\n     * No-op for websockets, we don't need to do anything once the connection is confirmed as open\r\n     */ start() {}\n    static forceDisallow() {\n        WebSocketConnection.forceDisallow_ = true;\n    }\n    static isAvailable() {\n        let isOldAndroid = false;\n        if (typeof navigator !== \"undefined\" && navigator.userAgent) {\n            const oldAndroidRegex = /Android ([0-9]{0,}\\.[0-9]{0,})/;\n            const oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);\n            if (oldAndroidMatch && oldAndroidMatch.length > 1) {\n                if (parseFloat(oldAndroidMatch[1]) < 4.4) {\n                    isOldAndroid = true;\n                }\n            }\n        }\n        return !isOldAndroid && WebSocketImpl !== null && !WebSocketConnection.forceDisallow_;\n    }\n    /**\r\n     * Returns true if we previously failed to connect with this transport.\r\n     */ static previouslyFailed() {\n        // If our persistent storage is actually only in-memory storage,\n        // we default to assuming that it previously failed to be safe.\n        return PersistentStorage.isInMemoryStorage || PersistentStorage.get(\"previous_websocket_failure\") === true;\n    }\n    markConnectionHealthy() {\n        PersistentStorage.remove(\"previous_websocket_failure\");\n    }\n    appendFrame_(data) {\n        this.frames.push(data);\n        if (this.frames.length === this.totalFrames) {\n            const fullMess = this.frames.join(\"\");\n            this.frames = null;\n            const jsonMess = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.jsonEval)(fullMess);\n            //handle the message\n            this.onMessage(jsonMess);\n        }\n    }\n    /**\r\n     * @param frameCount - The number of frames we are expecting from the server\r\n     */ handleNewFrameCount_(frameCount) {\n        this.totalFrames = frameCount;\n        this.frames = [];\n    }\n    /**\r\n     * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1\r\n     * @returns Any remaining data to be process, or null if there is none\r\n     */ extractFrameCount_(data) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.frames === null, \"We already have a frame buffer\");\n        // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced\n        // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508\n        if (data.length <= 6) {\n            const frameCount = Number(data);\n            if (!isNaN(frameCount)) {\n                this.handleNewFrameCount_(frameCount);\n                return null;\n            }\n        }\n        this.handleNewFrameCount_(1);\n        return data;\n    }\n    /**\r\n     * Process a websocket frame that has arrived from the server.\r\n     * @param mess - The frame data\r\n     */ handleIncomingFrame(mess) {\n        if (this.mySock === null) {\n            return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.\n        }\n        const data = mess[\"data\"];\n        this.bytesReceived += data.length;\n        this.stats_.incrementCounter(\"bytes_received\", data.length);\n        this.resetKeepAlive();\n        if (this.frames !== null) {\n            // we're buffering\n            this.appendFrame_(data);\n        } else {\n            // try to parse out a frame count, otherwise, assume 1 and process it\n            const remainingData = this.extractFrameCount_(data);\n            if (remainingData !== null) {\n                this.appendFrame_(remainingData);\n            }\n        }\n    }\n    /**\r\n     * Send a message to the server\r\n     * @param data - The JSON object to transmit\r\n     */ send(data) {\n        this.resetKeepAlive();\n        const dataStr = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(data);\n        this.bytesSent += dataStr.length;\n        this.stats_.incrementCounter(\"bytes_sent\", dataStr.length);\n        //We can only fit a certain amount in each websocket frame, so we need to split this request\n        //up into multiple pieces if it doesn't fit in one request.\n        const dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);\n        //Send the length header\n        if (dataSegs.length > 1) {\n            this.sendString_(String(dataSegs.length));\n        }\n        //Send the actual data in segments.\n        for(let i = 0; i < dataSegs.length; i++){\n            this.sendString_(dataSegs[i]);\n        }\n    }\n    shutdown_() {\n        this.isClosed_ = true;\n        if (this.keepaliveTimer) {\n            clearInterval(this.keepaliveTimer);\n            this.keepaliveTimer = null;\n        }\n        if (this.mySock) {\n            this.mySock.close();\n            this.mySock = null;\n        }\n    }\n    onClosed_() {\n        if (!this.isClosed_) {\n            this.log_(\"WebSocket is closing itself\");\n            this.shutdown_();\n            // since this is an internal close, trigger the close listener\n            if (this.onDisconnect) {\n                this.onDisconnect(this.everConnected_);\n                this.onDisconnect = null;\n            }\n        }\n    }\n    /**\r\n     * External-facing close handler.\r\n     * Close the websocket and kill the connection.\r\n     */ close() {\n        if (!this.isClosed_) {\n            this.log_(\"WebSocket is being closed\");\n            this.shutdown_();\n        }\n    }\n    /**\r\n     * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after\r\n     * the last activity.\r\n     */ resetKeepAlive() {\n        clearInterval(this.keepaliveTimer);\n        this.keepaliveTimer = setInterval(()=>{\n            //If there has been no websocket activity for a while, send a no-op\n            if (this.mySock) {\n                this.sendString_(\"0\");\n            }\n            this.resetKeepAlive();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));\n    }\n    /**\r\n     * Send a string over the websocket.\r\n     *\r\n     * @param str - String to send.\r\n     */ sendString_(str) {\n        // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()\n        // calls for some unknown reason.  We treat these as an error and disconnect.\n        // See https://app.asana.com/0/58926111402292/68021340250410\n        try {\n            this.mySock.send(str);\n        } catch (e) {\n            this.log_(\"Exception thrown from WebSocket.send():\", e.message || e.data, \"Closing connection.\");\n            setTimeout(this.onClosed_.bind(this), 0);\n        }\n    }\n}\n/**\r\n * Number of response before we consider the connection \"healthy.\"\r\n */ WebSocketConnection.responsesRequiredToBeHealthy = 2;\n/**\r\n * Time to wait for the connection te become healthy before giving up.\r\n */ WebSocketConnection.healthyTimeout = 30000;\nconst name = \"@firebase/database\";\nconst version = \"1.0.5\";\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Abstraction around AppCheck's token fetching capabilities.\r\n */ class AppCheckTokenProvider {\n    constructor(appName_, appCheckProvider){\n        this.appName_ = appName_;\n        this.appCheckProvider = appCheckProvider;\n        this.appCheck = appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.getImmediate({\n            optional: true\n        });\n        if (!this.appCheck) {\n            appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.get().then((appCheck)=>this.appCheck = appCheck);\n        }\n    }\n    getToken(forceRefresh) {\n        if (!this.appCheck) {\n            return new Promise((resolve, reject)=>{\n                // Support delayed initialization of FirebaseAppCheck. This allows our\n                // customers to initialize the RTDB SDK before initializing Firebase\n                // AppCheck and ensures that all requests are authenticated if a token\n                // becomes available before the timoeout below expires.\n                setTimeout(()=>{\n                    if (this.appCheck) {\n                        this.getToken(forceRefresh).then(resolve, reject);\n                    } else {\n                        resolve(null);\n                    }\n                }, 0);\n            });\n        }\n        return this.appCheck.getToken(forceRefresh);\n    }\n    addTokenChangeListener(listener) {\n        var _a;\n        (_a = this.appCheckProvider) === null || _a === void 0 ? void 0 : _a.get().then((appCheck)=>appCheck.addTokenListener(listener));\n    }\n    notifyForInvalidToken() {\n        warn(`Provided AppCheck credentials for the app named \"${this.appName_}\" ` + \"are invalid. This usually indicates your app was not initialized correctly.\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Abstraction around FirebaseApp's token fetching capabilities.\r\n */ class FirebaseAuthTokenProvider {\n    constructor(appName_, firebaseOptions_, authProvider_){\n        this.appName_ = appName_;\n        this.firebaseOptions_ = firebaseOptions_;\n        this.authProvider_ = authProvider_;\n        this.auth_ = null;\n        this.auth_ = authProvider_.getImmediate({\n            optional: true\n        });\n        if (!this.auth_) {\n            authProvider_.onInit((auth)=>this.auth_ = auth);\n        }\n    }\n    getToken(forceRefresh) {\n        if (!this.auth_) {\n            return new Promise((resolve, reject)=>{\n                // Support delayed initialization of FirebaseAuth. This allows our\n                // customers to initialize the RTDB SDK before initializing Firebase\n                // Auth and ensures that all requests are authenticated if a token\n                // becomes available before the timoeout below expires.\n                setTimeout(()=>{\n                    if (this.auth_) {\n                        this.getToken(forceRefresh).then(resolve, reject);\n                    } else {\n                        resolve(null);\n                    }\n                }, 0);\n            });\n        }\n        return this.auth_.getToken(forceRefresh).catch((error)=>{\n            // TODO: Need to figure out all the cases this is raised and whether\n            // this makes sense.\n            if (error && error.code === \"auth/token-not-initialized\") {\n                log(\"Got auth/token-not-initialized error.  Treating as null token.\");\n                return null;\n            } else {\n                return Promise.reject(error);\n            }\n        });\n    }\n    addTokenChangeListener(listener) {\n        // TODO: We might want to wrap the listener and call it with no args to\n        // avoid a leaky abstraction, but that makes removing the listener harder.\n        if (this.auth_) {\n            this.auth_.addAuthTokenListener(listener);\n        } else {\n            this.authProvider_.get().then((auth)=>auth.addAuthTokenListener(listener));\n        }\n    }\n    removeTokenChangeListener(listener) {\n        this.authProvider_.get().then((auth)=>auth.removeAuthTokenListener(listener));\n    }\n    notifyForInvalidToken() {\n        let errorMessage = 'Provided authentication credentials for the app named \"' + this.appName_ + '\" are invalid. This usually indicates your app was not ' + \"initialized correctly. \";\n        if (\"credential\" in this.firebaseOptions_) {\n            errorMessage += 'Make sure the \"credential\" property provided to initializeApp() ' + 'is authorized to access the specified \"databaseURL\" and is from the correct ' + \"project.\";\n        } else if (\"serviceAccount\" in this.firebaseOptions_) {\n            errorMessage += 'Make sure the \"serviceAccount\" property provided to initializeApp() ' + 'is authorized to access the specified \"databaseURL\" and is from the correct ' + \"project.\";\n        } else {\n            errorMessage += 'Make sure the \"apiKey\" and \"databaseURL\" properties provided to ' + \"initializeApp() match the values provided for your app at \" + \"https://console.firebase.google.com/.\";\n        }\n        warn(errorMessage);\n    }\n}\n/* AuthTokenProvider that supplies a constant token. Used by Admin SDK or mockUserToken with emulators. */ class EmulatorTokenProvider {\n    constructor(accessToken){\n        this.accessToken = accessToken;\n    }\n    getToken(forceRefresh) {\n        return Promise.resolve({\n            accessToken: this.accessToken\n        });\n    }\n    addTokenChangeListener(listener) {\n        // Invoke the listener immediately to match the behavior in Firebase Auth\n        // (see packages/auth/src/auth.js#L1807)\n        listener(this.accessToken);\n    }\n    removeTokenChangeListener(listener) {}\n    notifyForInvalidToken() {}\n}\n/** A string that is treated as an admin access token by the RTDB emulator. Used by Admin SDK. */ EmulatorTokenProvider.OWNER = \"owner\";\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * This class ensures the packets from the server arrive in order\r\n * This class takes data from the server and ensures it gets passed into the callbacks in order.\r\n */ class PacketReceiver {\n    /**\r\n     * @param onMessage_\r\n     */ constructor(onMessage_){\n        this.onMessage_ = onMessage_;\n        this.pendingResponses = [];\n        this.currentResponseNum = 0;\n        this.closeAfterResponse = -1;\n        this.onClose = null;\n    }\n    closeAfter(responseNum, callback) {\n        this.closeAfterResponse = responseNum;\n        this.onClose = callback;\n        if (this.closeAfterResponse < this.currentResponseNum) {\n            this.onClose();\n            this.onClose = null;\n        }\n    }\n    /**\r\n     * Each message from the server comes with a response number, and an array of data. The responseNumber\r\n     * allows us to ensure that we process them in the right order, since we can't be guaranteed that all\r\n     * browsers will respond in the same order as the requests we sent\r\n     */ handleResponse(requestNum, data) {\n        this.pendingResponses[requestNum] = data;\n        while(this.pendingResponses[this.currentResponseNum]){\n            const toProcess = this.pendingResponses[this.currentResponseNum];\n            delete this.pendingResponses[this.currentResponseNum];\n            for(let i = 0; i < toProcess.length; ++i){\n                if (toProcess[i]) {\n                    exceptionGuard(()=>{\n                        this.onMessage_(toProcess[i]);\n                    });\n                }\n            }\n            if (this.currentResponseNum === this.closeAfterResponse) {\n                if (this.onClose) {\n                    this.onClose();\n                    this.onClose = null;\n                }\n                break;\n            }\n            this.currentResponseNum++;\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // URL query parameters associated with longpolling\nconst FIREBASE_LONGPOLL_START_PARAM = \"start\";\nconst FIREBASE_LONGPOLL_CLOSE_COMMAND = \"close\";\nconst FIREBASE_LONGPOLL_COMMAND_CB_NAME = \"pLPCommand\";\nconst FIREBASE_LONGPOLL_DATA_CB_NAME = \"pRTLPCB\";\nconst FIREBASE_LONGPOLL_ID_PARAM = \"id\";\nconst FIREBASE_LONGPOLL_PW_PARAM = \"pw\";\nconst FIREBASE_LONGPOLL_SERIAL_PARAM = \"ser\";\nconst FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = \"cb\";\nconst FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = \"seg\";\nconst FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = \"ts\";\nconst FIREBASE_LONGPOLL_DATA_PARAM = \"d\";\nconst FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = \"dframe\";\n//Data size constants.\n//TODO: Perf: the maximum length actually differs from browser to browser.\n// We should check what browser we're on and set accordingly.\nconst MAX_URL_DATA_SIZE = 1870;\nconst SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=\nconst MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;\n/**\r\n * Keepalive period\r\n * send a fresh request at minimum every 25 seconds. Opera has a maximum request\r\n * length of 30 seconds that we can't exceed.\r\n */ const KEEPALIVE_REQUEST_INTERVAL = 25000;\n/**\r\n * How long to wait before aborting a long-polling connection attempt.\r\n */ const LP_CONNECT_TIMEOUT = 30000;\n/**\r\n * This class manages a single long-polling connection.\r\n */ class BrowserPollConnection {\n    /**\r\n     * @param connId An identifier for this connection, used for logging\r\n     * @param repoInfo The info for the endpoint to send data to.\r\n     * @param applicationId The Firebase App ID for this project.\r\n     * @param appCheckToken The AppCheck token for this client.\r\n     * @param authToken The AuthToken to use for this connection.\r\n     * @param transportSessionId Optional transportSessionid if we are\r\n     * reconnecting for an existing transport session\r\n     * @param lastSessionId Optional lastSessionId if the PersistentConnection has\r\n     * already created a connection previously\r\n     */ constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId){\n        this.connId = connId;\n        this.repoInfo = repoInfo;\n        this.applicationId = applicationId;\n        this.appCheckToken = appCheckToken;\n        this.authToken = authToken;\n        this.transportSessionId = transportSessionId;\n        this.lastSessionId = lastSessionId;\n        this.bytesSent = 0;\n        this.bytesReceived = 0;\n        this.everConnected_ = false;\n        this.log_ = logWrapper(connId);\n        this.stats_ = statsManagerGetCollection(repoInfo);\n        this.urlFn = (params)=>{\n            // Always add the token if we have one.\n            if (this.appCheckToken) {\n                params[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;\n            }\n            return repoInfoConnectionURL(repoInfo, LONG_POLLING, params);\n        };\n    }\n    /**\r\n     * @param onMessage - Callback when messages arrive\r\n     * @param onDisconnect - Callback with connection lost.\r\n     */ open(onMessage, onDisconnect) {\n        this.curSegmentNum = 0;\n        this.onDisconnect_ = onDisconnect;\n        this.myPacketOrderer = new PacketReceiver(onMessage);\n        this.isClosed_ = false;\n        this.connectTimeoutTimer_ = setTimeout(()=>{\n            this.log_(\"Timed out trying to connect.\");\n            // Make sure we clear the host cache\n            this.onClosed_();\n            this.connectTimeoutTimer_ = null;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }, Math.floor(LP_CONNECT_TIMEOUT));\n        // Ensure we delay the creation of the iframe until the DOM is loaded.\n        executeWhenDOMReady(()=>{\n            if (this.isClosed_) {\n                return;\n            }\n            //Set up a callback that gets triggered once a connection is set up.\n            this.scriptTagHolder = new FirebaseIFrameScriptHolder((...args)=>{\n                const [command, arg1, arg2, arg3, arg4] = args;\n                this.incrementIncomingBytes_(args);\n                if (!this.scriptTagHolder) {\n                    return; // we closed the connection.\n                }\n                if (this.connectTimeoutTimer_) {\n                    clearTimeout(this.connectTimeoutTimer_);\n                    this.connectTimeoutTimer_ = null;\n                }\n                this.everConnected_ = true;\n                if (command === FIREBASE_LONGPOLL_START_PARAM) {\n                    this.id = arg1;\n                    this.password = arg2;\n                } else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {\n                    // Don't clear the host cache. We got a response from the server, so we know it's reachable\n                    if (arg1) {\n                        // We aren't expecting any more data (other than what the server's already in the process of sending us\n                        // through our already open polls), so don't send any more.\n                        this.scriptTagHolder.sendNewPolls = false;\n                        // arg1 in this case is the last response number sent by the server. We should try to receive\n                        // all of the responses up to this one before closing\n                        this.myPacketOrderer.closeAfter(arg1, ()=>{\n                            this.onClosed_();\n                        });\n                    } else {\n                        this.onClosed_();\n                    }\n                } else {\n                    throw new Error(\"Unrecognized command received: \" + command);\n                }\n            }, (...args)=>{\n                const [pN, data] = args;\n                this.incrementIncomingBytes_(args);\n                this.myPacketOrderer.handleResponse(pN, data);\n            }, ()=>{\n                this.onClosed_();\n            }, this.urlFn);\n            //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results\n            //from cache.\n            const urlParams = {};\n            urlParams[FIREBASE_LONGPOLL_START_PARAM] = \"t\";\n            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 100000000);\n            if (this.scriptTagHolder.uniqueCallbackIdentifier) {\n                urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] = this.scriptTagHolder.uniqueCallbackIdentifier;\n            }\n            urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\n            if (this.transportSessionId) {\n                urlParams[TRANSPORT_SESSION_PARAM] = this.transportSessionId;\n            }\n            if (this.lastSessionId) {\n                urlParams[LAST_SESSION_PARAM] = this.lastSessionId;\n            }\n            if (this.applicationId) {\n                urlParams[APPLICATION_ID_PARAM] = this.applicationId;\n            }\n            if (this.appCheckToken) {\n                urlParams[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;\n            }\n            if (typeof location !== \"undefined\" && location.hostname && FORGE_DOMAIN_RE.test(location.hostname)) {\n                urlParams[REFERER_PARAM] = FORGE_REF;\n            }\n            const connectURL = this.urlFn(urlParams);\n            this.log_(\"Connecting via long-poll to \" + connectURL);\n            this.scriptTagHolder.addTag(connectURL, ()=>{\n            /* do nothing */ });\n        });\n    }\n    /**\r\n     * Call this when a handshake has completed successfully and we want to consider the connection established\r\n     */ start() {\n        this.scriptTagHolder.startLongPoll(this.id, this.password);\n        this.addDisconnectPingFrame(this.id, this.password);\n    }\n    /**\r\n     * Forces long polling to be considered as a potential transport\r\n     */ static forceAllow() {\n        BrowserPollConnection.forceAllow_ = true;\n    }\n    /**\r\n     * Forces longpolling to not be considered as a potential transport\r\n     */ static forceDisallow() {\n        BrowserPollConnection.forceDisallow_ = true;\n    }\n    // Static method, use string literal so it can be accessed in a generic way\n    static isAvailable() {\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n            return false;\n        } else if (BrowserPollConnection.forceAllow_) {\n            return true;\n        } else {\n            // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in\n            // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).\n            return !BrowserPollConnection.forceDisallow_ && typeof document !== \"undefined\" && document.createElement != null && !isChromeExtensionContentScript() && !isWindowsStoreApp();\n        }\n    }\n    /**\r\n     * No-op for polling\r\n     */ markConnectionHealthy() {}\n    /**\r\n     * Stops polling and cleans up the iframe\r\n     */ shutdown_() {\n        this.isClosed_ = true;\n        if (this.scriptTagHolder) {\n            this.scriptTagHolder.close();\n            this.scriptTagHolder = null;\n        }\n        //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.\n        if (this.myDisconnFrame) {\n            document.body.removeChild(this.myDisconnFrame);\n            this.myDisconnFrame = null;\n        }\n        if (this.connectTimeoutTimer_) {\n            clearTimeout(this.connectTimeoutTimer_);\n            this.connectTimeoutTimer_ = null;\n        }\n    }\n    /**\r\n     * Triggered when this transport is closed\r\n     */ onClosed_() {\n        if (!this.isClosed_) {\n            this.log_(\"Longpoll is closing itself\");\n            this.shutdown_();\n            if (this.onDisconnect_) {\n                this.onDisconnect_(this.everConnected_);\n                this.onDisconnect_ = null;\n            }\n        }\n    }\n    /**\r\n     * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server\r\n     * that we've left.\r\n     */ close() {\n        if (!this.isClosed_) {\n            this.log_(\"Longpoll is being closed.\");\n            this.shutdown_();\n        }\n    }\n    /**\r\n     * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then\r\n     * broken into chunks (since URLs have a small maximum length).\r\n     * @param data - The JSON data to transmit.\r\n     */ send(data) {\n        const dataStr = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(data);\n        this.bytesSent += dataStr.length;\n        this.stats_.incrementCounter(\"bytes_sent\", dataStr.length);\n        //first, lets get the base64-encoded data\n        const base64data = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.base64Encode)(dataStr);\n        //We can only fit a certain amount in each URL, so we need to split this request\n        //up into multiple pieces if it doesn't fit in one request.\n        const dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);\n        //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number\n        //of segments so that we can reassemble the packet on the server.\n        for(let i = 0; i < dataSegs.length; i++){\n            this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);\n            this.curSegmentNum++;\n        }\n    }\n    /**\r\n     * This is how we notify the server that we're leaving.\r\n     * We aren't able to send requests with DHTML on a window close event, but we can\r\n     * trigger XHR requests in some browsers (everything but Opera basically).\r\n     */ addDisconnectPingFrame(id, pw) {\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n            return;\n        }\n        this.myDisconnFrame = document.createElement(\"iframe\");\n        const urlParams = {};\n        urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = \"t\";\n        urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;\n        urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;\n        this.myDisconnFrame.src = this.urlFn(urlParams);\n        this.myDisconnFrame.style.display = \"none\";\n        document.body.appendChild(this.myDisconnFrame);\n    }\n    /**\r\n     * Used to track the bytes received by this client\r\n     */ incrementIncomingBytes_(args) {\n        // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.\n        const bytesReceived = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(args).length;\n        this.bytesReceived += bytesReceived;\n        this.stats_.incrementCounter(\"bytes_received\", bytesReceived);\n    }\n}\n/*********************************************************************************************\r\n * A wrapper around an iframe that is used as a long-polling script holder.\r\n *********************************************************************************************/ class FirebaseIFrameScriptHolder {\n    /**\r\n     * @param commandCB - The callback to be called when control commands are recevied from the server.\r\n     * @param onMessageCB - The callback to be triggered when responses arrive from the server.\r\n     * @param onDisconnect - The callback to be triggered when this tag holder is closed\r\n     * @param urlFn - A function that provides the URL of the endpoint to send data to.\r\n     */ constructor(commandCB, onMessageCB, onDisconnect, urlFn){\n        this.onDisconnect = onDisconnect;\n        this.urlFn = urlFn;\n        //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause\n        //problems in some browsers.\n        this.outstandingRequests = new Set();\n        //A queue of the pending segments waiting for transmission to the server.\n        this.pendingSegs = [];\n        //A serial number. We use this for two things:\n        // 1) A way to ensure the browser doesn't cache responses to polls\n        // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The\n        //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute\n        //    JSONP code in the order it was added to the iframe.\n        this.currentSerial = Math.floor(Math.random() * 100000000);\n        // This gets set to false when we're \"closing down\" the connection (e.g. we're switching transports but there's still\n        // incoming data from the server that we're waiting for).\n        this.sendNewPolls = true;\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n            //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the\n            //iframes where we put the long-polling script tags. We have two callbacks:\n            //   1) Command Callback - Triggered for control issues, like starting a connection.\n            //   2) Message Callback - Triggered when new data arrives.\n            this.uniqueCallbackIdentifier = LUIDGenerator();\n            window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;\n            window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] = onMessageCB;\n            //Create an iframe for us to add script tags to.\n            this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();\n            // Set the iframe's contents.\n            let script = \"\";\n            // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient\n            // for ie9, but ie8 needs to do it again in the document itself.\n            if (this.myIFrame.src && this.myIFrame.src.substr(0, \"javascript:\".length) === \"javascript:\") {\n                const currentDomain = document.domain;\n                script = '<script>document.domain=\"' + currentDomain + '\";</script>';\n            }\n            const iframeContents = \"<html><body>\" + script + \"</body></html>\";\n            try {\n                this.myIFrame.doc.open();\n                this.myIFrame.doc.write(iframeContents);\n                this.myIFrame.doc.close();\n            } catch (e) {\n                log(\"frame writing exception\");\n                if (e.stack) {\n                    log(e.stack);\n                }\n                log(e);\n            }\n        } else {\n            this.commandCB = commandCB;\n            this.onMessageCB = onMessageCB;\n        }\n    }\n    /**\r\n     * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can\r\n     * actually use.\r\n     */ static createIFrame_() {\n        const iframe = document.createElement(\"iframe\");\n        iframe.style.display = \"none\";\n        // This is necessary in order to initialize the document inside the iframe\n        if (document.body) {\n            document.body.appendChild(iframe);\n            try {\n                // If document.domain has been modified in IE, this will throw an error, and we need to set the\n                // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute\n                // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.\n                const a = iframe.contentWindow.document;\n                if (!a) {\n                    // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.\n                    log(\"No IE domain setting required\");\n                }\n            } catch (e) {\n                const domain = document.domain;\n                iframe.src = \"javascript:void((function(){document.open();document.domain='\" + domain + \"';document.close();})())\";\n            }\n        } else {\n            // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this\n            // never gets hit.\n            throw \"Document body has not initialized. Wait to initialize Firebase until after the document is ready.\";\n        }\n        // Get the document of the iframe in a browser-specific way.\n        if (iframe.contentDocument) {\n            iframe.doc = iframe.contentDocument; // Firefox, Opera, Safari\n        } else if (iframe.contentWindow) {\n            iframe.doc = iframe.contentWindow.document; // Internet Explorer\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } else if (iframe.document) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            iframe.doc = iframe.document; //others?\n        }\n        return iframe;\n    }\n    /**\r\n     * Cancel all outstanding queries and remove the frame.\r\n     */ close() {\n        //Mark this iframe as dead, so no new requests are sent.\n        this.alive = false;\n        if (this.myIFrame) {\n            //We have to actually remove all of the html inside this iframe before removing it from the\n            //window, or IE will continue loading and executing the script tags we've already added, which\n            //can lead to some errors being thrown. Setting textContent seems to be the safest way to do this.\n            this.myIFrame.doc.body.textContent = \"\";\n            setTimeout(()=>{\n                if (this.myIFrame !== null) {\n                    document.body.removeChild(this.myIFrame);\n                    this.myIFrame = null;\n                }\n            }, Math.floor(0));\n        }\n        // Protect from being called recursively.\n        const onDisconnect = this.onDisconnect;\n        if (onDisconnect) {\n            this.onDisconnect = null;\n            onDisconnect();\n        }\n    }\n    /**\r\n     * Actually start the long-polling session by adding the first script tag(s) to the iframe.\r\n     * @param id - The ID of this connection\r\n     * @param pw - The password for this connection\r\n     */ startLongPoll(id, pw) {\n        this.myID = id;\n        this.myPW = pw;\n        this.alive = true;\n        //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.\n        while(this.newRequest_()){}\n    }\n    /**\r\n     * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't\r\n     * too many outstanding requests and we are still alive.\r\n     *\r\n     * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if\r\n     * needed.\r\n     */ newRequest_() {\n        // We keep one outstanding request open all the time to receive data, but if we need to send data\n        // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically\n        // close the old request.\n        if (this.alive && this.sendNewPolls && this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {\n            //construct our url\n            this.currentSerial++;\n            const urlParams = {};\n            urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\n            urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\n            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;\n            let theURL = this.urlFn(urlParams);\n            //Now add as much data as we can.\n            let curDataString = \"\";\n            let i = 0;\n            while(this.pendingSegs.length > 0){\n                //first, lets see if the next segment will fit.\n                const nextSeg = this.pendingSegs[0];\n                if (nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <= MAX_URL_DATA_SIZE) {\n                    //great, the segment will fit. Lets append it.\n                    const theSeg = this.pendingSegs.shift();\n                    curDataString = curDataString + \"&\" + FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM + i + \"=\" + theSeg.seg + \"&\" + FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET + i + \"=\" + theSeg.ts + \"&\" + FIREBASE_LONGPOLL_DATA_PARAM + i + \"=\" + theSeg.d;\n                    i++;\n                } else {\n                    break;\n                }\n            }\n            theURL = theURL + curDataString;\n            this.addLongPollTag_(theURL, this.currentSerial);\n            return true;\n        } else {\n            return false;\n        }\n    }\n    /**\r\n     * Queue a packet for transmission to the server.\r\n     * @param segnum - A sequential id for this packet segment used for reassembly\r\n     * @param totalsegs - The total number of segments in this packet\r\n     * @param data - The data for this segment.\r\n     */ enqueueSegment(segnum, totalsegs, data) {\n        //add this to the queue of segments to send.\n        this.pendingSegs.push({\n            seg: segnum,\n            ts: totalsegs,\n            d: data\n        });\n        //send the data immediately if there isn't already data being transmitted, unless\n        //startLongPoll hasn't been called yet.\n        if (this.alive) {\n            this.newRequest_();\n        }\n    }\n    /**\r\n     * Add a script tag for a regular long-poll request.\r\n     * @param url - The URL of the script tag.\r\n     * @param serial - The serial number of the request.\r\n     */ addLongPollTag_(url, serial) {\n        //remember that we sent this request.\n        this.outstandingRequests.add(serial);\n        const doNewRequest = ()=>{\n            this.outstandingRequests.delete(serial);\n            this.newRequest_();\n        };\n        // If this request doesn't return on its own accord (by the server sending us some data), we'll\n        // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.\n        const keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));\n        const readyStateCB = ()=>{\n            // Request completed.  Cancel the keepalive.\n            clearTimeout(keepaliveTimeout);\n            // Trigger a new request so we can continue receiving data.\n            doNewRequest();\n        };\n        this.addTag(url, readyStateCB);\n    }\n    /**\r\n     * Add an arbitrary script tag to the iframe.\r\n     * @param url - The URL for the script tag source.\r\n     * @param loadCB - A callback to be triggered once the script has loaded.\r\n     */ addTag(url, loadCB) {\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.doNodeLongPoll(url, loadCB);\n        } else {\n            setTimeout(()=>{\n                try {\n                    // if we're already closed, don't add this poll\n                    if (!this.sendNewPolls) {\n                        return;\n                    }\n                    const newScript = this.myIFrame.doc.createElement(\"script\");\n                    newScript.type = \"text/javascript\";\n                    newScript.async = true;\n                    newScript.src = url;\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    newScript.onload = newScript.onreadystatechange = function() {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        const rstate = newScript.readyState;\n                        if (!rstate || rstate === \"loaded\" || rstate === \"complete\") {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            newScript.onload = newScript.onreadystatechange = null;\n                            if (newScript.parentNode) {\n                                newScript.parentNode.removeChild(newScript);\n                            }\n                            loadCB();\n                        }\n                    };\n                    newScript.onerror = ()=>{\n                        log(\"Long-poll script failed to load: \" + url);\n                        this.sendNewPolls = false;\n                        this.close();\n                    };\n                    this.myIFrame.doc.body.appendChild(newScript);\n                } catch (e) {\n                // TODO: we should make this error visible somehow\n                }\n            }, Math.floor(1));\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Currently simplistic, this class manages what transport a Connection should use at various stages of its\r\n * lifecycle.\r\n *\r\n * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if\r\n * they are available.\r\n */ class TransportManager {\n    /**\r\n     * @param repoInfo - Metadata around the namespace we're connecting to\r\n     */ constructor(repoInfo){\n        this.initTransports_(repoInfo);\n    }\n    static get ALL_TRANSPORTS() {\n        return [\n            BrowserPollConnection,\n            WebSocketConnection\n        ];\n    }\n    /**\r\n     * Returns whether transport has been selected to ensure WebSocketConnection or BrowserPollConnection are not called after\r\n     * TransportManager has already set up transports_\r\n     */ static get IS_TRANSPORT_INITIALIZED() {\n        return this.globalTransportInitialized_;\n    }\n    initTransports_(repoInfo) {\n        const isWebSocketsAvailable = WebSocketConnection && WebSocketConnection[\"isAvailable\"]();\n        let isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection.previouslyFailed();\n        if (repoInfo.webSocketOnly) {\n            if (!isWebSocketsAvailable) {\n                warn(\"wss:// URL used, but browser isn't known to support websockets.  Trying anyway.\");\n            }\n            isSkipPollConnection = true;\n        }\n        if (isSkipPollConnection) {\n            this.transports_ = [\n                WebSocketConnection\n            ];\n        } else {\n            const transports = this.transports_ = [];\n            for (const transport of TransportManager.ALL_TRANSPORTS){\n                if (transport && transport[\"isAvailable\"]()) {\n                    transports.push(transport);\n                }\n            }\n            TransportManager.globalTransportInitialized_ = true;\n        }\n    }\n    /**\r\n     * @returns The constructor for the initial transport to use\r\n     */ initialTransport() {\n        if (this.transports_.length > 0) {\n            return this.transports_[0];\n        } else {\n            throw new Error(\"No transports available\");\n        }\n    }\n    /**\r\n     * @returns The constructor for the next transport, or null\r\n     */ upgradeTransport() {\n        if (this.transports_.length > 1) {\n            return this.transports_[1];\n        } else {\n            return null;\n        }\n    }\n}\n// Keeps track of whether the TransportManager has already chosen a transport to use\nTransportManager.globalTransportInitialized_ = false;\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Abort upgrade attempt if it takes longer than 60s.\nconst UPGRADE_TIMEOUT = 60000;\n// For some transports (WebSockets), we need to \"validate\" the transport by exchanging a few requests and responses.\n// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.\nconst DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;\n// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)\n// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout\n// but we've sent/received enough bytes, we don't cancel the connection.\nconst BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;\nconst BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;\nconst MESSAGE_TYPE = \"t\";\nconst MESSAGE_DATA = \"d\";\nconst CONTROL_SHUTDOWN = \"s\";\nconst CONTROL_RESET = \"r\";\nconst CONTROL_ERROR = \"e\";\nconst CONTROL_PONG = \"o\";\nconst SWITCH_ACK = \"a\";\nconst END_TRANSMISSION = \"n\";\nconst PING = \"p\";\nconst SERVER_HELLO = \"h\";\n/**\r\n * Creates a new real-time connection to the server using whichever method works\r\n * best in the current browser.\r\n */ class Connection {\n    /**\r\n     * @param id - an id for this connection\r\n     * @param repoInfo_ - the info for the endpoint to connect to\r\n     * @param applicationId_ - the Firebase App ID for this project\r\n     * @param appCheckToken_ - The App Check Token for this device.\r\n     * @param authToken_ - The auth token for this session.\r\n     * @param onMessage_ - the callback to be triggered when a server-push message arrives\r\n     * @param onReady_ - the callback to be triggered when this connection is ready to send messages.\r\n     * @param onDisconnect_ - the callback to be triggered when a connection was lost\r\n     * @param onKill_ - the callback to be triggered when this connection has permanently shut down.\r\n     * @param lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server\r\n     */ constructor(id, repoInfo_, applicationId_, appCheckToken_, authToken_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId){\n        this.id = id;\n        this.repoInfo_ = repoInfo_;\n        this.applicationId_ = applicationId_;\n        this.appCheckToken_ = appCheckToken_;\n        this.authToken_ = authToken_;\n        this.onMessage_ = onMessage_;\n        this.onReady_ = onReady_;\n        this.onDisconnect_ = onDisconnect_;\n        this.onKill_ = onKill_;\n        this.lastSessionId = lastSessionId;\n        this.connectionCount = 0;\n        this.pendingDataMessages = [];\n        this.state_ = 0 /* RealtimeState.CONNECTING */ ;\n        this.log_ = logWrapper(\"c:\" + this.id + \":\");\n        this.transportManager_ = new TransportManager(repoInfo_);\n        this.log_(\"Connection created\");\n        this.start_();\n    }\n    /**\r\n     * Starts a connection attempt\r\n     */ start_() {\n        const conn = this.transportManager_.initialTransport();\n        this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId);\n        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n        // can consider the transport healthy.\n        this.primaryResponsesRequired_ = conn[\"responsesRequiredToBeHealthy\"] || 0;\n        const onMessageReceived = this.connReceiver_(this.conn_);\n        const onConnectionLost = this.disconnReceiver_(this.conn_);\n        this.tx_ = this.conn_;\n        this.rx_ = this.conn_;\n        this.secondaryConn_ = null;\n        this.isHealthy_ = false;\n        /*\r\n         * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.\r\n         * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.\r\n         * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should\r\n         * still have the context of your originating frame.\r\n         */ setTimeout(()=>{\n            // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it\n            this.conn_ && this.conn_.open(onMessageReceived, onConnectionLost);\n        }, Math.floor(0));\n        const healthyTimeoutMS = conn[\"healthyTimeout\"] || 0;\n        if (healthyTimeoutMS > 0) {\n            this.healthyTimeout_ = setTimeoutNonBlocking(()=>{\n                this.healthyTimeout_ = null;\n                if (!this.isHealthy_) {\n                    if (this.conn_ && this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {\n                        this.log_(\"Connection exceeded healthy timeout but has received \" + this.conn_.bytesReceived + \" bytes.  Marking connection healthy.\");\n                        this.isHealthy_ = true;\n                        this.conn_.markConnectionHealthy();\n                    } else if (this.conn_ && this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {\n                        this.log_(\"Connection exceeded healthy timeout but has sent \" + this.conn_.bytesSent + \" bytes.  Leaving connection alive.\");\n                    // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to\n                    // the server.\n                    } else {\n                        this.log_(\"Closing unhealthy connection after timeout.\");\n                        this.close();\n                    }\n                }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }, Math.floor(healthyTimeoutMS));\n        }\n    }\n    nextTransportId_() {\n        return \"c:\" + this.id + \":\" + this.connectionCount++;\n    }\n    disconnReceiver_(conn) {\n        return (everConnected)=>{\n            if (conn === this.conn_) {\n                this.onConnectionLost_(everConnected);\n            } else if (conn === this.secondaryConn_) {\n                this.log_(\"Secondary connection lost.\");\n                this.onSecondaryConnectionLost_();\n            } else {\n                this.log_(\"closing an old connection\");\n            }\n        };\n    }\n    connReceiver_(conn) {\n        return (message)=>{\n            if (this.state_ !== 2 /* RealtimeState.DISCONNECTED */ ) {\n                if (conn === this.rx_) {\n                    this.onPrimaryMessageReceived_(message);\n                } else if (conn === this.secondaryConn_) {\n                    this.onSecondaryMessageReceived_(message);\n                } else {\n                    this.log_(\"message on old connection\");\n                }\n            }\n        };\n    }\n    /**\r\n     * @param dataMsg - An arbitrary data message to be sent to the server\r\n     */ sendRequest(dataMsg) {\n        // wrap in a data message envelope and send it on\n        const msg = {\n            t: \"d\",\n            d: dataMsg\n        };\n        this.sendData_(msg);\n    }\n    tryCleanupConnection() {\n        if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {\n            this.log_(\"cleaning up and promoting a connection: \" + this.secondaryConn_.connId);\n            this.conn_ = this.secondaryConn_;\n            this.secondaryConn_ = null;\n        // the server will shutdown the old connection\n        }\n    }\n    onSecondaryControl_(controlData) {\n        if (MESSAGE_TYPE in controlData) {\n            const cmd = controlData[MESSAGE_TYPE];\n            if (cmd === SWITCH_ACK) {\n                this.upgradeIfSecondaryHealthy_();\n            } else if (cmd === CONTROL_RESET) {\n                // Most likely the session wasn't valid. Abandon the switch attempt\n                this.log_(\"Got a reset on secondary, closing it\");\n                this.secondaryConn_.close();\n                // If we were already using this connection for something, than we need to fully close\n                if (this.tx_ === this.secondaryConn_ || this.rx_ === this.secondaryConn_) {\n                    this.close();\n                }\n            } else if (cmd === CONTROL_PONG) {\n                this.log_(\"got pong on secondary.\");\n                this.secondaryResponsesRequired_--;\n                this.upgradeIfSecondaryHealthy_();\n            }\n        }\n    }\n    onSecondaryMessageReceived_(parsedData) {\n        const layer = requireKey(\"t\", parsedData);\n        const data = requireKey(\"d\", parsedData);\n        if (layer === \"c\") {\n            this.onSecondaryControl_(data);\n        } else if (layer === \"d\") {\n            // got a data message, but we're still second connection. Need to buffer it up\n            this.pendingDataMessages.push(data);\n        } else {\n            throw new Error(\"Unknown protocol layer: \" + layer);\n        }\n    }\n    upgradeIfSecondaryHealthy_() {\n        if (this.secondaryResponsesRequired_ <= 0) {\n            this.log_(\"Secondary connection is healthy.\");\n            this.isHealthy_ = true;\n            this.secondaryConn_.markConnectionHealthy();\n            this.proceedWithUpgrade_();\n        } else {\n            // Send a ping to make sure the connection is healthy.\n            this.log_(\"sending ping on secondary.\");\n            this.secondaryConn_.send({\n                t: \"c\",\n                d: {\n                    t: PING,\n                    d: {}\n                }\n            });\n        }\n    }\n    proceedWithUpgrade_() {\n        // tell this connection to consider itself open\n        this.secondaryConn_.start();\n        // send ack\n        this.log_(\"sending client ack on secondary\");\n        this.secondaryConn_.send({\n            t: \"c\",\n            d: {\n                t: SWITCH_ACK,\n                d: {}\n            }\n        });\n        // send end packet on primary transport, switch to sending on this one\n        // can receive on this one, buffer responses until end received on primary transport\n        this.log_(\"Ending transmission on primary\");\n        this.conn_.send({\n            t: \"c\",\n            d: {\n                t: END_TRANSMISSION,\n                d: {}\n            }\n        });\n        this.tx_ = this.secondaryConn_;\n        this.tryCleanupConnection();\n    }\n    onPrimaryMessageReceived_(parsedData) {\n        // Must refer to parsedData properties in quotes, so closure doesn't touch them.\n        const layer = requireKey(\"t\", parsedData);\n        const data = requireKey(\"d\", parsedData);\n        if (layer === \"c\") {\n            this.onControl_(data);\n        } else if (layer === \"d\") {\n            this.onDataMessage_(data);\n        }\n    }\n    onDataMessage_(message) {\n        this.onPrimaryResponse_();\n        // We don't do anything with data messages, just kick them up a level\n        this.onMessage_(message);\n    }\n    onPrimaryResponse_() {\n        if (!this.isHealthy_) {\n            this.primaryResponsesRequired_--;\n            if (this.primaryResponsesRequired_ <= 0) {\n                this.log_(\"Primary connection is healthy.\");\n                this.isHealthy_ = true;\n                this.conn_.markConnectionHealthy();\n            }\n        }\n    }\n    onControl_(controlData) {\n        const cmd = requireKey(MESSAGE_TYPE, controlData);\n        if (MESSAGE_DATA in controlData) {\n            const payload = controlData[MESSAGE_DATA];\n            if (cmd === SERVER_HELLO) {\n                const handshakePayload = Object.assign({}, payload);\n                if (this.repoInfo_.isUsingEmulator) {\n                    // Upon connecting, the emulator will pass the hostname that it's aware of, but we prefer the user's set hostname via `connectDatabaseEmulator` over what the emulator passes.\n                    handshakePayload.h = this.repoInfo_.host;\n                }\n                this.onHandshake_(handshakePayload);\n            } else if (cmd === END_TRANSMISSION) {\n                this.log_(\"recvd end transmission on primary\");\n                this.rx_ = this.secondaryConn_;\n                for(let i = 0; i < this.pendingDataMessages.length; ++i){\n                    this.onDataMessage_(this.pendingDataMessages[i]);\n                }\n                this.pendingDataMessages = [];\n                this.tryCleanupConnection();\n            } else if (cmd === CONTROL_SHUTDOWN) {\n                // This was previously the 'onKill' callback passed to the lower-level connection\n                // payload in this case is the reason for the shutdown. Generally a human-readable error\n                this.onConnectionShutdown_(payload);\n            } else if (cmd === CONTROL_RESET) {\n                // payload in this case is the host we should contact\n                this.onReset_(payload);\n            } else if (cmd === CONTROL_ERROR) {\n                error(\"Server Error: \" + payload);\n            } else if (cmd === CONTROL_PONG) {\n                this.log_(\"got pong on primary.\");\n                this.onPrimaryResponse_();\n                this.sendPingOnPrimaryIfNecessary_();\n            } else {\n                error(\"Unknown control packet command: \" + cmd);\n            }\n        }\n    }\n    /**\r\n     * @param handshake - The handshake data returned from the server\r\n     */ onHandshake_(handshake) {\n        const timestamp = handshake.ts;\n        const version = handshake.v;\n        const host = handshake.h;\n        this.sessionId = handshake.s;\n        this.repoInfo_.host = host;\n        // if we've already closed the connection, then don't bother trying to progress further\n        if (this.state_ === 0 /* RealtimeState.CONNECTING */ ) {\n            this.conn_.start();\n            this.onConnectionEstablished_(this.conn_, timestamp);\n            if (PROTOCOL_VERSION !== version) {\n                warn(\"Protocol version mismatch detected\");\n            }\n            // TODO: do we want to upgrade? when? maybe a delay?\n            this.tryStartUpgrade_();\n        }\n    }\n    tryStartUpgrade_() {\n        const conn = this.transportManager_.upgradeTransport();\n        if (conn) {\n            this.startUpgrade_(conn);\n        }\n    }\n    startUpgrade_(conn) {\n        this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId);\n        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n        // can consider the transport healthy.\n        this.secondaryResponsesRequired_ = conn[\"responsesRequiredToBeHealthy\"] || 0;\n        const onMessage = this.connReceiver_(this.secondaryConn_);\n        const onDisconnect = this.disconnReceiver_(this.secondaryConn_);\n        this.secondaryConn_.open(onMessage, onDisconnect);\n        // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.\n        setTimeoutNonBlocking(()=>{\n            if (this.secondaryConn_) {\n                this.log_(\"Timed out trying to upgrade.\");\n                this.secondaryConn_.close();\n            }\n        }, Math.floor(UPGRADE_TIMEOUT));\n    }\n    onReset_(host) {\n        this.log_(\"Reset packet received.  New host: \" + host);\n        this.repoInfo_.host = host;\n        // TODO: if we're already \"connected\", we need to trigger a disconnect at the next layer up.\n        // We don't currently support resets after the connection has already been established\n        if (this.state_ === 1 /* RealtimeState.CONNECTED */ ) {\n            this.close();\n        } else {\n            // Close whatever connections we have open and start again.\n            this.closeConnections_();\n            this.start_();\n        }\n    }\n    onConnectionEstablished_(conn, timestamp) {\n        this.log_(\"Realtime connection established.\");\n        this.conn_ = conn;\n        this.state_ = 1 /* RealtimeState.CONNECTED */ ;\n        if (this.onReady_) {\n            this.onReady_(timestamp, this.sessionId);\n            this.onReady_ = null;\n        }\n        // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,\n        // send some pings.\n        if (this.primaryResponsesRequired_ === 0) {\n            this.log_(\"Primary connection is healthy.\");\n            this.isHealthy_ = true;\n        } else {\n            setTimeoutNonBlocking(()=>{\n                this.sendPingOnPrimaryIfNecessary_();\n            }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));\n        }\n    }\n    sendPingOnPrimaryIfNecessary_() {\n        // If the connection isn't considered healthy yet, we'll send a noop ping packet request.\n        if (!this.isHealthy_ && this.state_ === 1 /* RealtimeState.CONNECTED */ ) {\n            this.log_(\"sending ping on primary.\");\n            this.sendData_({\n                t: \"c\",\n                d: {\n                    t: PING,\n                    d: {}\n                }\n            });\n        }\n    }\n    onSecondaryConnectionLost_() {\n        const conn = this.secondaryConn_;\n        this.secondaryConn_ = null;\n        if (this.tx_ === conn || this.rx_ === conn) {\n            // we are relying on this connection already in some capacity. Therefore, a failure is real\n            this.close();\n        }\n    }\n    /**\r\n     * @param everConnected - Whether or not the connection ever reached a server. Used to determine if\r\n     * we should flush the host cache\r\n     */ onConnectionLost_(everConnected) {\n        this.conn_ = null;\n        // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting\n        // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.\n        if (!everConnected && this.state_ === 0 /* RealtimeState.CONNECTING */ ) {\n            this.log_(\"Realtime connection failed.\");\n            // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away\n            if (this.repoInfo_.isCacheableHost()) {\n                PersistentStorage.remove(\"host:\" + this.repoInfo_.host);\n                // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com\n                this.repoInfo_.internalHost = this.repoInfo_.host;\n            }\n        } else if (this.state_ === 1 /* RealtimeState.CONNECTED */ ) {\n            this.log_(\"Realtime connection lost.\");\n        }\n        this.close();\n    }\n    onConnectionShutdown_(reason) {\n        this.log_(\"Connection shutdown command received. Shutting down...\");\n        if (this.onKill_) {\n            this.onKill_(reason);\n            this.onKill_ = null;\n        }\n        // We intentionally don't want to fire onDisconnect (kill is a different case),\n        // so clear the callback.\n        this.onDisconnect_ = null;\n        this.close();\n    }\n    sendData_(data) {\n        if (this.state_ !== 1 /* RealtimeState.CONNECTED */ ) {\n            throw \"Connection is not connected\";\n        } else {\n            this.tx_.send(data);\n        }\n    }\n    /**\r\n     * Cleans up this connection, calling the appropriate callbacks\r\n     */ close() {\n        if (this.state_ !== 2 /* RealtimeState.DISCONNECTED */ ) {\n            this.log_(\"Closing realtime connection.\");\n            this.state_ = 2 /* RealtimeState.DISCONNECTED */ ;\n            this.closeConnections_();\n            if (this.onDisconnect_) {\n                this.onDisconnect_();\n                this.onDisconnect_ = null;\n            }\n        }\n    }\n    closeConnections_() {\n        this.log_(\"Shutting down all connections\");\n        if (this.conn_) {\n            this.conn_.close();\n            this.conn_ = null;\n        }\n        if (this.secondaryConn_) {\n            this.secondaryConn_.close();\n            this.secondaryConn_ = null;\n        }\n        if (this.healthyTimeout_) {\n            clearTimeout(this.healthyTimeout_);\n            this.healthyTimeout_ = null;\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Interface defining the set of actions that can be performed against the Firebase server\r\n * (basically corresponds to our wire protocol).\r\n *\r\n * @interface\r\n */ class ServerActions {\n    put(pathString, data, onComplete, hash) {}\n    merge(pathString, data, onComplete, hash) {}\n    /**\r\n     * Refreshes the auth token for the current connection.\r\n     * @param token - The authentication token\r\n     */ refreshAuthToken(token) {}\n    /**\r\n     * Refreshes the app check token for the current connection.\r\n     * @param token The app check token\r\n     */ refreshAppCheckToken(token) {}\n    onDisconnectPut(pathString, data, onComplete) {}\n    onDisconnectMerge(pathString, data, onComplete) {}\n    onDisconnectCancel(pathString, onComplete) {}\n    reportStats(stats) {}\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Base class to be used if you want to emit events. Call the constructor with\r\n * the set of allowed event names.\r\n */ class EventEmitter {\n    constructor(allowedEvents_){\n        this.allowedEvents_ = allowedEvents_;\n        this.listeners_ = {};\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, \"Requires a non-empty array\");\n    }\n    /**\r\n     * To be called by derived classes to trigger events.\r\n     */ trigger(eventType, ...varArgs) {\n        if (Array.isArray(this.listeners_[eventType])) {\n            // Clone the list, since callbacks could add/remove listeners.\n            const listeners = [\n                ...this.listeners_[eventType]\n            ];\n            for(let i = 0; i < listeners.length; i++){\n                listeners[i].callback.apply(listeners[i].context, varArgs);\n            }\n        }\n    }\n    on(eventType, callback, context) {\n        this.validateEventType_(eventType);\n        this.listeners_[eventType] = this.listeners_[eventType] || [];\n        this.listeners_[eventType].push({\n            callback,\n            context\n        });\n        const eventData = this.getInitialEvent(eventType);\n        if (eventData) {\n            callback.apply(context, eventData);\n        }\n    }\n    off(eventType, callback, context) {\n        this.validateEventType_(eventType);\n        const listeners = this.listeners_[eventType] || [];\n        for(let i = 0; i < listeners.length; i++){\n            if (listeners[i].callback === callback && (!context || context === listeners[i].context)) {\n                listeners.splice(i, 1);\n                return;\n            }\n        }\n    }\n    validateEventType_(eventType) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.allowedEvents_.find((et)=>{\n            return et === eventType;\n        }), \"Unknown event: \" + eventType);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Monitors online state (as reported by window.online/offline events).\r\n *\r\n * The expectation is that this could have many false positives (thinks we are online\r\n * when we're not), but no false negatives.  So we can safely use it to determine when\r\n * we definitely cannot reach the internet.\r\n */ class OnlineMonitor extends EventEmitter {\n    constructor(){\n        super([\n            \"online\"\n        ]);\n        this.online_ = true;\n        // We've had repeated complaints that Cordova apps can get stuck \"offline\", e.g.\n        // https://forum.ionicframework.com/t/firebase-connection-is-lost-and-never-come-back/43810\n        // It would seem that the 'online' event does not always fire consistently. So we disable it\n        // for Cordova.\n        if (false) {}\n    }\n    static getInstance() {\n        return new OnlineMonitor();\n    }\n    getInitialEvent(eventType) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(eventType === \"online\", \"Unknown event type: \" + eventType);\n        return [\n            this.online_\n        ];\n    }\n    currentlyOnline() {\n        return this.online_;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /** Maximum key depth. */ const MAX_PATH_DEPTH = 32;\n/** Maximum number of (UTF8) bytes in a Firebase path. */ const MAX_PATH_LENGTH_BYTES = 768;\n/**\r\n * An immutable object representing a parsed path.  It's immutable so that you\r\n * can pass them around to other functions without worrying about them changing\r\n * it.\r\n */ class Path {\n    /**\r\n     * @param pathOrString - Path string to parse, or another path, or the raw\r\n     * tokens array\r\n     */ constructor(pathOrString, pieceNum){\n        if (pieceNum === void 0) {\n            this.pieces_ = pathOrString.split(\"/\");\n            // Remove empty pieces.\n            let copyTo = 0;\n            for(let i = 0; i < this.pieces_.length; i++){\n                if (this.pieces_[i].length > 0) {\n                    this.pieces_[copyTo] = this.pieces_[i];\n                    copyTo++;\n                }\n            }\n            this.pieces_.length = copyTo;\n            this.pieceNum_ = 0;\n        } else {\n            this.pieces_ = pathOrString;\n            this.pieceNum_ = pieceNum;\n        }\n    }\n    toString() {\n        let pathString = \"\";\n        for(let i = this.pieceNum_; i < this.pieces_.length; i++){\n            if (this.pieces_[i] !== \"\") {\n                pathString += \"/\" + this.pieces_[i];\n            }\n        }\n        return pathString || \"/\";\n    }\n}\nfunction newEmptyPath() {\n    return new Path(\"\");\n}\nfunction pathGetFront(path) {\n    if (path.pieceNum_ >= path.pieces_.length) {\n        return null;\n    }\n    return path.pieces_[path.pieceNum_];\n}\n/**\r\n * @returns The number of segments in this path\r\n */ function pathGetLength(path) {\n    return path.pieces_.length - path.pieceNum_;\n}\nfunction pathPopFront(path) {\n    let pieceNum = path.pieceNum_;\n    if (pieceNum < path.pieces_.length) {\n        pieceNum++;\n    }\n    return new Path(path.pieces_, pieceNum);\n}\nfunction pathGetBack(path) {\n    if (path.pieceNum_ < path.pieces_.length) {\n        return path.pieces_[path.pieces_.length - 1];\n    }\n    return null;\n}\nfunction pathToUrlEncodedString(path) {\n    let pathString = \"\";\n    for(let i = path.pieceNum_; i < path.pieces_.length; i++){\n        if (path.pieces_[i] !== \"\") {\n            pathString += \"/\" + encodeURIComponent(String(path.pieces_[i]));\n        }\n    }\n    return pathString || \"/\";\n}\n/**\r\n * Shallow copy of the parts of the path.\r\n *\r\n */ function pathSlice(path, begin = 0) {\n    return path.pieces_.slice(path.pieceNum_ + begin);\n}\nfunction pathParent(path) {\n    if (path.pieceNum_ >= path.pieces_.length) {\n        return null;\n    }\n    const pieces = [];\n    for(let i = path.pieceNum_; i < path.pieces_.length - 1; i++){\n        pieces.push(path.pieces_[i]);\n    }\n    return new Path(pieces, 0);\n}\nfunction pathChild(path, childPathObj) {\n    const pieces = [];\n    for(let i = path.pieceNum_; i < path.pieces_.length; i++){\n        pieces.push(path.pieces_[i]);\n    }\n    if (childPathObj instanceof Path) {\n        for(let i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++){\n            pieces.push(childPathObj.pieces_[i]);\n        }\n    } else {\n        const childPieces = childPathObj.split(\"/\");\n        for(let i = 0; i < childPieces.length; i++){\n            if (childPieces[i].length > 0) {\n                pieces.push(childPieces[i]);\n            }\n        }\n    }\n    return new Path(pieces, 0);\n}\n/**\r\n * @returns True if there are no segments in this path\r\n */ function pathIsEmpty(path) {\n    return path.pieceNum_ >= path.pieces_.length;\n}\n/**\r\n * @returns The path from outerPath to innerPath\r\n */ function newRelativePath(outerPath, innerPath) {\n    const outer = pathGetFront(outerPath), inner = pathGetFront(innerPath);\n    if (outer === null) {\n        return innerPath;\n    } else if (outer === inner) {\n        return newRelativePath(pathPopFront(outerPath), pathPopFront(innerPath));\n    } else {\n        throw new Error(\"INTERNAL ERROR: innerPath (\" + innerPath + \") is not within \" + \"outerPath (\" + outerPath + \")\");\n    }\n}\n/**\r\n * @returns -1, 0, 1 if left is less, equal, or greater than the right.\r\n */ function pathCompare(left, right) {\n    const leftKeys = pathSlice(left, 0);\n    const rightKeys = pathSlice(right, 0);\n    for(let i = 0; i < leftKeys.length && i < rightKeys.length; i++){\n        const cmp = nameCompare(leftKeys[i], rightKeys[i]);\n        if (cmp !== 0) {\n            return cmp;\n        }\n    }\n    if (leftKeys.length === rightKeys.length) {\n        return 0;\n    }\n    return leftKeys.length < rightKeys.length ? -1 : 1;\n}\n/**\r\n * @returns true if paths are the same.\r\n */ function pathEquals(path, other) {\n    if (pathGetLength(path) !== pathGetLength(other)) {\n        return false;\n    }\n    for(let i = path.pieceNum_, j = other.pieceNum_; i <= path.pieces_.length; i++, j++){\n        if (path.pieces_[i] !== other.pieces_[j]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\r\n * @returns True if this path is a parent of (or the same as) other\r\n */ function pathContains(path, other) {\n    let i = path.pieceNum_;\n    let j = other.pieceNum_;\n    if (pathGetLength(path) > pathGetLength(other)) {\n        return false;\n    }\n    while(i < path.pieces_.length){\n        if (path.pieces_[i] !== other.pieces_[j]) {\n            return false;\n        }\n        ++i;\n        ++j;\n    }\n    return true;\n}\n/**\r\n * Dynamic (mutable) path used to count path lengths.\r\n *\r\n * This class is used to efficiently check paths for valid\r\n * length (in UTF8 bytes) and depth (used in path validation).\r\n *\r\n * Throws Error exception if path is ever invalid.\r\n *\r\n * The definition of a path always begins with '/'.\r\n */ class ValidationPath {\n    /**\r\n     * @param path - Initial Path.\r\n     * @param errorPrefix_ - Prefix for any error messages.\r\n     */ constructor(path, errorPrefix_){\n        this.errorPrefix_ = errorPrefix_;\n        this.parts_ = pathSlice(path, 0);\n        /** Initialize to number of '/' chars needed in path. */ this.byteLength_ = Math.max(1, this.parts_.length);\n        for(let i = 0; i < this.parts_.length; i++){\n            this.byteLength_ += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringLength)(this.parts_[i]);\n        }\n        validationPathCheckValid(this);\n    }\n}\nfunction validationPathPush(validationPath, child) {\n    // Count the needed '/'\n    if (validationPath.parts_.length > 0) {\n        validationPath.byteLength_ += 1;\n    }\n    validationPath.parts_.push(child);\n    validationPath.byteLength_ += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringLength)(child);\n    validationPathCheckValid(validationPath);\n}\nfunction validationPathPop(validationPath) {\n    const last = validationPath.parts_.pop();\n    validationPath.byteLength_ -= (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringLength)(last);\n    // Un-count the previous '/'\n    if (validationPath.parts_.length > 0) {\n        validationPath.byteLength_ -= 1;\n    }\n}\nfunction validationPathCheckValid(validationPath) {\n    if (validationPath.byteLength_ > MAX_PATH_LENGTH_BYTES) {\n        throw new Error(validationPath.errorPrefix_ + \"has a key path longer than \" + MAX_PATH_LENGTH_BYTES + \" bytes (\" + validationPath.byteLength_ + \").\");\n    }\n    if (validationPath.parts_.length > MAX_PATH_DEPTH) {\n        throw new Error(validationPath.errorPrefix_ + \"path specified exceeds the maximum depth that can be written (\" + MAX_PATH_DEPTH + \") or object contains a cycle \" + validationPathToErrorString(validationPath));\n    }\n}\n/**\r\n * String for use in error messages - uses '.' notation for path.\r\n */ function validationPathToErrorString(validationPath) {\n    if (validationPath.parts_.length === 0) {\n        return \"\";\n    }\n    return \"in property '\" + validationPath.parts_.join(\".\") + \"'\";\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class VisibilityMonitor extends EventEmitter {\n    constructor(){\n        super([\n            \"visible\"\n        ]);\n        let hidden;\n        let visibilityChange;\n        if (typeof document !== \"undefined\" && typeof document.addEventListener !== \"undefined\") {\n            if (typeof document[\"hidden\"] !== \"undefined\") {\n                // Opera 12.10 and Firefox 18 and later support\n                visibilityChange = \"visibilitychange\";\n                hidden = \"hidden\";\n            } else if (typeof document[\"mozHidden\"] !== \"undefined\") {\n                visibilityChange = \"mozvisibilitychange\";\n                hidden = \"mozHidden\";\n            } else if (typeof document[\"msHidden\"] !== \"undefined\") {\n                visibilityChange = \"msvisibilitychange\";\n                hidden = \"msHidden\";\n            } else if (typeof document[\"webkitHidden\"] !== \"undefined\") {\n                visibilityChange = \"webkitvisibilitychange\";\n                hidden = \"webkitHidden\";\n            }\n        }\n        // Initially, we always assume we are visible. This ensures that in browsers\n        // without page visibility support or in cases where we are never visible\n        // (e.g. chrome extension), we act as if we are visible, i.e. don't delay\n        // reconnects\n        this.visible_ = true;\n        if (visibilityChange) {\n            document.addEventListener(visibilityChange, ()=>{\n                const visible = !document[hidden];\n                if (visible !== this.visible_) {\n                    this.visible_ = visible;\n                    this.trigger(\"visible\", visible);\n                }\n            }, false);\n        }\n    }\n    static getInstance() {\n        return new VisibilityMonitor();\n    }\n    getInitialEvent(eventType) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(eventType === \"visible\", \"Unknown event type: \" + eventType);\n        return [\n            this.visible_\n        ];\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const RECONNECT_MIN_DELAY = 1000;\nconst RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)\nconst RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)\nconst RECONNECT_DELAY_MULTIPLIER = 1.3;\nconst RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.\nconst SERVER_KILL_INTERRUPT_REASON = \"server_kill\";\n// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.\nconst INVALID_TOKEN_THRESHOLD = 3;\n/**\r\n * Firebase connection.  Abstracts wire protocol and handles reconnecting.\r\n *\r\n * NOTE: All JSON objects sent to the realtime connection must have property names enclosed\r\n * in quotes to make sure the closure compiler does not minify them.\r\n */ class PersistentConnection extends ServerActions {\n    /**\r\n     * @param repoInfo_ - Data about the namespace we are connecting to\r\n     * @param applicationId_ - The Firebase App ID for this project\r\n     * @param onDataUpdate_ - A callback for new data from the server\r\n     */ constructor(repoInfo_, applicationId_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, appCheckTokenProvider_, authOverride_){\n        super();\n        this.repoInfo_ = repoInfo_;\n        this.applicationId_ = applicationId_;\n        this.onDataUpdate_ = onDataUpdate_;\n        this.onConnectStatus_ = onConnectStatus_;\n        this.onServerInfoUpdate_ = onServerInfoUpdate_;\n        this.authTokenProvider_ = authTokenProvider_;\n        this.appCheckTokenProvider_ = appCheckTokenProvider_;\n        this.authOverride_ = authOverride_;\n        // Used for diagnostic logging.\n        this.id = PersistentConnection.nextPersistentConnectionId_++;\n        this.log_ = logWrapper(\"p:\" + this.id + \":\");\n        this.interruptReasons_ = {};\n        this.listens = new Map();\n        this.outstandingPuts_ = [];\n        this.outstandingGets_ = [];\n        this.outstandingPutCount_ = 0;\n        this.outstandingGetCount_ = 0;\n        this.onDisconnectRequestQueue_ = [];\n        this.connected_ = false;\n        this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n        this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;\n        this.securityDebugCallback_ = null;\n        this.lastSessionId = null;\n        this.establishConnectionTimer_ = null;\n        this.visible_ = false;\n        // Before we get connected, we keep a queue of pending messages to send.\n        this.requestCBHash_ = {};\n        this.requestNumber_ = 0;\n        this.realtime_ = null;\n        this.authToken_ = null;\n        this.appCheckToken_ = null;\n        this.forceTokenRefresh_ = false;\n        this.invalidAuthTokenCount_ = 0;\n        this.invalidAppCheckTokenCount_ = 0;\n        this.firstConnection_ = true;\n        this.lastConnectionAttemptTime_ = null;\n        this.lastConnectionEstablishedTime_ = null;\n        if (authOverride_ && !(0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n            throw new Error(\"Auth override specified in options, but not supported on non Node.js platforms\");\n        }\n        VisibilityMonitor.getInstance().on(\"visible\", this.onVisible_, this);\n        if (repoInfo_.host.indexOf(\"fblocal\") === -1) {\n            OnlineMonitor.getInstance().on(\"online\", this.onOnline_, this);\n        }\n    }\n    sendRequest(action, body, onResponse) {\n        const curReqNum = ++this.requestNumber_;\n        const msg = {\n            r: curReqNum,\n            a: action,\n            b: body\n        };\n        this.log_((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(msg));\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.connected_, \"sendRequest call when we're not connected not allowed.\");\n        this.realtime_.sendRequest(msg);\n        if (onResponse) {\n            this.requestCBHash_[curReqNum] = onResponse;\n        }\n    }\n    get(query) {\n        this.initConnection_();\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        const request = {\n            p: query._path.toString(),\n            q: query._queryObject\n        };\n        const outstandingGet = {\n            action: \"g\",\n            request,\n            onComplete: (message)=>{\n                const payload = message[\"d\"];\n                if (message[\"s\"] === \"ok\") {\n                    deferred.resolve(payload);\n                } else {\n                    deferred.reject(payload);\n                }\n            }\n        };\n        this.outstandingGets_.push(outstandingGet);\n        this.outstandingGetCount_++;\n        const index = this.outstandingGets_.length - 1;\n        if (this.connected_) {\n            this.sendGet_(index);\n        }\n        return deferred.promise;\n    }\n    listen(query, currentHashFn, tag, onComplete) {\n        this.initConnection_();\n        const queryId = query._queryIdentifier;\n        const pathString = query._path.toString();\n        this.log_(\"Listen called for \" + pathString + \" \" + queryId);\n        if (!this.listens.has(pathString)) {\n            this.listens.set(pathString, new Map());\n        }\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), \"listen() called for non-default but complete query\");\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.listens.get(pathString).has(queryId), `listen() called twice for same path/queryId.`);\n        const listenSpec = {\n            onComplete,\n            hashFn: currentHashFn,\n            query,\n            tag\n        };\n        this.listens.get(pathString).set(queryId, listenSpec);\n        if (this.connected_) {\n            this.sendListen_(listenSpec);\n        }\n    }\n    sendGet_(index) {\n        const get = this.outstandingGets_[index];\n        this.sendRequest(\"g\", get.request, (message)=>{\n            delete this.outstandingGets_[index];\n            this.outstandingGetCount_--;\n            if (this.outstandingGetCount_ === 0) {\n                this.outstandingGets_ = [];\n            }\n            if (get.onComplete) {\n                get.onComplete(message);\n            }\n        });\n    }\n    sendListen_(listenSpec) {\n        const query = listenSpec.query;\n        const pathString = query._path.toString();\n        const queryId = query._queryIdentifier;\n        this.log_(\"Listen on \" + pathString + \" for \" + queryId);\n        const req = {\n            p: pathString\n        };\n        const action = \"q\";\n        // Only bother to send query if it's non-default.\n        if (listenSpec.tag) {\n            req[\"q\"] = query._queryObject;\n            req[\"t\"] = listenSpec.tag;\n        }\n        req[/*hash*/ \"h\"] = listenSpec.hashFn();\n        this.sendRequest(action, req, (message)=>{\n            const payload = message[/*data*/ \"d\"];\n            const status = message[/*status*/ \"s\"];\n            // print warnings in any case...\n            PersistentConnection.warnOnListenWarnings_(payload, query);\n            const currentListenSpec = this.listens.get(pathString) && this.listens.get(pathString).get(queryId);\n            // only trigger actions if the listen hasn't been removed and readded\n            if (currentListenSpec === listenSpec) {\n                this.log_(\"listen response\", message);\n                if (status !== \"ok\") {\n                    this.removeListen_(pathString, queryId);\n                }\n                if (listenSpec.onComplete) {\n                    listenSpec.onComplete(status, payload);\n                }\n            }\n        });\n    }\n    static warnOnListenWarnings_(payload, query) {\n        if (payload && typeof payload === \"object\" && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(payload, \"w\")) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const warnings = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(payload, \"w\");\n            if (Array.isArray(warnings) && ~warnings.indexOf(\"no_index\")) {\n                const indexSpec = '\".indexOn\": \"' + query._queryParams.getIndex().toString() + '\"';\n                const indexPath = query._path.toString();\n                warn(`Using an unspecified index. Your data will be downloaded and ` + `filtered on the client. Consider adding ${indexSpec} at ` + `${indexPath} to your security rules for better performance.`);\n            }\n        }\n    }\n    refreshAuthToken(token) {\n        this.authToken_ = token;\n        this.log_(\"Auth token refreshed\");\n        if (this.authToken_) {\n            this.tryAuth();\n        } else {\n            //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete\n            //the credential so we dont become authenticated next time we connect.\n            if (this.connected_) {\n                this.sendRequest(\"unauth\", {}, ()=>{});\n            }\n        }\n        this.reduceReconnectDelayIfAdminCredential_(token);\n    }\n    reduceReconnectDelayIfAdminCredential_(credential) {\n        // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).\n        // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.\n        const isFirebaseSecret = credential && credential.length === 40;\n        if (isFirebaseSecret || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isAdmin)(credential)) {\n            this.log_(\"Admin auth credential detected.  Reducing max reconnect time.\");\n            this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n        }\n    }\n    refreshAppCheckToken(token) {\n        this.appCheckToken_ = token;\n        this.log_(\"App check token refreshed\");\n        if (this.appCheckToken_) {\n            this.tryAppCheck();\n        } else {\n            //If we're connected we want to let the server know to unauthenticate us.\n            //If we're not connected, simply delete the credential so we dont become\n            // authenticated next time we connect.\n            if (this.connected_) {\n                this.sendRequest(\"unappeck\", {}, ()=>{});\n            }\n        }\n    }\n    /**\r\n     * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like\r\n     * a auth revoked (the connection is closed).\r\n     */ tryAuth() {\n        if (this.connected_ && this.authToken_) {\n            const token = this.authToken_;\n            const authMethod = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isValidFormat)(token) ? \"auth\" : \"gauth\";\n            const requestData = {\n                cred: token\n            };\n            if (this.authOverride_ === null) {\n                requestData[\"noauth\"] = true;\n            } else if (typeof this.authOverride_ === \"object\") {\n                requestData[\"authvar\"] = this.authOverride_;\n            }\n            this.sendRequest(authMethod, requestData, (res)=>{\n                const status = res[/*status*/ \"s\"];\n                const data = res[/*data*/ \"d\"] || \"error\";\n                if (this.authToken_ === token) {\n                    if (status === \"ok\") {\n                        this.invalidAuthTokenCount_ = 0;\n                    } else {\n                        // Triggers reconnect and force refresh for auth token\n                        this.onAuthRevoked_(status, data);\n                    }\n                }\n            });\n        }\n    }\n    /**\r\n     * Attempts to authenticate with the given token. If the authentication\r\n     * attempt fails, it's triggered like the token was revoked (the connection is\r\n     * closed).\r\n     */ tryAppCheck() {\n        if (this.connected_ && this.appCheckToken_) {\n            this.sendRequest(\"appcheck\", {\n                \"token\": this.appCheckToken_\n            }, (res)=>{\n                const status = res[/*status*/ \"s\"];\n                const data = res[/*data*/ \"d\"] || \"error\";\n                if (status === \"ok\") {\n                    this.invalidAppCheckTokenCount_ = 0;\n                } else {\n                    this.onAppCheckRevoked_(status, data);\n                }\n            });\n        }\n    }\n    /**\r\n     * @inheritDoc\r\n     */ unlisten(query, tag) {\n        const pathString = query._path.toString();\n        const queryId = query._queryIdentifier;\n        this.log_(\"Unlisten called for \" + pathString + \" \" + queryId);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), \"unlisten() called for non-default but complete query\");\n        const listen = this.removeListen_(pathString, queryId);\n        if (listen && this.connected_) {\n            this.sendUnlisten_(pathString, queryId, query._queryObject, tag);\n        }\n    }\n    sendUnlisten_(pathString, queryId, queryObj, tag) {\n        this.log_(\"Unlisten on \" + pathString + \" for \" + queryId);\n        const req = {\n            p: pathString\n        };\n        const action = \"n\";\n        // Only bother sending queryId if it's non-default.\n        if (tag) {\n            req[\"q\"] = queryObj;\n            req[\"t\"] = tag;\n        }\n        this.sendRequest(action, req);\n    }\n    onDisconnectPut(pathString, data, onComplete) {\n        this.initConnection_();\n        if (this.connected_) {\n            this.sendOnDisconnect_(\"o\", pathString, data, onComplete);\n        } else {\n            this.onDisconnectRequestQueue_.push({\n                pathString,\n                action: \"o\",\n                data,\n                onComplete\n            });\n        }\n    }\n    onDisconnectMerge(pathString, data, onComplete) {\n        this.initConnection_();\n        if (this.connected_) {\n            this.sendOnDisconnect_(\"om\", pathString, data, onComplete);\n        } else {\n            this.onDisconnectRequestQueue_.push({\n                pathString,\n                action: \"om\",\n                data,\n                onComplete\n            });\n        }\n    }\n    onDisconnectCancel(pathString, onComplete) {\n        this.initConnection_();\n        if (this.connected_) {\n            this.sendOnDisconnect_(\"oc\", pathString, null, onComplete);\n        } else {\n            this.onDisconnectRequestQueue_.push({\n                pathString,\n                action: \"oc\",\n                data: null,\n                onComplete\n            });\n        }\n    }\n    sendOnDisconnect_(action, pathString, data, onComplete) {\n        const request = {\n            p: pathString,\n            /*data*/ d: data\n        };\n        this.log_(\"onDisconnect \" + action, request);\n        this.sendRequest(action, request, (response)=>{\n            if (onComplete) {\n                setTimeout(()=>{\n                    onComplete(response[/*status*/ \"s\"], response[/* data */ \"d\"]);\n                }, Math.floor(0));\n            }\n        });\n    }\n    put(pathString, data, onComplete, hash) {\n        this.putInternal(\"p\", pathString, data, onComplete, hash);\n    }\n    merge(pathString, data, onComplete, hash) {\n        this.putInternal(\"m\", pathString, data, onComplete, hash);\n    }\n    putInternal(action, pathString, data, onComplete, hash) {\n        this.initConnection_();\n        const request = {\n            /*path*/ p: pathString,\n            /*data*/ d: data\n        };\n        if (hash !== undefined) {\n            request[/*hash*/ \"h\"] = hash;\n        }\n        // TODO: Only keep track of the most recent put for a given path?\n        this.outstandingPuts_.push({\n            action,\n            request,\n            onComplete\n        });\n        this.outstandingPutCount_++;\n        const index = this.outstandingPuts_.length - 1;\n        if (this.connected_) {\n            this.sendPut_(index);\n        } else {\n            this.log_(\"Buffering put: \" + pathString);\n        }\n    }\n    sendPut_(index) {\n        const action = this.outstandingPuts_[index].action;\n        const request = this.outstandingPuts_[index].request;\n        const onComplete = this.outstandingPuts_[index].onComplete;\n        this.outstandingPuts_[index].queued = this.connected_;\n        this.sendRequest(action, request, (message)=>{\n            this.log_(action + \" response\", message);\n            delete this.outstandingPuts_[index];\n            this.outstandingPutCount_--;\n            // Clean up array occasionally.\n            if (this.outstandingPutCount_ === 0) {\n                this.outstandingPuts_ = [];\n            }\n            if (onComplete) {\n                onComplete(message[/*status*/ \"s\"], message[/* data */ \"d\"]);\n            }\n        });\n    }\n    reportStats(stats) {\n        // If we're not connected, we just drop the stats.\n        if (this.connected_) {\n            const request = {\n                c: stats\n            };\n            this.log_(\"reportStats\", request);\n            this.sendRequest(/*stats*/ \"s\", request, (result)=>{\n                const status = result[/*status*/ \"s\"];\n                if (status !== \"ok\") {\n                    const errorReason = result[/* data */ \"d\"];\n                    this.log_(\"reportStats\", \"Error sending stats: \" + errorReason);\n                }\n            });\n        }\n    }\n    onDataMessage_(message) {\n        if (\"r\" in message) {\n            // this is a response\n            this.log_(\"from server: \" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(message));\n            const reqNum = message[\"r\"];\n            const onResponse = this.requestCBHash_[reqNum];\n            if (onResponse) {\n                delete this.requestCBHash_[reqNum];\n                onResponse(message[/*body*/ \"b\"]);\n            }\n        } else if (\"error\" in message) {\n            throw \"A server-side error has occurred: \" + message[\"error\"];\n        } else if (\"a\" in message) {\n            // a and b are action and body, respectively\n            this.onDataPush_(message[\"a\"], message[\"b\"]);\n        }\n    }\n    onDataPush_(action, body) {\n        this.log_(\"handleServerMessage\", action, body);\n        if (action === \"d\") {\n            this.onDataUpdate_(body[/*path*/ \"p\"], body[/*data*/ \"d\"], /*isMerge*/ false, body[\"t\"]);\n        } else if (action === \"m\") {\n            this.onDataUpdate_(body[/*path*/ \"p\"], body[/*data*/ \"d\"], /*isMerge=*/ true, body[\"t\"]);\n        } else if (action === \"c\") {\n            this.onListenRevoked_(body[/*path*/ \"p\"], body[/*query*/ \"q\"]);\n        } else if (action === \"ac\") {\n            this.onAuthRevoked_(body[/*status code*/ \"s\"], body[/* explanation */ \"d\"]);\n        } else if (action === \"apc\") {\n            this.onAppCheckRevoked_(body[/*status code*/ \"s\"], body[/* explanation */ \"d\"]);\n        } else if (action === \"sd\") {\n            this.onSecurityDebugPacket_(body);\n        } else {\n            error(\"Unrecognized action received from server: \" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(action) + \"\\nAre you using the latest client?\");\n        }\n    }\n    onReady_(timestamp, sessionId) {\n        this.log_(\"connection ready\");\n        this.connected_ = true;\n        this.lastConnectionEstablishedTime_ = new Date().getTime();\n        this.handleTimestamp_(timestamp);\n        this.lastSessionId = sessionId;\n        if (this.firstConnection_) {\n            this.sendConnectStats_();\n        }\n        this.restoreState_();\n        this.firstConnection_ = false;\n        this.onConnectStatus_(true);\n    }\n    scheduleConnect_(timeout) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.realtime_, \"Scheduling a connect when we're already connected/ing?\");\n        if (this.establishConnectionTimer_) {\n            clearTimeout(this.establishConnectionTimer_);\n        }\n        // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating \"Security Error\" in\n        // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).\n        this.establishConnectionTimer_ = setTimeout(()=>{\n            this.establishConnectionTimer_ = null;\n            this.establishConnection_();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }, Math.floor(timeout));\n    }\n    initConnection_() {\n        if (!this.realtime_ && this.firstConnection_) {\n            this.scheduleConnect_(0);\n        }\n    }\n    onVisible_(visible) {\n        // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.\n        if (visible && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_) {\n            this.log_(\"Window became visible.  Reducing delay.\");\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n            if (!this.realtime_) {\n                this.scheduleConnect_(0);\n            }\n        }\n        this.visible_ = visible;\n    }\n    onOnline_(online) {\n        if (online) {\n            this.log_(\"Browser went online.\");\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n            if (!this.realtime_) {\n                this.scheduleConnect_(0);\n            }\n        } else {\n            this.log_(\"Browser went offline.  Killing connection.\");\n            if (this.realtime_) {\n                this.realtime_.close();\n            }\n        }\n    }\n    onRealtimeDisconnect_() {\n        this.log_(\"data client disconnected\");\n        this.connected_ = false;\n        this.realtime_ = null;\n        // Since we don't know if our sent transactions succeeded or not, we need to cancel them.\n        this.cancelSentTransactions_();\n        // Clear out the pending requests.\n        this.requestCBHash_ = {};\n        if (this.shouldReconnect_()) {\n            if (!this.visible_) {\n                this.log_(\"Window isn't visible.  Delaying reconnect.\");\n                this.reconnectDelay_ = this.maxReconnectDelay_;\n                this.lastConnectionAttemptTime_ = new Date().getTime();\n            } else if (this.lastConnectionEstablishedTime_) {\n                // If we've been connected long enough, reset reconnect delay to minimum.\n                const timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;\n                if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT) {\n                    this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n                }\n                this.lastConnectionEstablishedTime_ = null;\n            }\n            const timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;\n            let reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);\n            reconnectDelay = Math.random() * reconnectDelay;\n            this.log_(\"Trying to reconnect in \" + reconnectDelay + \"ms\");\n            this.scheduleConnect_(reconnectDelay);\n            // Adjust reconnect delay for next time.\n            this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);\n        }\n        this.onConnectStatus_(false);\n    }\n    async establishConnection_() {\n        if (this.shouldReconnect_()) {\n            this.log_(\"Making a connection attempt\");\n            this.lastConnectionAttemptTime_ = new Date().getTime();\n            this.lastConnectionEstablishedTime_ = null;\n            const onDataMessage = this.onDataMessage_.bind(this);\n            const onReady = this.onReady_.bind(this);\n            const onDisconnect = this.onRealtimeDisconnect_.bind(this);\n            const connId = this.id + \":\" + PersistentConnection.nextConnectionId_++;\n            const lastSessionId = this.lastSessionId;\n            let canceled = false;\n            let connection = null;\n            const closeFn = function() {\n                if (connection) {\n                    connection.close();\n                } else {\n                    canceled = true;\n                    onDisconnect();\n                }\n            };\n            const sendRequestFn = function(msg) {\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(connection, \"sendRequest call when we're not connected not allowed.\");\n                connection.sendRequest(msg);\n            };\n            this.realtime_ = {\n                close: closeFn,\n                sendRequest: sendRequestFn\n            };\n            const forceRefresh = this.forceTokenRefresh_;\n            this.forceTokenRefresh_ = false;\n            try {\n                // First fetch auth and app check token, and establish connection after\n                // fetching the token was successful\n                const [authToken, appCheckToken] = await Promise.all([\n                    this.authTokenProvider_.getToken(forceRefresh),\n                    this.appCheckTokenProvider_.getToken(forceRefresh)\n                ]);\n                if (!canceled) {\n                    log(\"getToken() completed. Creating connection.\");\n                    this.authToken_ = authToken && authToken.accessToken;\n                    this.appCheckToken_ = appCheckToken && appCheckToken.token;\n                    connection = new Connection(connId, this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, onDataMessage, onReady, onDisconnect, /* onKill= */ (reason)=>{\n                        warn(reason + \" (\" + this.repoInfo_.toString() + \")\");\n                        this.interrupt(SERVER_KILL_INTERRUPT_REASON);\n                    }, lastSessionId);\n                } else {\n                    log(\"getToken() completed but was canceled\");\n                }\n            } catch (error) {\n                this.log_(\"Failed to get token: \" + error);\n                if (!canceled) {\n                    if (this.repoInfo_.nodeAdmin) {\n                        // This may be a critical error for the Admin Node.js SDK, so log a warning.\n                        // But getToken() may also just have temporarily failed, so we still want to\n                        // continue retrying.\n                        warn(error);\n                    }\n                    closeFn();\n                }\n            }\n        }\n    }\n    interrupt(reason) {\n        log(\"Interrupting connection for reason: \" + reason);\n        this.interruptReasons_[reason] = true;\n        if (this.realtime_) {\n            this.realtime_.close();\n        } else {\n            if (this.establishConnectionTimer_) {\n                clearTimeout(this.establishConnectionTimer_);\n                this.establishConnectionTimer_ = null;\n            }\n            if (this.connected_) {\n                this.onRealtimeDisconnect_();\n            }\n        }\n    }\n    resume(reason) {\n        log(\"Resuming connection for reason: \" + reason);\n        delete this.interruptReasons_[reason];\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(this.interruptReasons_)) {\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n            if (!this.realtime_) {\n                this.scheduleConnect_(0);\n            }\n        }\n    }\n    handleTimestamp_(timestamp) {\n        const delta = timestamp - new Date().getTime();\n        this.onServerInfoUpdate_({\n            serverTimeOffset: delta\n        });\n    }\n    cancelSentTransactions_() {\n        for(let i = 0; i < this.outstandingPuts_.length; i++){\n            const put = this.outstandingPuts_[i];\n            if (put && /*hash*/ \"h\" in put.request && put.queued) {\n                if (put.onComplete) {\n                    put.onComplete(\"disconnect\");\n                }\n                delete this.outstandingPuts_[i];\n                this.outstandingPutCount_--;\n            }\n        }\n        // Clean up array occasionally.\n        if (this.outstandingPutCount_ === 0) {\n            this.outstandingPuts_ = [];\n        }\n    }\n    onListenRevoked_(pathString, query) {\n        // Remove the listen and manufacture a \"permission_denied\" error for the failed listen.\n        let queryId;\n        if (!query) {\n            queryId = \"default\";\n        } else {\n            queryId = query.map((q)=>ObjectToUniqueKey(q)).join(\"$\");\n        }\n        const listen = this.removeListen_(pathString, queryId);\n        if (listen && listen.onComplete) {\n            listen.onComplete(\"permission_denied\");\n        }\n    }\n    removeListen_(pathString, queryId) {\n        const normalizedPathString = new Path(pathString).toString(); // normalize path.\n        let listen;\n        if (this.listens.has(normalizedPathString)) {\n            const map = this.listens.get(normalizedPathString);\n            listen = map.get(queryId);\n            map.delete(queryId);\n            if (map.size === 0) {\n                this.listens.delete(normalizedPathString);\n            }\n        } else {\n            // all listens for this path has already been removed\n            listen = undefined;\n        }\n        return listen;\n    }\n    onAuthRevoked_(statusCode, explanation) {\n        log(\"Auth token revoked: \" + statusCode + \"/\" + explanation);\n        this.authToken_ = null;\n        this.forceTokenRefresh_ = true;\n        this.realtime_.close();\n        if (statusCode === \"invalid_token\" || statusCode === \"permission_denied\") {\n            // We'll wait a couple times before logging the warning / increasing the\n            // retry period since oauth tokens will report as \"invalid\" if they're\n            // just expired. Plus there may be transient issues that resolve themselves.\n            this.invalidAuthTokenCount_++;\n            if (this.invalidAuthTokenCount_ >= INVALID_TOKEN_THRESHOLD) {\n                // Set a long reconnect delay because recovery is unlikely\n                this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n                // Notify the auth token provider that the token is invalid, which will log\n                // a warning\n                this.authTokenProvider_.notifyForInvalidToken();\n            }\n        }\n    }\n    onAppCheckRevoked_(statusCode, explanation) {\n        log(\"App check token revoked: \" + statusCode + \"/\" + explanation);\n        this.appCheckToken_ = null;\n        this.forceTokenRefresh_ = true;\n        // Note: We don't close the connection as the developer may not have\n        // enforcement enabled. The backend closes connections with enforcements.\n        if (statusCode === \"invalid_token\" || statusCode === \"permission_denied\") {\n            // We'll wait a couple times before logging the warning / increasing the\n            // retry period since oauth tokens will report as \"invalid\" if they're\n            // just expired. Plus there may be transient issues that resolve themselves.\n            this.invalidAppCheckTokenCount_++;\n            if (this.invalidAppCheckTokenCount_ >= INVALID_TOKEN_THRESHOLD) {\n                this.appCheckTokenProvider_.notifyForInvalidToken();\n            }\n        }\n    }\n    onSecurityDebugPacket_(body) {\n        if (this.securityDebugCallback_) {\n            this.securityDebugCallback_(body);\n        } else {\n            if (\"msg\" in body) {\n                console.log(\"FIREBASE: \" + body[\"msg\"].replace(\"\\n\", \"\\nFIREBASE: \"));\n            }\n        }\n    }\n    restoreState_() {\n        //Re-authenticate ourselves if we have a credential stored.\n        this.tryAuth();\n        this.tryAppCheck();\n        // Puts depend on having received the corresponding data update from the server before they complete, so we must\n        // make sure to send listens before puts.\n        for (const queries of this.listens.values()){\n            for (const listenSpec of queries.values()){\n                this.sendListen_(listenSpec);\n            }\n        }\n        for(let i = 0; i < this.outstandingPuts_.length; i++){\n            if (this.outstandingPuts_[i]) {\n                this.sendPut_(i);\n            }\n        }\n        while(this.onDisconnectRequestQueue_.length){\n            const request = this.onDisconnectRequestQueue_.shift();\n            this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);\n        }\n        for(let i = 0; i < this.outstandingGets_.length; i++){\n            if (this.outstandingGets_[i]) {\n                this.sendGet_(i);\n            }\n        }\n    }\n    /**\r\n     * Sends client stats for first connection\r\n     */ sendConnectStats_() {\n        const stats = {};\n        let clientName = \"js\";\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n            if (this.repoInfo_.nodeAdmin) {\n                clientName = \"admin_node\";\n            } else {\n                clientName = \"node\";\n            }\n        }\n        stats[\"sdk.\" + clientName + \".\" + SDK_VERSION.replace(/\\./g, \"-\")] = 1;\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isMobileCordova)()) {\n            stats[\"framework.cordova\"] = 1;\n        } else if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isReactNative)()) {\n            stats[\"framework.reactnative\"] = 1;\n        }\n        this.reportStats(stats);\n    }\n    shouldReconnect_() {\n        const online = OnlineMonitor.getInstance().currentlyOnline();\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(this.interruptReasons_) && online;\n    }\n}\nPersistentConnection.nextPersistentConnectionId_ = 0;\n/**\r\n * Counter for number of connections created. Mainly used for tagging in the logs\r\n */ PersistentConnection.nextConnectionId_ = 0;\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class NamedNode {\n    constructor(name, node){\n        this.name = name;\n        this.node = node;\n    }\n    static Wrap(name, node) {\n        return new NamedNode(name, node);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class Index {\n    /**\r\n     * @returns A standalone comparison function for\r\n     * this index\r\n     */ getCompare() {\n        return this.compare.bind(this);\n    }\n    /**\r\n     * Given a before and after value for a node, determine if the indexed value has changed. Even if they are different,\r\n     * it's possible that the changes are isolated to parts of the snapshot that are not indexed.\r\n     *\r\n     *\r\n     * @returns True if the portion of the snapshot being indexed changed between oldNode and newNode\r\n     */ indexedValueChanged(oldNode, newNode) {\n        const oldWrapped = new NamedNode(MIN_NAME, oldNode);\n        const newWrapped = new NamedNode(MIN_NAME, newNode);\n        return this.compare(oldWrapped, newWrapped) !== 0;\n    }\n    /**\r\n     * @returns a node wrapper that will sort equal to or less than\r\n     * any other node wrapper, using this index\r\n     */ minPost() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return NamedNode.MIN;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let __EMPTY_NODE;\nclass KeyIndex extends Index {\n    static get __EMPTY_NODE() {\n        return __EMPTY_NODE;\n    }\n    static set __EMPTY_NODE(val) {\n        __EMPTY_NODE = val;\n    }\n    compare(a, b) {\n        return nameCompare(a.name, b.name);\n    }\n    isDefinedOn(node) {\n        // We could probably return true here (since every node has a key), but it's never called\n        // so just leaving unimplemented for now.\n        throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assertionError)(\"KeyIndex.isDefinedOn not expected to be called.\");\n    }\n    indexedValueChanged(oldNode, newNode) {\n        return false; // The key for a node never changes.\n    }\n    minPost() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return NamedNode.MIN;\n    }\n    maxPost() {\n        // TODO: This should really be created once and cached in a static property, but\n        // NamedNode isn't defined yet, so I can't use it in a static.  Bleh.\n        return new NamedNode(MAX_NAME, __EMPTY_NODE);\n    }\n    makePost(indexValue, name) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof indexValue === \"string\", \"KeyIndex indexValue must always be a string.\");\n        // We just use empty node, but it'll never be compared, since our comparator only looks at name.\n        return new NamedNode(indexValue, __EMPTY_NODE);\n    }\n    /**\r\n     * @returns String representation for inclusion in a query spec\r\n     */ toString() {\n        return \".key\";\n    }\n}\nconst KEY_INDEX = new KeyIndex();\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An iterator over an LLRBNode.\r\n */ class SortedMapIterator {\n    /**\r\n     * @param node - Node to iterate.\r\n     * @param isReverse_ - Whether or not to iterate in reverse\r\n     */ constructor(node, startKey, comparator, isReverse_, resultGenerator_ = null){\n        this.isReverse_ = isReverse_;\n        this.resultGenerator_ = resultGenerator_;\n        this.nodeStack_ = [];\n        let cmp = 1;\n        while(!node.isEmpty()){\n            node = node;\n            cmp = startKey ? comparator(node.key, startKey) : 1;\n            // flip the comparison if we're going in reverse\n            if (isReverse_) {\n                cmp *= -1;\n            }\n            if (cmp < 0) {\n                // This node is less than our start key. ignore it\n                if (this.isReverse_) {\n                    node = node.left;\n                } else {\n                    node = node.right;\n                }\n            } else if (cmp === 0) {\n                // This node is exactly equal to our start key. Push it on the stack, but stop iterating;\n                this.nodeStack_.push(node);\n                break;\n            } else {\n                // This node is greater than our start key, add it to the stack and move to the next one\n                this.nodeStack_.push(node);\n                if (this.isReverse_) {\n                    node = node.right;\n                } else {\n                    node = node.left;\n                }\n            }\n        }\n    }\n    getNext() {\n        if (this.nodeStack_.length === 0) {\n            return null;\n        }\n        let node = this.nodeStack_.pop();\n        let result;\n        if (this.resultGenerator_) {\n            result = this.resultGenerator_(node.key, node.value);\n        } else {\n            result = {\n                key: node.key,\n                value: node.value\n            };\n        }\n        if (this.isReverse_) {\n            node = node.left;\n            while(!node.isEmpty()){\n                this.nodeStack_.push(node);\n                node = node.right;\n            }\n        } else {\n            node = node.right;\n            while(!node.isEmpty()){\n                this.nodeStack_.push(node);\n                node = node.left;\n            }\n        }\n        return result;\n    }\n    hasNext() {\n        return this.nodeStack_.length > 0;\n    }\n    peek() {\n        if (this.nodeStack_.length === 0) {\n            return null;\n        }\n        const node = this.nodeStack_[this.nodeStack_.length - 1];\n        if (this.resultGenerator_) {\n            return this.resultGenerator_(node.key, node.value);\n        } else {\n            return {\n                key: node.key,\n                value: node.value\n            };\n        }\n    }\n}\n/**\r\n * Represents a node in a Left-leaning Red-Black tree.\r\n */ class LLRBNode {\n    /**\r\n     * @param key - Key associated with this node.\r\n     * @param value - Value associated with this node.\r\n     * @param color - Whether this node is red.\r\n     * @param left - Left child.\r\n     * @param right - Right child.\r\n     */ constructor(key, value, color, left, right){\n        this.key = key;\n        this.value = value;\n        this.color = color != null ? color : LLRBNode.RED;\n        this.left = left != null ? left : SortedMap.EMPTY_NODE;\n        this.right = right != null ? right : SortedMap.EMPTY_NODE;\n    }\n    /**\r\n     * Returns a copy of the current node, optionally replacing pieces of it.\r\n     *\r\n     * @param key - New key for the node, or null.\r\n     * @param value - New value for the node, or null.\r\n     * @param color - New color for the node, or null.\r\n     * @param left - New left child for the node, or null.\r\n     * @param right - New right child for the node, or null.\r\n     * @returns The node copy.\r\n     */ copy(key, value, color, left, right) {\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\n    }\n    /**\r\n     * @returns The total number of nodes in the tree.\r\n     */ count() {\n        return this.left.count() + 1 + this.right.count();\n    }\n    /**\r\n     * @returns True if the tree is empty.\r\n     */ isEmpty() {\n        return false;\n    }\n    /**\r\n     * Traverses the tree in key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     *   node.  If it returns true, traversal is aborted.\r\n     * @returns The first truthy value returned by action, or the last falsey\r\n     *   value returned by action\r\n     */ inorderTraversal(action) {\n        return this.left.inorderTraversal(action) || !!action(this.key, this.value) || this.right.inorderTraversal(action);\n    }\n    /**\r\n     * Traverses the tree in reverse key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @returns True if traversal was aborted.\r\n     */ reverseTraversal(action) {\n        return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);\n    }\n    /**\r\n     * @returns The minimum node in the tree.\r\n     */ min_() {\n        if (this.left.isEmpty()) {\n            return this;\n        } else {\n            return this.left.min_();\n        }\n    }\n    /**\r\n     * @returns The maximum key in the tree.\r\n     */ minKey() {\n        return this.min_().key;\n    }\n    /**\r\n     * @returns The maximum key in the tree.\r\n     */ maxKey() {\n        if (this.right.isEmpty()) {\n            return this.key;\n        } else {\n            return this.right.maxKey();\n        }\n    }\n    /**\r\n     * @param key - Key to insert.\r\n     * @param value - Value to insert.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with the key/value added.\r\n     */ insert(key, value, comparator) {\n        let n = this;\n        const cmp = comparator(key, n.key);\n        if (cmp < 0) {\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n        } else if (cmp === 0) {\n            n = n.copy(null, value, null, null, null);\n        } else {\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\n        }\n        return n.fixUp_();\n    }\n    /**\r\n     * @returns New tree, with the minimum key removed.\r\n     */ removeMin_() {\n        if (this.left.isEmpty()) {\n            return SortedMap.EMPTY_NODE;\n        }\n        let n = this;\n        if (!n.left.isRed_() && !n.left.left.isRed_()) {\n            n = n.moveRedLeft_();\n        }\n        n = n.copy(null, null, null, n.left.removeMin_(), null);\n        return n.fixUp_();\n    }\n    /**\r\n     * @param key - The key of the item to remove.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with the specified item removed.\r\n     */ remove(key, comparator) {\n        let n, smallest;\n        n = this;\n        if (comparator(key, n.key) < 0) {\n            if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {\n                n = n.moveRedLeft_();\n            }\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n        } else {\n            if (n.left.isRed_()) {\n                n = n.rotateRight_();\n            }\n            if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {\n                n = n.moveRedRight_();\n            }\n            if (comparator(key, n.key) === 0) {\n                if (n.right.isEmpty()) {\n                    return SortedMap.EMPTY_NODE;\n                } else {\n                    smallest = n.right.min_();\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());\n                }\n            }\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n        }\n        return n.fixUp_();\n    }\n    /**\r\n     * @returns Whether this is a RED node.\r\n     */ isRed_() {\n        return this.color;\n    }\n    /**\r\n     * @returns New tree after performing any needed rotations.\r\n     */ fixUp_() {\n        let n = this;\n        if (n.right.isRed_() && !n.left.isRed_()) {\n            n = n.rotateLeft_();\n        }\n        if (n.left.isRed_() && n.left.left.isRed_()) {\n            n = n.rotateRight_();\n        }\n        if (n.left.isRed_() && n.right.isRed_()) {\n            n = n.colorFlip_();\n        }\n        return n;\n    }\n    /**\r\n     * @returns New tree, after moveRedLeft.\r\n     */ moveRedLeft_() {\n        let n = this.colorFlip_();\n        if (n.right.left.isRed_()) {\n            n = n.copy(null, null, null, null, n.right.rotateRight_());\n            n = n.rotateLeft_();\n            n = n.colorFlip_();\n        }\n        return n;\n    }\n    /**\r\n     * @returns New tree, after moveRedRight.\r\n     */ moveRedRight_() {\n        let n = this.colorFlip_();\n        if (n.left.left.isRed_()) {\n            n = n.rotateRight_();\n            n = n.colorFlip_();\n        }\n        return n;\n    }\n    /**\r\n     * @returns New tree, after rotateLeft.\r\n     */ rotateLeft_() {\n        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n        return this.right.copy(null, null, this.color, nl, null);\n    }\n    /**\r\n     * @returns New tree, after rotateRight.\r\n     */ rotateRight_() {\n        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n        return this.left.copy(null, null, this.color, null, nr);\n    }\n    /**\r\n     * @returns Newt ree, after colorFlip.\r\n     */ colorFlip_() {\n        const left = this.left.copy(null, null, !this.left.color, null, null);\n        const right = this.right.copy(null, null, !this.right.color, null, null);\n        return this.copy(null, null, !this.color, left, right);\n    }\n    /**\r\n     * For testing.\r\n     *\r\n     * @returns True if all is well.\r\n     */ checkMaxDepth_() {\n        const blackDepth = this.check_();\n        return Math.pow(2.0, blackDepth) <= this.count() + 1;\n    }\n    check_() {\n        if (this.isRed_() && this.left.isRed_()) {\n            throw new Error(\"Red node has red child(\" + this.key + \",\" + this.value + \")\");\n        }\n        if (this.right.isRed_()) {\n            throw new Error(\"Right child of (\" + this.key + \",\" + this.value + \") is red\");\n        }\n        const blackDepth = this.left.check_();\n        if (blackDepth !== this.right.check_()) {\n            throw new Error(\"Black depths differ\");\n        } else {\n            return blackDepth + (this.isRed_() ? 0 : 1);\n        }\n    }\n}\nLLRBNode.RED = true;\nLLRBNode.BLACK = false;\n/**\r\n * Represents an empty node (a leaf node in the Red-Black Tree).\r\n */ class LLRBEmptyNode {\n    /**\r\n     * Returns a copy of the current node.\r\n     *\r\n     * @returns The node copy.\r\n     */ copy(key, value, color, left, right) {\n        return this;\n    }\n    /**\r\n     * Returns a copy of the tree, with the specified key/value added.\r\n     *\r\n     * @param key - Key to be added.\r\n     * @param value - Value to be added.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with item added.\r\n     */ insert(key, value, comparator) {\n        return new LLRBNode(key, value, null);\n    }\n    /**\r\n     * Returns a copy of the tree, with the specified key removed.\r\n     *\r\n     * @param key - The key to remove.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with item removed.\r\n     */ remove(key, comparator) {\n        return this;\n    }\n    /**\r\n     * @returns The total number of nodes in the tree.\r\n     */ count() {\n        return 0;\n    }\n    /**\r\n     * @returns True if the tree is empty.\r\n     */ isEmpty() {\n        return true;\n    }\n    /**\r\n     * Traverses the tree in key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @returns True if traversal was aborted.\r\n     */ inorderTraversal(action) {\n        return false;\n    }\n    /**\r\n     * Traverses the tree in reverse key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @returns True if traversal was aborted.\r\n     */ reverseTraversal(action) {\n        return false;\n    }\n    minKey() {\n        return null;\n    }\n    maxKey() {\n        return null;\n    }\n    check_() {\n        return 0;\n    }\n    /**\r\n     * @returns Whether this node is red.\r\n     */ isRed_() {\n        return false;\n    }\n}\n/**\r\n * An immutable sorted map implementation, based on a Left-leaning Red-Black\r\n * tree.\r\n */ class SortedMap {\n    /**\r\n     * @param comparator_ - Key comparator.\r\n     * @param root_ - Optional root node for the map.\r\n     */ constructor(comparator_, root_ = SortedMap.EMPTY_NODE){\n        this.comparator_ = comparator_;\n        this.root_ = root_;\n    }\n    /**\r\n     * Returns a copy of the map, with the specified key/value added or replaced.\r\n     * (TODO: We should perhaps rename this method to 'put')\r\n     *\r\n     * @param key - Key to be added.\r\n     * @param value - Value to be added.\r\n     * @returns New map, with item added.\r\n     */ insert(key, value) {\n        return new SortedMap(this.comparator_, this.root_.insert(key, value, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));\n    }\n    /**\r\n     * Returns a copy of the map, with the specified key removed.\r\n     *\r\n     * @param key - The key to remove.\r\n     * @returns New map, with item removed.\r\n     */ remove(key) {\n        return new SortedMap(this.comparator_, this.root_.remove(key, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));\n    }\n    /**\r\n     * Returns the value of the node with the given key, or null.\r\n     *\r\n     * @param key - The key to look up.\r\n     * @returns The value of the node with the given key, or null if the\r\n     * key doesn't exist.\r\n     */ get(key) {\n        let cmp;\n        let node = this.root_;\n        while(!node.isEmpty()){\n            cmp = this.comparator_(key, node.key);\n            if (cmp === 0) {\n                return node.value;\n            } else if (cmp < 0) {\n                node = node.left;\n            } else if (cmp > 0) {\n                node = node.right;\n            }\n        }\n        return null;\n    }\n    /**\r\n     * Returns the key of the item *before* the specified key, or null if key is the first item.\r\n     * @param key - The key to find the predecessor of\r\n     * @returns The predecessor key.\r\n     */ getPredecessorKey(key) {\n        let cmp, node = this.root_, rightParent = null;\n        while(!node.isEmpty()){\n            cmp = this.comparator_(key, node.key);\n            if (cmp === 0) {\n                if (!node.left.isEmpty()) {\n                    node = node.left;\n                    while(!node.right.isEmpty()){\n                        node = node.right;\n                    }\n                    return node.key;\n                } else if (rightParent) {\n                    return rightParent.key;\n                } else {\n                    return null; // first item.\n                }\n            } else if (cmp < 0) {\n                node = node.left;\n            } else if (cmp > 0) {\n                rightParent = node;\n                node = node.right;\n            }\n        }\n        throw new Error(\"Attempted to find predecessor key for a nonexistent key.  What gives?\");\n    }\n    /**\r\n     * @returns True if the map is empty.\r\n     */ isEmpty() {\n        return this.root_.isEmpty();\n    }\n    /**\r\n     * @returns The total number of nodes in the map.\r\n     */ count() {\n        return this.root_.count();\n    }\n    /**\r\n     * @returns The minimum key in the map.\r\n     */ minKey() {\n        return this.root_.minKey();\n    }\n    /**\r\n     * @returns The maximum key in the map.\r\n     */ maxKey() {\n        return this.root_.maxKey();\n    }\n    /**\r\n     * Traverses the map in key order and calls the specified action function\r\n     * for each key/value pair.\r\n     *\r\n     * @param action - Callback function to be called\r\n     * for each key/value pair.  If action returns true, traversal is aborted.\r\n     * @returns The first truthy value returned by action, or the last falsey\r\n     *   value returned by action\r\n     */ inorderTraversal(action) {\n        return this.root_.inorderTraversal(action);\n    }\n    /**\r\n     * Traverses the map in reverse key order and calls the specified action function\r\n     * for each key/value pair.\r\n     *\r\n     * @param action - Callback function to be called\r\n     * for each key/value pair.  If action returns true, traversal is aborted.\r\n     * @returns True if the traversal was aborted.\r\n     */ reverseTraversal(action) {\n        return this.root_.reverseTraversal(action);\n    }\n    /**\r\n     * Returns an iterator over the SortedMap.\r\n     * @returns The iterator.\r\n     */ getIterator(resultGenerator) {\n        return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);\n    }\n    getIteratorFrom(key, resultGenerator) {\n        return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);\n    }\n    getReverseIteratorFrom(key, resultGenerator) {\n        return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);\n    }\n    getReverseIterator(resultGenerator) {\n        return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);\n    }\n}\n/**\r\n * Always use the same empty node, to reduce memory.\r\n */ SortedMap.EMPTY_NODE = new LLRBEmptyNode();\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function NAME_ONLY_COMPARATOR(left, right) {\n    return nameCompare(left.name, right.name);\n}\nfunction NAME_COMPARATOR(left, right) {\n    return nameCompare(left, right);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let MAX_NODE$2;\nfunction setMaxNode$1(val) {\n    MAX_NODE$2 = val;\n}\nconst priorityHashText = function(priority) {\n    if (typeof priority === \"number\") {\n        return \"number:\" + doubleToIEEE754String(priority);\n    } else {\n        return \"string:\" + priority;\n    }\n};\n/**\r\n * Validates that a priority snapshot Node is valid.\r\n */ const validatePriorityNode = function(priorityNode) {\n    if (priorityNode.isLeafNode()) {\n        const val = priorityNode.val();\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof val === \"string\" || typeof val === \"number\" || typeof val === \"object\" && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(val, \".sv\"), \"Priority must be a string or number.\");\n    } else {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(priorityNode === MAX_NODE$2 || priorityNode.isEmpty(), \"priority of unexpected type.\");\n    }\n    // Don't call getPriority() on MAX_NODE to avoid hitting assertion.\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(priorityNode === MAX_NODE$2 || priorityNode.getPriority().isEmpty(), \"Priority nodes can't have a priority of their own.\");\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let __childrenNodeConstructor;\n/**\r\n * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It\r\n * implements Node and stores the value of the node (a string,\r\n * number, or boolean) accessible via getValue().\r\n */ class LeafNode {\n    /**\r\n     * @param value_ - The value to store in this leaf node. The object type is\r\n     * possible in the event of a deferred value\r\n     * @param priorityNode_ - The priority of this node.\r\n     */ constructor(value_, priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE){\n        this.value_ = value_;\n        this.priorityNode_ = priorityNode_;\n        this.lazyHash_ = null;\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.value_ !== undefined && this.value_ !== null, \"LeafNode shouldn't be created with null/undefined value.\");\n        validatePriorityNode(this.priorityNode_);\n    }\n    static set __childrenNodeConstructor(val) {\n        __childrenNodeConstructor = val;\n    }\n    static get __childrenNodeConstructor() {\n        return __childrenNodeConstructor;\n    }\n    /** @inheritDoc */ isLeafNode() {\n        return true;\n    }\n    /** @inheritDoc */ getPriority() {\n        return this.priorityNode_;\n    }\n    /** @inheritDoc */ updatePriority(newPriorityNode) {\n        return new LeafNode(this.value_, newPriorityNode);\n    }\n    /** @inheritDoc */ getImmediateChild(childName) {\n        // Hack to treat priority as a regular child\n        if (childName === \".priority\") {\n            return this.priorityNode_;\n        } else {\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n        }\n    }\n    /** @inheritDoc */ getChild(path) {\n        if (pathIsEmpty(path)) {\n            return this;\n        } else if (pathGetFront(path) === \".priority\") {\n            return this.priorityNode_;\n        } else {\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n        }\n    }\n    hasChild() {\n        return false;\n    }\n    /** @inheritDoc */ getPredecessorChildName(childName, childNode) {\n        return null;\n    }\n    /** @inheritDoc */ updateImmediateChild(childName, newChildNode) {\n        if (childName === \".priority\") {\n            return this.updatePriority(newChildNode);\n        } else if (newChildNode.isEmpty() && childName !== \".priority\") {\n            return this;\n        } else {\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);\n        }\n    }\n    /** @inheritDoc */ updateChild(path, newChildNode) {\n        const front = pathGetFront(path);\n        if (front === null) {\n            return newChildNode;\n        } else if (newChildNode.isEmpty() && front !== \".priority\") {\n            return this;\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(front !== \".priority\" || pathGetLength(path) === 1, \".priority must be the last token in a path\");\n            return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path), newChildNode));\n        }\n    }\n    /** @inheritDoc */ isEmpty() {\n        return false;\n    }\n    /** @inheritDoc */ numChildren() {\n        return 0;\n    }\n    /** @inheritDoc */ forEachChild(index, action) {\n        return false;\n    }\n    val(exportFormat) {\n        if (exportFormat && !this.getPriority().isEmpty()) {\n            return {\n                \".value\": this.getValue(),\n                \".priority\": this.getPriority().val()\n            };\n        } else {\n            return this.getValue();\n        }\n    }\n    /** @inheritDoc */ hash() {\n        if (this.lazyHash_ === null) {\n            let toHash = \"\";\n            if (!this.priorityNode_.isEmpty()) {\n                toHash += \"priority:\" + priorityHashText(this.priorityNode_.val()) + \":\";\n            }\n            const type = typeof this.value_;\n            toHash += type + \":\";\n            if (type === \"number\") {\n                toHash += doubleToIEEE754String(this.value_);\n            } else {\n                toHash += this.value_;\n            }\n            this.lazyHash_ = sha1(toHash);\n        }\n        return this.lazyHash_;\n    }\n    /**\r\n     * Returns the value of the leaf node.\r\n     * @returns The value of the node.\r\n     */ getValue() {\n        return this.value_;\n    }\n    compareTo(other) {\n        if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {\n            return 1;\n        } else if (other instanceof LeafNode.__childrenNodeConstructor) {\n            return -1;\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(other.isLeafNode(), \"Unknown node type\");\n            return this.compareToLeafNode_(other);\n        }\n    }\n    /**\r\n     * Comparison specifically for two leaf nodes\r\n     */ compareToLeafNode_(otherLeaf) {\n        const otherLeafType = typeof otherLeaf.value_;\n        const thisLeafType = typeof this.value_;\n        const otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);\n        const thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(otherIndex >= 0, \"Unknown leaf type: \" + otherLeafType);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(thisIndex >= 0, \"Unknown leaf type: \" + thisLeafType);\n        if (otherIndex === thisIndex) {\n            // Same type, compare values\n            if (thisLeafType === \"object\") {\n                // Deferred value nodes are all equal, but we should also never get to this point...\n                return 0;\n            } else {\n                // Note that this works because true > false, all others are number or string comparisons\n                if (this.value_ < otherLeaf.value_) {\n                    return -1;\n                } else if (this.value_ === otherLeaf.value_) {\n                    return 0;\n                } else {\n                    return 1;\n                }\n            }\n        } else {\n            return thisIndex - otherIndex;\n        }\n    }\n    withIndex() {\n        return this;\n    }\n    isIndexed() {\n        return true;\n    }\n    equals(other) {\n        if (other === this) {\n            return true;\n        } else if (other.isLeafNode()) {\n            const otherLeaf = other;\n            return this.value_ === otherLeaf.value_ && this.priorityNode_.equals(otherLeaf.priorityNode_);\n        } else {\n            return false;\n        }\n    }\n}\n/**\r\n * The sort order for comparing leaf nodes of different types. If two leaf nodes have\r\n * the same type, the comparison falls back to their value\r\n */ LeafNode.VALUE_TYPE_ORDER = [\n    \"object\",\n    \"boolean\",\n    \"number\",\n    \"string\"\n];\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let nodeFromJSON$1;\nlet MAX_NODE$1;\nfunction setNodeFromJSON(val) {\n    nodeFromJSON$1 = val;\n}\nfunction setMaxNode(val) {\n    MAX_NODE$1 = val;\n}\nclass PriorityIndex extends Index {\n    compare(a, b) {\n        const aPriority = a.node.getPriority();\n        const bPriority = b.node.getPriority();\n        const indexCmp = aPriority.compareTo(bPriority);\n        if (indexCmp === 0) {\n            return nameCompare(a.name, b.name);\n        } else {\n            return indexCmp;\n        }\n    }\n    isDefinedOn(node) {\n        return !node.getPriority().isEmpty();\n    }\n    indexedValueChanged(oldNode, newNode) {\n        return !oldNode.getPriority().equals(newNode.getPriority());\n    }\n    minPost() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return NamedNode.MIN;\n    }\n    maxPost() {\n        return new NamedNode(MAX_NAME, new LeafNode(\"[PRIORITY-POST]\", MAX_NODE$1));\n    }\n    makePost(indexValue, name) {\n        const priorityNode = nodeFromJSON$1(indexValue);\n        return new NamedNode(name, new LeafNode(\"[PRIORITY-POST]\", priorityNode));\n    }\n    /**\r\n     * @returns String representation for inclusion in a query spec\r\n     */ toString() {\n        return \".priority\";\n    }\n}\nconst PRIORITY_INDEX = new PriorityIndex();\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const LOG_2 = Math.log(2);\nclass Base12Num {\n    constructor(length){\n        const logBase2 = (num)=>// eslint-disable-next-line @typescript-eslint/no-explicit-any\n            parseInt(Math.log(num) / LOG_2, 10);\n        const bitMask = (bits)=>parseInt(Array(bits + 1).join(\"1\"), 2);\n        this.count = logBase2(length + 1);\n        this.current_ = this.count - 1;\n        const mask = bitMask(this.count);\n        this.bits_ = length + 1 & mask;\n    }\n    nextBitIsOne() {\n        //noinspection JSBitwiseOperatorUsage\n        const result = !(this.bits_ & 0x1 << this.current_);\n        this.current_--;\n        return result;\n    }\n}\n/**\r\n * Takes a list of child nodes and constructs a SortedSet using the given comparison\r\n * function\r\n *\r\n * Uses the algorithm described in the paper linked here:\r\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458\r\n *\r\n * @param childList - Unsorted list of children\r\n * @param cmp - The comparison method to be used\r\n * @param keyFn - An optional function to extract K from a node wrapper, if K's\r\n * type is not NamedNode\r\n * @param mapSortFn - An optional override for comparator used by the generated sorted map\r\n */ const buildChildSet = function(childList, cmp, keyFn, mapSortFn) {\n    childList.sort(cmp);\n    const buildBalancedTree = function(low, high) {\n        const length = high - low;\n        let namedNode;\n        let key;\n        if (length === 0) {\n            return null;\n        } else if (length === 1) {\n            namedNode = childList[low];\n            key = keyFn ? keyFn(namedNode) : namedNode;\n            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, null, null);\n        } else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const middle = parseInt(length / 2, 10) + low;\n            const left = buildBalancedTree(low, middle);\n            const right = buildBalancedTree(middle + 1, high);\n            namedNode = childList[middle];\n            key = keyFn ? keyFn(namedNode) : namedNode;\n            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, left, right);\n        }\n    };\n    const buildFrom12Array = function(base12) {\n        let node = null;\n        let root = null;\n        let index = childList.length;\n        const buildPennant = function(chunkSize, color) {\n            const low = index - chunkSize;\n            const high = index;\n            index -= chunkSize;\n            const childTree = buildBalancedTree(low + 1, high);\n            const namedNode = childList[low];\n            const key = keyFn ? keyFn(namedNode) : namedNode;\n            attachPennant(new LLRBNode(key, namedNode.node, color, null, childTree));\n        };\n        const attachPennant = function(pennant) {\n            if (node) {\n                node.left = pennant;\n                node = pennant;\n            } else {\n                root = pennant;\n                node = pennant;\n            }\n        };\n        for(let i = 0; i < base12.count; ++i){\n            const isOne = base12.nextBitIsOne();\n            // The number of nodes taken in each slice is 2^(arr.length - (i + 1))\n            const chunkSize = Math.pow(2, base12.count - (i + 1));\n            if (isOne) {\n                buildPennant(chunkSize, LLRBNode.BLACK);\n            } else {\n                // current == 2\n                buildPennant(chunkSize, LLRBNode.BLACK);\n                buildPennant(chunkSize, LLRBNode.RED);\n            }\n        }\n        return root;\n    };\n    const base12 = new Base12Num(childList.length);\n    const root = buildFrom12Array(base12);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new SortedMap(mapSortFn || cmp, root);\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let _defaultIndexMap;\nconst fallbackObject = {};\nclass IndexMap {\n    constructor(indexes_, indexSet_){\n        this.indexes_ = indexes_;\n        this.indexSet_ = indexSet_;\n    }\n    /**\r\n     * The default IndexMap for nodes without a priority\r\n     */ static get Default() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(fallbackObject && PRIORITY_INDEX, \"ChildrenNode.ts has not been loaded\");\n        _defaultIndexMap = _defaultIndexMap || new IndexMap({\n            \".priority\": fallbackObject\n        }, {\n            \".priority\": PRIORITY_INDEX\n        });\n        return _defaultIndexMap;\n    }\n    get(indexKey) {\n        const sortedMap = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(this.indexes_, indexKey);\n        if (!sortedMap) {\n            throw new Error(\"No index defined for \" + indexKey);\n        }\n        if (sortedMap instanceof SortedMap) {\n            return sortedMap;\n        } else {\n            // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the\n            // regular child map\n            return null;\n        }\n    }\n    hasIndex(indexDefinition) {\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(this.indexSet_, indexDefinition.toString());\n    }\n    addIndex(indexDefinition, existingChildren) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(indexDefinition !== KEY_INDEX, \"KeyIndex always exists and isn't meant to be added to the IndexMap.\");\n        const childList = [];\n        let sawIndexedValue = false;\n        const iter = existingChildren.getIterator(NamedNode.Wrap);\n        let next = iter.getNext();\n        while(next){\n            sawIndexedValue = sawIndexedValue || indexDefinition.isDefinedOn(next.node);\n            childList.push(next);\n            next = iter.getNext();\n        }\n        let newIndex;\n        if (sawIndexedValue) {\n            newIndex = buildChildSet(childList, indexDefinition.getCompare());\n        } else {\n            newIndex = fallbackObject;\n        }\n        const indexName = indexDefinition.toString();\n        const newIndexSet = Object.assign({}, this.indexSet_);\n        newIndexSet[indexName] = indexDefinition;\n        const newIndexes = Object.assign({}, this.indexes_);\n        newIndexes[indexName] = newIndex;\n        return new IndexMap(newIndexes, newIndexSet);\n    }\n    /**\r\n     * Ensure that this node is properly tracked in any indexes that we're maintaining\r\n     */ addToIndexes(namedNode, existingChildren) {\n        const newIndexes = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.map)(this.indexes_, (indexedChildren, indexName)=>{\n            const index = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(this.indexSet_, indexName);\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(index, \"Missing index implementation for \" + indexName);\n            if (indexedChildren === fallbackObject) {\n                // Check to see if we need to index everything\n                if (index.isDefinedOn(namedNode.node)) {\n                    // We need to build this index\n                    const childList = [];\n                    const iter = existingChildren.getIterator(NamedNode.Wrap);\n                    let next = iter.getNext();\n                    while(next){\n                        if (next.name !== namedNode.name) {\n                            childList.push(next);\n                        }\n                        next = iter.getNext();\n                    }\n                    childList.push(namedNode);\n                    return buildChildSet(childList, index.getCompare());\n                } else {\n                    // No change, this remains a fallback\n                    return fallbackObject;\n                }\n            } else {\n                const existingSnap = existingChildren.get(namedNode.name);\n                let newChildren = indexedChildren;\n                if (existingSnap) {\n                    newChildren = newChildren.remove(new NamedNode(namedNode.name, existingSnap));\n                }\n                return newChildren.insert(namedNode, namedNode.node);\n            }\n        });\n        return new IndexMap(newIndexes, this.indexSet_);\n    }\n    /**\r\n     * Create a new IndexMap instance with the given value removed\r\n     */ removeFromIndexes(namedNode, existingChildren) {\n        const newIndexes = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.map)(this.indexes_, (indexedChildren)=>{\n            if (indexedChildren === fallbackObject) {\n                // This is the fallback. Just return it, nothing to do in this case\n                return indexedChildren;\n            } else {\n                const existingSnap = existingChildren.get(namedNode.name);\n                if (existingSnap) {\n                    return indexedChildren.remove(new NamedNode(namedNode.name, existingSnap));\n                } else {\n                    // No record of this child\n                    return indexedChildren;\n                }\n            }\n        });\n        return new IndexMap(newIndexes, this.indexSet_);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // TODO: For memory savings, don't store priorityNode_ if it's empty.\nlet EMPTY_NODE;\n/**\r\n * ChildrenNode is a class for storing internal nodes in a DataSnapshot\r\n * (i.e. nodes with children).  It implements Node and stores the\r\n * list of children in the children property, sorted by child name.\r\n */ class ChildrenNode {\n    /**\r\n     * @param children_ - List of children of this node..\r\n     * @param priorityNode_ - The priority of this node (as a snapshot node).\r\n     */ constructor(children_, priorityNode_, indexMap_){\n        this.children_ = children_;\n        this.priorityNode_ = priorityNode_;\n        this.indexMap_ = indexMap_;\n        this.lazyHash_ = null;\n        /**\r\n         * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use\r\n         * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own\r\n         * class instead of an empty ChildrenNode.\r\n         */ if (this.priorityNode_) {\n            validatePriorityNode(this.priorityNode_);\n        }\n        if (this.children_.isEmpty()) {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.priorityNode_ || this.priorityNode_.isEmpty(), \"An empty node cannot have a priority\");\n        }\n    }\n    static get EMPTY_NODE() {\n        return EMPTY_NODE || (EMPTY_NODE = new ChildrenNode(new SortedMap(NAME_COMPARATOR), null, IndexMap.Default));\n    }\n    /** @inheritDoc */ isLeafNode() {\n        return false;\n    }\n    /** @inheritDoc */ getPriority() {\n        return this.priorityNode_ || EMPTY_NODE;\n    }\n    /** @inheritDoc */ updatePriority(newPriorityNode) {\n        if (this.children_.isEmpty()) {\n            // Don't allow priorities on empty nodes\n            return this;\n        } else {\n            return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);\n        }\n    }\n    /** @inheritDoc */ getImmediateChild(childName) {\n        // Hack to treat priority as a regular child\n        if (childName === \".priority\") {\n            return this.getPriority();\n        } else {\n            const child = this.children_.get(childName);\n            return child === null ? EMPTY_NODE : child;\n        }\n    }\n    /** @inheritDoc */ getChild(path) {\n        const front = pathGetFront(path);\n        if (front === null) {\n            return this;\n        }\n        return this.getImmediateChild(front).getChild(pathPopFront(path));\n    }\n    /** @inheritDoc */ hasChild(childName) {\n        return this.children_.get(childName) !== null;\n    }\n    /** @inheritDoc */ updateImmediateChild(childName, newChildNode) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(newChildNode, \"We should always be passing snapshot nodes\");\n        if (childName === \".priority\") {\n            return this.updatePriority(newChildNode);\n        } else {\n            const namedNode = new NamedNode(childName, newChildNode);\n            let newChildren, newIndexMap;\n            if (newChildNode.isEmpty()) {\n                newChildren = this.children_.remove(childName);\n                newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);\n            } else {\n                newChildren = this.children_.insert(childName, newChildNode);\n                newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);\n            }\n            const newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;\n            return new ChildrenNode(newChildren, newPriority, newIndexMap);\n        }\n    }\n    /** @inheritDoc */ updateChild(path, newChildNode) {\n        const front = pathGetFront(path);\n        if (front === null) {\n            return newChildNode;\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(pathGetFront(path) !== \".priority\" || pathGetLength(path) === 1, \".priority must be the last token in a path\");\n            const newImmediateChild = this.getImmediateChild(front).updateChild(pathPopFront(path), newChildNode);\n            return this.updateImmediateChild(front, newImmediateChild);\n        }\n    }\n    /** @inheritDoc */ isEmpty() {\n        return this.children_.isEmpty();\n    }\n    /** @inheritDoc */ numChildren() {\n        return this.children_.count();\n    }\n    /** @inheritDoc */ val(exportFormat) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        const obj = {};\n        let numKeys = 0, maxKey = 0, allIntegerKeys = true;\n        this.forEachChild(PRIORITY_INDEX, (key, childNode)=>{\n            obj[key] = childNode.val(exportFormat);\n            numKeys++;\n            if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {\n                maxKey = Math.max(maxKey, Number(key));\n            } else {\n                allIntegerKeys = false;\n            }\n        });\n        if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {\n            // convert to array.\n            const array = [];\n            // eslint-disable-next-line guard-for-in\n            for(const key in obj){\n                array[key] = obj[key];\n            }\n            return array;\n        } else {\n            if (exportFormat && !this.getPriority().isEmpty()) {\n                obj[\".priority\"] = this.getPriority().val();\n            }\n            return obj;\n        }\n    }\n    /** @inheritDoc */ hash() {\n        if (this.lazyHash_ === null) {\n            let toHash = \"\";\n            if (!this.getPriority().isEmpty()) {\n                toHash += \"priority:\" + priorityHashText(this.getPriority().val()) + \":\";\n            }\n            this.forEachChild(PRIORITY_INDEX, (key, childNode)=>{\n                const childHash = childNode.hash();\n                if (childHash !== \"\") {\n                    toHash += \":\" + key + \":\" + childHash;\n                }\n            });\n            this.lazyHash_ = toHash === \"\" ? \"\" : sha1(toHash);\n        }\n        return this.lazyHash_;\n    }\n    /** @inheritDoc */ getPredecessorChildName(childName, childNode, index) {\n        const idx = this.resolveIndex_(index);\n        if (idx) {\n            const predecessor = idx.getPredecessorKey(new NamedNode(childName, childNode));\n            return predecessor ? predecessor.name : null;\n        } else {\n            return this.children_.getPredecessorKey(childName);\n        }\n    }\n    getFirstChildName(indexDefinition) {\n        const idx = this.resolveIndex_(indexDefinition);\n        if (idx) {\n            const minKey = idx.minKey();\n            return minKey && minKey.name;\n        } else {\n            return this.children_.minKey();\n        }\n    }\n    getFirstChild(indexDefinition) {\n        const minKey = this.getFirstChildName(indexDefinition);\n        if (minKey) {\n            return new NamedNode(minKey, this.children_.get(minKey));\n        } else {\n            return null;\n        }\n    }\n    /**\r\n     * Given an index, return the key name of the largest value we have, according to that index\r\n     */ getLastChildName(indexDefinition) {\n        const idx = this.resolveIndex_(indexDefinition);\n        if (idx) {\n            const maxKey = idx.maxKey();\n            return maxKey && maxKey.name;\n        } else {\n            return this.children_.maxKey();\n        }\n    }\n    getLastChild(indexDefinition) {\n        const maxKey = this.getLastChildName(indexDefinition);\n        if (maxKey) {\n            return new NamedNode(maxKey, this.children_.get(maxKey));\n        } else {\n            return null;\n        }\n    }\n    forEachChild(index, action) {\n        const idx = this.resolveIndex_(index);\n        if (idx) {\n            return idx.inorderTraversal((wrappedNode)=>{\n                return action(wrappedNode.name, wrappedNode.node);\n            });\n        } else {\n            return this.children_.inorderTraversal(action);\n        }\n    }\n    getIterator(indexDefinition) {\n        return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);\n    }\n    getIteratorFrom(startPost, indexDefinition) {\n        const idx = this.resolveIndex_(indexDefinition);\n        if (idx) {\n            return idx.getIteratorFrom(startPost, (key)=>key);\n        } else {\n            const iterator = this.children_.getIteratorFrom(startPost.name, NamedNode.Wrap);\n            let next = iterator.peek();\n            while(next != null && indexDefinition.compare(next, startPost) < 0){\n                iterator.getNext();\n                next = iterator.peek();\n            }\n            return iterator;\n        }\n    }\n    getReverseIterator(indexDefinition) {\n        return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);\n    }\n    getReverseIteratorFrom(endPost, indexDefinition) {\n        const idx = this.resolveIndex_(indexDefinition);\n        if (idx) {\n            return idx.getReverseIteratorFrom(endPost, (key)=>{\n                return key;\n            });\n        } else {\n            const iterator = this.children_.getReverseIteratorFrom(endPost.name, NamedNode.Wrap);\n            let next = iterator.peek();\n            while(next != null && indexDefinition.compare(next, endPost) > 0){\n                iterator.getNext();\n                next = iterator.peek();\n            }\n            return iterator;\n        }\n    }\n    compareTo(other) {\n        if (this.isEmpty()) {\n            if (other.isEmpty()) {\n                return 0;\n            } else {\n                return -1;\n            }\n        } else if (other.isLeafNode() || other.isEmpty()) {\n            return 1;\n        } else if (other === MAX_NODE) {\n            return -1;\n        } else {\n            // Must be another node with children.\n            return 0;\n        }\n    }\n    withIndex(indexDefinition) {\n        if (indexDefinition === KEY_INDEX || this.indexMap_.hasIndex(indexDefinition)) {\n            return this;\n        } else {\n            const newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);\n            return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);\n        }\n    }\n    isIndexed(index) {\n        return index === KEY_INDEX || this.indexMap_.hasIndex(index);\n    }\n    equals(other) {\n        if (other === this) {\n            return true;\n        } else if (other.isLeafNode()) {\n            return false;\n        } else {\n            const otherChildrenNode = other;\n            if (!this.getPriority().equals(otherChildrenNode.getPriority())) {\n                return false;\n            } else if (this.children_.count() === otherChildrenNode.children_.count()) {\n                const thisIter = this.getIterator(PRIORITY_INDEX);\n                const otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);\n                let thisCurrent = thisIter.getNext();\n                let otherCurrent = otherIter.getNext();\n                while(thisCurrent && otherCurrent){\n                    if (thisCurrent.name !== otherCurrent.name || !thisCurrent.node.equals(otherCurrent.node)) {\n                        return false;\n                    }\n                    thisCurrent = thisIter.getNext();\n                    otherCurrent = otherIter.getNext();\n                }\n                return thisCurrent === null && otherCurrent === null;\n            } else {\n                return false;\n            }\n        }\n    }\n    /**\r\n     * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used\r\n     * instead.\r\n     *\r\n     */ resolveIndex_(indexDefinition) {\n        if (indexDefinition === KEY_INDEX) {\n            return null;\n        } else {\n            return this.indexMap_.get(indexDefinition.toString());\n        }\n    }\n}\nChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\\d*)$/;\nclass MaxNode extends ChildrenNode {\n    constructor(){\n        super(new SortedMap(NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap.Default);\n    }\n    compareTo(other) {\n        if (other === this) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n    equals(other) {\n        // Not that we every compare it, but MAX_NODE is only ever equal to itself\n        return other === this;\n    }\n    getPriority() {\n        return this;\n    }\n    getImmediateChild(childName) {\n        return ChildrenNode.EMPTY_NODE;\n    }\n    isEmpty() {\n        return false;\n    }\n}\n/**\r\n * Marker that will sort higher than any other snapshot.\r\n */ const MAX_NODE = new MaxNode();\nObject.defineProperties(NamedNode, {\n    MIN: {\n        value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)\n    },\n    MAX: {\n        value: new NamedNode(MAX_NAME, MAX_NODE)\n    }\n});\n/**\r\n * Reference Extensions\r\n */ KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;\nLeafNode.__childrenNodeConstructor = ChildrenNode;\nsetMaxNode$1(MAX_NODE);\nsetMaxNode(MAX_NODE);\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const USE_HINZE = true;\n/**\r\n * Constructs a snapshot node representing the passed JSON and returns it.\r\n * @param json - JSON to create a node for.\r\n * @param priority - Optional priority to use.  This will be ignored if the\r\n * passed JSON contains a .priority property.\r\n */ function nodeFromJSON(json, priority = null) {\n    if (json === null) {\n        return ChildrenNode.EMPTY_NODE;\n    }\n    if (typeof json === \"object\" && \".priority\" in json) {\n        priority = json[\".priority\"];\n    }\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(priority === null || typeof priority === \"string\" || typeof priority === \"number\" || typeof priority === \"object\" && \".sv\" in priority, \"Invalid priority type found: \" + typeof priority);\n    if (typeof json === \"object\" && \".value\" in json && json[\".value\"] !== null) {\n        json = json[\".value\"];\n    }\n    // Valid leaf nodes include non-objects or server-value wrapper objects\n    if (typeof json !== \"object\" || \".sv\" in json) {\n        const jsonLeaf = json;\n        return new LeafNode(jsonLeaf, nodeFromJSON(priority));\n    }\n    if (!(json instanceof Array) && USE_HINZE) {\n        const children = [];\n        let childrenHavePriority = false;\n        const hinzeJsonObj = json;\n        each(hinzeJsonObj, (key, child)=>{\n            if (key.substring(0, 1) !== \".\") {\n                // Ignore metadata nodes\n                const childNode = nodeFromJSON(child);\n                if (!childNode.isEmpty()) {\n                    childrenHavePriority = childrenHavePriority || !childNode.getPriority().isEmpty();\n                    children.push(new NamedNode(key, childNode));\n                }\n            }\n        });\n        if (children.length === 0) {\n            return ChildrenNode.EMPTY_NODE;\n        }\n        const childSet = buildChildSet(children, NAME_ONLY_COMPARATOR, (namedNode)=>namedNode.name, NAME_COMPARATOR);\n        if (childrenHavePriority) {\n            const sortedChildSet = buildChildSet(children, PRIORITY_INDEX.getCompare());\n            return new ChildrenNode(childSet, nodeFromJSON(priority), new IndexMap({\n                \".priority\": sortedChildSet\n            }, {\n                \".priority\": PRIORITY_INDEX\n            }));\n        } else {\n            return new ChildrenNode(childSet, nodeFromJSON(priority), IndexMap.Default);\n        }\n    } else {\n        let node = ChildrenNode.EMPTY_NODE;\n        each(json, (key, childData)=>{\n            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(json, key)) {\n                if (key.substring(0, 1) !== \".\") {\n                    // ignore metadata nodes.\n                    const childNode = nodeFromJSON(childData);\n                    if (childNode.isLeafNode() || !childNode.isEmpty()) {\n                        node = node.updateImmediateChild(key, childNode);\n                    }\n                }\n            }\n        });\n        return node.updatePriority(nodeFromJSON(priority));\n    }\n}\nsetNodeFromJSON(nodeFromJSON);\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class PathIndex extends Index {\n    constructor(indexPath_){\n        super();\n        this.indexPath_ = indexPath_;\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!pathIsEmpty(indexPath_) && pathGetFront(indexPath_) !== \".priority\", \"Can't create PathIndex with empty path or .priority key\");\n    }\n    extractChild(snap) {\n        return snap.getChild(this.indexPath_);\n    }\n    isDefinedOn(node) {\n        return !node.getChild(this.indexPath_).isEmpty();\n    }\n    compare(a, b) {\n        const aChild = this.extractChild(a.node);\n        const bChild = this.extractChild(b.node);\n        const indexCmp = aChild.compareTo(bChild);\n        if (indexCmp === 0) {\n            return nameCompare(a.name, b.name);\n        } else {\n            return indexCmp;\n        }\n    }\n    makePost(indexValue, name) {\n        const valueNode = nodeFromJSON(indexValue);\n        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);\n        return new NamedNode(name, node);\n    }\n    maxPost() {\n        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE);\n        return new NamedNode(MAX_NAME, node);\n    }\n    toString() {\n        return pathSlice(this.indexPath_, 0).join(\"/\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class ValueIndex extends Index {\n    compare(a, b) {\n        const indexCmp = a.node.compareTo(b.node);\n        if (indexCmp === 0) {\n            return nameCompare(a.name, b.name);\n        } else {\n            return indexCmp;\n        }\n    }\n    isDefinedOn(node) {\n        return true;\n    }\n    indexedValueChanged(oldNode, newNode) {\n        return !oldNode.equals(newNode);\n    }\n    minPost() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return NamedNode.MIN;\n    }\n    maxPost() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return NamedNode.MAX;\n    }\n    makePost(indexValue, name) {\n        const valueNode = nodeFromJSON(indexValue);\n        return new NamedNode(name, valueNode);\n    }\n    /**\r\n     * @returns String representation for inclusion in a query spec\r\n     */ toString() {\n        return \".value\";\n    }\n}\nconst VALUE_INDEX = new ValueIndex();\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function changeValue(snapshotNode) {\n    return {\n        type: \"value\" /* ChangeType.VALUE */ ,\n        snapshotNode\n    };\n}\nfunction changeChildAdded(childName, snapshotNode) {\n    return {\n        type: \"child_added\" /* ChangeType.CHILD_ADDED */ ,\n        snapshotNode,\n        childName\n    };\n}\nfunction changeChildRemoved(childName, snapshotNode) {\n    return {\n        type: \"child_removed\" /* ChangeType.CHILD_REMOVED */ ,\n        snapshotNode,\n        childName\n    };\n}\nfunction changeChildChanged(childName, snapshotNode, oldSnap) {\n    return {\n        type: \"child_changed\" /* ChangeType.CHILD_CHANGED */ ,\n        snapshotNode,\n        childName,\n        oldSnap\n    };\n}\nfunction changeChildMoved(childName, snapshotNode) {\n    return {\n        type: \"child_moved\" /* ChangeType.CHILD_MOVED */ ,\n        snapshotNode,\n        childName\n    };\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\r\n */ class IndexedFilter {\n    constructor(index_){\n        this.index_ = index_;\n    }\n    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(snap.isIndexed(this.index_), \"A node must be indexed if only a child is updated\");\n        const oldChild = snap.getImmediateChild(key);\n        // Check if anything actually changed.\n        if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {\n            // There's an edge case where a child can enter or leave the view because affectedPath was set to null.\n            // In this case, affectedPath will appear null in both the old and new snapshots.  So we need\n            // to avoid treating these cases as \"nothing changed.\"\n            if (oldChild.isEmpty() === newChild.isEmpty()) {\n                // Nothing changed.\n                // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\n                //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\n                return snap;\n            }\n        }\n        if (optChangeAccumulator != null) {\n            if (newChild.isEmpty()) {\n                if (snap.hasChild(key)) {\n                    optChangeAccumulator.trackChildChange(changeChildRemoved(key, oldChild));\n                } else {\n                    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(snap.isLeafNode(), \"A child remove without an old child only makes sense on a leaf node\");\n                }\n            } else if (oldChild.isEmpty()) {\n                optChangeAccumulator.trackChildChange(changeChildAdded(key, newChild));\n            } else {\n                optChangeAccumulator.trackChildChange(changeChildChanged(key, newChild, oldChild));\n            }\n        }\n        if (snap.isLeafNode() && newChild.isEmpty()) {\n            return snap;\n        } else {\n            // Make sure the node is indexed\n            return snap.updateImmediateChild(key, newChild).withIndex(this.index_);\n        }\n    }\n    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {\n        if (optChangeAccumulator != null) {\n            if (!oldSnap.isLeafNode()) {\n                oldSnap.forEachChild(PRIORITY_INDEX, (key, childNode)=>{\n                    if (!newSnap.hasChild(key)) {\n                        optChangeAccumulator.trackChildChange(changeChildRemoved(key, childNode));\n                    }\n                });\n            }\n            if (!newSnap.isLeafNode()) {\n                newSnap.forEachChild(PRIORITY_INDEX, (key, childNode)=>{\n                    if (oldSnap.hasChild(key)) {\n                        const oldChild = oldSnap.getImmediateChild(key);\n                        if (!oldChild.equals(childNode)) {\n                            optChangeAccumulator.trackChildChange(changeChildChanged(key, childNode, oldChild));\n                        }\n                    } else {\n                        optChangeAccumulator.trackChildChange(changeChildAdded(key, childNode));\n                    }\n                });\n            }\n        }\n        return newSnap.withIndex(this.index_);\n    }\n    updatePriority(oldSnap, newPriority) {\n        if (oldSnap.isEmpty()) {\n            return ChildrenNode.EMPTY_NODE;\n        } else {\n            return oldSnap.updatePriority(newPriority);\n        }\n    }\n    filtersNodes() {\n        return false;\n    }\n    getIndexedFilter() {\n        return this;\n    }\n    getIndex() {\n        return this.index_;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node\r\n */ class RangedFilter {\n    constructor(params){\n        this.indexedFilter_ = new IndexedFilter(params.getIndex());\n        this.index_ = params.getIndex();\n        this.startPost_ = RangedFilter.getStartPost_(params);\n        this.endPost_ = RangedFilter.getEndPost_(params);\n        this.startIsInclusive_ = !params.startAfterSet_;\n        this.endIsInclusive_ = !params.endBeforeSet_;\n    }\n    getStartPost() {\n        return this.startPost_;\n    }\n    getEndPost() {\n        return this.endPost_;\n    }\n    matches(node) {\n        const isWithinStart = this.startIsInclusive_ ? this.index_.compare(this.getStartPost(), node) <= 0 : this.index_.compare(this.getStartPost(), node) < 0;\n        const isWithinEnd = this.endIsInclusive_ ? this.index_.compare(node, this.getEndPost()) <= 0 : this.index_.compare(node, this.getEndPost()) < 0;\n        return isWithinStart && isWithinEnd;\n    }\n    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n        if (!this.matches(new NamedNode(key, newChild))) {\n            newChild = ChildrenNode.EMPTY_NODE;\n        }\n        return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\n    }\n    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {\n        if (newSnap.isLeafNode()) {\n            // Make sure we have a children node with the correct index, not a leaf node;\n            newSnap = ChildrenNode.EMPTY_NODE;\n        }\n        let filtered = newSnap.withIndex(this.index_);\n        // Don't support priorities on queries\n        filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);\n        const self = this;\n        newSnap.forEachChild(PRIORITY_INDEX, (key, childNode)=>{\n            if (!self.matches(new NamedNode(key, childNode))) {\n                filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);\n            }\n        });\n        return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);\n    }\n    updatePriority(oldSnap, newPriority) {\n        // Don't support priorities on queries\n        return oldSnap;\n    }\n    filtersNodes() {\n        return true;\n    }\n    getIndexedFilter() {\n        return this.indexedFilter_;\n    }\n    getIndex() {\n        return this.index_;\n    }\n    static getStartPost_(params) {\n        if (params.hasStart()) {\n            const startName = params.getIndexStartName();\n            return params.getIndex().makePost(params.getIndexStartValue(), startName);\n        } else {\n            return params.getIndex().minPost();\n        }\n    }\n    static getEndPost_(params) {\n        if (params.hasEnd()) {\n            const endName = params.getIndexEndName();\n            return params.getIndex().makePost(params.getIndexEndValue(), endName);\n        } else {\n            return params.getIndex().maxPost();\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible\r\n */ class LimitedFilter {\n    constructor(params){\n        this.withinDirectionalStart = (node)=>this.reverse_ ? this.withinEndPost(node) : this.withinStartPost(node);\n        this.withinDirectionalEnd = (node)=>this.reverse_ ? this.withinStartPost(node) : this.withinEndPost(node);\n        this.withinStartPost = (node)=>{\n            const compareRes = this.index_.compare(this.rangedFilter_.getStartPost(), node);\n            return this.startIsInclusive_ ? compareRes <= 0 : compareRes < 0;\n        };\n        this.withinEndPost = (node)=>{\n            const compareRes = this.index_.compare(node, this.rangedFilter_.getEndPost());\n            return this.endIsInclusive_ ? compareRes <= 0 : compareRes < 0;\n        };\n        this.rangedFilter_ = new RangedFilter(params);\n        this.index_ = params.getIndex();\n        this.limit_ = params.getLimit();\n        this.reverse_ = !params.isViewFromLeft();\n        this.startIsInclusive_ = !params.startAfterSet_;\n        this.endIsInclusive_ = !params.endBeforeSet_;\n    }\n    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n        if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {\n            newChild = ChildrenNode.EMPTY_NODE;\n        }\n        if (snap.getImmediateChild(key).equals(newChild)) {\n            // No change\n            return snap;\n        } else if (snap.numChildren() < this.limit_) {\n            return this.rangedFilter_.getIndexedFilter().updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\n        } else {\n            return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);\n        }\n    }\n    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {\n        let filtered;\n        if (newSnap.isLeafNode() || newSnap.isEmpty()) {\n            // Make sure we have a children node with the correct index, not a leaf node;\n            filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n        } else {\n            if (this.limit_ * 2 < newSnap.numChildren() && newSnap.isIndexed(this.index_)) {\n                // Easier to build up a snapshot, since what we're given has more than twice the elements we want\n                filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n                // anchor to the startPost, endPost, or last element as appropriate\n                let iterator;\n                if (this.reverse_) {\n                    iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);\n                } else {\n                    iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);\n                }\n                let count = 0;\n                while(iterator.hasNext() && count < this.limit_){\n                    const next = iterator.getNext();\n                    if (!this.withinDirectionalStart(next)) {\n                        continue;\n                    } else if (!this.withinDirectionalEnd(next)) {\n                        break;\n                    } else {\n                        filtered = filtered.updateImmediateChild(next.name, next.node);\n                        count++;\n                    }\n                }\n            } else {\n                // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one\n                filtered = newSnap.withIndex(this.index_);\n                // Don't support priorities on queries\n                filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);\n                let iterator;\n                if (this.reverse_) {\n                    iterator = filtered.getReverseIterator(this.index_);\n                } else {\n                    iterator = filtered.getIterator(this.index_);\n                }\n                let count = 0;\n                while(iterator.hasNext()){\n                    const next = iterator.getNext();\n                    const inRange = count < this.limit_ && this.withinDirectionalStart(next) && this.withinDirectionalEnd(next);\n                    if (inRange) {\n                        count++;\n                    } else {\n                        filtered = filtered.updateImmediateChild(next.name, ChildrenNode.EMPTY_NODE);\n                    }\n                }\n            }\n        }\n        return this.rangedFilter_.getIndexedFilter().updateFullNode(oldSnap, filtered, optChangeAccumulator);\n    }\n    updatePriority(oldSnap, newPriority) {\n        // Don't support priorities on queries\n        return oldSnap;\n    }\n    filtersNodes() {\n        return true;\n    }\n    getIndexedFilter() {\n        return this.rangedFilter_.getIndexedFilter();\n    }\n    getIndex() {\n        return this.index_;\n    }\n    fullLimitUpdateChild_(snap, childKey, childSnap, source, changeAccumulator) {\n        // TODO: rename all cache stuff etc to general snap terminology\n        let cmp;\n        if (this.reverse_) {\n            const indexCmp = this.index_.getCompare();\n            cmp = (a, b)=>indexCmp(b, a);\n        } else {\n            cmp = this.index_.getCompare();\n        }\n        const oldEventCache = snap;\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(oldEventCache.numChildren() === this.limit_, \"\");\n        const newChildNamedNode = new NamedNode(childKey, childSnap);\n        const windowBoundary = this.reverse_ ? oldEventCache.getFirstChild(this.index_) : oldEventCache.getLastChild(this.index_);\n        const inRange = this.rangedFilter_.matches(newChildNamedNode);\n        if (oldEventCache.hasChild(childKey)) {\n            const oldChildSnap = oldEventCache.getImmediateChild(childKey);\n            let nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);\n            while(nextChild != null && (nextChild.name === childKey || oldEventCache.hasChild(nextChild.name))){\n                // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't\n                // been applied to the limited filter yet. Ignore this next child which will be updated later in\n                // the limited filter...\n                nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);\n            }\n            const compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);\n            const remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;\n            if (remainsInWindow) {\n                if (changeAccumulator != null) {\n                    changeAccumulator.trackChildChange(changeChildChanged(childKey, childSnap, oldChildSnap));\n                }\n                return oldEventCache.updateImmediateChild(childKey, childSnap);\n            } else {\n                if (changeAccumulator != null) {\n                    changeAccumulator.trackChildChange(changeChildRemoved(childKey, oldChildSnap));\n                }\n                const newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode.EMPTY_NODE);\n                const nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);\n                if (nextChildInRange) {\n                    if (changeAccumulator != null) {\n                        changeAccumulator.trackChildChange(changeChildAdded(nextChild.name, nextChild.node));\n                    }\n                    return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);\n                } else {\n                    return newEventCache;\n                }\n            }\n        } else if (childSnap.isEmpty()) {\n            // we're deleting a node, but it was not in the window, so ignore it\n            return snap;\n        } else if (inRange) {\n            if (cmp(windowBoundary, newChildNamedNode) >= 0) {\n                if (changeAccumulator != null) {\n                    changeAccumulator.trackChildChange(changeChildRemoved(windowBoundary.name, windowBoundary.node));\n                    changeAccumulator.trackChildChange(changeChildAdded(childKey, childSnap));\n                }\n                return oldEventCache.updateImmediateChild(childKey, childSnap).updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);\n            } else {\n                return snap;\n            }\n        } else {\n            return snap;\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * This class is an immutable-from-the-public-api struct containing a set of query parameters defining a\r\n * range to be returned for a particular location. It is assumed that validation of parameters is done at the\r\n * user-facing API level, so it is not done here.\r\n *\r\n * @internal\r\n */ class QueryParams {\n    constructor(){\n        this.limitSet_ = false;\n        this.startSet_ = false;\n        this.startNameSet_ = false;\n        this.startAfterSet_ = false; // can only be true if startSet_ is true\n        this.endSet_ = false;\n        this.endNameSet_ = false;\n        this.endBeforeSet_ = false; // can only be true if endSet_ is true\n        this.limit_ = 0;\n        this.viewFrom_ = \"\";\n        this.indexStartValue_ = null;\n        this.indexStartName_ = \"\";\n        this.indexEndValue_ = null;\n        this.indexEndName_ = \"\";\n        this.index_ = PRIORITY_INDEX;\n    }\n    hasStart() {\n        return this.startSet_;\n    }\n    /**\r\n     * @returns True if it would return from left.\r\n     */ isViewFromLeft() {\n        if (this.viewFrom_ === \"\") {\n            // limit(), rather than limitToFirst or limitToLast was called.\n            // This means that only one of startSet_ and endSet_ is true. Use them\n            // to calculate which side of the view to anchor to. If neither is set,\n            // anchor to the end.\n            return this.startSet_;\n        } else {\n            return this.viewFrom_ === \"l\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */ ;\n        }\n    }\n    /**\r\n     * Only valid to call if hasStart() returns true\r\n     */ getIndexStartValue() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.startSet_, \"Only valid if start has been set\");\n        return this.indexStartValue_;\n    }\n    /**\r\n     * Only valid to call if hasStart() returns true.\r\n     * Returns the starting key name for the range defined by these query parameters\r\n     */ getIndexStartName() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.startSet_, \"Only valid if start has been set\");\n        if (this.startNameSet_) {\n            return this.indexStartName_;\n        } else {\n            return MIN_NAME;\n        }\n    }\n    hasEnd() {\n        return this.endSet_;\n    }\n    /**\r\n     * Only valid to call if hasEnd() returns true.\r\n     */ getIndexEndValue() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.endSet_, \"Only valid if end has been set\");\n        return this.indexEndValue_;\n    }\n    /**\r\n     * Only valid to call if hasEnd() returns true.\r\n     * Returns the end key name for the range defined by these query parameters\r\n     */ getIndexEndName() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.endSet_, \"Only valid if end has been set\");\n        if (this.endNameSet_) {\n            return this.indexEndName_;\n        } else {\n            return MAX_NAME;\n        }\n    }\n    hasLimit() {\n        return this.limitSet_;\n    }\n    /**\r\n     * @returns True if a limit has been set and it has been explicitly anchored\r\n     */ hasAnchoredLimit() {\n        return this.limitSet_ && this.viewFrom_ !== \"\";\n    }\n    /**\r\n     * Only valid to call if hasLimit() returns true\r\n     */ getLimit() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.limitSet_, \"Only valid if limit has been set\");\n        return this.limit_;\n    }\n    getIndex() {\n        return this.index_;\n    }\n    loadsAllData() {\n        return !(this.startSet_ || this.endSet_ || this.limitSet_);\n    }\n    isDefault() {\n        return this.loadsAllData() && this.index_ === PRIORITY_INDEX;\n    }\n    copy() {\n        const copy = new QueryParams();\n        copy.limitSet_ = this.limitSet_;\n        copy.limit_ = this.limit_;\n        copy.startSet_ = this.startSet_;\n        copy.startAfterSet_ = this.startAfterSet_;\n        copy.indexStartValue_ = this.indexStartValue_;\n        copy.startNameSet_ = this.startNameSet_;\n        copy.indexStartName_ = this.indexStartName_;\n        copy.endSet_ = this.endSet_;\n        copy.endBeforeSet_ = this.endBeforeSet_;\n        copy.indexEndValue_ = this.indexEndValue_;\n        copy.endNameSet_ = this.endNameSet_;\n        copy.indexEndName_ = this.indexEndName_;\n        copy.index_ = this.index_;\n        copy.viewFrom_ = this.viewFrom_;\n        return copy;\n    }\n}\nfunction queryParamsGetNodeFilter(queryParams) {\n    if (queryParams.loadsAllData()) {\n        return new IndexedFilter(queryParams.getIndex());\n    } else if (queryParams.hasLimit()) {\n        return new LimitedFilter(queryParams);\n    } else {\n        return new RangedFilter(queryParams);\n    }\n}\nfunction queryParamsLimitToFirst(queryParams, newLimit) {\n    const newParams = queryParams.copy();\n    newParams.limitSet_ = true;\n    newParams.limit_ = newLimit;\n    newParams.viewFrom_ = \"l\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */ ;\n    return newParams;\n}\nfunction queryParamsLimitToLast(queryParams, newLimit) {\n    const newParams = queryParams.copy();\n    newParams.limitSet_ = true;\n    newParams.limit_ = newLimit;\n    newParams.viewFrom_ = \"r\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT */ ;\n    return newParams;\n}\nfunction queryParamsStartAt(queryParams, indexValue, key) {\n    const newParams = queryParams.copy();\n    newParams.startSet_ = true;\n    if (indexValue === undefined) {\n        indexValue = null;\n    }\n    newParams.indexStartValue_ = indexValue;\n    if (key != null) {\n        newParams.startNameSet_ = true;\n        newParams.indexStartName_ = key;\n    } else {\n        newParams.startNameSet_ = false;\n        newParams.indexStartName_ = \"\";\n    }\n    return newParams;\n}\nfunction queryParamsStartAfter(queryParams, indexValue, key) {\n    let params;\n    if (queryParams.index_ === KEY_INDEX || !!key) {\n        params = queryParamsStartAt(queryParams, indexValue, key);\n    } else {\n        params = queryParamsStartAt(queryParams, indexValue, MAX_NAME);\n    }\n    params.startAfterSet_ = true;\n    return params;\n}\nfunction queryParamsEndAt(queryParams, indexValue, key) {\n    const newParams = queryParams.copy();\n    newParams.endSet_ = true;\n    if (indexValue === undefined) {\n        indexValue = null;\n    }\n    newParams.indexEndValue_ = indexValue;\n    if (key !== undefined) {\n        newParams.endNameSet_ = true;\n        newParams.indexEndName_ = key;\n    } else {\n        newParams.endNameSet_ = false;\n        newParams.indexEndName_ = \"\";\n    }\n    return newParams;\n}\nfunction queryParamsEndBefore(queryParams, indexValue, key) {\n    let params;\n    if (queryParams.index_ === KEY_INDEX || !!key) {\n        params = queryParamsEndAt(queryParams, indexValue, key);\n    } else {\n        params = queryParamsEndAt(queryParams, indexValue, MIN_NAME);\n    }\n    params.endBeforeSet_ = true;\n    return params;\n}\nfunction queryParamsOrderBy(queryParams, index) {\n    const newParams = queryParams.copy();\n    newParams.index_ = index;\n    return newParams;\n}\n/**\r\n * Returns a set of REST query string parameters representing this query.\r\n *\r\n * @returns query string parameters\r\n */ function queryParamsToRestQueryStringParameters(queryParams) {\n    const qs = {};\n    if (queryParams.isDefault()) {\n        return qs;\n    }\n    let orderBy;\n    if (queryParams.index_ === PRIORITY_INDEX) {\n        orderBy = \"$priority\" /* REST_QUERY_CONSTANTS.PRIORITY_INDEX */ ;\n    } else if (queryParams.index_ === VALUE_INDEX) {\n        orderBy = \"$value\" /* REST_QUERY_CONSTANTS.VALUE_INDEX */ ;\n    } else if (queryParams.index_ === KEY_INDEX) {\n        orderBy = \"$key\" /* REST_QUERY_CONSTANTS.KEY_INDEX */ ;\n    } else {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(queryParams.index_ instanceof PathIndex, \"Unrecognized index type!\");\n        orderBy = queryParams.index_.toString();\n    }\n    qs[\"orderBy\" /* REST_QUERY_CONSTANTS.ORDER_BY */ ] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(orderBy);\n    if (queryParams.startSet_) {\n        const startParam = queryParams.startAfterSet_ ? \"startAfter\" /* REST_QUERY_CONSTANTS.START_AFTER */  : \"startAt\" /* REST_QUERY_CONSTANTS.START_AT */ ;\n        qs[startParam] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(queryParams.indexStartValue_);\n        if (queryParams.startNameSet_) {\n            qs[startParam] += \",\" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(queryParams.indexStartName_);\n        }\n    }\n    if (queryParams.endSet_) {\n        const endParam = queryParams.endBeforeSet_ ? \"endBefore\" /* REST_QUERY_CONSTANTS.END_BEFORE */  : \"endAt\" /* REST_QUERY_CONSTANTS.END_AT */ ;\n        qs[endParam] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(queryParams.indexEndValue_);\n        if (queryParams.endNameSet_) {\n            qs[endParam] += \",\" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(queryParams.indexEndName_);\n        }\n    }\n    if (queryParams.limitSet_) {\n        if (queryParams.isViewFromLeft()) {\n            qs[\"limitToFirst\" /* REST_QUERY_CONSTANTS.LIMIT_TO_FIRST */ ] = queryParams.limit_;\n        } else {\n            qs[\"limitToLast\" /* REST_QUERY_CONSTANTS.LIMIT_TO_LAST */ ] = queryParams.limit_;\n        }\n    }\n    return qs;\n}\nfunction queryParamsGetQueryObject(queryParams) {\n    const obj = {};\n    if (queryParams.startSet_) {\n        obj[\"sp\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_VALUE */ ] = queryParams.indexStartValue_;\n        if (queryParams.startNameSet_) {\n            obj[\"sn\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_NAME */ ] = queryParams.indexStartName_;\n        }\n        obj[\"sin\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_IS_INCLUSIVE */ ] = !queryParams.startAfterSet_;\n    }\n    if (queryParams.endSet_) {\n        obj[\"ep\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_VALUE */ ] = queryParams.indexEndValue_;\n        if (queryParams.endNameSet_) {\n            obj[\"en\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_NAME */ ] = queryParams.indexEndName_;\n        }\n        obj[\"ein\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_IS_INCLUSIVE */ ] = !queryParams.endBeforeSet_;\n    }\n    if (queryParams.limitSet_) {\n        obj[\"l\" /* WIRE_PROTOCOL_CONSTANTS.LIMIT */ ] = queryParams.limit_;\n        let viewFrom = queryParams.viewFrom_;\n        if (viewFrom === \"\") {\n            if (queryParams.isViewFromLeft()) {\n                viewFrom = \"l\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */ ;\n            } else {\n                viewFrom = \"r\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT */ ;\n            }\n        }\n        obj[\"vf\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM */ ] = viewFrom;\n    }\n    // For now, priority index is the default, so we only specify if it's some other index\n    if (queryParams.index_ !== PRIORITY_INDEX) {\n        obj[\"i\" /* WIRE_PROTOCOL_CONSTANTS.INDEX */ ] = queryParams.index_.toString();\n    }\n    return obj;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An implementation of ServerActions that communicates with the server via REST requests.\r\n * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full\r\n * persistent connection (using WebSockets or long-polling)\r\n */ class ReadonlyRestClient extends ServerActions {\n    /**\r\n     * @param repoInfo_ - Data about the namespace we are connecting to\r\n     * @param onDataUpdate_ - A callback for new data from the server\r\n     */ constructor(repoInfo_, onDataUpdate_, authTokenProvider_, appCheckTokenProvider_){\n        super();\n        this.repoInfo_ = repoInfo_;\n        this.onDataUpdate_ = onDataUpdate_;\n        this.authTokenProvider_ = authTokenProvider_;\n        this.appCheckTokenProvider_ = appCheckTokenProvider_;\n        /** @private {function(...[*])} */ this.log_ = logWrapper(\"p:rest:\");\n        /**\r\n         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen\r\n         * that's been removed. :-/\r\n         */ this.listens_ = {};\n    }\n    reportStats(stats) {\n        throw new Error(\"Method not implemented.\");\n    }\n    static getListenId_(query, tag) {\n        if (tag !== undefined) {\n            return \"tag$\" + tag;\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(query._queryParams.isDefault(), \"should have a tag if it's not a default query.\");\n            return query._path.toString();\n        }\n    }\n    /** @inheritDoc */ listen(query, currentHashFn, tag, onComplete) {\n        const pathString = query._path.toString();\n        this.log_(\"Listen called for \" + pathString + \" \" + query._queryIdentifier);\n        // Mark this listener so we can tell if it's removed.\n        const listenId = ReadonlyRestClient.getListenId_(query, tag);\n        const thisListen = {};\n        this.listens_[listenId] = thisListen;\n        const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);\n        this.restRequest_(pathString + \".json\", queryStringParameters, (error, result)=>{\n            let data = result;\n            if (error === 404) {\n                data = null;\n                error = null;\n            }\n            if (error === null) {\n                this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);\n            }\n            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(this.listens_, listenId) === thisListen) {\n                let status;\n                if (!error) {\n                    status = \"ok\";\n                } else if (error === 401) {\n                    status = \"permission_denied\";\n                } else {\n                    status = \"rest_error:\" + error;\n                }\n                onComplete(status, null);\n            }\n        });\n    }\n    /** @inheritDoc */ unlisten(query, tag) {\n        const listenId = ReadonlyRestClient.getListenId_(query, tag);\n        delete this.listens_[listenId];\n    }\n    get(query) {\n        const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);\n        const pathString = query._path.toString();\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        this.restRequest_(pathString + \".json\", queryStringParameters, (error, result)=>{\n            let data = result;\n            if (error === 404) {\n                data = null;\n                error = null;\n            }\n            if (error === null) {\n                this.onDataUpdate_(pathString, data, /*isMerge=*/ false, /*tag=*/ null);\n                deferred.resolve(data);\n            } else {\n                deferred.reject(new Error(data));\n            }\n        });\n        return deferred.promise;\n    }\n    /** @inheritDoc */ refreshAuthToken(token) {\n    // no-op since we just always call getToken.\n    }\n    /**\r\n     * Performs a REST request to the given path, with the provided query string parameters,\r\n     * and any auth credentials we have.\r\n     */ restRequest_(pathString, queryStringParameters = {}, callback) {\n        queryStringParameters[\"format\"] = \"export\";\n        return Promise.all([\n            this.authTokenProvider_.getToken(/*forceRefresh=*/ false),\n            this.appCheckTokenProvider_.getToken(/*forceRefresh=*/ false)\n        ]).then(([authToken, appCheckToken])=>{\n            if (authToken && authToken.accessToken) {\n                queryStringParameters[\"auth\"] = authToken.accessToken;\n            }\n            if (appCheckToken && appCheckToken.token) {\n                queryStringParameters[\"ac\"] = appCheckToken.token;\n            }\n            const url = (this.repoInfo_.secure ? \"https://\" : \"http://\") + this.repoInfo_.host + pathString + \"?\" + \"ns=\" + this.repoInfo_.namespace + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)(queryStringParameters);\n            this.log_(\"Sending REST request for \" + url);\n            const xhr = new XMLHttpRequest();\n            xhr.onreadystatechange = ()=>{\n                if (callback && xhr.readyState === 4) {\n                    this.log_(\"REST Response for \" + url + \" received. status:\", xhr.status, \"response:\", xhr.responseText);\n                    let res = null;\n                    if (xhr.status >= 200 && xhr.status < 300) {\n                        try {\n                            res = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.jsonEval)(xhr.responseText);\n                        } catch (e) {\n                            warn(\"Failed to parse JSON response for \" + url + \": \" + xhr.responseText);\n                        }\n                        callback(null, res);\n                    } else {\n                        // 401 and 404 are expected.\n                        if (xhr.status !== 401 && xhr.status !== 404) {\n                            warn(\"Got unsuccessful REST response for \" + url + \" Status: \" + xhr.status);\n                        }\n                        callback(xhr.status);\n                    }\n                    callback = null;\n                }\n            };\n            xhr.open(\"GET\", url, /*asynchronous=*/ true);\n            xhr.send();\n        });\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Mutable object which basically just stores a reference to the \"latest\" immutable snapshot.\r\n */ class SnapshotHolder {\n    constructor(){\n        this.rootNode_ = ChildrenNode.EMPTY_NODE;\n    }\n    getNode(path) {\n        return this.rootNode_.getChild(path);\n    }\n    updateSnapshot(path, newSnapshotNode) {\n        this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function newSparseSnapshotTree() {\n    return {\n        value: null,\n        children: new Map()\n    };\n}\n/**\r\n * Stores the given node at the specified path. If there is already a node\r\n * at a shallower path, it merges the new data into that snapshot node.\r\n *\r\n * @param path - Path to look up snapshot for.\r\n * @param data - The new data, or null.\r\n */ function sparseSnapshotTreeRemember(sparseSnapshotTree, path, data) {\n    if (pathIsEmpty(path)) {\n        sparseSnapshotTree.value = data;\n        sparseSnapshotTree.children.clear();\n    } else if (sparseSnapshotTree.value !== null) {\n        sparseSnapshotTree.value = sparseSnapshotTree.value.updateChild(path, data);\n    } else {\n        const childKey = pathGetFront(path);\n        if (!sparseSnapshotTree.children.has(childKey)) {\n            sparseSnapshotTree.children.set(childKey, newSparseSnapshotTree());\n        }\n        const child = sparseSnapshotTree.children.get(childKey);\n        path = pathPopFront(path);\n        sparseSnapshotTreeRemember(child, path, data);\n    }\n}\n/**\r\n * Purge the data at path from the cache.\r\n *\r\n * @param path - Path to look up snapshot for.\r\n * @returns True if this node should now be removed.\r\n */ function sparseSnapshotTreeForget(sparseSnapshotTree, path) {\n    if (pathIsEmpty(path)) {\n        sparseSnapshotTree.value = null;\n        sparseSnapshotTree.children.clear();\n        return true;\n    } else {\n        if (sparseSnapshotTree.value !== null) {\n            if (sparseSnapshotTree.value.isLeafNode()) {\n                // We're trying to forget a node that doesn't exist\n                return false;\n            } else {\n                const value = sparseSnapshotTree.value;\n                sparseSnapshotTree.value = null;\n                value.forEachChild(PRIORITY_INDEX, (key, tree)=>{\n                    sparseSnapshotTreeRemember(sparseSnapshotTree, new Path(key), tree);\n                });\n                return sparseSnapshotTreeForget(sparseSnapshotTree, path);\n            }\n        } else if (sparseSnapshotTree.children.size > 0) {\n            const childKey = pathGetFront(path);\n            path = pathPopFront(path);\n            if (sparseSnapshotTree.children.has(childKey)) {\n                const safeToRemove = sparseSnapshotTreeForget(sparseSnapshotTree.children.get(childKey), path);\n                if (safeToRemove) {\n                    sparseSnapshotTree.children.delete(childKey);\n                }\n            }\n            return sparseSnapshotTree.children.size === 0;\n        } else {\n            return true;\n        }\n    }\n}\n/**\r\n * Recursively iterates through all of the stored tree and calls the\r\n * callback on each one.\r\n *\r\n * @param prefixPath - Path to look up node for.\r\n * @param func - The function to invoke for each tree.\r\n */ function sparseSnapshotTreeForEachTree(sparseSnapshotTree, prefixPath, func) {\n    if (sparseSnapshotTree.value !== null) {\n        func(prefixPath, sparseSnapshotTree.value);\n    } else {\n        sparseSnapshotTreeForEachChild(sparseSnapshotTree, (key, tree)=>{\n            const path = new Path(prefixPath.toString() + \"/\" + key);\n            sparseSnapshotTreeForEachTree(tree, path, func);\n        });\n    }\n}\n/**\r\n * Iterates through each immediate child and triggers the callback.\r\n * Only seems to be used in tests.\r\n *\r\n * @param func - The function to invoke for each child.\r\n */ function sparseSnapshotTreeForEachChild(sparseSnapshotTree, func) {\n    sparseSnapshotTree.children.forEach((tree, key)=>{\n        func(key, tree);\n    });\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns the delta from the previous call to get stats.\r\n *\r\n * @param collection_ - The collection to \"listen\" to.\r\n */ class StatsListener {\n    constructor(collection_){\n        this.collection_ = collection_;\n        this.last_ = null;\n    }\n    get() {\n        const newStats = this.collection_.get();\n        const delta = Object.assign({}, newStats);\n        if (this.last_) {\n            each(this.last_, (stat, value)=>{\n                delta[stat] = delta[stat] - value;\n            });\n        }\n        this.last_ = newStats;\n        return delta;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably\n// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10\n// seconds to try to ensure the Firebase connection is established / settled.\nconst FIRST_STATS_MIN_TIME = 10 * 1000;\nconst FIRST_STATS_MAX_TIME = 30 * 1000;\n// We'll continue to report stats on average every 5 minutes.\nconst REPORT_STATS_INTERVAL = 5 * 60 * 1000;\nclass StatsReporter {\n    constructor(collection, server_){\n        this.server_ = server_;\n        this.statsToReport_ = {};\n        this.statsListener_ = new StatsListener(collection);\n        const timeout = FIRST_STATS_MIN_TIME + (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();\n        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));\n    }\n    reportStats_() {\n        const stats = this.statsListener_.get();\n        const reportedStats = {};\n        let haveStatsToReport = false;\n        each(stats, (stat, value)=>{\n            if (value > 0 && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(this.statsToReport_, stat)) {\n                reportedStats[stat] = value;\n                haveStatsToReport = true;\n            }\n        });\n        if (haveStatsToReport) {\n            this.server_.reportStats(reportedStats);\n        }\n        // queue our next run.\n        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n *\r\n * @enum\r\n */ var OperationType;\n(function(OperationType) {\n    OperationType[OperationType[\"OVERWRITE\"] = 0] = \"OVERWRITE\";\n    OperationType[OperationType[\"MERGE\"] = 1] = \"MERGE\";\n    OperationType[OperationType[\"ACK_USER_WRITE\"] = 2] = \"ACK_USER_WRITE\";\n    OperationType[OperationType[\"LISTEN_COMPLETE\"] = 3] = \"LISTEN_COMPLETE\";\n})(OperationType || (OperationType = {}));\nfunction newOperationSourceUser() {\n    return {\n        fromUser: true,\n        fromServer: false,\n        queryId: null,\n        tagged: false\n    };\n}\nfunction newOperationSourceServer() {\n    return {\n        fromUser: false,\n        fromServer: true,\n        queryId: null,\n        tagged: false\n    };\n}\nfunction newOperationSourceServerTaggedQuery(queryId) {\n    return {\n        fromUser: false,\n        fromServer: true,\n        queryId,\n        tagged: true\n    };\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class AckUserWrite {\n    /**\r\n     * @param affectedTree - A tree containing true for each affected path. Affected paths can't overlap.\r\n     */ constructor(/** @inheritDoc */ path, /** @inheritDoc */ affectedTree, /** @inheritDoc */ revert){\n        this.path = path;\n        this.affectedTree = affectedTree;\n        this.revert = revert;\n        /** @inheritDoc */ this.type = OperationType.ACK_USER_WRITE;\n        /** @inheritDoc */ this.source = newOperationSourceUser();\n    }\n    operationForChild(childName) {\n        if (!pathIsEmpty(this.path)) {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(pathGetFront(this.path) === childName, \"operationForChild called for unrelated child.\");\n            return new AckUserWrite(pathPopFront(this.path), this.affectedTree, this.revert);\n        } else if (this.affectedTree.value != null) {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.affectedTree.children.isEmpty(), \"affectedTree should not have overlapping affected paths.\");\n            // All child locations are affected as well; just return same operation.\n            return this;\n        } else {\n            const childTree = this.affectedTree.subtree(new Path(childName));\n            return new AckUserWrite(newEmptyPath(), childTree, this.revert);\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class ListenComplete {\n    constructor(source, path){\n        this.source = source;\n        this.path = path;\n        /** @inheritDoc */ this.type = OperationType.LISTEN_COMPLETE;\n    }\n    operationForChild(childName) {\n        if (pathIsEmpty(this.path)) {\n            return new ListenComplete(this.source, newEmptyPath());\n        } else {\n            return new ListenComplete(this.source, pathPopFront(this.path));\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class Overwrite {\n    constructor(source, path, snap){\n        this.source = source;\n        this.path = path;\n        this.snap = snap;\n        /** @inheritDoc */ this.type = OperationType.OVERWRITE;\n    }\n    operationForChild(childName) {\n        if (pathIsEmpty(this.path)) {\n            return new Overwrite(this.source, newEmptyPath(), this.snap.getImmediateChild(childName));\n        } else {\n            return new Overwrite(this.source, pathPopFront(this.path), this.snap);\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class Merge {\n    constructor(/** @inheritDoc */ source, /** @inheritDoc */ path, /** @inheritDoc */ children){\n        this.source = source;\n        this.path = path;\n        this.children = children;\n        /** @inheritDoc */ this.type = OperationType.MERGE;\n    }\n    operationForChild(childName) {\n        if (pathIsEmpty(this.path)) {\n            const childTree = this.children.subtree(new Path(childName));\n            if (childTree.isEmpty()) {\n                // This child is unaffected\n                return null;\n            } else if (childTree.value) {\n                // We have a snapshot for the child in question.  This becomes an overwrite of the child.\n                return new Overwrite(this.source, newEmptyPath(), childTree.value);\n            } else {\n                // This is a merge at a deeper level\n                return new Merge(this.source, newEmptyPath(), childTree);\n            }\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(pathGetFront(this.path) === childName, \"Can't get a merge for a child not on the path of the operation\");\n            return new Merge(this.source, pathPopFront(this.path), this.children);\n        }\n    }\n    toString() {\n        return \"Operation(\" + this.path + \": \" + this.source.toString() + \" merge: \" + this.children.toString() + \")\";\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A cache node only stores complete children. Additionally it holds a flag whether the node can be considered fully\r\n * initialized in the sense that we know at one point in time this represented a valid state of the world, e.g.\r\n * initialized with data from the server, or a complete overwrite by the client. The filtered flag also tracks\r\n * whether a node potentially had children removed due to a filter.\r\n */ class CacheNode {\n    constructor(node_, fullyInitialized_, filtered_){\n        this.node_ = node_;\n        this.fullyInitialized_ = fullyInitialized_;\n        this.filtered_ = filtered_;\n    }\n    /**\r\n     * Returns whether this node was fully initialized with either server data or a complete overwrite by the client\r\n     */ isFullyInitialized() {\n        return this.fullyInitialized_;\n    }\n    /**\r\n     * Returns whether this node is potentially missing children due to a filter applied to the node\r\n     */ isFiltered() {\n        return this.filtered_;\n    }\n    isCompleteForPath(path) {\n        if (pathIsEmpty(path)) {\n            return this.isFullyInitialized() && !this.filtered_;\n        }\n        const childKey = pathGetFront(path);\n        return this.isCompleteForChild(childKey);\n    }\n    isCompleteForChild(key) {\n        return this.isFullyInitialized() && !this.filtered_ || this.node_.hasChild(key);\n    }\n    getNode() {\n        return this.node_;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An EventGenerator is used to convert \"raw\" changes (Change) as computed by the\r\n * CacheDiffer into actual events (Event) that can be raised.  See generateEventsForChanges()\r\n * for details.\r\n *\r\n */ class EventGenerator {\n    constructor(query_){\n        this.query_ = query_;\n        this.index_ = this.query_._queryParams.getIndex();\n    }\n}\n/**\r\n * Given a set of raw changes (no moved events and prevName not specified yet), and a set of\r\n * EventRegistrations that should be notified of these changes, generate the actual events to be raised.\r\n *\r\n * Notes:\r\n *  - child_moved events will be synthesized at this time for any child_changed events that affect\r\n *    our index.\r\n *  - prevName will be calculated based on the index ordering.\r\n */ function eventGeneratorGenerateEventsForChanges(eventGenerator, changes, eventCache, eventRegistrations) {\n    const events = [];\n    const moves = [];\n    changes.forEach((change)=>{\n        if (change.type === \"child_changed\" /* ChangeType.CHILD_CHANGED */  && eventGenerator.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) {\n            moves.push(changeChildMoved(change.childName, change.snapshotNode));\n        }\n    });\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_removed\" /* ChangeType.CHILD_REMOVED */ , changes, eventRegistrations, eventCache);\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_added\" /* ChangeType.CHILD_ADDED */ , changes, eventRegistrations, eventCache);\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_moved\" /* ChangeType.CHILD_MOVED */ , moves, eventRegistrations, eventCache);\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_changed\" /* ChangeType.CHILD_CHANGED */ , changes, eventRegistrations, eventCache);\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"value\" /* ChangeType.VALUE */ , changes, eventRegistrations, eventCache);\n    return events;\n}\n/**\r\n * Given changes of a single change type, generate the corresponding events.\r\n */ function eventGeneratorGenerateEventsForType(eventGenerator, events, eventType, changes, registrations, eventCache) {\n    const filteredChanges = changes.filter((change)=>change.type === eventType);\n    filteredChanges.sort((a, b)=>eventGeneratorCompareChanges(eventGenerator, a, b));\n    filteredChanges.forEach((change)=>{\n        const materializedChange = eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache);\n        registrations.forEach((registration)=>{\n            if (registration.respondsTo(change.type)) {\n                events.push(registration.createEvent(materializedChange, eventGenerator.query_));\n            }\n        });\n    });\n}\nfunction eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache) {\n    if (change.type === \"value\" || change.type === \"child_removed\") {\n        return change;\n    } else {\n        change.prevName = eventCache.getPredecessorChildName(change.childName, change.snapshotNode, eventGenerator.index_);\n        return change;\n    }\n}\nfunction eventGeneratorCompareChanges(eventGenerator, a, b) {\n    if (a.childName == null || b.childName == null) {\n        throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assertionError)(\"Should only compare child_ events.\");\n    }\n    const aWrapped = new NamedNode(a.childName, a.snapshotNode);\n    const bWrapped = new NamedNode(b.childName, b.snapshotNode);\n    return eventGenerator.index_.compare(aWrapped, bWrapped);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function newViewCache(eventCache, serverCache) {\n    return {\n        eventCache,\n        serverCache\n    };\n}\nfunction viewCacheUpdateEventSnap(viewCache, eventSnap, complete, filtered) {\n    return newViewCache(new CacheNode(eventSnap, complete, filtered), viewCache.serverCache);\n}\nfunction viewCacheUpdateServerSnap(viewCache, serverSnap, complete, filtered) {\n    return newViewCache(viewCache.eventCache, new CacheNode(serverSnap, complete, filtered));\n}\nfunction viewCacheGetCompleteEventSnap(viewCache) {\n    return viewCache.eventCache.isFullyInitialized() ? viewCache.eventCache.getNode() : null;\n}\nfunction viewCacheGetCompleteServerSnap(viewCache) {\n    return viewCache.serverCache.isFullyInitialized() ? viewCache.serverCache.getNode() : null;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let emptyChildrenSingleton;\n/**\r\n * Singleton empty children collection.\r\n *\r\n */ const EmptyChildren = ()=>{\n    if (!emptyChildrenSingleton) {\n        emptyChildrenSingleton = new SortedMap(stringCompare);\n    }\n    return emptyChildrenSingleton;\n};\n/**\r\n * A tree with immutable elements.\r\n */ class ImmutableTree {\n    constructor(value, children = EmptyChildren()){\n        this.value = value;\n        this.children = children;\n    }\n    static fromObject(obj) {\n        let tree = new ImmutableTree(null);\n        each(obj, (childPath, childSnap)=>{\n            tree = tree.set(new Path(childPath), childSnap);\n        });\n        return tree;\n    }\n    /**\r\n     * True if the value is empty and there are no children\r\n     */ isEmpty() {\n        return this.value === null && this.children.isEmpty();\n    }\n    /**\r\n     * Given a path and predicate, return the first node and the path to that node\r\n     * where the predicate returns true.\r\n     *\r\n     * TODO Do a perf test -- If we're creating a bunch of `{path: value:}`\r\n     * objects on the way back out, it may be better to pass down a pathSoFar obj.\r\n     *\r\n     * @param relativePath - The remainder of the path\r\n     * @param predicate - The predicate to satisfy to return a node\r\n     */ findRootMostMatchingPathAndValue(relativePath, predicate) {\n        if (this.value != null && predicate(this.value)) {\n            return {\n                path: newEmptyPath(),\n                value: this.value\n            };\n        } else {\n            if (pathIsEmpty(relativePath)) {\n                return null;\n            } else {\n                const front = pathGetFront(relativePath);\n                const child = this.children.get(front);\n                if (child !== null) {\n                    const childExistingPathAndValue = child.findRootMostMatchingPathAndValue(pathPopFront(relativePath), predicate);\n                    if (childExistingPathAndValue != null) {\n                        const fullPath = pathChild(new Path(front), childExistingPathAndValue.path);\n                        return {\n                            path: fullPath,\n                            value: childExistingPathAndValue.value\n                        };\n                    } else {\n                        return null;\n                    }\n                } else {\n                    return null;\n                }\n            }\n        }\n    }\n    /**\r\n     * Find, if it exists, the shortest subpath of the given path that points a defined\r\n     * value in the tree\r\n     */ findRootMostValueAndPath(relativePath) {\n        return this.findRootMostMatchingPathAndValue(relativePath, ()=>true);\n    }\n    /**\r\n     * @returns The subtree at the given path\r\n     */ subtree(relativePath) {\n        if (pathIsEmpty(relativePath)) {\n            return this;\n        } else {\n            const front = pathGetFront(relativePath);\n            const childTree = this.children.get(front);\n            if (childTree !== null) {\n                return childTree.subtree(pathPopFront(relativePath));\n            } else {\n                return new ImmutableTree(null);\n            }\n        }\n    }\n    /**\r\n     * Sets a value at the specified path.\r\n     *\r\n     * @param relativePath - Path to set value at.\r\n     * @param toSet - Value to set.\r\n     * @returns Resulting tree.\r\n     */ set(relativePath, toSet) {\n        if (pathIsEmpty(relativePath)) {\n            return new ImmutableTree(toSet, this.children);\n        } else {\n            const front = pathGetFront(relativePath);\n            const child = this.children.get(front) || new ImmutableTree(null);\n            const newChild = child.set(pathPopFront(relativePath), toSet);\n            const newChildren = this.children.insert(front, newChild);\n            return new ImmutableTree(this.value, newChildren);\n        }\n    }\n    /**\r\n     * Removes the value at the specified path.\r\n     *\r\n     * @param relativePath - Path to value to remove.\r\n     * @returns Resulting tree.\r\n     */ remove(relativePath) {\n        if (pathIsEmpty(relativePath)) {\n            if (this.children.isEmpty()) {\n                return new ImmutableTree(null);\n            } else {\n                return new ImmutableTree(null, this.children);\n            }\n        } else {\n            const front = pathGetFront(relativePath);\n            const child = this.children.get(front);\n            if (child) {\n                const newChild = child.remove(pathPopFront(relativePath));\n                let newChildren;\n                if (newChild.isEmpty()) {\n                    newChildren = this.children.remove(front);\n                } else {\n                    newChildren = this.children.insert(front, newChild);\n                }\n                if (this.value === null && newChildren.isEmpty()) {\n                    return new ImmutableTree(null);\n                } else {\n                    return new ImmutableTree(this.value, newChildren);\n                }\n            } else {\n                return this;\n            }\n        }\n    }\n    /**\r\n     * Gets a value from the tree.\r\n     *\r\n     * @param relativePath - Path to get value for.\r\n     * @returns Value at path, or null.\r\n     */ get(relativePath) {\n        if (pathIsEmpty(relativePath)) {\n            return this.value;\n        } else {\n            const front = pathGetFront(relativePath);\n            const child = this.children.get(front);\n            if (child) {\n                return child.get(pathPopFront(relativePath));\n            } else {\n                return null;\n            }\n        }\n    }\n    /**\r\n     * Replace the subtree at the specified path with the given new tree.\r\n     *\r\n     * @param relativePath - Path to replace subtree for.\r\n     * @param newTree - New tree.\r\n     * @returns Resulting tree.\r\n     */ setTree(relativePath, newTree) {\n        if (pathIsEmpty(relativePath)) {\n            return newTree;\n        } else {\n            const front = pathGetFront(relativePath);\n            const child = this.children.get(front) || new ImmutableTree(null);\n            const newChild = child.setTree(pathPopFront(relativePath), newTree);\n            let newChildren;\n            if (newChild.isEmpty()) {\n                newChildren = this.children.remove(front);\n            } else {\n                newChildren = this.children.insert(front, newChild);\n            }\n            return new ImmutableTree(this.value, newChildren);\n        }\n    }\n    /**\r\n     * Performs a depth first fold on this tree. Transforms a tree into a single\r\n     * value, given a function that operates on the path to a node, an optional\r\n     * current value, and a map of child names to folded subtrees\r\n     */ fold(fn) {\n        return this.fold_(newEmptyPath(), fn);\n    }\n    /**\r\n     * Recursive helper for public-facing fold() method\r\n     */ fold_(pathSoFar, fn) {\n        const accum = {};\n        this.children.inorderTraversal((childKey, childTree)=>{\n            accum[childKey] = childTree.fold_(pathChild(pathSoFar, childKey), fn);\n        });\n        return fn(pathSoFar, this.value, accum);\n    }\n    /**\r\n     * Find the first matching value on the given path. Return the result of applying f to it.\r\n     */ findOnPath(path, f) {\n        return this.findOnPath_(path, newEmptyPath(), f);\n    }\n    findOnPath_(pathToFollow, pathSoFar, f) {\n        const result = this.value ? f(pathSoFar, this.value) : false;\n        if (result) {\n            return result;\n        } else {\n            if (pathIsEmpty(pathToFollow)) {\n                return null;\n            } else {\n                const front = pathGetFront(pathToFollow);\n                const nextChild = this.children.get(front);\n                if (nextChild) {\n                    return nextChild.findOnPath_(pathPopFront(pathToFollow), pathChild(pathSoFar, front), f);\n                } else {\n                    return null;\n                }\n            }\n        }\n    }\n    foreachOnPath(path, f) {\n        return this.foreachOnPath_(path, newEmptyPath(), f);\n    }\n    foreachOnPath_(pathToFollow, currentRelativePath, f) {\n        if (pathIsEmpty(pathToFollow)) {\n            return this;\n        } else {\n            if (this.value) {\n                f(currentRelativePath, this.value);\n            }\n            const front = pathGetFront(pathToFollow);\n            const nextChild = this.children.get(front);\n            if (nextChild) {\n                return nextChild.foreachOnPath_(pathPopFront(pathToFollow), pathChild(currentRelativePath, front), f);\n            } else {\n                return new ImmutableTree(null);\n            }\n        }\n    }\n    /**\r\n     * Calls the given function for each node in the tree that has a value.\r\n     *\r\n     * @param f - A function to be called with the path from the root of the tree to\r\n     * a node, and the value at that node. Called in depth-first order.\r\n     */ foreach(f) {\n        this.foreach_(newEmptyPath(), f);\n    }\n    foreach_(currentRelativePath, f) {\n        this.children.inorderTraversal((childName, childTree)=>{\n            childTree.foreach_(pathChild(currentRelativePath, childName), f);\n        });\n        if (this.value) {\n            f(currentRelativePath, this.value);\n        }\n    }\n    foreachChild(f) {\n        this.children.inorderTraversal((childName, childTree)=>{\n            if (childTree.value) {\n                f(childName, childTree.value);\n            }\n        });\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with\r\n * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write\r\n * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write\r\n * to reflect the write added.\r\n */ class CompoundWrite {\n    constructor(writeTree_){\n        this.writeTree_ = writeTree_;\n    }\n    static empty() {\n        return new CompoundWrite(new ImmutableTree(null));\n    }\n}\nfunction compoundWriteAddWrite(compoundWrite, path, node) {\n    if (pathIsEmpty(path)) {\n        return new CompoundWrite(new ImmutableTree(node));\n    } else {\n        const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);\n        if (rootmost != null) {\n            const rootMostPath = rootmost.path;\n            let value = rootmost.value;\n            const relativePath = newRelativePath(rootMostPath, path);\n            value = value.updateChild(relativePath, node);\n            return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath, value));\n        } else {\n            const subtree = new ImmutableTree(node);\n            const newWriteTree = compoundWrite.writeTree_.setTree(path, subtree);\n            return new CompoundWrite(newWriteTree);\n        }\n    }\n}\nfunction compoundWriteAddWrites(compoundWrite, path, updates) {\n    let newWrite = compoundWrite;\n    each(updates, (childKey, node)=>{\n        newWrite = compoundWriteAddWrite(newWrite, pathChild(path, childKey), node);\n    });\n    return newWrite;\n}\n/**\r\n * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher\r\n * location, which must be removed by calling this method with that path.\r\n *\r\n * @param compoundWrite - The CompoundWrite to remove.\r\n * @param path - The path at which a write and all deeper writes should be removed\r\n * @returns The new CompoundWrite with the removed path\r\n */ function compoundWriteRemoveWrite(compoundWrite, path) {\n    if (pathIsEmpty(path)) {\n        return CompoundWrite.empty();\n    } else {\n        const newWriteTree = compoundWrite.writeTree_.setTree(path, new ImmutableTree(null));\n        return new CompoundWrite(newWriteTree);\n    }\n}\n/**\r\n * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be\r\n * considered \"complete\".\r\n *\r\n * @param compoundWrite - The CompoundWrite to check.\r\n * @param path - The path to check for\r\n * @returns Whether there is a complete write at that path\r\n */ function compoundWriteHasCompleteWrite(compoundWrite, path) {\n    return compoundWriteGetCompleteNode(compoundWrite, path) != null;\n}\n/**\r\n * Returns a node for a path if and only if the node is a \"complete\" overwrite at that path. This will not aggregate\r\n * writes from deeper paths, but will return child nodes from a more shallow path.\r\n *\r\n * @param compoundWrite - The CompoundWrite to get the node from.\r\n * @param path - The path to get a complete write\r\n * @returns The node if complete at that path, or null otherwise.\r\n */ function compoundWriteGetCompleteNode(compoundWrite, path) {\n    const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);\n    if (rootmost != null) {\n        return compoundWrite.writeTree_.get(rootmost.path).getChild(newRelativePath(rootmost.path, path));\n    } else {\n        return null;\n    }\n}\n/**\r\n * Returns all children that are guaranteed to be a complete overwrite.\r\n *\r\n * @param compoundWrite - The CompoundWrite to get children from.\r\n * @returns A list of all complete children.\r\n */ function compoundWriteGetCompleteChildren(compoundWrite) {\n    const children = [];\n    const node = compoundWrite.writeTree_.value;\n    if (node != null) {\n        // If it's a leaf node, it has no children; so nothing to do.\n        if (!node.isLeafNode()) {\n            node.forEachChild(PRIORITY_INDEX, (childName, childNode)=>{\n                children.push(new NamedNode(childName, childNode));\n            });\n        }\n    } else {\n        compoundWrite.writeTree_.children.inorderTraversal((childName, childTree)=>{\n            if (childTree.value != null) {\n                children.push(new NamedNode(childName, childTree.value));\n            }\n        });\n    }\n    return children;\n}\nfunction compoundWriteChildCompoundWrite(compoundWrite, path) {\n    if (pathIsEmpty(path)) {\n        return compoundWrite;\n    } else {\n        const shadowingNode = compoundWriteGetCompleteNode(compoundWrite, path);\n        if (shadowingNode != null) {\n            return new CompoundWrite(new ImmutableTree(shadowingNode));\n        } else {\n            return new CompoundWrite(compoundWrite.writeTree_.subtree(path));\n        }\n    }\n}\n/**\r\n * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.\r\n * @returns Whether this CompoundWrite is empty\r\n */ function compoundWriteIsEmpty(compoundWrite) {\n    return compoundWrite.writeTree_.isEmpty();\n}\n/**\r\n * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the\r\n * node\r\n * @param node - The node to apply this CompoundWrite to\r\n * @returns The node with all writes applied\r\n */ function compoundWriteApply(compoundWrite, node) {\n    return applySubtreeWrite(newEmptyPath(), compoundWrite.writeTree_, node);\n}\nfunction applySubtreeWrite(relativePath, writeTree, node) {\n    if (writeTree.value != null) {\n        // Since there a write is always a leaf, we're done here\n        return node.updateChild(relativePath, writeTree.value);\n    } else {\n        let priorityWrite = null;\n        writeTree.children.inorderTraversal((childKey, childTree)=>{\n            if (childKey === \".priority\") {\n                // Apply priorities at the end so we don't update priorities for either empty nodes or forget\n                // to apply priorities to empty nodes that are later filled\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(childTree.value !== null, \"Priority writes must always be leaf nodes\");\n                priorityWrite = childTree.value;\n            } else {\n                node = applySubtreeWrite(pathChild(relativePath, childKey), childTree, node);\n            }\n        });\n        // If there was a priority write, we only apply it if the node is not empty\n        if (!node.getChild(relativePath).isEmpty() && priorityWrite !== null) {\n            node = node.updateChild(pathChild(relativePath, \".priority\"), priorityWrite);\n        }\n        return node;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\r\n *\r\n */ function writeTreeChildWrites(writeTree, path) {\n    return newWriteTreeRef(path, writeTree);\n}\n/**\r\n * Record a new overwrite from user code.\r\n *\r\n * @param visible - This is set to false by some transactions. It should be excluded from event caches\r\n */ function writeTreeAddOverwrite(writeTree, path, snap, writeId, visible) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(writeId > writeTree.lastWriteId, \"Stacking an older write on top of newer ones\");\n    if (visible === undefined) {\n        visible = true;\n    }\n    writeTree.allWrites.push({\n        path,\n        snap,\n        writeId,\n        visible\n    });\n    if (visible) {\n        writeTree.visibleWrites = compoundWriteAddWrite(writeTree.visibleWrites, path, snap);\n    }\n    writeTree.lastWriteId = writeId;\n}\n/**\r\n * Record a new merge from user code.\r\n */ function writeTreeAddMerge(writeTree, path, changedChildren, writeId) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(writeId > writeTree.lastWriteId, \"Stacking an older merge on top of newer ones\");\n    writeTree.allWrites.push({\n        path,\n        children: changedChildren,\n        writeId,\n        visible: true\n    });\n    writeTree.visibleWrites = compoundWriteAddWrites(writeTree.visibleWrites, path, changedChildren);\n    writeTree.lastWriteId = writeId;\n}\nfunction writeTreeGetWrite(writeTree, writeId) {\n    for(let i = 0; i < writeTree.allWrites.length; i++){\n        const record = writeTree.allWrites[i];\n        if (record.writeId === writeId) {\n            return record;\n        }\n    }\n    return null;\n}\n/**\r\n * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\r\n * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\r\n *\r\n * @returns true if the write may have been visible (meaning we'll need to reevaluate / raise\r\n * events as a result).\r\n */ function writeTreeRemoveWrite(writeTree, writeId) {\n    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied\n    // out of order.\n    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;\n    //assert(validClear, \"Either we don't have this write, or it's the first one in the queue\");\n    const idx = writeTree.allWrites.findIndex((s)=>{\n        return s.writeId === writeId;\n    });\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(idx >= 0, \"removeWrite called with nonexistent writeId.\");\n    const writeToRemove = writeTree.allWrites[idx];\n    writeTree.allWrites.splice(idx, 1);\n    let removedWriteWasVisible = writeToRemove.visible;\n    let removedWriteOverlapsWithOtherWrites = false;\n    let i = writeTree.allWrites.length - 1;\n    while(removedWriteWasVisible && i >= 0){\n        const currentWrite = writeTree.allWrites[i];\n        if (currentWrite.visible) {\n            if (i >= idx && writeTreeRecordContainsPath_(currentWrite, writeToRemove.path)) {\n                // The removed write was completely shadowed by a subsequent write.\n                removedWriteWasVisible = false;\n            } else if (pathContains(writeToRemove.path, currentWrite.path)) {\n                // Either we're covering some writes or they're covering part of us (depending on which came first).\n                removedWriteOverlapsWithOtherWrites = true;\n            }\n        }\n        i--;\n    }\n    if (!removedWriteWasVisible) {\n        return false;\n    } else if (removedWriteOverlapsWithOtherWrites) {\n        // There's some shadowing going on. Just rebuild the visible writes from scratch.\n        writeTreeResetTree_(writeTree);\n        return true;\n    } else {\n        // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.\n        if (writeToRemove.snap) {\n            writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, writeToRemove.path);\n        } else {\n            const children = writeToRemove.children;\n            each(children, (childName)=>{\n                writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, pathChild(writeToRemove.path, childName));\n            });\n        }\n        return true;\n    }\n}\nfunction writeTreeRecordContainsPath_(writeRecord, path) {\n    if (writeRecord.snap) {\n        return pathContains(writeRecord.path, path);\n    } else {\n        for(const childName in writeRecord.children){\n            if (writeRecord.children.hasOwnProperty(childName) && pathContains(pathChild(writeRecord.path, childName), path)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n/**\r\n * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots\r\n */ function writeTreeResetTree_(writeTree) {\n    writeTree.visibleWrites = writeTreeLayerTree_(writeTree.allWrites, writeTreeDefaultFilter_, newEmptyPath());\n    if (writeTree.allWrites.length > 0) {\n        writeTree.lastWriteId = writeTree.allWrites[writeTree.allWrites.length - 1].writeId;\n    } else {\n        writeTree.lastWriteId = -1;\n    }\n}\n/**\r\n * The default filter used when constructing the tree. Keep everything that's visible.\r\n */ function writeTreeDefaultFilter_(write) {\n    return write.visible;\n}\n/**\r\n * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of\r\n * event data at that path.\r\n */ function writeTreeLayerTree_(writes, filter, treeRoot) {\n    let compoundWrite = CompoundWrite.empty();\n    for(let i = 0; i < writes.length; ++i){\n        const write = writes[i];\n        // Theory, a later set will either:\n        // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction\n        // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction\n        if (filter(write)) {\n            const writePath = write.path;\n            let relativePath;\n            if (write.snap) {\n                if (pathContains(treeRoot, writePath)) {\n                    relativePath = newRelativePath(treeRoot, writePath);\n                    compoundWrite = compoundWriteAddWrite(compoundWrite, relativePath, write.snap);\n                } else if (pathContains(writePath, treeRoot)) {\n                    relativePath = newRelativePath(writePath, treeRoot);\n                    compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), write.snap.getChild(relativePath));\n                } else ;\n            } else if (write.children) {\n                if (pathContains(treeRoot, writePath)) {\n                    relativePath = newRelativePath(treeRoot, writePath);\n                    compoundWrite = compoundWriteAddWrites(compoundWrite, relativePath, write.children);\n                } else if (pathContains(writePath, treeRoot)) {\n                    relativePath = newRelativePath(writePath, treeRoot);\n                    if (pathIsEmpty(relativePath)) {\n                        compoundWrite = compoundWriteAddWrites(compoundWrite, newEmptyPath(), write.children);\n                    } else {\n                        const child = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(write.children, pathGetFront(relativePath));\n                        if (child) {\n                            // There exists a child in this node that matches the root path\n                            const deepNode = child.getChild(pathPopFront(relativePath));\n                            compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), deepNode);\n                        }\n                    }\n                } else ;\n            } else {\n                throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assertionError)(\"WriteRecord should have .snap or .children\");\n            }\n        }\n    }\n    return compoundWrite;\n}\n/**\r\n * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\r\n * writes), attempt to calculate a complete snapshot for the given path\r\n *\r\n * @param writeIdsToExclude - An optional set to be excluded\r\n * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false\r\n */ function writeTreeCalcCompleteEventCache(writeTree, treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {\n    if (!writeIdsToExclude && !includeHiddenWrites) {\n        const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);\n        if (shadowingNode != null) {\n            return shadowingNode;\n        } else {\n            const subMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\n            if (compoundWriteIsEmpty(subMerge)) {\n                return completeServerCache;\n            } else if (completeServerCache == null && !compoundWriteHasCompleteWrite(subMerge, newEmptyPath())) {\n                // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow\n                return null;\n            } else {\n                const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n                return compoundWriteApply(subMerge, layeredCache);\n            }\n        }\n    } else {\n        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\n        if (!includeHiddenWrites && compoundWriteIsEmpty(merge)) {\n            return completeServerCache;\n        } else {\n            // If the server cache is null, and we don't have a complete cache, we need to return null\n            if (!includeHiddenWrites && completeServerCache == null && !compoundWriteHasCompleteWrite(merge, newEmptyPath())) {\n                return null;\n            } else {\n                const filter = function(write) {\n                    return (write.visible || includeHiddenWrites) && (!writeIdsToExclude || !~writeIdsToExclude.indexOf(write.writeId)) && (pathContains(write.path, treePath) || pathContains(treePath, write.path));\n                };\n                const mergeAtPath = writeTreeLayerTree_(writeTree.allWrites, filter, treePath);\n                const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n                return compoundWriteApply(mergeAtPath, layeredCache);\n            }\n        }\n    }\n}\n/**\r\n * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\r\n * Used when creating new views, to pre-fill their complete event children snapshot.\r\n */ function writeTreeCalcCompleteEventChildren(writeTree, treePath, completeServerChildren) {\n    let completeChildren = ChildrenNode.EMPTY_NODE;\n    const topLevelSet = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);\n    if (topLevelSet) {\n        if (!topLevelSet.isLeafNode()) {\n            // we're shadowing everything. Return the children.\n            topLevelSet.forEachChild(PRIORITY_INDEX, (childName, childSnap)=>{\n                completeChildren = completeChildren.updateImmediateChild(childName, childSnap);\n            });\n        }\n        return completeChildren;\n    } else if (completeServerChildren) {\n        // Layer any children we have on top of this\n        // We know we don't have a top-level set, so just enumerate existing children\n        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\n        completeServerChildren.forEachChild(PRIORITY_INDEX, (childName, childNode)=>{\n            const node = compoundWriteApply(compoundWriteChildCompoundWrite(merge, new Path(childName)), childNode);\n            completeChildren = completeChildren.updateImmediateChild(childName, node);\n        });\n        // Add any complete children we have from the set\n        compoundWriteGetCompleteChildren(merge).forEach((namedNode)=>{\n            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\n        });\n        return completeChildren;\n    } else {\n        // We don't have anything to layer on top of. Layer on any children we have\n        // Note that we can return an empty snap if we have a defined delete\n        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\n        compoundWriteGetCompleteChildren(merge).forEach((namedNode)=>{\n            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\n        });\n        return completeChildren;\n    }\n}\n/**\r\n * Given that the underlying server data has updated, determine what, if anything, needs to be\r\n * applied to the event cache.\r\n *\r\n * Possibilities:\r\n *\r\n * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n *\r\n * 2. Some write is completely shadowing. No events to be raised\r\n *\r\n * 3. Is partially shadowed. Events\r\n *\r\n * Either existingEventSnap or existingServerSnap must exist\r\n */ function writeTreeCalcEventCacheAfterServerOverwrite(writeTree, treePath, childPath, existingEventSnap, existingServerSnap) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(existingEventSnap || existingServerSnap, \"Either existingEventSnap or existingServerSnap must exist\");\n    const path = pathChild(treePath, childPath);\n    if (compoundWriteHasCompleteWrite(writeTree.visibleWrites, path)) {\n        // At this point we can probably guarantee that we're in case 2, meaning no events\n        // May need to check visibility while doing the findRootMostValueAndPath call\n        return null;\n    } else {\n        // No complete shadowing. We're either partially shadowing or not shadowing at all.\n        const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);\n        if (compoundWriteIsEmpty(childMerge)) {\n            // We're not shadowing at all. Case 1\n            return existingServerSnap.getChild(childPath);\n        } else {\n            // This could be more efficient if the serverNode + updates doesn't change the eventSnap\n            // However this is tricky to find out, since user updates don't necessary change the server\n            // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server\n            // adds nodes, but doesn't change any existing writes. It is therefore not enough to\n            // only check if the updates change the serverNode.\n            // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?\n            return compoundWriteApply(childMerge, existingServerSnap.getChild(childPath));\n        }\n    }\n}\n/**\r\n * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n * complete child for this ChildKey.\r\n */ function writeTreeCalcCompleteChild(writeTree, treePath, childKey, existingServerSnap) {\n    const path = pathChild(treePath, childKey);\n    const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, path);\n    if (shadowingNode != null) {\n        return shadowingNode;\n    } else {\n        if (existingServerSnap.isCompleteForChild(childKey)) {\n            const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);\n            return compoundWriteApply(childMerge, existingServerSnap.getNode().getImmediateChild(childKey));\n        } else {\n            return null;\n        }\n    }\n}\n/**\r\n * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n * a higher path, this will return the child of that write relative to the write and this path.\r\n * Returns null if there is no write at this path.\r\n */ function writeTreeShadowingWrite(writeTree, path) {\n    return compoundWriteGetCompleteNode(writeTree.visibleWrites, path);\n}\n/**\r\n * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n * the window, but may now be in the window.\r\n */ function writeTreeCalcIndexedSlice(writeTree, treePath, completeServerData, startPost, count, reverse, index) {\n    let toIterate;\n    const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\n    const shadowingNode = compoundWriteGetCompleteNode(merge, newEmptyPath());\n    if (shadowingNode != null) {\n        toIterate = shadowingNode;\n    } else if (completeServerData != null) {\n        toIterate = compoundWriteApply(merge, completeServerData);\n    } else {\n        // no children to iterate on\n        return [];\n    }\n    toIterate = toIterate.withIndex(index);\n    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {\n        const nodes = [];\n        const cmp = index.getCompare();\n        const iter = reverse ? toIterate.getReverseIteratorFrom(startPost, index) : toIterate.getIteratorFrom(startPost, index);\n        let next = iter.getNext();\n        while(next && nodes.length < count){\n            if (cmp(next, startPost) !== 0) {\n                nodes.push(next);\n            }\n            next = iter.getNext();\n        }\n        return nodes;\n    } else {\n        return [];\n    }\n}\nfunction newWriteTree() {\n    return {\n        visibleWrites: CompoundWrite.empty(),\n        allWrites: [],\n        lastWriteId: -1\n    };\n}\n/**\r\n * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\r\n * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\r\n * can lead to a more expensive calculation.\r\n *\r\n * @param writeIdsToExclude - Optional writes to exclude.\r\n * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false\r\n */ function writeTreeRefCalcCompleteEventCache(writeTreeRef, completeServerCache, writeIdsToExclude, includeHiddenWrites) {\n    return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites);\n}\n/**\r\n * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\r\n * mix of the given server data and write data.\r\n *\r\n */ function writeTreeRefCalcCompleteEventChildren(writeTreeRef, completeServerChildren) {\n    return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerChildren);\n}\n/**\r\n * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\r\n * if anything, needs to be applied to the event cache.\r\n *\r\n * Possibilities:\r\n *\r\n * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n *\r\n * 2. Some write is completely shadowing. No events to be raised\r\n *\r\n * 3. Is partially shadowed. Events should be raised\r\n *\r\n * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\r\n *\r\n *\r\n */ function writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef, path, existingEventSnap, existingServerSnap) {\n    return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree, writeTreeRef.treePath, path, existingEventSnap, existingServerSnap);\n}\n/**\r\n * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n * a higher path, this will return the child of that write relative to the write and this path.\r\n * Returns null if there is no write at this path.\r\n *\r\n */ function writeTreeRefShadowingWrite(writeTreeRef, path) {\n    return writeTreeShadowingWrite(writeTreeRef.writeTree, pathChild(writeTreeRef.treePath, path));\n}\n/**\r\n * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n * the window, but may now be in the window\r\n */ function writeTreeRefCalcIndexedSlice(writeTreeRef, completeServerData, startPost, count, reverse, index) {\n    return writeTreeCalcIndexedSlice(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerData, startPost, count, reverse, index);\n}\n/**\r\n * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n * complete child for this ChildKey.\r\n */ function writeTreeRefCalcCompleteChild(writeTreeRef, childKey, existingServerCache) {\n    return writeTreeCalcCompleteChild(writeTreeRef.writeTree, writeTreeRef.treePath, childKey, existingServerCache);\n}\n/**\r\n * Return a WriteTreeRef for a child.\r\n */ function writeTreeRefChild(writeTreeRef, childName) {\n    return newWriteTreeRef(pathChild(writeTreeRef.treePath, childName), writeTreeRef.writeTree);\n}\nfunction newWriteTreeRef(path, writeTree) {\n    return {\n        treePath: path,\n        writeTree\n    };\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class ChildChangeAccumulator {\n    constructor(){\n        this.changeMap = new Map();\n    }\n    trackChildChange(change) {\n        const type = change.type;\n        const childKey = change.childName;\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(type === \"child_added\" /* ChangeType.CHILD_ADDED */  || type === \"child_changed\" /* ChangeType.CHILD_CHANGED */  || type === \"child_removed\" /* ChangeType.CHILD_REMOVED */ , \"Only child changes supported for tracking\");\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(childKey !== \".priority\", \"Only non-priority child changes can be tracked.\");\n        const oldChange = this.changeMap.get(childKey);\n        if (oldChange) {\n            const oldType = oldChange.type;\n            if (type === \"child_added\" /* ChangeType.CHILD_ADDED */  && oldType === \"child_removed\" /* ChangeType.CHILD_REMOVED */ ) {\n                this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.snapshotNode));\n            } else if (type === \"child_removed\" /* ChangeType.CHILD_REMOVED */  && oldType === \"child_added\" /* ChangeType.CHILD_ADDED */ ) {\n                this.changeMap.delete(childKey);\n            } else if (type === \"child_removed\" /* ChangeType.CHILD_REMOVED */  && oldType === \"child_changed\" /* ChangeType.CHILD_CHANGED */ ) {\n                this.changeMap.set(childKey, changeChildRemoved(childKey, oldChange.oldSnap));\n            } else if (type === \"child_changed\" /* ChangeType.CHILD_CHANGED */  && oldType === \"child_added\" /* ChangeType.CHILD_ADDED */ ) {\n                this.changeMap.set(childKey, changeChildAdded(childKey, change.snapshotNode));\n            } else if (type === \"child_changed\" /* ChangeType.CHILD_CHANGED */  && oldType === \"child_changed\" /* ChangeType.CHILD_CHANGED */ ) {\n                this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.oldSnap));\n            } else {\n                throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assertionError)(\"Illegal combination of changes: \" + change + \" occurred after \" + oldChange);\n            }\n        } else {\n            this.changeMap.set(childKey, change);\n        }\n    }\n    getChanges() {\n        return Array.from(this.changeMap.values());\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An implementation of CompleteChildSource that never returns any additional children\r\n */ // eslint-disable-next-line @typescript-eslint/naming-convention\nclass NoCompleteChildSource_ {\n    getCompleteChild(childKey) {\n        return null;\n    }\n    getChildAfterChild(index, child, reverse) {\n        return null;\n    }\n}\n/**\r\n * Singleton instance.\r\n */ const NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();\n/**\r\n * An implementation of CompleteChildSource that uses a WriteTree in addition to any other server data or\r\n * old event caches available to calculate complete children.\r\n */ class WriteTreeCompleteChildSource {\n    constructor(writes_, viewCache_, optCompleteServerCache_ = null){\n        this.writes_ = writes_;\n        this.viewCache_ = viewCache_;\n        this.optCompleteServerCache_ = optCompleteServerCache_;\n    }\n    getCompleteChild(childKey) {\n        const node = this.viewCache_.eventCache;\n        if (node.isCompleteForChild(childKey)) {\n            return node.getNode().getImmediateChild(childKey);\n        } else {\n            const serverNode = this.optCompleteServerCache_ != null ? new CacheNode(this.optCompleteServerCache_, true, false) : this.viewCache_.serverCache;\n            return writeTreeRefCalcCompleteChild(this.writes_, childKey, serverNode);\n        }\n    }\n    getChildAfterChild(index, child, reverse) {\n        const completeServerData = this.optCompleteServerCache_ != null ? this.optCompleteServerCache_ : viewCacheGetCompleteServerSnap(this.viewCache_);\n        const nodes = writeTreeRefCalcIndexedSlice(this.writes_, completeServerData, child, 1, reverse, index);\n        if (nodes.length === 0) {\n            return null;\n        } else {\n            return nodes[0];\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function newViewProcessor(filter) {\n    return {\n        filter\n    };\n}\nfunction viewProcessorAssertIndexed(viewProcessor, viewCache) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(viewCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()), \"Event snap not indexed\");\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(viewCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()), \"Server snap not indexed\");\n}\nfunction viewProcessorApplyOperation(viewProcessor, oldViewCache, operation, writesCache, completeCache) {\n    const accumulator = new ChildChangeAccumulator();\n    let newViewCache, filterServerNode;\n    if (operation.type === OperationType.OVERWRITE) {\n        const overwrite = operation;\n        if (overwrite.source.fromUser) {\n            newViewCache = viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(overwrite.source.fromServer, \"Unknown source.\");\n            // We filter the node if it's a tagged update or the node has been previously filtered  and the\n            // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\n            // again\n            filterServerNode = overwrite.source.tagged || oldViewCache.serverCache.isFiltered() && !pathIsEmpty(overwrite.path);\n            newViewCache = viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);\n        }\n    } else if (operation.type === OperationType.MERGE) {\n        const merge = operation;\n        if (merge.source.fromUser) {\n            newViewCache = viewProcessorApplyUserMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(merge.source.fromServer, \"Unknown source.\");\n            // We filter the node if it's a tagged update or the node has been previously filtered\n            filterServerNode = merge.source.tagged || oldViewCache.serverCache.isFiltered();\n            newViewCache = viewProcessorApplyServerMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);\n        }\n    } else if (operation.type === OperationType.ACK_USER_WRITE) {\n        const ackUserWrite = operation;\n        if (!ackUserWrite.revert) {\n            newViewCache = viewProcessorAckUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);\n        } else {\n            newViewCache = viewProcessorRevertUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);\n        }\n    } else if (operation.type === OperationType.LISTEN_COMPLETE) {\n        newViewCache = viewProcessorListenComplete(viewProcessor, oldViewCache, operation.path, writesCache, accumulator);\n    } else {\n        throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assertionError)(\"Unknown operation type: \" + operation.type);\n    }\n    const changes = accumulator.getChanges();\n    viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache, changes);\n    return {\n        viewCache: newViewCache,\n        changes\n    };\n}\nfunction viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache, accumulator) {\n    const eventSnap = newViewCache.eventCache;\n    if (eventSnap.isFullyInitialized()) {\n        const isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();\n        const oldCompleteSnap = viewCacheGetCompleteEventSnap(oldViewCache);\n        if (accumulator.length > 0 || !oldViewCache.eventCache.isFullyInitialized() || isLeafOrEmpty && !eventSnap.getNode().equals(oldCompleteSnap) || !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {\n            accumulator.push(changeValue(viewCacheGetCompleteEventSnap(newViewCache)));\n        }\n    }\n}\nfunction viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, viewCache, changePath, writesCache, source, accumulator) {\n    const oldEventSnap = viewCache.eventCache;\n    if (writeTreeRefShadowingWrite(writesCache, changePath) != null) {\n        // we have a shadowing write, ignore changes\n        return viewCache;\n    } else {\n        let newEventCache, serverNode;\n        if (pathIsEmpty(changePath)) {\n            // TODO: figure out how this plays with \"sliding ack windows\"\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(viewCache.serverCache.isFullyInitialized(), \"If change path is empty, we must have complete server data\");\n            if (viewCache.serverCache.isFiltered()) {\n                // We need to special case this, because we need to only apply writes to complete children, or\n                // we might end up raising events for incomplete children. If the server data is filtered deep\n                // writes cannot be guaranteed to be complete\n                const serverCache = viewCacheGetCompleteServerSnap(viewCache);\n                const completeChildren = serverCache instanceof ChildrenNode ? serverCache : ChildrenNode.EMPTY_NODE;\n                const completeEventChildren = writeTreeRefCalcCompleteEventChildren(writesCache, completeChildren);\n                newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeEventChildren, accumulator);\n            } else {\n                const completeNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));\n                newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeNode, accumulator);\n            }\n        } else {\n            const childKey = pathGetFront(changePath);\n            if (childKey === \".priority\") {\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(pathGetLength(changePath) === 1, \"Can't have a priority with additional path components\");\n                const oldEventNode = oldEventSnap.getNode();\n                serverNode = viewCache.serverCache.getNode();\n                // we might have overwrites for this priority\n                const updatedPriority = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventNode, serverNode);\n                if (updatedPriority != null) {\n                    newEventCache = viewProcessor.filter.updatePriority(oldEventNode, updatedPriority);\n                } else {\n                    // priority didn't change, keep old node\n                    newEventCache = oldEventSnap.getNode();\n                }\n            } else {\n                const childChangePath = pathPopFront(changePath);\n                // update child\n                let newEventChild;\n                if (oldEventSnap.isCompleteForChild(childKey)) {\n                    serverNode = viewCache.serverCache.getNode();\n                    const eventChildUpdate = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventSnap.getNode(), serverNode);\n                    if (eventChildUpdate != null) {\n                        newEventChild = oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath, eventChildUpdate);\n                    } else {\n                        // Nothing changed, just keep the old child\n                        newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);\n                    }\n                } else {\n                    newEventChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);\n                }\n                if (newEventChild != null) {\n                    newEventCache = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);\n                } else {\n                    // no complete child available or no change\n                    newEventCache = oldEventSnap.getNode();\n                }\n            }\n        }\n        return viewCacheUpdateEventSnap(viewCache, newEventCache, oldEventSnap.isFullyInitialized() || pathIsEmpty(changePath), viewProcessor.filter.filtersNodes());\n    }\n}\nfunction viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {\n    const oldServerSnap = oldViewCache.serverCache;\n    let newServerCache;\n    const serverFilter = filterServerNode ? viewProcessor.filter : viewProcessor.filter.getIndexedFilter();\n    if (pathIsEmpty(changePath)) {\n        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);\n    } else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {\n        // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\n        const newServerNode = oldServerSnap.getNode().updateChild(changePath, changedSnap);\n        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);\n    } else {\n        const childKey = pathGetFront(changePath);\n        if (!oldServerSnap.isCompleteForPath(changePath) && pathGetLength(changePath) > 1) {\n            // We don't update incomplete nodes with updates intended for other listeners\n            return oldViewCache;\n        }\n        const childChangePath = pathPopFront(changePath);\n        const childNode = oldServerSnap.getNode().getImmediateChild(childKey);\n        const newChildNode = childNode.updateChild(childChangePath, changedSnap);\n        if (childKey === \".priority\") {\n            newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);\n        } else {\n            newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);\n        }\n    }\n    const newViewCache = viewCacheUpdateServerSnap(oldViewCache, newServerCache, oldServerSnap.isFullyInitialized() || pathIsEmpty(changePath), serverFilter.filtersNodes());\n    const source = new WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);\n    return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache, changePath, writesCache, source, accumulator);\n}\nfunction viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {\n    const oldEventSnap = oldViewCache.eventCache;\n    let newViewCache, newEventCache;\n    const source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);\n    if (pathIsEmpty(changePath)) {\n        newEventCache = viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(), changedSnap, accumulator);\n        newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventCache, true, viewProcessor.filter.filtersNodes());\n    } else {\n        const childKey = pathGetFront(changePath);\n        if (childKey === \".priority\") {\n            newEventCache = viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(), changedSnap);\n            newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());\n        } else {\n            const childChangePath = pathPopFront(changePath);\n            const oldChild = oldEventSnap.getNode().getImmediateChild(childKey);\n            let newChild;\n            if (pathIsEmpty(childChangePath)) {\n                // Child overwrite, we can replace the child\n                newChild = changedSnap;\n            } else {\n                const childNode = source.getCompleteChild(childKey);\n                if (childNode != null) {\n                    if (pathGetBack(childChangePath) === \".priority\" && childNode.getChild(pathParent(childChangePath)).isEmpty()) {\n                        // This is a priority update on an empty node. If this node exists on the server, the\n                        // server will send down the priority in the update, so ignore for now\n                        newChild = childNode;\n                    } else {\n                        newChild = childNode.updateChild(childChangePath, changedSnap);\n                    }\n                } else {\n                    // There is no complete child node available\n                    newChild = ChildrenNode.EMPTY_NODE;\n                }\n            }\n            if (!oldChild.equals(newChild)) {\n                const newEventSnap = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);\n                newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventSnap, oldEventSnap.isFullyInitialized(), viewProcessor.filter.filtersNodes());\n            } else {\n                newViewCache = oldViewCache;\n            }\n        }\n    }\n    return newViewCache;\n}\nfunction viewProcessorCacheHasChild(viewCache, childKey) {\n    return viewCache.eventCache.isCompleteForChild(childKey);\n}\nfunction viewProcessorApplyUserMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, accumulator) {\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    let curViewCache = viewCache;\n    changedChildren.foreach((relativePath, childNode)=>{\n        const writePath = pathChild(path, relativePath);\n        if (viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {\n            curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\n        }\n    });\n    changedChildren.foreach((relativePath, childNode)=>{\n        const writePath = pathChild(path, relativePath);\n        if (!viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {\n            curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\n        }\n    });\n    return curViewCache;\n}\nfunction viewProcessorApplyMerge(viewProcessor, node, merge) {\n    merge.foreach((relativePath, childNode)=>{\n        node = node.updateChild(relativePath, childNode);\n    });\n    return node;\n}\nfunction viewProcessorApplyServerMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {\n    // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\n    // wait for the complete data update coming soon.\n    if (viewCache.serverCache.getNode().isEmpty() && !viewCache.serverCache.isFullyInitialized()) {\n        return viewCache;\n    }\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    let curViewCache = viewCache;\n    let viewMergeTree;\n    if (pathIsEmpty(path)) {\n        viewMergeTree = changedChildren;\n    } else {\n        viewMergeTree = new ImmutableTree(null).setTree(path, changedChildren);\n    }\n    const serverNode = viewCache.serverCache.getNode();\n    viewMergeTree.children.inorderTraversal((childKey, childTree)=>{\n        if (serverNode.hasChild(childKey)) {\n            const serverChild = viewCache.serverCache.getNode().getImmediateChild(childKey);\n            const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childTree);\n            curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\n        }\n    });\n    viewMergeTree.children.inorderTraversal((childKey, childMergeTree)=>{\n        const isUnknownDeepMerge = !viewCache.serverCache.isCompleteForChild(childKey) && childMergeTree.value === null;\n        if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {\n            const serverChild = viewCache.serverCache.getNode().getImmediateChild(childKey);\n            const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childMergeTree);\n            curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\n        }\n    });\n    return curViewCache;\n}\nfunction viewProcessorAckUserWrite(viewProcessor, viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {\n    if (writeTreeRefShadowingWrite(writesCache, ackPath) != null) {\n        return viewCache;\n    }\n    // Only filter server node if it is currently filtered\n    const filterServerNode = viewCache.serverCache.isFiltered();\n    // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\n    // now that it won't be shadowed.\n    const serverCache = viewCache.serverCache;\n    if (affectedTree.value != null) {\n        // This is an overwrite.\n        if (pathIsEmpty(ackPath) && serverCache.isFullyInitialized() || serverCache.isCompleteForPath(ackPath)) {\n            return viewProcessorApplyServerOverwrite(viewProcessor, viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);\n        } else if (pathIsEmpty(ackPath)) {\n            // This is a goofy edge case where we are acking data at this location but don't have full data.  We\n            // should just re-apply whatever we have in our cache as a merge.\n            let changedChildren = new ImmutableTree(null);\n            serverCache.getNode().forEachChild(KEY_INDEX, (name, node)=>{\n                changedChildren = changedChildren.set(new Path(name), node);\n            });\n            return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);\n        } else {\n            return viewCache;\n        }\n    } else {\n        // This is a merge.\n        let changedChildren = new ImmutableTree(null);\n        affectedTree.foreach((mergePath, value)=>{\n            const serverCachePath = pathChild(ackPath, mergePath);\n            if (serverCache.isCompleteForPath(serverCachePath)) {\n                changedChildren = changedChildren.set(mergePath, serverCache.getNode().getChild(serverCachePath));\n            }\n        });\n        return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);\n    }\n}\nfunction viewProcessorListenComplete(viewProcessor, viewCache, path, writesCache, accumulator) {\n    const oldServerNode = viewCache.serverCache;\n    const newViewCache = viewCacheUpdateServerSnap(viewCache, oldServerNode.getNode(), oldServerNode.isFullyInitialized() || pathIsEmpty(path), oldServerNode.isFiltered());\n    return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);\n}\nfunction viewProcessorRevertUserWrite(viewProcessor, viewCache, path, writesCache, completeServerCache, accumulator) {\n    let complete;\n    if (writeTreeRefShadowingWrite(writesCache, path) != null) {\n        return viewCache;\n    } else {\n        const source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);\n        const oldEventCache = viewCache.eventCache.getNode();\n        let newEventCache;\n        if (pathIsEmpty(path) || pathGetFront(path) === \".priority\") {\n            let newNode;\n            if (viewCache.serverCache.isFullyInitialized()) {\n                newNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));\n            } else {\n                const serverChildren = viewCache.serverCache.getNode();\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(serverChildren instanceof ChildrenNode, \"serverChildren would be complete if leaf node\");\n                newNode = writeTreeRefCalcCompleteEventChildren(writesCache, serverChildren);\n            }\n            newNode = newNode;\n            newEventCache = viewProcessor.filter.updateFullNode(oldEventCache, newNode, accumulator);\n        } else {\n            const childKey = pathGetFront(path);\n            let newChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);\n            if (newChild == null && viewCache.serverCache.isCompleteForChild(childKey)) {\n                newChild = oldEventCache.getImmediateChild(childKey);\n            }\n            if (newChild != null) {\n                newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, newChild, pathPopFront(path), source, accumulator);\n            } else if (viewCache.eventCache.getNode().hasChild(childKey)) {\n                // No complete child available, delete the existing one, if any\n                newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, pathPopFront(path), source, accumulator);\n            } else {\n                newEventCache = oldEventCache;\n            }\n            if (newEventCache.isEmpty() && viewCache.serverCache.isFullyInitialized()) {\n                // We might have reverted all child writes. Maybe the old event was a leaf node\n                complete = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));\n                if (complete.isLeafNode()) {\n                    newEventCache = viewProcessor.filter.updateFullNode(newEventCache, complete, accumulator);\n                }\n            }\n        }\n        complete = viewCache.serverCache.isFullyInitialized() || writeTreeRefShadowingWrite(writesCache, newEmptyPath()) != null;\n        return viewCacheUpdateEventSnap(viewCache, newEventCache, complete, viewProcessor.filter.filtersNodes());\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A view represents a specific location and query that has 1 or more event registrations.\r\n *\r\n * It does several things:\r\n *  - Maintains the list of event registrations for this location/query.\r\n *  - Maintains a cache of the data visible for this location/query.\r\n *  - Applies new operations (via applyOperation), updates the cache, and based on the event\r\n *    registrations returns the set of events to be raised.\r\n */ class View {\n    constructor(query_, initialViewCache){\n        this.query_ = query_;\n        this.eventRegistrations_ = [];\n        const params = this.query_._queryParams;\n        const indexFilter = new IndexedFilter(params.getIndex());\n        const filter = queryParamsGetNodeFilter(params);\n        this.processor_ = newViewProcessor(filter);\n        const initialServerCache = initialViewCache.serverCache;\n        const initialEventCache = initialViewCache.eventCache;\n        // Don't filter server node with other filter than index, wait for tagged listen\n        const serverSnap = indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);\n        const eventSnap = filter.updateFullNode(ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);\n        const newServerCache = new CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());\n        const newEventCache = new CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());\n        this.viewCache_ = newViewCache(newEventCache, newServerCache);\n        this.eventGenerator_ = new EventGenerator(this.query_);\n    }\n    get query() {\n        return this.query_;\n    }\n}\nfunction viewGetServerCache(view) {\n    return view.viewCache_.serverCache.getNode();\n}\nfunction viewGetCompleteNode(view) {\n    return viewCacheGetCompleteEventSnap(view.viewCache_);\n}\nfunction viewGetCompleteServerCache(view, path) {\n    const cache = viewCacheGetCompleteServerSnap(view.viewCache_);\n    if (cache) {\n        // If this isn't a \"loadsAllData\" view, then cache isn't actually a complete cache and\n        // we need to see if it contains the child we're interested in.\n        if (view.query._queryParams.loadsAllData() || !pathIsEmpty(path) && !cache.getImmediateChild(pathGetFront(path)).isEmpty()) {\n            return cache.getChild(path);\n        }\n    }\n    return null;\n}\nfunction viewIsEmpty(view) {\n    return view.eventRegistrations_.length === 0;\n}\nfunction viewAddEventRegistration(view, eventRegistration) {\n    view.eventRegistrations_.push(eventRegistration);\n}\n/**\r\n * @param eventRegistration - If null, remove all callbacks.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @returns Cancel events, if cancelError was provided.\r\n */ function viewRemoveEventRegistration(view, eventRegistration, cancelError) {\n    const cancelEvents = [];\n    if (cancelError) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(eventRegistration == null, \"A cancel should cancel all event registrations.\");\n        const path = view.query._path;\n        view.eventRegistrations_.forEach((registration)=>{\n            const maybeEvent = registration.createCancelEvent(cancelError, path);\n            if (maybeEvent) {\n                cancelEvents.push(maybeEvent);\n            }\n        });\n    }\n    if (eventRegistration) {\n        let remaining = [];\n        for(let i = 0; i < view.eventRegistrations_.length; ++i){\n            const existing = view.eventRegistrations_[i];\n            if (!existing.matches(eventRegistration)) {\n                remaining.push(existing);\n            } else if (eventRegistration.hasAnyCallback()) {\n                // We're removing just this one\n                remaining = remaining.concat(view.eventRegistrations_.slice(i + 1));\n                break;\n            }\n        }\n        view.eventRegistrations_ = remaining;\n    } else {\n        view.eventRegistrations_ = [];\n    }\n    return cancelEvents;\n}\n/**\r\n * Applies the given Operation, updates our cache, and returns the appropriate events.\r\n */ function viewApplyOperation(view, operation, writesCache, completeServerCache) {\n    if (operation.type === OperationType.MERGE && operation.source.queryId !== null) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(viewCacheGetCompleteServerSnap(view.viewCache_), \"We should always have a full cache before handling merges\");\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(viewCacheGetCompleteEventSnap(view.viewCache_), \"Missing event cache, even though we have a server cache\");\n    }\n    const oldViewCache = view.viewCache_;\n    const result = viewProcessorApplyOperation(view.processor_, oldViewCache, operation, writesCache, completeServerCache);\n    viewProcessorAssertIndexed(view.processor_, result.viewCache);\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(result.viewCache.serverCache.isFullyInitialized() || !oldViewCache.serverCache.isFullyInitialized(), \"Once a server snap is complete, it should never go back\");\n    view.viewCache_ = result.viewCache;\n    return viewGenerateEventsForChanges_(view, result.changes, result.viewCache.eventCache.getNode(), null);\n}\nfunction viewGetInitialEvents(view, registration) {\n    const eventSnap = view.viewCache_.eventCache;\n    const initialChanges = [];\n    if (!eventSnap.getNode().isLeafNode()) {\n        const eventNode = eventSnap.getNode();\n        eventNode.forEachChild(PRIORITY_INDEX, (key, childNode)=>{\n            initialChanges.push(changeChildAdded(key, childNode));\n        });\n    }\n    if (eventSnap.isFullyInitialized()) {\n        initialChanges.push(changeValue(eventSnap.getNode()));\n    }\n    return viewGenerateEventsForChanges_(view, initialChanges, eventSnap.getNode(), registration);\n}\nfunction viewGenerateEventsForChanges_(view, changes, eventCache, eventRegistration) {\n    const registrations = eventRegistration ? [\n        eventRegistration\n    ] : view.eventRegistrations_;\n    return eventGeneratorGenerateEventsForChanges(view.eventGenerator_, changes, eventCache, registrations);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let referenceConstructor$1;\n/**\r\n * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to\r\n * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes\r\n * and user writes (set, transaction, update).\r\n *\r\n * It's responsible for:\r\n *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).\r\n *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,\r\n *    applyUserOverwrite, etc.)\r\n */ class SyncPoint {\n    constructor(){\n        /**\r\n         * The Views being tracked at this location in the tree, stored as a map where the key is a\r\n         * queryId and the value is the View for that query.\r\n         *\r\n         * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).\r\n         */ this.views = new Map();\n    }\n}\nfunction syncPointSetReferenceConstructor(val) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!referenceConstructor$1, \"__referenceConstructor has already been defined\");\n    referenceConstructor$1 = val;\n}\nfunction syncPointGetReferenceConstructor() {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(referenceConstructor$1, \"Reference.ts has not been loaded\");\n    return referenceConstructor$1;\n}\nfunction syncPointIsEmpty(syncPoint) {\n    return syncPoint.views.size === 0;\n}\nfunction syncPointApplyOperation(syncPoint, operation, writesCache, optCompleteServerCache) {\n    const queryId = operation.source.queryId;\n    if (queryId !== null) {\n        const view = syncPoint.views.get(queryId);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(view != null, \"SyncTree gave us an op for an invalid query.\");\n        return viewApplyOperation(view, operation, writesCache, optCompleteServerCache);\n    } else {\n        let events = [];\n        for (const view of syncPoint.views.values()){\n            events = events.concat(viewApplyOperation(view, operation, writesCache, optCompleteServerCache));\n        }\n        return events;\n    }\n}\n/**\r\n * Get a view for the specified query.\r\n *\r\n * @param query - The query to return a view for\r\n * @param writesCache\r\n * @param serverCache\r\n * @param serverCacheComplete\r\n * @returns Events to raise.\r\n */ function syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete) {\n    const queryId = query._queryIdentifier;\n    const view = syncPoint.views.get(queryId);\n    if (!view) {\n        // TODO: make writesCache take flag for complete server node\n        let eventCache = writeTreeRefCalcCompleteEventCache(writesCache, serverCacheComplete ? serverCache : null);\n        let eventCacheComplete = false;\n        if (eventCache) {\n            eventCacheComplete = true;\n        } else if (serverCache instanceof ChildrenNode) {\n            eventCache = writeTreeRefCalcCompleteEventChildren(writesCache, serverCache);\n            eventCacheComplete = false;\n        } else {\n            eventCache = ChildrenNode.EMPTY_NODE;\n            eventCacheComplete = false;\n        }\n        const viewCache = newViewCache(new CacheNode(eventCache, eventCacheComplete, false), new CacheNode(serverCache, serverCacheComplete, false));\n        return new View(query, viewCache);\n    }\n    return view;\n}\n/**\r\n * Add an event callback for the specified query.\r\n *\r\n * @param query\r\n * @param eventRegistration\r\n * @param writesCache\r\n * @param serverCache - Complete server cache, if we have it.\r\n * @param serverCacheComplete\r\n * @returns Events to raise.\r\n */ function syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete) {\n    const view = syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete);\n    if (!syncPoint.views.has(query._queryIdentifier)) {\n        syncPoint.views.set(query._queryIdentifier, view);\n    }\n    // This is guaranteed to exist now, we just created anything that was missing\n    viewAddEventRegistration(view, eventRegistration);\n    return viewGetInitialEvents(view, eventRegistration);\n}\n/**\r\n * Remove event callback(s).  Return cancelEvents if a cancelError is specified.\r\n *\r\n * If query is the default query, we'll check all views for the specified eventRegistration.\r\n * If eventRegistration is null, we'll remove all callbacks for the specified view(s).\r\n *\r\n * @param eventRegistration - If null, remove all callbacks.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @returns removed queries and any cancel events\r\n */ function syncPointRemoveEventRegistration(syncPoint, query, eventRegistration, cancelError) {\n    const queryId = query._queryIdentifier;\n    const removed = [];\n    let cancelEvents = [];\n    const hadCompleteView = syncPointHasCompleteView(syncPoint);\n    if (queryId === \"default\") {\n        // When you do ref.off(...), we search all views for the registration to remove.\n        for (const [viewQueryId, view] of syncPoint.views.entries()){\n            cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));\n            if (viewIsEmpty(view)) {\n                syncPoint.views.delete(viewQueryId);\n                // We'll deal with complete views later.\n                if (!view.query._queryParams.loadsAllData()) {\n                    removed.push(view.query);\n                }\n            }\n        }\n    } else {\n        // remove the callback from the specific view.\n        const view = syncPoint.views.get(queryId);\n        if (view) {\n            cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));\n            if (viewIsEmpty(view)) {\n                syncPoint.views.delete(queryId);\n                // We'll deal with complete views later.\n                if (!view.query._queryParams.loadsAllData()) {\n                    removed.push(view.query);\n                }\n            }\n        }\n    }\n    if (hadCompleteView && !syncPointHasCompleteView(syncPoint)) {\n        // We removed our last complete view.\n        removed.push(new (syncPointGetReferenceConstructor())(query._repo, query._path));\n    }\n    return {\n        removed,\n        events: cancelEvents\n    };\n}\nfunction syncPointGetQueryViews(syncPoint) {\n    const result = [];\n    for (const view of syncPoint.views.values()){\n        if (!view.query._queryParams.loadsAllData()) {\n            result.push(view);\n        }\n    }\n    return result;\n}\n/**\r\n * @param path - The path to the desired complete snapshot\r\n * @returns A complete cache, if it exists\r\n */ function syncPointGetCompleteServerCache(syncPoint, path) {\n    let serverCache = null;\n    for (const view of syncPoint.views.values()){\n        serverCache = serverCache || viewGetCompleteServerCache(view, path);\n    }\n    return serverCache;\n}\nfunction syncPointViewForQuery(syncPoint, query) {\n    const params = query._queryParams;\n    if (params.loadsAllData()) {\n        return syncPointGetCompleteView(syncPoint);\n    } else {\n        const queryId = query._queryIdentifier;\n        return syncPoint.views.get(queryId);\n    }\n}\nfunction syncPointViewExistsForQuery(syncPoint, query) {\n    return syncPointViewForQuery(syncPoint, query) != null;\n}\nfunction syncPointHasCompleteView(syncPoint) {\n    return syncPointGetCompleteView(syncPoint) != null;\n}\nfunction syncPointGetCompleteView(syncPoint) {\n    for (const view of syncPoint.views.values()){\n        if (view.query._queryParams.loadsAllData()) {\n            return view;\n        }\n    }\n    return null;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let referenceConstructor;\nfunction syncTreeSetReferenceConstructor(val) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!referenceConstructor, \"__referenceConstructor has already been defined\");\n    referenceConstructor = val;\n}\nfunction syncTreeGetReferenceConstructor() {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(referenceConstructor, \"Reference.ts has not been loaded\");\n    return referenceConstructor;\n}\n/**\r\n * Static tracker for next query tag.\r\n */ let syncTreeNextQueryTag_ = 1;\n/**\r\n * SyncTree is the central class for managing event callback registration, data caching, views\r\n * (query processing), and event generation.  There are typically two SyncTree instances for\r\n * each Repo, one for the normal Firebase data, and one for the .info data.\r\n *\r\n * It has a number of responsibilities, including:\r\n *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).\r\n *  - Applying and caching data changes for user set(), transaction(), and update() calls\r\n *    (applyUserOverwrite(), applyUserMerge()).\r\n *  - Applying and caching data changes for server data changes (applyServerOverwrite(),\r\n *    applyServerMerge()).\r\n *  - Generating user-facing events for server and user changes (all of the apply* methods\r\n *    return the set of events that need to be raised as a result).\r\n *  - Maintaining the appropriate set of server listens to ensure we are always subscribed\r\n *    to the correct set of paths and queries to satisfy the current set of user event\r\n *    callbacks (listens are started/stopped using the provided listenProvider).\r\n *\r\n * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual\r\n * events are returned to the caller rather than raised synchronously.\r\n *\r\n */ class SyncTree {\n    /**\r\n     * @param listenProvider_ - Used by SyncTree to start / stop listening\r\n     *   to server data.\r\n     */ constructor(listenProvider_){\n        this.listenProvider_ = listenProvider_;\n        /**\r\n         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.\r\n         */ this.syncPointTree_ = new ImmutableTree(null);\n        /**\r\n         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).\r\n         */ this.pendingWriteTree_ = newWriteTree();\n        this.tagToQueryMap = new Map();\n        this.queryToTagMap = new Map();\n    }\n}\n/**\r\n * Apply the data changes for a user-generated set() or transaction() call.\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyUserOverwrite(syncTree, path, newData, writeId, visible) {\n    // Record pending write.\n    writeTreeAddOverwrite(syncTree.pendingWriteTree_, path, newData, writeId, visible);\n    if (!visible) {\n        return [];\n    } else {\n        return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceUser(), path, newData));\n    }\n}\n/**\r\n * Apply the data from a user-generated update() call\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyUserMerge(syncTree, path, changedChildren, writeId) {\n    // Record pending merge.\n    writeTreeAddMerge(syncTree.pendingWriteTree_, path, changedChildren, writeId);\n    const changeTree = ImmutableTree.fromObject(changedChildren);\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceUser(), path, changeTree));\n}\n/**\r\n * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().\r\n *\r\n * @param revert - True if the given write failed and needs to be reverted\r\n * @returns Events to raise.\r\n */ function syncTreeAckUserWrite(syncTree, writeId, revert = false) {\n    const write = writeTreeGetWrite(syncTree.pendingWriteTree_, writeId);\n    const needToReevaluate = writeTreeRemoveWrite(syncTree.pendingWriteTree_, writeId);\n    if (!needToReevaluate) {\n        return [];\n    } else {\n        let affectedTree = new ImmutableTree(null);\n        if (write.snap != null) {\n            // overwrite\n            affectedTree = affectedTree.set(newEmptyPath(), true);\n        } else {\n            each(write.children, (pathString)=>{\n                affectedTree = affectedTree.set(new Path(pathString), true);\n            });\n        }\n        return syncTreeApplyOperationToSyncPoints_(syncTree, new AckUserWrite(write.path, affectedTree, revert));\n    }\n}\n/**\r\n * Apply new server data for the specified path..\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyServerOverwrite(syncTree, path, newData) {\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceServer(), path, newData));\n}\n/**\r\n * Apply new server data to be merged in at the specified path.\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyServerMerge(syncTree, path, changedChildren) {\n    const changeTree = ImmutableTree.fromObject(changedChildren);\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceServer(), path, changeTree));\n}\n/**\r\n * Apply a listen complete for a query\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyListenComplete(syncTree, path) {\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new ListenComplete(newOperationSourceServer(), path));\n}\n/**\r\n * Apply a listen complete for a tagged query\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyTaggedListenComplete(syncTree, path, tag) {\n    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);\n    if (queryKey) {\n        const r = syncTreeParseQueryKey_(queryKey);\n        const queryPath = r.path, queryId = r.queryId;\n        const relativePath = newRelativePath(queryPath, path);\n        const op = new ListenComplete(newOperationSourceServerTaggedQuery(queryId), relativePath);\n        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);\n    } else {\n        // We've already removed the query. No big deal, ignore the update\n        return [];\n    }\n}\n/**\r\n * Remove event callback(s).\r\n *\r\n * If query is the default query, we'll check all queries for the specified eventRegistration.\r\n * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.\r\n *\r\n * @param eventRegistration - If null, all callbacks are removed.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @param skipListenerDedup - When performing a `get()`, we don't add any new listeners, so no\r\n *  deduping needs to take place. This flag allows toggling of that behavior\r\n * @returns Cancel events, if cancelError was provided.\r\n */ function syncTreeRemoveEventRegistration(syncTree, query, eventRegistration, cancelError, skipListenerDedup = false) {\n    // Find the syncPoint first. Then deal with whether or not it has matching listeners\n    const path = query._path;\n    const maybeSyncPoint = syncTree.syncPointTree_.get(path);\n    let cancelEvents = [];\n    // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without\n    // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and\n    // not loadsAllData().\n    if (maybeSyncPoint && (query._queryIdentifier === \"default\" || syncPointViewExistsForQuery(maybeSyncPoint, query))) {\n        const removedAndEvents = syncPointRemoveEventRegistration(maybeSyncPoint, query, eventRegistration, cancelError);\n        if (syncPointIsEmpty(maybeSyncPoint)) {\n            syncTree.syncPointTree_ = syncTree.syncPointTree_.remove(path);\n        }\n        const removed = removedAndEvents.removed;\n        cancelEvents = removedAndEvents.events;\n        if (!skipListenerDedup) {\n            /**\r\n             * We may have just removed one of many listeners and can short-circuit this whole process\r\n             * We may also not have removed a default listener, in which case all of the descendant listeners should already be\r\n             * properly set up.\r\n             */ // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of\n            // queryId === 'default'\n            const removingDefault = -1 !== removed.findIndex((query)=>{\n                return query._queryParams.loadsAllData();\n            });\n            const covered = syncTree.syncPointTree_.findOnPath(path, (relativePath, parentSyncPoint)=>syncPointHasCompleteView(parentSyncPoint));\n            if (removingDefault && !covered) {\n                const subtree = syncTree.syncPointTree_.subtree(path);\n                // There are potentially child listeners. Determine what if any listens we need to send before executing the\n                // removal\n                if (!subtree.isEmpty()) {\n                    // We need to fold over our subtree and collect the listeners to send\n                    const newViews = syncTreeCollectDistinctViewsForSubTree_(subtree);\n                    // Ok, we've collected all the listens we need. Set them up.\n                    for(let i = 0; i < newViews.length; ++i){\n                        const view = newViews[i], newQuery = view.query;\n                        const listener = syncTreeCreateListenerForView_(syncTree, view);\n                        syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery), syncTreeTagForQuery(syncTree, newQuery), listener.hashFn, listener.onComplete);\n                    }\n                }\n            // Otherwise there's nothing below us, so nothing we need to start listening on\n            }\n            // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query\n            // The above block has us covered in terms of making sure we're set up on listens lower in the tree.\n            // Also, note that if we have a cancelError, it's already been removed at the provider level.\n            if (!covered && removed.length > 0 && !cancelError) {\n                // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one\n                // default. Otherwise, we need to iterate through and cancel each individual query\n                if (removingDefault) {\n                    // We don't tag default listeners\n                    const defaultTag = null;\n                    syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query), defaultTag);\n                } else {\n                    removed.forEach((queryToRemove)=>{\n                        const tagToRemove = syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));\n                        syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove), tagToRemove);\n                    });\n                }\n            }\n        }\n        // Now, clear all of the tags we're tracking for the removed listens\n        syncTreeRemoveTags_(syncTree, removed);\n    }\n    return cancelEvents;\n}\n/**\r\n * Apply new server data for the specified tagged query.\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyTaggedQueryOverwrite(syncTree, path, snap, tag) {\n    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);\n    if (queryKey != null) {\n        const r = syncTreeParseQueryKey_(queryKey);\n        const queryPath = r.path, queryId = r.queryId;\n        const relativePath = newRelativePath(queryPath, path);\n        const op = new Overwrite(newOperationSourceServerTaggedQuery(queryId), relativePath, snap);\n        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);\n    } else {\n        // Query must have been removed already\n        return [];\n    }\n}\n/**\r\n * Apply server data to be merged in for the specified tagged query.\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyTaggedQueryMerge(syncTree, path, changedChildren, tag) {\n    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);\n    if (queryKey) {\n        const r = syncTreeParseQueryKey_(queryKey);\n        const queryPath = r.path, queryId = r.queryId;\n        const relativePath = newRelativePath(queryPath, path);\n        const changeTree = ImmutableTree.fromObject(changedChildren);\n        const op = new Merge(newOperationSourceServerTaggedQuery(queryId), relativePath, changeTree);\n        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);\n    } else {\n        // We've already removed the query. No big deal, ignore the update\n        return [];\n    }\n}\n/**\r\n * Add an event callback for the specified query.\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeAddEventRegistration(syncTree, query, eventRegistration, skipSetupListener = false) {\n    const path = query._path;\n    let serverCache = null;\n    let foundAncestorDefaultView = false;\n    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\n    // Consider optimizing this once there's a better understanding of what actual behavior will be.\n    syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp)=>{\n        const relativePath = newRelativePath(pathToSyncPoint, path);\n        serverCache = serverCache || syncPointGetCompleteServerCache(sp, relativePath);\n        foundAncestorDefaultView = foundAncestorDefaultView || syncPointHasCompleteView(sp);\n    });\n    let syncPoint = syncTree.syncPointTree_.get(path);\n    if (!syncPoint) {\n        syncPoint = new SyncPoint();\n        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);\n    } else {\n        foundAncestorDefaultView = foundAncestorDefaultView || syncPointHasCompleteView(syncPoint);\n        serverCache = serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\n    }\n    let serverCacheComplete;\n    if (serverCache != null) {\n        serverCacheComplete = true;\n    } else {\n        serverCacheComplete = false;\n        serverCache = ChildrenNode.EMPTY_NODE;\n        const subtree = syncTree.syncPointTree_.subtree(path);\n        subtree.foreachChild((childName, childSyncPoint)=>{\n            const completeCache = syncPointGetCompleteServerCache(childSyncPoint, newEmptyPath());\n            if (completeCache) {\n                serverCache = serverCache.updateImmediateChild(childName, completeCache);\n            }\n        });\n    }\n    const viewAlreadyExists = syncPointViewExistsForQuery(syncPoint, query);\n    if (!viewAlreadyExists && !query._queryParams.loadsAllData()) {\n        // We need to track a tag for this query\n        const queryKey = syncTreeMakeQueryKey_(query);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!syncTree.queryToTagMap.has(queryKey), \"View does not exist, but we have a tag\");\n        const tag = syncTreeGetNextQueryTag_();\n        syncTree.queryToTagMap.set(queryKey, tag);\n        syncTree.tagToQueryMap.set(tag, queryKey);\n    }\n    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, path);\n    let events = syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete);\n    if (!viewAlreadyExists && !foundAncestorDefaultView && !skipSetupListener) {\n        const view = syncPointViewForQuery(syncPoint, query);\n        events = events.concat(syncTreeSetupListener_(syncTree, query, view));\n    }\n    return events;\n}\n/**\r\n * Returns a complete cache, if we have one, of the data at a particular path. If the location does not have a\r\n * listener above it, we will get a false \"null\". This shouldn't be a problem because transactions will always\r\n * have a listener above, and atomic operations would correctly show a jitter of <increment value> ->\r\n *     <incremented total> as the write is applied locally and then acknowledged at the server.\r\n *\r\n * Note: this method will *include* hidden writes from transaction with applyLocally set to false.\r\n *\r\n * @param path - The path to the data we want\r\n * @param writeIdsToExclude - A specific set to be excluded\r\n */ function syncTreeCalcCompleteEventCache(syncTree, path, writeIdsToExclude) {\n    const includeHiddenSets = true;\n    const writeTree = syncTree.pendingWriteTree_;\n    const serverCache = syncTree.syncPointTree_.findOnPath(path, (pathSoFar, syncPoint)=>{\n        const relativePath = newRelativePath(pathSoFar, path);\n        const serverCache = syncPointGetCompleteServerCache(syncPoint, relativePath);\n        if (serverCache) {\n            return serverCache;\n        }\n    });\n    return writeTreeCalcCompleteEventCache(writeTree, path, serverCache, writeIdsToExclude, includeHiddenSets);\n}\nfunction syncTreeGetServerValue(syncTree, query) {\n    const path = query._path;\n    let serverCache = null;\n    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\n    // Consider optimizing this once there's a better understanding of what actual behavior will be.\n    syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp)=>{\n        const relativePath = newRelativePath(pathToSyncPoint, path);\n        serverCache = serverCache || syncPointGetCompleteServerCache(sp, relativePath);\n    });\n    let syncPoint = syncTree.syncPointTree_.get(path);\n    if (!syncPoint) {\n        syncPoint = new SyncPoint();\n        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);\n    } else {\n        serverCache = serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\n    }\n    const serverCacheComplete = serverCache != null;\n    const serverCacheNode = serverCacheComplete ? new CacheNode(serverCache, true, false) : null;\n    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, query._path);\n    const view = syncPointGetView(syncPoint, query, writesCache, serverCacheComplete ? serverCacheNode.getNode() : ChildrenNode.EMPTY_NODE, serverCacheComplete);\n    return viewGetCompleteNode(view);\n}\n/**\r\n * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.\r\n *\r\n * NOTES:\r\n * - Descendant SyncPoints will be visited first (since we raise events depth-first).\r\n *\r\n * - We call applyOperation() on each SyncPoint passing three things:\r\n *   1. A version of the Operation that has been made relative to the SyncPoint location.\r\n *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.\r\n *   3. A snapshot Node with cached server data, if we have it.\r\n *\r\n * - We concatenate all of the events returned by each SyncPoint and return the result.\r\n */ function syncTreeApplyOperationToSyncPoints_(syncTree, operation) {\n    return syncTreeApplyOperationHelper_(operation, syncTree.syncPointTree_, /*serverCache=*/ null, writeTreeChildWrites(syncTree.pendingWriteTree_, newEmptyPath()));\n}\n/**\r\n * Recursive helper for applyOperationToSyncPoints_\r\n */ function syncTreeApplyOperationHelper_(operation, syncPointTree, serverCache, writesCache) {\n    if (pathIsEmpty(operation.path)) {\n        return syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);\n    } else {\n        const syncPoint = syncPointTree.get(newEmptyPath());\n        // If we don't have cached server data, see if we can get it from this SyncPoint.\n        if (serverCache == null && syncPoint != null) {\n            serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\n        }\n        let events = [];\n        const childName = pathGetFront(operation.path);\n        const childOperation = operation.operationForChild(childName);\n        const childTree = syncPointTree.children.get(childName);\n        if (childTree && childOperation) {\n            const childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;\n            const childWritesCache = writeTreeRefChild(writesCache, childName);\n            events = events.concat(syncTreeApplyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));\n        }\n        if (syncPoint) {\n            events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));\n        }\n        return events;\n    }\n}\n/**\r\n * Recursive helper for applyOperationToSyncPoints_\r\n */ function syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache) {\n    const syncPoint = syncPointTree.get(newEmptyPath());\n    // If we don't have cached server data, see if we can get it from this SyncPoint.\n    if (serverCache == null && syncPoint != null) {\n        serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\n    }\n    let events = [];\n    syncPointTree.children.inorderTraversal((childName, childTree)=>{\n        const childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;\n        const childWritesCache = writeTreeRefChild(writesCache, childName);\n        const childOperation = operation.operationForChild(childName);\n        if (childOperation) {\n            events = events.concat(syncTreeApplyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));\n        }\n    });\n    if (syncPoint) {\n        events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));\n    }\n    return events;\n}\nfunction syncTreeCreateListenerForView_(syncTree, view) {\n    const query = view.query;\n    const tag = syncTreeTagForQuery(syncTree, query);\n    return {\n        hashFn: ()=>{\n            const cache = viewGetServerCache(view) || ChildrenNode.EMPTY_NODE;\n            return cache.hash();\n        },\n        onComplete: (status)=>{\n            if (status === \"ok\") {\n                if (tag) {\n                    return syncTreeApplyTaggedListenComplete(syncTree, query._path, tag);\n                } else {\n                    return syncTreeApplyListenComplete(syncTree, query._path);\n                }\n            } else {\n                // If a listen failed, kill all of the listeners here, not just the one that triggered the error.\n                // Note that this may need to be scoped to just this listener if we change permissions on filtered children\n                const error = errorForServerCode(status, query);\n                return syncTreeRemoveEventRegistration(syncTree, query, /*eventRegistration*/ null, error);\n            }\n        }\n    };\n}\n/**\r\n * Return the tag associated with the given query.\r\n */ function syncTreeTagForQuery(syncTree, query) {\n    const queryKey = syncTreeMakeQueryKey_(query);\n    return syncTree.queryToTagMap.get(queryKey);\n}\n/**\r\n * Given a query, computes a \"queryKey\" suitable for use in our queryToTagMap_.\r\n */ function syncTreeMakeQueryKey_(query) {\n    return query._path.toString() + \"$\" + query._queryIdentifier;\n}\n/**\r\n * Return the query associated with the given tag, if we have one\r\n */ function syncTreeQueryKeyForTag_(syncTree, tag) {\n    return syncTree.tagToQueryMap.get(tag);\n}\n/**\r\n * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.\r\n */ function syncTreeParseQueryKey_(queryKey) {\n    const splitIndex = queryKey.indexOf(\"$\");\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(splitIndex !== -1 && splitIndex < queryKey.length - 1, \"Bad queryKey.\");\n    return {\n        queryId: queryKey.substr(splitIndex + 1),\n        path: new Path(queryKey.substr(0, splitIndex))\n    };\n}\n/**\r\n * A helper method to apply tagged operations\r\n */ function syncTreeApplyTaggedOperation_(syncTree, queryPath, operation) {\n    const syncPoint = syncTree.syncPointTree_.get(queryPath);\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(syncPoint, \"Missing sync point for query tag that we're tracking\");\n    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, queryPath);\n    return syncPointApplyOperation(syncPoint, operation, writesCache, null);\n}\n/**\r\n * This collapses multiple unfiltered views into a single view, since we only need a single\r\n * listener for them.\r\n */ function syncTreeCollectDistinctViewsForSubTree_(subtree) {\n    return subtree.fold((relativePath, maybeChildSyncPoint, childMap)=>{\n        if (maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {\n            const completeView = syncPointGetCompleteView(maybeChildSyncPoint);\n            return [\n                completeView\n            ];\n        } else {\n            // No complete view here, flatten any deeper listens into an array\n            let views = [];\n            if (maybeChildSyncPoint) {\n                views = syncPointGetQueryViews(maybeChildSyncPoint);\n            }\n            each(childMap, (_key, childViews)=>{\n                views = views.concat(childViews);\n            });\n            return views;\n        }\n    });\n}\n/**\r\n * Normalizes a query to a query we send the server for listening\r\n *\r\n * @returns The normalized query\r\n */ function syncTreeQueryForListening_(query) {\n    if (query._queryParams.loadsAllData() && !query._queryParams.isDefault()) {\n        // We treat queries that load all data as default queries\n        // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits\n        // from Query\n        return new (syncTreeGetReferenceConstructor())(query._repo, query._path);\n    } else {\n        return query;\n    }\n}\nfunction syncTreeRemoveTags_(syncTree, queries) {\n    for(let j = 0; j < queries.length; ++j){\n        const removedQuery = queries[j];\n        if (!removedQuery._queryParams.loadsAllData()) {\n            // We should have a tag for this\n            const removedQueryKey = syncTreeMakeQueryKey_(removedQuery);\n            const removedQueryTag = syncTree.queryToTagMap.get(removedQueryKey);\n            syncTree.queryToTagMap.delete(removedQueryKey);\n            syncTree.tagToQueryMap.delete(removedQueryTag);\n        }\n    }\n}\n/**\r\n * Static accessor for query tags.\r\n */ function syncTreeGetNextQueryTag_() {\n    return syncTreeNextQueryTag_++;\n}\n/**\r\n * For a given new listen, manage the de-duplication of outstanding subscriptions.\r\n *\r\n * @returns This method can return events to support synchronous data sources\r\n */ function syncTreeSetupListener_(syncTree, query, view) {\n    const path = query._path;\n    const tag = syncTreeTagForQuery(syncTree, query);\n    const listener = syncTreeCreateListenerForView_(syncTree, view);\n    const events = syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query), tag, listener.hashFn, listener.onComplete);\n    const subtree = syncTree.syncPointTree_.subtree(path);\n    // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we\n    // may need to shadow other listens as well.\n    if (tag) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!syncPointHasCompleteView(subtree.value), \"If we're adding a query, it shouldn't be shadowed\");\n    } else {\n        // Shadow everything at or below this location, this is a default listener.\n        const queriesToStop = subtree.fold((relativePath, maybeChildSyncPoint, childMap)=>{\n            if (!pathIsEmpty(relativePath) && maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {\n                return [\n                    syncPointGetCompleteView(maybeChildSyncPoint).query\n                ];\n            } else {\n                // No default listener here, flatten any deeper queries into an array\n                let queries = [];\n                if (maybeChildSyncPoint) {\n                    queries = queries.concat(syncPointGetQueryViews(maybeChildSyncPoint).map((view)=>view.query));\n                }\n                each(childMap, (_key, childQueries)=>{\n                    queries = queries.concat(childQueries);\n                });\n                return queries;\n            }\n        });\n        for(let i = 0; i < queriesToStop.length; ++i){\n            const queryToStop = queriesToStop[i];\n            syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToStop), syncTreeTagForQuery(syncTree, queryToStop));\n        }\n    }\n    return events;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class ExistingValueProvider {\n    constructor(node_){\n        this.node_ = node_;\n    }\n    getImmediateChild(childName) {\n        const child = this.node_.getImmediateChild(childName);\n        return new ExistingValueProvider(child);\n    }\n    node() {\n        return this.node_;\n    }\n}\nclass DeferredValueProvider {\n    constructor(syncTree, path){\n        this.syncTree_ = syncTree;\n        this.path_ = path;\n    }\n    getImmediateChild(childName) {\n        const childPath = pathChild(this.path_, childName);\n        return new DeferredValueProvider(this.syncTree_, childPath);\n    }\n    node() {\n        return syncTreeCalcCompleteEventCache(this.syncTree_, this.path_);\n    }\n}\n/**\r\n * Generate placeholders for deferred values.\r\n */ const generateWithValues = function(values) {\n    values = values || {};\n    values[\"timestamp\"] = values[\"timestamp\"] || new Date().getTime();\n    return values;\n};\n/**\r\n * Value to use when firing local events. When writing server values, fire\r\n * local events with an approximate value, otherwise return value as-is.\r\n */ const resolveDeferredLeafValue = function(value, existingVal, serverValues) {\n    if (!value || typeof value !== \"object\") {\n        return value;\n    }\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(\".sv\" in value, \"Unexpected leaf node or priority contents\");\n    if (typeof value[\".sv\"] === \"string\") {\n        return resolveScalarDeferredValue(value[\".sv\"], existingVal, serverValues);\n    } else if (typeof value[\".sv\"] === \"object\") {\n        return resolveComplexDeferredValue(value[\".sv\"], existingVal);\n    } else {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"Unexpected server value: \" + JSON.stringify(value, null, 2));\n    }\n};\nconst resolveScalarDeferredValue = function(op, existing, serverValues) {\n    switch(op){\n        case \"timestamp\":\n            return serverValues[\"timestamp\"];\n        default:\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"Unexpected server value: \" + op);\n    }\n};\nconst resolveComplexDeferredValue = function(op, existing, unused) {\n    if (!op.hasOwnProperty(\"increment\")) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"Unexpected server value: \" + JSON.stringify(op, null, 2));\n    }\n    const delta = op[\"increment\"];\n    if (typeof delta !== \"number\") {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"Unexpected increment value: \" + delta);\n    }\n    const existingNode = existing.node();\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(existingNode !== null && typeof existingNode !== \"undefined\", \"Expected ChildrenNode.EMPTY_NODE for nulls\");\n    // Incrementing a non-number sets the value to the incremented amount\n    if (!existingNode.isLeafNode()) {\n        return delta;\n    }\n    const leaf = existingNode;\n    const existingVal = leaf.getValue();\n    if (typeof existingVal !== \"number\") {\n        return delta;\n    }\n    // No need to do over/underflow arithmetic here because JS only handles floats under the covers\n    return existingVal + delta;\n};\n/**\r\n * Recursively replace all deferred values and priorities in the tree with the\r\n * specified generated replacement values.\r\n * @param path - path to which write is relative\r\n * @param node - new data written at path\r\n * @param syncTree - current data\r\n */ const resolveDeferredValueTree = function(path, node, syncTree, serverValues) {\n    return resolveDeferredValue(node, new DeferredValueProvider(syncTree, path), serverValues);\n};\n/**\r\n * Recursively replace all deferred values and priorities in the node with the\r\n * specified generated replacement values.  If there are no server values in the node,\r\n * it'll be returned as-is.\r\n */ const resolveDeferredValueSnapshot = function(node, existing, serverValues) {\n    return resolveDeferredValue(node, new ExistingValueProvider(existing), serverValues);\n};\nfunction resolveDeferredValue(node, existingVal, serverValues) {\n    const rawPri = node.getPriority().val();\n    const priority = resolveDeferredLeafValue(rawPri, existingVal.getImmediateChild(\".priority\"), serverValues);\n    let newNode;\n    if (node.isLeafNode()) {\n        const leafNode = node;\n        const value = resolveDeferredLeafValue(leafNode.getValue(), existingVal, serverValues);\n        if (value !== leafNode.getValue() || priority !== leafNode.getPriority().val()) {\n            return new LeafNode(value, nodeFromJSON(priority));\n        } else {\n            return node;\n        }\n    } else {\n        const childrenNode = node;\n        newNode = childrenNode;\n        if (priority !== childrenNode.getPriority().val()) {\n            newNode = newNode.updatePriority(new LeafNode(priority));\n        }\n        childrenNode.forEachChild(PRIORITY_INDEX, (childName, childNode)=>{\n            const newChildNode = resolveDeferredValue(childNode, existingVal.getImmediateChild(childName), serverValues);\n            if (newChildNode !== childNode) {\n                newNode = newNode.updateImmediateChild(childName, newChildNode);\n            }\n        });\n        return newNode;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A light-weight tree, traversable by path.  Nodes can have both values and children.\r\n * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty\r\n * children.\r\n */ class Tree {\n    /**\r\n     * @param name - Optional name of the node.\r\n     * @param parent - Optional parent node.\r\n     * @param node - Optional node to wrap.\r\n     */ constructor(name = \"\", parent = null, node = {\n        children: {},\n        childCount: 0\n    }){\n        this.name = name;\n        this.parent = parent;\n        this.node = node;\n    }\n}\n/**\r\n * Returns a sub-Tree for the given path.\r\n *\r\n * @param pathObj - Path to look up.\r\n * @returns Tree for path.\r\n */ function treeSubTree(tree, pathObj) {\n    // TODO: Require pathObj to be Path?\n    let path = pathObj instanceof Path ? pathObj : new Path(pathObj);\n    let child = tree, next = pathGetFront(path);\n    while(next !== null){\n        const childNode = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(child.node.children, next) || {\n            children: {},\n            childCount: 0\n        };\n        child = new Tree(next, child, childNode);\n        path = pathPopFront(path);\n        next = pathGetFront(path);\n    }\n    return child;\n}\n/**\r\n * Returns the data associated with this tree node.\r\n *\r\n * @returns The data or null if no data exists.\r\n */ function treeGetValue(tree) {\n    return tree.node.value;\n}\n/**\r\n * Sets data to this tree node.\r\n *\r\n * @param value - Value to set.\r\n */ function treeSetValue(tree, value) {\n    tree.node.value = value;\n    treeUpdateParents(tree);\n}\n/**\r\n * @returns Whether the tree has any children.\r\n */ function treeHasChildren(tree) {\n    return tree.node.childCount > 0;\n}\n/**\r\n * @returns Whethe rthe tree is empty (no value or children).\r\n */ function treeIsEmpty(tree) {\n    return treeGetValue(tree) === undefined && !treeHasChildren(tree);\n}\n/**\r\n * Calls action for each child of this tree node.\r\n *\r\n * @param action - Action to be called for each child.\r\n */ function treeForEachChild(tree, action) {\n    each(tree.node.children, (child, childTree)=>{\n        action(new Tree(child, tree, childTree));\n    });\n}\n/**\r\n * Does a depth-first traversal of this node's descendants, calling action for each one.\r\n *\r\n * @param action - Action to be called for each child.\r\n * @param includeSelf - Whether to call action on this node as well. Defaults to\r\n *   false.\r\n * @param childrenFirst - Whether to call action on children before calling it on\r\n *   parent.\r\n */ function treeForEachDescendant(tree, action, includeSelf, childrenFirst) {\n    if (includeSelf && !childrenFirst) {\n        action(tree);\n    }\n    treeForEachChild(tree, (child)=>{\n        treeForEachDescendant(child, action, true, childrenFirst);\n    });\n    if (includeSelf && childrenFirst) {\n        action(tree);\n    }\n}\n/**\r\n * Calls action on each ancestor node.\r\n *\r\n * @param action - Action to be called on each parent; return\r\n *   true to abort.\r\n * @param includeSelf - Whether to call action on this node as well.\r\n * @returns true if the action callback returned true.\r\n */ function treeForEachAncestor(tree, action, includeSelf) {\n    let node = includeSelf ? tree : tree.parent;\n    while(node !== null){\n        if (action(node)) {\n            return true;\n        }\n        node = node.parent;\n    }\n    return false;\n}\n/**\r\n * @returns The path of this tree node, as a Path.\r\n */ function treeGetPath(tree) {\n    return new Path(tree.parent === null ? tree.name : treeGetPath(tree.parent) + \"/\" + tree.name);\n}\n/**\r\n * Adds or removes this child from its parent based on whether it's empty or not.\r\n */ function treeUpdateParents(tree) {\n    if (tree.parent !== null) {\n        treeUpdateChild(tree.parent, tree.name, tree);\n    }\n}\n/**\r\n * Adds or removes the passed child to this tree node, depending on whether it's empty.\r\n *\r\n * @param childName - The name of the child to update.\r\n * @param child - The child to update.\r\n */ function treeUpdateChild(tree, childName, child) {\n    const childEmpty = treeIsEmpty(child);\n    const childExists = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(tree.node.children, childName);\n    if (childEmpty && childExists) {\n        delete tree.node.children[childName];\n        tree.node.childCount--;\n        treeUpdateParents(tree);\n    } else if (!childEmpty && !childExists) {\n        tree.node.children[childName] = child.node;\n        tree.node.childCount++;\n        treeUpdateParents(tree);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * True for invalid Firebase keys\r\n */ const INVALID_KEY_REGEX_ = /[\\[\\].#$\\/\\u0000-\\u001F\\u007F]/;\n/**\r\n * True for invalid Firebase paths.\r\n * Allows '/' in paths.\r\n */ const INVALID_PATH_REGEX_ = /[\\[\\].#$\\u0000-\\u001F\\u007F]/;\n/**\r\n * Maximum number of characters to allow in leaf value\r\n */ const MAX_LEAF_SIZE_ = 10 * 1024 * 1024;\nconst isValidKey = function(key) {\n    return typeof key === \"string\" && key.length !== 0 && !INVALID_KEY_REGEX_.test(key);\n};\nconst isValidPathString = function(pathString) {\n    return typeof pathString === \"string\" && pathString.length !== 0 && !INVALID_PATH_REGEX_.test(pathString);\n};\nconst isValidRootPathString = function(pathString) {\n    if (pathString) {\n        // Allow '/.info/' at the beginning.\n        pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, \"/\");\n    }\n    return isValidPathString(pathString);\n};\nconst isValidPriority = function(priority) {\n    return priority === null || typeof priority === \"string\" || typeof priority === \"number\" && !isInvalidJSONNumber(priority) || priority && typeof priority === \"object\" && // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(priority, \".sv\");\n};\n/**\r\n * Pre-validate a datum passed as an argument to Firebase function.\r\n */ const validateFirebaseDataArg = function(fnName, value, path, optional) {\n    if (optional && value === undefined) {\n        return;\n    }\n    validateFirebaseData((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, \"value\"), value, path);\n};\n/**\r\n * Validate a data object client-side before sending to server.\r\n */ const validateFirebaseData = function(errorPrefix, data, path_) {\n    const path = path_ instanceof Path ? new ValidationPath(path_, errorPrefix) : path_;\n    if (data === undefined) {\n        throw new Error(errorPrefix + \"contains undefined \" + validationPathToErrorString(path));\n    }\n    if (typeof data === \"function\") {\n        throw new Error(errorPrefix + \"contains a function \" + validationPathToErrorString(path) + \" with contents = \" + data.toString());\n    }\n    if (isInvalidJSONNumber(data)) {\n        throw new Error(errorPrefix + \"contains \" + data.toString() + \" \" + validationPathToErrorString(path));\n    }\n    // Check max leaf size, but try to avoid the utf8 conversion if we can.\n    if (typeof data === \"string\" && data.length > MAX_LEAF_SIZE_ / 3 && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringLength)(data) > MAX_LEAF_SIZE_) {\n        throw new Error(errorPrefix + \"contains a string greater than \" + MAX_LEAF_SIZE_ + \" utf8 bytes \" + validationPathToErrorString(path) + \" ('\" + data.substring(0, 50) + \"...')\");\n    }\n    // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON\n    // to save extra walking of large objects.\n    if (data && typeof data === \"object\") {\n        let hasDotValue = false;\n        let hasActualChild = false;\n        each(data, (key, value)=>{\n            if (key === \".value\") {\n                hasDotValue = true;\n            } else if (key !== \".priority\" && key !== \".sv\") {\n                hasActualChild = true;\n                if (!isValidKey(key)) {\n                    throw new Error(errorPrefix + \" contains an invalid key (\" + key + \") \" + validationPathToErrorString(path) + \".  Keys must be non-empty strings \" + 'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\n                }\n            }\n            validationPathPush(path, key);\n            validateFirebaseData(errorPrefix, value, path);\n            validationPathPop(path);\n        });\n        if (hasDotValue && hasActualChild) {\n            throw new Error(errorPrefix + ' contains \".value\" child ' + validationPathToErrorString(path) + \" in addition to actual children.\");\n        }\n    }\n};\n/**\r\n * Pre-validate paths passed in the firebase function.\r\n */ const validateFirebaseMergePaths = function(errorPrefix, mergePaths) {\n    let i, curPath;\n    for(i = 0; i < mergePaths.length; i++){\n        curPath = mergePaths[i];\n        const keys = pathSlice(curPath);\n        for(let j = 0; j < keys.length; j++){\n            if (keys[j] === \".priority\" && j === keys.length - 1) ;\n            else if (!isValidKey(keys[j])) {\n                throw new Error(errorPrefix + \"contains an invalid key (\" + keys[j] + \") in path \" + curPath.toString() + \". Keys must be non-empty strings \" + 'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\n            }\n        }\n    }\n    // Check that update keys are not descendants of each other.\n    // We rely on the property that sorting guarantees that ancestors come\n    // right before descendants.\n    mergePaths.sort(pathCompare);\n    let prevPath = null;\n    for(i = 0; i < mergePaths.length; i++){\n        curPath = mergePaths[i];\n        if (prevPath !== null && pathContains(prevPath, curPath)) {\n            throw new Error(errorPrefix + \"contains a path \" + prevPath.toString() + \" that is ancestor of another path \" + curPath.toString());\n        }\n        prevPath = curPath;\n    }\n};\n/**\r\n * pre-validate an object passed as an argument to firebase function (\r\n * must be an object - e.g. for firebase.update()).\r\n */ const validateFirebaseMergeDataArg = function(fnName, data, path, optional) {\n    if (optional && data === undefined) {\n        return;\n    }\n    const errorPrefix$1 = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, \"values\");\n    if (!(data && typeof data === \"object\") || Array.isArray(data)) {\n        throw new Error(errorPrefix$1 + \" must be an object containing the children to replace.\");\n    }\n    const mergePaths = [];\n    each(data, (key, value)=>{\n        const curPath = new Path(key);\n        validateFirebaseData(errorPrefix$1, value, pathChild(path, curPath));\n        if (pathGetBack(curPath) === \".priority\") {\n            if (!isValidPriority(value)) {\n                throw new Error(errorPrefix$1 + \"contains an invalid value for '\" + curPath.toString() + \"', which must be a valid \" + \"Firebase priority (a string, finite number, server value, or null).\");\n            }\n        }\n        mergePaths.push(curPath);\n    });\n    validateFirebaseMergePaths(errorPrefix$1, mergePaths);\n};\nconst validatePriority = function(fnName, priority, optional) {\n    if (optional && priority === undefined) {\n        return;\n    }\n    if (isInvalidJSONNumber(priority)) {\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, \"priority\") + \"is \" + priority.toString() + \", but must be a valid Firebase priority (a string, finite number, \" + \"server value, or null).\");\n    }\n    // Special case to allow importing data with a .sv.\n    if (!isValidPriority(priority)) {\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, \"priority\") + \"must be a valid Firebase priority \" + \"(a string, finite number, server value, or null).\");\n    }\n};\nconst validateKey = function(fnName, argumentName, key, optional) {\n    if (optional && key === undefined) {\n        return;\n    }\n    if (!isValidKey(key)) {\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, argumentName) + 'was an invalid key = \"' + key + '\".  Firebase keys must be non-empty strings and ' + 'can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\").');\n    }\n};\n/**\r\n * @internal\r\n */ const validatePathString = function(fnName, argumentName, pathString, optional) {\n    if (optional && pathString === undefined) {\n        return;\n    }\n    if (!isValidPathString(pathString)) {\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, argumentName) + 'was an invalid path = \"' + pathString + '\". Paths must be non-empty strings and ' + 'can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\"');\n    }\n};\nconst validateRootPathString = function(fnName, argumentName, pathString, optional) {\n    if (pathString) {\n        // Allow '/.info/' at the beginning.\n        pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, \"/\");\n    }\n    validatePathString(fnName, argumentName, pathString, optional);\n};\n/**\r\n * @internal\r\n */ const validateWritablePath = function(fnName, path) {\n    if (pathGetFront(path) === \".info\") {\n        throw new Error(fnName + \" failed = Can't modify data under /.info/\");\n    }\n};\nconst validateUrl = function(fnName, parsedUrl) {\n    // TODO = Validate server better.\n    const pathString = parsedUrl.path.toString();\n    if (!(typeof parsedUrl.repoInfo.host === \"string\") || parsedUrl.repoInfo.host.length === 0 || !isValidKey(parsedUrl.repoInfo.namespace) && parsedUrl.repoInfo.host.split(\":\")[0] !== \"localhost\" || pathString.length !== 0 && !isValidRootPathString(pathString)) {\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, \"url\") + \"must be a valid firebase URL and \" + 'the path can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\".');\n    }\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The event queue serves a few purposes:\r\n * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more\r\n *    events being queued.\r\n * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,\r\n *    raiseQueuedEvents() is called again, the \"inner\" call will pick up raising events where the \"outer\" call\r\n *    left off, ensuring that the events are still raised synchronously and in order.\r\n * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued\r\n *    events are raised synchronously.\r\n *\r\n * NOTE: This can all go away if/when we move to async events.\r\n *\r\n */ class EventQueue {\n    constructor(){\n        this.eventLists_ = [];\n        /**\r\n         * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.\r\n         */ this.recursionDepth_ = 0;\n    }\n}\n/**\r\n * @param eventDataList - The new events to queue.\r\n */ function eventQueueQueueEvents(eventQueue, eventDataList) {\n    // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.\n    let currList = null;\n    for(let i = 0; i < eventDataList.length; i++){\n        const data = eventDataList[i];\n        const path = data.getPath();\n        if (currList !== null && !pathEquals(path, currList.path)) {\n            eventQueue.eventLists_.push(currList);\n            currList = null;\n        }\n        if (currList === null) {\n            currList = {\n                events: [],\n                path\n            };\n        }\n        currList.events.push(data);\n    }\n    if (currList) {\n        eventQueue.eventLists_.push(currList);\n    }\n}\n/**\r\n * Queues the specified events and synchronously raises all events (including previously queued ones)\r\n * for the specified path.\r\n *\r\n * It is assumed that the new events are all for the specified path.\r\n *\r\n * @param path - The path to raise events for.\r\n * @param eventDataList - The new events to raise.\r\n */ function eventQueueRaiseEventsAtPath(eventQueue, path, eventDataList) {\n    eventQueueQueueEvents(eventQueue, eventDataList);\n    eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, (eventPath)=>pathEquals(eventPath, path));\n}\n/**\r\n * Queues the specified events and synchronously raises all events (including previously queued ones) for\r\n * locations related to the specified change path (i.e. all ancestors and descendants).\r\n *\r\n * It is assumed that the new events are all related (ancestor or descendant) to the specified path.\r\n *\r\n * @param changedPath - The path to raise events for.\r\n * @param eventDataList - The events to raise\r\n */ function eventQueueRaiseEventsForChangedPath(eventQueue, changedPath, eventDataList) {\n    eventQueueQueueEvents(eventQueue, eventDataList);\n    eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, (eventPath)=>pathContains(eventPath, changedPath) || pathContains(changedPath, eventPath));\n}\nfunction eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, predicate) {\n    eventQueue.recursionDepth_++;\n    let sentAll = true;\n    for(let i = 0; i < eventQueue.eventLists_.length; i++){\n        const eventList = eventQueue.eventLists_[i];\n        if (eventList) {\n            const eventPath = eventList.path;\n            if (predicate(eventPath)) {\n                eventListRaise(eventQueue.eventLists_[i]);\n                eventQueue.eventLists_[i] = null;\n            } else {\n                sentAll = false;\n            }\n        }\n    }\n    if (sentAll) {\n        eventQueue.eventLists_ = [];\n    }\n    eventQueue.recursionDepth_--;\n}\n/**\r\n * Iterates through the list and raises each event\r\n */ function eventListRaise(eventList) {\n    for(let i = 0; i < eventList.events.length; i++){\n        const eventData = eventList.events[i];\n        if (eventData !== null) {\n            eventList.events[i] = null;\n            const eventFn = eventData.getEventRunner();\n            if (logger) {\n                log(\"event: \" + eventData.toString());\n            }\n            exceptionGuard(eventFn);\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const INTERRUPT_REASON = \"repo_interrupt\";\n/**\r\n * If a transaction does not succeed after 25 retries, we abort it. Among other\r\n * things this ensure that if there's ever a bug causing a mismatch between\r\n * client / server hashes for some data, we won't retry indefinitely.\r\n */ const MAX_TRANSACTION_RETRIES = 25;\n/**\r\n * A connection to a single data repository.\r\n */ class Repo {\n    constructor(repoInfo_, forceRestClient_, authTokenProvider_, appCheckProvider_){\n        this.repoInfo_ = repoInfo_;\n        this.forceRestClient_ = forceRestClient_;\n        this.authTokenProvider_ = authTokenProvider_;\n        this.appCheckProvider_ = appCheckProvider_;\n        this.dataUpdateCount = 0;\n        this.statsListener_ = null;\n        this.eventQueue_ = new EventQueue();\n        this.nextWriteId_ = 1;\n        this.interceptServerDataCallback_ = null;\n        /** A list of data pieces and paths to be set when this client disconnects. */ this.onDisconnect_ = newSparseSnapshotTree();\n        /** Stores queues of outstanding transactions for Firebase locations. */ this.transactionQueueTree_ = new Tree();\n        // TODO: This should be @private but it's used by test_access.js and internal.js\n        this.persistentConnection_ = null;\n        // This key is intentionally not updated if RepoInfo is later changed or replaced\n        this.key = this.repoInfo_.toURLString();\n    }\n    /**\r\n     * @returns The URL corresponding to the root of this Firebase.\r\n     */ toString() {\n        return (this.repoInfo_.secure ? \"https://\" : \"http://\") + this.repoInfo_.host;\n    }\n}\nfunction repoStart(repo, appId, authOverride) {\n    repo.stats_ = statsManagerGetCollection(repo.repoInfo_);\n    if (repo.forceRestClient_ || beingCrawled()) {\n        repo.server_ = new ReadonlyRestClient(repo.repoInfo_, (pathString, data, isMerge, tag)=>{\n            repoOnDataUpdate(repo, pathString, data, isMerge, tag);\n        }, repo.authTokenProvider_, repo.appCheckProvider_);\n        // Minor hack: Fire onConnect immediately, since there's no actual connection.\n        setTimeout(()=>repoOnConnectStatus(repo, /* connectStatus= */ true), 0);\n    } else {\n        // Validate authOverride\n        if (typeof authOverride !== \"undefined\" && authOverride !== null) {\n            if (typeof authOverride !== \"object\") {\n                throw new Error(\"Only objects are supported for option databaseAuthVariableOverride\");\n            }\n            try {\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(authOverride);\n            } catch (e) {\n                throw new Error(\"Invalid authOverride provided: \" + e);\n            }\n        }\n        repo.persistentConnection_ = new PersistentConnection(repo.repoInfo_, appId, (pathString, data, isMerge, tag)=>{\n            repoOnDataUpdate(repo, pathString, data, isMerge, tag);\n        }, (connectStatus)=>{\n            repoOnConnectStatus(repo, connectStatus);\n        }, (updates)=>{\n            repoOnServerInfoUpdate(repo, updates);\n        }, repo.authTokenProvider_, repo.appCheckProvider_, authOverride);\n        repo.server_ = repo.persistentConnection_;\n    }\n    repo.authTokenProvider_.addTokenChangeListener((token)=>{\n        repo.server_.refreshAuthToken(token);\n    });\n    repo.appCheckProvider_.addTokenChangeListener((result)=>{\n        repo.server_.refreshAppCheckToken(result.token);\n    });\n    // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),\n    // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.\n    repo.statsReporter_ = statsManagerGetOrCreateReporter(repo.repoInfo_, ()=>new StatsReporter(repo.stats_, repo.server_));\n    // Used for .info.\n    repo.infoData_ = new SnapshotHolder();\n    repo.infoSyncTree_ = new SyncTree({\n        startListening: (query, tag, currentHashFn, onComplete)=>{\n            let infoEvents = [];\n            const node = repo.infoData_.getNode(query._path);\n            // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events\n            // on initial data...\n            if (!node.isEmpty()) {\n                infoEvents = syncTreeApplyServerOverwrite(repo.infoSyncTree_, query._path, node);\n                setTimeout(()=>{\n                    onComplete(\"ok\");\n                }, 0);\n            }\n            return infoEvents;\n        },\n        stopListening: ()=>{}\n    });\n    repoUpdateInfo(repo, \"connected\", false);\n    repo.serverSyncTree_ = new SyncTree({\n        startListening: (query, tag, currentHashFn, onComplete)=>{\n            repo.server_.listen(query, currentHashFn, tag, (status, data)=>{\n                const events = onComplete(status, data);\n                eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events);\n            });\n            // No synchronous events for network-backed sync trees\n            return [];\n        },\n        stopListening: (query, tag)=>{\n            repo.server_.unlisten(query, tag);\n        }\n    });\n}\n/**\r\n * @returns The time in milliseconds, taking the server offset into account if we have one.\r\n */ function repoServerTime(repo) {\n    const offsetNode = repo.infoData_.getNode(new Path(\".info/serverTimeOffset\"));\n    const offset = offsetNode.val() || 0;\n    return new Date().getTime() + offset;\n}\n/**\r\n * Generate ServerValues using some variables from the repo object.\r\n */ function repoGenerateServerValues(repo) {\n    return generateWithValues({\n        timestamp: repoServerTime(repo)\n    });\n}\n/**\r\n * Called by realtime when we get new messages from the server.\r\n */ function repoOnDataUpdate(repo, pathString, data, isMerge, tag) {\n    // For testing.\n    repo.dataUpdateCount++;\n    const path = new Path(pathString);\n    data = repo.interceptServerDataCallback_ ? repo.interceptServerDataCallback_(pathString, data) : data;\n    let events = [];\n    if (tag) {\n        if (isMerge) {\n            const taggedChildren = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.map)(data, (raw)=>nodeFromJSON(raw));\n            events = syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_, path, taggedChildren, tag);\n        } else {\n            const taggedSnap = nodeFromJSON(data);\n            events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, path, taggedSnap, tag);\n        }\n    } else if (isMerge) {\n        const changedChildren = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.map)(data, (raw)=>nodeFromJSON(raw));\n        events = syncTreeApplyServerMerge(repo.serverSyncTree_, path, changedChildren);\n    } else {\n        const snap = nodeFromJSON(data);\n        events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap);\n    }\n    let affectedPath = path;\n    if (events.length > 0) {\n        // Since we have a listener outstanding for each transaction, receiving any events\n        // is a proxy for some change having occurred.\n        affectedPath = repoRerunTransactions(repo, path);\n    }\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, events);\n}\nfunction repoOnConnectStatus(repo, connectStatus) {\n    repoUpdateInfo(repo, \"connected\", connectStatus);\n    if (connectStatus === false) {\n        repoRunOnDisconnectEvents(repo);\n    }\n}\nfunction repoOnServerInfoUpdate(repo, updates) {\n    each(updates, (key, value)=>{\n        repoUpdateInfo(repo, key, value);\n    });\n}\nfunction repoUpdateInfo(repo, pathString, value) {\n    const path = new Path(\"/.info/\" + pathString);\n    const newNode = nodeFromJSON(value);\n    repo.infoData_.updateSnapshot(path, newNode);\n    const events = syncTreeApplyServerOverwrite(repo.infoSyncTree_, path, newNode);\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\n}\nfunction repoGetNextWriteId(repo) {\n    return repo.nextWriteId_++;\n}\n/**\r\n * The purpose of `getValue` is to return the latest known value\r\n * satisfying `query`.\r\n *\r\n * This method will first check for in-memory cached values\r\n * belonging to active listeners. If they are found, such values\r\n * are considered to be the most up-to-date.\r\n *\r\n * If the client is not connected, this method will wait until the\r\n *  repo has established a connection and then request the value for `query`.\r\n * If the client is not able to retrieve the query result for another reason,\r\n * it reports an error.\r\n *\r\n * @param query - The query to surface a value for.\r\n */ function repoGetValue(repo, query, eventRegistration) {\n    // Only active queries are cached. There is no persisted cache.\n    const cached = syncTreeGetServerValue(repo.serverSyncTree_, query);\n    if (cached != null) {\n        return Promise.resolve(cached);\n    }\n    return repo.server_.get(query).then((payload)=>{\n        const node = nodeFromJSON(payload).withIndex(query._queryParams.getIndex());\n        /**\r\n         * Below we simulate the actions of an `onlyOnce` `onValue()` event where:\r\n         * Add an event registration,\r\n         * Update data at the path,\r\n         * Raise any events,\r\n         * Cleanup the SyncTree\r\n         */ syncTreeAddEventRegistration(repo.serverSyncTree_, query, eventRegistration, true);\n        let events;\n        if (query._queryParams.loadsAllData()) {\n            events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, query._path, node);\n        } else {\n            const tag = syncTreeTagForQuery(repo.serverSyncTree_, query);\n            events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, query._path, node, tag);\n        }\n        /*\r\n         * We need to raise events in the scenario where `get()` is called at a parent path, and\r\n         * while the `get()` is pending, `onValue` is called at a child location. While get() is waiting\r\n         * for the data, `onValue` will register a new event. Then, get() will come back, and update the syncTree\r\n         * and its corresponding serverCache, including the child location where `onValue` is called. Then,\r\n         * `onValue` will receive the event from the server, but look at the syncTree and see that the data received\r\n         * from the server is already at the SyncPoint, and so the `onValue` callback will never get fired.\r\n         * Calling `eventQueueRaiseEventsForChangedPath()` is the correct way to propagate the events and\r\n         * ensure the corresponding child events will get fired.\r\n         */ eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events);\n        syncTreeRemoveEventRegistration(repo.serverSyncTree_, query, eventRegistration, null, true);\n        return node;\n    }, (err)=>{\n        repoLog(repo, \"get for query \" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(query) + \" failed: \" + err);\n        return Promise.reject(new Error(err));\n    });\n}\nfunction repoSetWithPriority(repo, path, newVal, newPriority, onComplete) {\n    repoLog(repo, \"set\", {\n        path: path.toString(),\n        value: newVal,\n        priority: newPriority\n    });\n    // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or\n    // (b) store unresolved paths on JSON parse\n    const serverValues = repoGenerateServerValues(repo);\n    const newNodeUnresolved = nodeFromJSON(newVal, newPriority);\n    const existing = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path);\n    const newNode = resolveDeferredValueSnapshot(newNodeUnresolved, existing, serverValues);\n    const writeId = repoGetNextWriteId(repo);\n    const events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, writeId, true);\n    eventQueueQueueEvents(repo.eventQueue_, events);\n    repo.server_.put(path.toString(), newNodeUnresolved.val(/*export=*/ true), (status, errorReason)=>{\n        const success = status === \"ok\";\n        if (!success) {\n            warn(\"set at \" + path + \" failed: \" + status);\n        }\n        const clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, clearEvents);\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\n    });\n    const affectedPath = repoAbortTransactions(repo, path);\n    repoRerunTransactions(repo, affectedPath);\n    // We queued the events above, so just flush the queue here\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, []);\n}\nfunction repoUpdate(repo, path, childrenToMerge, onComplete) {\n    repoLog(repo, \"update\", {\n        path: path.toString(),\n        value: childrenToMerge\n    });\n    // Start with our existing data and merge each child into it.\n    let empty = true;\n    const serverValues = repoGenerateServerValues(repo);\n    const changedChildren = {};\n    each(childrenToMerge, (changedKey, changedValue)=>{\n        empty = false;\n        changedChildren[changedKey] = resolveDeferredValueTree(pathChild(path, changedKey), nodeFromJSON(changedValue), repo.serverSyncTree_, serverValues);\n    });\n    if (!empty) {\n        const writeId = repoGetNextWriteId(repo);\n        const events = syncTreeApplyUserMerge(repo.serverSyncTree_, path, changedChildren, writeId);\n        eventQueueQueueEvents(repo.eventQueue_, events);\n        repo.server_.merge(path.toString(), childrenToMerge, (status, errorReason)=>{\n            const success = status === \"ok\";\n            if (!success) {\n                warn(\"update at \" + path + \" failed: \" + status);\n            }\n            const clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);\n            const affectedPath = clearEvents.length > 0 ? repoRerunTransactions(repo, path) : path;\n            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, clearEvents);\n            repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\n        });\n        each(childrenToMerge, (changedPath)=>{\n            const affectedPath = repoAbortTransactions(repo, pathChild(path, changedPath));\n            repoRerunTransactions(repo, affectedPath);\n        });\n        // We queued the events above, so just flush the queue here\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, []);\n    } else {\n        log(\"update() called with empty data.  Don't do anything.\");\n        repoCallOnCompleteCallback(repo, onComplete, \"ok\", undefined);\n    }\n}\n/**\r\n * Applies all of the changes stored up in the onDisconnect_ tree.\r\n */ function repoRunOnDisconnectEvents(repo) {\n    repoLog(repo, \"onDisconnectEvents\");\n    const serverValues = repoGenerateServerValues(repo);\n    const resolvedOnDisconnectTree = newSparseSnapshotTree();\n    sparseSnapshotTreeForEachTree(repo.onDisconnect_, newEmptyPath(), (path, node)=>{\n        const resolved = resolveDeferredValueTree(path, node, repo.serverSyncTree_, serverValues);\n        sparseSnapshotTreeRemember(resolvedOnDisconnectTree, path, resolved);\n    });\n    let events = [];\n    sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree, newEmptyPath(), (path, snap)=>{\n        events = events.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap));\n        const affectedPath = repoAbortTransactions(repo, path);\n        repoRerunTransactions(repo, affectedPath);\n    });\n    repo.onDisconnect_ = newSparseSnapshotTree();\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, newEmptyPath(), events);\n}\nfunction repoOnDisconnectCancel(repo, path, onComplete) {\n    repo.server_.onDisconnectCancel(path.toString(), (status, errorReason)=>{\n        if (status === \"ok\") {\n            sparseSnapshotTreeForget(repo.onDisconnect_, path);\n        }\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\n    });\n}\nfunction repoOnDisconnectSet(repo, path, value, onComplete) {\n    const newNode = nodeFromJSON(value);\n    repo.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), (status, errorReason)=>{\n        if (status === \"ok\") {\n            sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);\n        }\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\n    });\n}\nfunction repoOnDisconnectSetWithPriority(repo, path, value, priority, onComplete) {\n    const newNode = nodeFromJSON(value, priority);\n    repo.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), (status, errorReason)=>{\n        if (status === \"ok\") {\n            sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);\n        }\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\n    });\n}\nfunction repoOnDisconnectUpdate(repo, path, childrenToMerge, onComplete) {\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(childrenToMerge)) {\n        log(\"onDisconnect().update() called with empty data.  Don't do anything.\");\n        repoCallOnCompleteCallback(repo, onComplete, \"ok\", undefined);\n        return;\n    }\n    repo.server_.onDisconnectMerge(path.toString(), childrenToMerge, (status, errorReason)=>{\n        if (status === \"ok\") {\n            each(childrenToMerge, (childName, childNode)=>{\n                const newChildNode = nodeFromJSON(childNode);\n                sparseSnapshotTreeRemember(repo.onDisconnect_, pathChild(path, childName), newChildNode);\n            });\n        }\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\n    });\n}\nfunction repoAddEventCallbackForQuery(repo, query, eventRegistration) {\n    let events;\n    if (pathGetFront(query._path) === \".info\") {\n        events = syncTreeAddEventRegistration(repo.infoSyncTree_, query, eventRegistration);\n    } else {\n        events = syncTreeAddEventRegistration(repo.serverSyncTree_, query, eventRegistration);\n    }\n    eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);\n}\nfunction repoRemoveEventCallbackForQuery(repo, query, eventRegistration) {\n    // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof\n    // a little bit by handling the return values anyways.\n    let events;\n    if (pathGetFront(query._path) === \".info\") {\n        events = syncTreeRemoveEventRegistration(repo.infoSyncTree_, query, eventRegistration);\n    } else {\n        events = syncTreeRemoveEventRegistration(repo.serverSyncTree_, query, eventRegistration);\n    }\n    eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);\n}\nfunction repoInterrupt(repo) {\n    if (repo.persistentConnection_) {\n        repo.persistentConnection_.interrupt(INTERRUPT_REASON);\n    }\n}\nfunction repoResume(repo) {\n    if (repo.persistentConnection_) {\n        repo.persistentConnection_.resume(INTERRUPT_REASON);\n    }\n}\nfunction repoLog(repo, ...varArgs) {\n    let prefix = \"\";\n    if (repo.persistentConnection_) {\n        prefix = repo.persistentConnection_.id + \":\";\n    }\n    log(prefix, ...varArgs);\n}\nfunction repoCallOnCompleteCallback(repo, callback, status, errorReason) {\n    if (callback) {\n        exceptionGuard(()=>{\n            if (status === \"ok\") {\n                callback(null);\n            } else {\n                const code = (status || \"error\").toUpperCase();\n                let message = code;\n                if (errorReason) {\n                    message += \": \" + errorReason;\n                }\n                const error = new Error(message);\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                error.code = code;\n                callback(error);\n            }\n        });\n    }\n}\n/**\r\n * Creates a new transaction, adds it to the transactions we're tracking, and\r\n * sends it to the server if possible.\r\n *\r\n * @param path - Path at which to do transaction.\r\n * @param transactionUpdate - Update callback.\r\n * @param onComplete - Completion callback.\r\n * @param unwatcher - Function that will be called when the transaction no longer\r\n * need data updates for `path`.\r\n * @param applyLocally - Whether or not to make intermediate results visible\r\n */ function repoStartTransaction(repo, path, transactionUpdate, onComplete, unwatcher, applyLocally) {\n    repoLog(repo, \"transaction on \" + path);\n    // Initialize transaction.\n    const transaction = {\n        path,\n        update: transactionUpdate,\n        onComplete,\n        // One of TransactionStatus enums.\n        status: null,\n        // Used when combining transactions at different locations to figure out\n        // which one goes first.\n        order: LUIDGenerator(),\n        // Whether to raise local events for this transaction.\n        applyLocally,\n        // Count of how many times we've retried the transaction.\n        retryCount: 0,\n        // Function to call to clean up our .on() listener.\n        unwatcher,\n        // Stores why a transaction was aborted.\n        abortReason: null,\n        currentWriteId: null,\n        currentInputSnapshot: null,\n        currentOutputSnapshotRaw: null,\n        currentOutputSnapshotResolved: null\n    };\n    // Run transaction initially.\n    const currentState = repoGetLatestState(repo, path, undefined);\n    transaction.currentInputSnapshot = currentState;\n    const newVal = transaction.update(currentState.val());\n    if (newVal === undefined) {\n        // Abort transaction.\n        transaction.unwatcher();\n        transaction.currentOutputSnapshotRaw = null;\n        transaction.currentOutputSnapshotResolved = null;\n        if (transaction.onComplete) {\n            transaction.onComplete(null, false, transaction.currentInputSnapshot);\n        }\n    } else {\n        validateFirebaseData(\"transaction failed: Data returned \", newVal, transaction.path);\n        // Mark as run and add to our queue.\n        transaction.status = 0 /* TransactionStatus.RUN */ ;\n        const queueNode = treeSubTree(repo.transactionQueueTree_, path);\n        const nodeQueue = treeGetValue(queueNode) || [];\n        nodeQueue.push(transaction);\n        treeSetValue(queueNode, nodeQueue);\n        // Update visibleData and raise events\n        // Note: We intentionally raise events after updating all of our\n        // transaction state, since the user could start new transactions from the\n        // event callbacks.\n        let priorityForNode;\n        if (typeof newVal === \"object\" && newVal !== null && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(newVal, \".priority\")) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            priorityForNode = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(newVal, \".priority\");\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(isValidPriority(priorityForNode), \"Invalid priority returned by transaction. \" + \"Priority must be a valid string, finite number, server value, or null.\");\n        } else {\n            const currentNode = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path) || ChildrenNode.EMPTY_NODE;\n            priorityForNode = currentNode.getPriority().val();\n        }\n        const serverValues = repoGenerateServerValues(repo);\n        const newNodeUnresolved = nodeFromJSON(newVal, priorityForNode);\n        const newNode = resolveDeferredValueSnapshot(newNodeUnresolved, currentState, serverValues);\n        transaction.currentOutputSnapshotRaw = newNodeUnresolved;\n        transaction.currentOutputSnapshotResolved = newNode;\n        transaction.currentWriteId = repoGetNextWriteId(repo);\n        const events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, transaction.currentWriteId, transaction.applyLocally);\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\n        repoSendReadyTransactions(repo, repo.transactionQueueTree_);\n    }\n}\n/**\r\n * @param excludeSets - A specific set to exclude\r\n */ function repoGetLatestState(repo, path, excludeSets) {\n    return syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path, excludeSets) || ChildrenNode.EMPTY_NODE;\n}\n/**\r\n * Sends any already-run transactions that aren't waiting for outstanding\r\n * transactions to complete.\r\n *\r\n * Externally it's called with no arguments, but it calls itself recursively\r\n * with a particular transactionQueueTree node to recurse through the tree.\r\n *\r\n * @param node - transactionQueueTree node to start at.\r\n */ function repoSendReadyTransactions(repo, node = repo.transactionQueueTree_) {\n    // Before recursing, make sure any completed transactions are removed.\n    if (!node) {\n        repoPruneCompletedTransactionsBelowNode(repo, node);\n    }\n    if (treeGetValue(node)) {\n        const queue = repoBuildTransactionQueue(repo, node);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(queue.length > 0, \"Sending zero length transaction queue\");\n        const allRun = queue.every((transaction)=>transaction.status === 0 /* TransactionStatus.RUN */ );\n        // If they're all run (and not sent), we can send them.  Else, we must wait.\n        if (allRun) {\n            repoSendTransactionQueue(repo, treeGetPath(node), queue);\n        }\n    } else if (treeHasChildren(node)) {\n        treeForEachChild(node, (childNode)=>{\n            repoSendReadyTransactions(repo, childNode);\n        });\n    }\n}\n/**\r\n * Given a list of run transactions, send them to the server and then handle\r\n * the result (success or failure).\r\n *\r\n * @param path - The location of the queue.\r\n * @param queue - Queue of transactions under the specified location.\r\n */ function repoSendTransactionQueue(repo, path, queue) {\n    // Mark transactions as sent and increment retry count!\n    const setsToIgnore = queue.map((txn)=>{\n        return txn.currentWriteId;\n    });\n    const latestState = repoGetLatestState(repo, path, setsToIgnore);\n    let snapToSend = latestState;\n    const latestHash = latestState.hash();\n    for(let i = 0; i < queue.length; i++){\n        const txn = queue[i];\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(txn.status === 0 /* TransactionStatus.RUN */ , \"tryToSendTransactionQueue_: items in queue should all be run.\");\n        txn.status = 1 /* TransactionStatus.SENT */ ;\n        txn.retryCount++;\n        const relativePath = newRelativePath(path, txn.path);\n        // If we've gotten to this point, the output snapshot must be defined.\n        snapToSend = snapToSend.updateChild(relativePath /** @type {!Node} */ , txn.currentOutputSnapshotRaw);\n    }\n    const dataToSend = snapToSend.val(true);\n    const pathToSend = path;\n    // Send the put.\n    repo.server_.put(pathToSend.toString(), dataToSend, (status)=>{\n        repoLog(repo, \"transaction put response\", {\n            path: pathToSend.toString(),\n            status\n        });\n        let events = [];\n        if (status === \"ok\") {\n            // Queue up the callbacks and fire them after cleaning up all of our\n            // transaction state, since the callback could trigger more\n            // transactions or sets.\n            const callbacks = [];\n            for(let i = 0; i < queue.length; i++){\n                queue[i].status = 2 /* TransactionStatus.COMPLETED */ ;\n                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId));\n                if (queue[i].onComplete) {\n                    // We never unset the output snapshot, and given that this\n                    // transaction is complete, it should be set\n                    callbacks.push(()=>queue[i].onComplete(null, true, queue[i].currentOutputSnapshotResolved));\n                }\n                queue[i].unwatcher();\n            }\n            // Now remove the completed transactions.\n            repoPruneCompletedTransactionsBelowNode(repo, treeSubTree(repo.transactionQueueTree_, path));\n            // There may be pending transactions that we can now send.\n            repoSendReadyTransactions(repo, repo.transactionQueueTree_);\n            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\n            // Finally, trigger onComplete callbacks.\n            for(let i = 0; i < callbacks.length; i++){\n                exceptionGuard(callbacks[i]);\n            }\n        } else {\n            // transactions are no longer sent.  Update their status appropriately.\n            if (status === \"datastale\") {\n                for(let i = 0; i < queue.length; i++){\n                    if (queue[i].status === 3 /* TransactionStatus.SENT_NEEDS_ABORT */ ) {\n                        queue[i].status = 4 /* TransactionStatus.NEEDS_ABORT */ ;\n                    } else {\n                        queue[i].status = 0 /* TransactionStatus.RUN */ ;\n                    }\n                }\n            } else {\n                warn(\"transaction at \" + pathToSend.toString() + \" failed: \" + status);\n                for(let i = 0; i < queue.length; i++){\n                    queue[i].status = 4 /* TransactionStatus.NEEDS_ABORT */ ;\n                    queue[i].abortReason = status;\n                }\n            }\n            repoRerunTransactions(repo, path);\n        }\n    }, latestHash);\n}\n/**\r\n * Finds all transactions dependent on the data at changedPath and reruns them.\r\n *\r\n * Should be called any time cached data changes.\r\n *\r\n * Return the highest path that was affected by rerunning transactions. This\r\n * is the path at which events need to be raised for.\r\n *\r\n * @param changedPath - The path in mergedData that changed.\r\n * @returns The rootmost path that was affected by rerunning transactions.\r\n */ function repoRerunTransactions(repo, changedPath) {\n    const rootMostTransactionNode = repoGetAncestorTransactionNode(repo, changedPath);\n    const path = treeGetPath(rootMostTransactionNode);\n    const queue = repoBuildTransactionQueue(repo, rootMostTransactionNode);\n    repoRerunTransactionQueue(repo, queue, path);\n    return path;\n}\n/**\r\n * Does all the work of rerunning transactions (as well as cleans up aborted\r\n * transactions and whatnot).\r\n *\r\n * @param queue - The queue of transactions to run.\r\n * @param path - The path the queue is for.\r\n */ function repoRerunTransactionQueue(repo, queue, path) {\n    if (queue.length === 0) {\n        return; // Nothing to do!\n    }\n    // Queue up the callbacks and fire them after cleaning up all of our\n    // transaction state, since the callback could trigger more transactions or\n    // sets.\n    const callbacks = [];\n    let events = [];\n    // Ignore all of the sets we're going to re-run.\n    const txnsToRerun = queue.filter((q)=>{\n        return q.status === 0 /* TransactionStatus.RUN */ ;\n    });\n    const setsToIgnore = txnsToRerun.map((q)=>{\n        return q.currentWriteId;\n    });\n    for(let i = 0; i < queue.length; i++){\n        const transaction = queue[i];\n        const relativePath = newRelativePath(path, transaction.path);\n        let abortTransaction = false, abortReason;\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(relativePath !== null, \"rerunTransactionsUnderNode_: relativePath should not be null.\");\n        if (transaction.status === 4 /* TransactionStatus.NEEDS_ABORT */ ) {\n            abortTransaction = true;\n            abortReason = transaction.abortReason;\n            events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));\n        } else if (transaction.status === 0 /* TransactionStatus.RUN */ ) {\n            if (transaction.retryCount >= MAX_TRANSACTION_RETRIES) {\n                abortTransaction = true;\n                abortReason = \"maxretry\";\n                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));\n            } else {\n                // This code reruns a transaction\n                const currentNode = repoGetLatestState(repo, transaction.path, setsToIgnore);\n                transaction.currentInputSnapshot = currentNode;\n                const newData = queue[i].update(currentNode.val());\n                if (newData !== undefined) {\n                    validateFirebaseData(\"transaction failed: Data returned \", newData, transaction.path);\n                    let newDataNode = nodeFromJSON(newData);\n                    const hasExplicitPriority = typeof newData === \"object\" && newData != null && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(newData, \".priority\");\n                    if (!hasExplicitPriority) {\n                        // Keep the old priority if there wasn't a priority explicitly specified.\n                        newDataNode = newDataNode.updatePriority(currentNode.getPriority());\n                    }\n                    const oldWriteId = transaction.currentWriteId;\n                    const serverValues = repoGenerateServerValues(repo);\n                    const newNodeResolved = resolveDeferredValueSnapshot(newDataNode, currentNode, serverValues);\n                    transaction.currentOutputSnapshotRaw = newDataNode;\n                    transaction.currentOutputSnapshotResolved = newNodeResolved;\n                    transaction.currentWriteId = repoGetNextWriteId(repo);\n                    // Mutates setsToIgnore in place\n                    setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);\n                    events = events.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_, transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));\n                    events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, oldWriteId, true));\n                } else {\n                    abortTransaction = true;\n                    abortReason = \"nodata\";\n                    events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));\n                }\n            }\n        }\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\n        events = [];\n        if (abortTransaction) {\n            // Abort.\n            queue[i].status = 2 /* TransactionStatus.COMPLETED */ ;\n            // Removing a listener can trigger pruning which can muck with\n            // mergedData/visibleData (as it prunes data). So defer the unwatcher\n            // until we're done.\n            (function(unwatcher) {\n                setTimeout(unwatcher, Math.floor(0));\n            })(queue[i].unwatcher);\n            if (queue[i].onComplete) {\n                if (abortReason === \"nodata\") {\n                    callbacks.push(()=>queue[i].onComplete(null, false, queue[i].currentInputSnapshot));\n                } else {\n                    callbacks.push(()=>queue[i].onComplete(new Error(abortReason), false, null));\n                }\n            }\n        }\n    }\n    // Clean up completed transactions.\n    repoPruneCompletedTransactionsBelowNode(repo, repo.transactionQueueTree_);\n    // Now fire callbacks, now that we're in a good, known state.\n    for(let i = 0; i < callbacks.length; i++){\n        exceptionGuard(callbacks[i]);\n    }\n    // Try to send the transaction result to the server.\n    repoSendReadyTransactions(repo, repo.transactionQueueTree_);\n}\n/**\r\n * Returns the rootmost ancestor node of the specified path that has a pending\r\n * transaction on it, or just returns the node for the given path if there are\r\n * no pending transactions on any ancestor.\r\n *\r\n * @param path - The location to start at.\r\n * @returns The rootmost node with a transaction.\r\n */ function repoGetAncestorTransactionNode(repo, path) {\n    let front;\n    // Start at the root and walk deeper into the tree towards path until we\n    // find a node with pending transactions.\n    let transactionNode = repo.transactionQueueTree_;\n    front = pathGetFront(path);\n    while(front !== null && treeGetValue(transactionNode) === undefined){\n        transactionNode = treeSubTree(transactionNode, front);\n        path = pathPopFront(path);\n        front = pathGetFront(path);\n    }\n    return transactionNode;\n}\n/**\r\n * Builds the queue of all transactions at or below the specified\r\n * transactionNode.\r\n *\r\n * @param transactionNode\r\n * @returns The generated queue.\r\n */ function repoBuildTransactionQueue(repo, transactionNode) {\n    // Walk any child transaction queues and aggregate them into a single queue.\n    const transactionQueue = [];\n    repoAggregateTransactionQueuesForNode(repo, transactionNode, transactionQueue);\n    // Sort them by the order the transactions were created.\n    transactionQueue.sort((a, b)=>a.order - b.order);\n    return transactionQueue;\n}\nfunction repoAggregateTransactionQueuesForNode(repo, node, queue) {\n    const nodeQueue = treeGetValue(node);\n    if (nodeQueue) {\n        for(let i = 0; i < nodeQueue.length; i++){\n            queue.push(nodeQueue[i]);\n        }\n    }\n    treeForEachChild(node, (child)=>{\n        repoAggregateTransactionQueuesForNode(repo, child, queue);\n    });\n}\n/**\r\n * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.\r\n */ function repoPruneCompletedTransactionsBelowNode(repo, node) {\n    const queue = treeGetValue(node);\n    if (queue) {\n        let to = 0;\n        for(let from = 0; from < queue.length; from++){\n            if (queue[from].status !== 2 /* TransactionStatus.COMPLETED */ ) {\n                queue[to] = queue[from];\n                to++;\n            }\n        }\n        queue.length = to;\n        treeSetValue(node, queue.length > 0 ? queue : undefined);\n    }\n    treeForEachChild(node, (childNode)=>{\n        repoPruneCompletedTransactionsBelowNode(repo, childNode);\n    });\n}\n/**\r\n * Aborts all transactions on ancestors or descendants of the specified path.\r\n * Called when doing a set() or update() since we consider them incompatible\r\n * with transactions.\r\n *\r\n * @param path - Path for which we want to abort related transactions.\r\n */ function repoAbortTransactions(repo, path) {\n    const affectedPath = treeGetPath(repoGetAncestorTransactionNode(repo, path));\n    const transactionNode = treeSubTree(repo.transactionQueueTree_, path);\n    treeForEachAncestor(transactionNode, (node)=>{\n        repoAbortTransactionsOnNode(repo, node);\n    });\n    repoAbortTransactionsOnNode(repo, transactionNode);\n    treeForEachDescendant(transactionNode, (node)=>{\n        repoAbortTransactionsOnNode(repo, node);\n    });\n    return affectedPath;\n}\n/**\r\n * Abort transactions stored in this transaction queue node.\r\n *\r\n * @param node - Node to abort transactions for.\r\n */ function repoAbortTransactionsOnNode(repo, node) {\n    const queue = treeGetValue(node);\n    if (queue) {\n        // Queue up the callbacks and fire them after cleaning up all of our\n        // transaction state, since the callback could trigger more transactions\n        // or sets.\n        const callbacks = [];\n        // Go through queue.  Any already-sent transactions must be marked for\n        // abort, while the unsent ones can be immediately aborted and removed.\n        let events = [];\n        let lastSent = -1;\n        for(let i = 0; i < queue.length; i++){\n            if (queue[i].status === 3 /* TransactionStatus.SENT_NEEDS_ABORT */ ) ;\n            else if (queue[i].status === 1 /* TransactionStatus.SENT */ ) {\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(lastSent === i - 1, \"All SENT items should be at beginning of queue.\");\n                lastSent = i;\n                // Mark transaction for abort when it comes back.\n                queue[i].status = 3 /* TransactionStatus.SENT_NEEDS_ABORT */ ;\n                queue[i].abortReason = \"set\";\n            } else {\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(queue[i].status === 0 /* TransactionStatus.RUN */ , \"Unexpected transaction status in abort\");\n                // We can abort it immediately.\n                queue[i].unwatcher();\n                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId, true));\n                if (queue[i].onComplete) {\n                    callbacks.push(queue[i].onComplete.bind(null, new Error(\"set\"), false, null));\n                }\n            }\n        }\n        if (lastSent === -1) {\n            // We're not waiting for any sent transactions.  We can clear the queue.\n            treeSetValue(node, undefined);\n        } else {\n            // Remove the transactions we aborted.\n            queue.length = lastSent + 1;\n        }\n        // Now fire the callbacks.\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, treeGetPath(node), events);\n        for(let i = 0; i < callbacks.length; i++){\n            exceptionGuard(callbacks[i]);\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function decodePath(pathString) {\n    let pathStringDecoded = \"\";\n    const pieces = pathString.split(\"/\");\n    for(let i = 0; i < pieces.length; i++){\n        if (pieces[i].length > 0) {\n            let piece = pieces[i];\n            try {\n                piece = decodeURIComponent(piece.replace(/\\+/g, \" \"));\n            } catch (e) {}\n            pathStringDecoded += \"/\" + piece;\n        }\n    }\n    return pathStringDecoded;\n}\n/**\r\n * @returns key value hash\r\n */ function decodeQuery(queryString) {\n    const results = {};\n    if (queryString.charAt(0) === \"?\") {\n        queryString = queryString.substring(1);\n    }\n    for (const segment of queryString.split(\"&\")){\n        if (segment.length === 0) {\n            continue;\n        }\n        const kv = segment.split(\"=\");\n        if (kv.length === 2) {\n            results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);\n        } else {\n            warn(`Invalid query segment '${segment}' in query '${queryString}'`);\n        }\n    }\n    return results;\n}\nconst parseRepoInfo = function(dataURL, nodeAdmin) {\n    const parsedUrl = parseDatabaseURL(dataURL), namespace = parsedUrl.namespace;\n    if (parsedUrl.domain === \"firebase.com\") {\n        fatal(parsedUrl.host + \" is no longer supported. \" + \"Please use <YOUR FIREBASE>.firebaseio.com instead\");\n    }\n    // Catch common error of uninitialized namespace value.\n    if ((!namespace || namespace === \"undefined\") && parsedUrl.domain !== \"localhost\") {\n        fatal(\"Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com\");\n    }\n    if (!parsedUrl.secure) {\n        warnIfPageIsSecure();\n    }\n    const webSocketOnly = parsedUrl.scheme === \"ws\" || parsedUrl.scheme === \"wss\";\n    return {\n        repoInfo: new RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, webSocketOnly, nodeAdmin, /*persistenceKey=*/ \"\", /*includeNamespaceInQueryParams=*/ namespace !== parsedUrl.subdomain),\n        path: new Path(parsedUrl.pathString)\n    };\n};\nconst parseDatabaseURL = function(dataURL) {\n    // Default to empty strings in the event of a malformed string.\n    let host = \"\", domain = \"\", subdomain = \"\", pathString = \"\", namespace = \"\";\n    // Always default to SSL, unless otherwise specified.\n    let secure = true, scheme = \"https\", port = 443;\n    // Don't do any validation here. The caller is responsible for validating the result of parsing.\n    if (typeof dataURL === \"string\") {\n        // Parse scheme.\n        let colonInd = dataURL.indexOf(\"//\");\n        if (colonInd >= 0) {\n            scheme = dataURL.substring(0, colonInd - 1);\n            dataURL = dataURL.substring(colonInd + 2);\n        }\n        // Parse host, path, and query string.\n        let slashInd = dataURL.indexOf(\"/\");\n        if (slashInd === -1) {\n            slashInd = dataURL.length;\n        }\n        let questionMarkInd = dataURL.indexOf(\"?\");\n        if (questionMarkInd === -1) {\n            questionMarkInd = dataURL.length;\n        }\n        host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));\n        if (slashInd < questionMarkInd) {\n            // For pathString, questionMarkInd will always come after slashInd\n            pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));\n        }\n        const queryParams = decodeQuery(dataURL.substring(Math.min(dataURL.length, questionMarkInd)));\n        // If we have a port, use scheme for determining if it's secure.\n        colonInd = host.indexOf(\":\");\n        if (colonInd >= 0) {\n            secure = scheme === \"https\" || scheme === \"wss\";\n            port = parseInt(host.substring(colonInd + 1), 10);\n        } else {\n            colonInd = host.length;\n        }\n        const hostWithoutPort = host.slice(0, colonInd);\n        if (hostWithoutPort.toLowerCase() === \"localhost\") {\n            domain = \"localhost\";\n        } else if (hostWithoutPort.split(\".\").length <= 2) {\n            domain = hostWithoutPort;\n        } else {\n            // Interpret the subdomain of a 3 or more component URL as the namespace name.\n            const dotInd = host.indexOf(\".\");\n            subdomain = host.substring(0, dotInd).toLowerCase();\n            domain = host.substring(dotInd + 1);\n            // Normalize namespaces to lowercase to share storage / connection.\n            namespace = subdomain;\n        }\n        // Always treat the value of the `ns` as the namespace name if it is present.\n        if (\"ns\" in queryParams) {\n            namespace = queryParams[\"ns\"];\n        }\n    }\n    return {\n        host,\n        port,\n        domain,\n        subdomain,\n        secure,\n        scheme,\n        pathString,\n        namespace\n    };\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Modeled after base64 web-safe chars, but ordered by ASCII.\nconst PUSH_CHARS = \"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\";\n/**\r\n * Fancy ID generator that creates 20-character string identifiers with the\r\n * following properties:\r\n *\r\n * 1. They're based on timestamp so that they sort *after* any existing ids.\r\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't\r\n *    collide with other clients' IDs.\r\n * 3. They sort *lexicographically* (so the timestamp is converted to characters\r\n *    that will sort properly).\r\n * 4. They're monotonically increasing. Even if you generate more than one in\r\n *    the same timestamp, the latter ones will sort after the former ones. We do\r\n *    this by using the previous random bits but \"incrementing\" them by 1 (only\r\n *    in the case of a timestamp collision).\r\n */ const nextPushId = function() {\n    // Timestamp of last push, used to prevent local collisions if you push twice\n    // in one ms.\n    let lastPushTime = 0;\n    // We generate 72-bits of randomness which get turned into 12 characters and\n    // appended to the timestamp to prevent collisions with other clients. We\n    // store the last characters we generated because in the event of a collision,\n    // we'll use those same characters except \"incremented\" by one.\n    const lastRandChars = [];\n    return function(now) {\n        const duplicateTime = now === lastPushTime;\n        lastPushTime = now;\n        let i;\n        const timeStampChars = new Array(8);\n        for(i = 7; i >= 0; i--){\n            timeStampChars[i] = PUSH_CHARS.charAt(now % 64);\n            // NOTE: Can't use << here because javascript will convert to int and lose\n            // the upper bits.\n            now = Math.floor(now / 64);\n        }\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(now === 0, \"Cannot push at time == 0\");\n        let id = timeStampChars.join(\"\");\n        if (!duplicateTime) {\n            for(i = 0; i < 12; i++){\n                lastRandChars[i] = Math.floor(Math.random() * 64);\n            }\n        } else {\n            // If the timestamp hasn't changed since last push, use the same random\n            // number, except incremented by 1.\n            for(i = 11; i >= 0 && lastRandChars[i] === 63; i--){\n                lastRandChars[i] = 0;\n            }\n            lastRandChars[i]++;\n        }\n        for(i = 0; i < 12; i++){\n            id += PUSH_CHARS.charAt(lastRandChars[i]);\n        }\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(id.length === 20, \"nextPushId: Length should be 20.\");\n        return id;\n    };\n}();\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Encapsulates the data needed to raise an event\r\n */ class DataEvent {\n    /**\r\n     * @param eventType - One of: value, child_added, child_changed, child_moved, child_removed\r\n     * @param eventRegistration - The function to call to with the event data. User provided\r\n     * @param snapshot - The data backing the event\r\n     * @param prevName - Optional, the name of the previous child for child_* events.\r\n     */ constructor(eventType, eventRegistration, snapshot, prevName){\n        this.eventType = eventType;\n        this.eventRegistration = eventRegistration;\n        this.snapshot = snapshot;\n        this.prevName = prevName;\n    }\n    getPath() {\n        const ref = this.snapshot.ref;\n        if (this.eventType === \"value\") {\n            return ref._path;\n        } else {\n            return ref.parent._path;\n        }\n    }\n    getEventType() {\n        return this.eventType;\n    }\n    getEventRunner() {\n        return this.eventRegistration.getEventRunner(this);\n    }\n    toString() {\n        return this.getPath().toString() + \":\" + this.eventType + \":\" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(this.snapshot.exportVal());\n    }\n}\nclass CancelEvent {\n    constructor(eventRegistration, error, path){\n        this.eventRegistration = eventRegistration;\n        this.error = error;\n        this.path = path;\n    }\n    getPath() {\n        return this.path;\n    }\n    getEventType() {\n        return \"cancel\";\n    }\n    getEventRunner() {\n        return this.eventRegistration.getEventRunner(this);\n    }\n    toString() {\n        return this.path.toString() + \":cancel\";\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A wrapper class that converts events from the database@exp SDK to the legacy\r\n * Database SDK. Events are not converted directly as event registration relies\r\n * on reference comparison of the original user callback (see `matches()`) and\r\n * relies on equality of the legacy SDK's `context` object.\r\n */ class CallbackContext {\n    constructor(snapshotCallback, cancelCallback){\n        this.snapshotCallback = snapshotCallback;\n        this.cancelCallback = cancelCallback;\n    }\n    onValue(expDataSnapshot, previousChildName) {\n        this.snapshotCallback.call(null, expDataSnapshot, previousChildName);\n    }\n    onCancel(error) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.hasCancelCallback, \"Raising a cancel event on a listener with no cancel callback\");\n        return this.cancelCallback.call(null, error);\n    }\n    get hasCancelCallback() {\n        return !!this.cancelCallback;\n    }\n    matches(other) {\n        return this.snapshotCallback === other.snapshotCallback || this.snapshotCallback.userCallback !== undefined && this.snapshotCallback.userCallback === other.snapshotCallback.userCallback && this.snapshotCallback.context === other.snapshotCallback.context;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The `onDisconnect` class allows you to write or clear data when your client\r\n * disconnects from the Database server. These updates occur whether your\r\n * client disconnects cleanly or not, so you can rely on them to clean up data\r\n * even if a connection is dropped or a client crashes.\r\n *\r\n * The `onDisconnect` class is most commonly used to manage presence in\r\n * applications where it is useful to detect how many clients are connected and\r\n * when other clients disconnect. See\r\n * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}\r\n * for more information.\r\n *\r\n * To avoid problems when a connection is dropped before the requests can be\r\n * transferred to the Database server, these functions should be called before\r\n * writing any data.\r\n *\r\n * Note that `onDisconnect` operations are only triggered once. If you want an\r\n * operation to occur each time a disconnect occurs, you'll need to re-establish\r\n * the `onDisconnect` operations each time you reconnect.\r\n */ class OnDisconnect {\n    /** @hideconstructor */ constructor(_repo, _path){\n        this._repo = _repo;\n        this._path = _path;\n    }\n    /**\r\n     * Cancels all previously queued `onDisconnect()` set or update events for this\r\n     * location and all children.\r\n     *\r\n     * If a write has been queued for this location via a `set()` or `update()` at a\r\n     * parent location, the write at this location will be canceled, though writes\r\n     * to sibling locations will still occur.\r\n     *\r\n     * @returns Resolves when synchronization to the server is complete.\r\n     */ cancel() {\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        repoOnDisconnectCancel(this._repo, this._path, deferred.wrapCallback(()=>{}));\n        return deferred.promise;\n    }\n    /**\r\n     * Ensures the data at this location is deleted when the client is disconnected\r\n     * (due to closing the browser, navigating to a new page, or network issues).\r\n     *\r\n     * @returns Resolves when synchronization to the server is complete.\r\n     */ remove() {\n        validateWritablePath(\"OnDisconnect.remove\", this._path);\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        repoOnDisconnectSet(this._repo, this._path, null, deferred.wrapCallback(()=>{}));\n        return deferred.promise;\n    }\n    /**\r\n     * Ensures the data at this location is set to the specified value when the\r\n     * client is disconnected (due to closing the browser, navigating to a new page,\r\n     * or network issues).\r\n     *\r\n     * `set()` is especially useful for implementing \"presence\" systems, where a\r\n     * value should be changed or cleared when a user disconnects so that they\r\n     * appear \"offline\" to other users. See\r\n     * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}\r\n     * for more information.\r\n     *\r\n     * Note that `onDisconnect` operations are only triggered once. If you want an\r\n     * operation to occur each time a disconnect occurs, you'll need to re-establish\r\n     * the `onDisconnect` operations each time.\r\n     *\r\n     * @param value - The value to be written to this location on disconnect (can\r\n     * be an object, array, string, number, boolean, or null).\r\n     * @returns Resolves when synchronization to the Database is complete.\r\n     */ set(value) {\n        validateWritablePath(\"OnDisconnect.set\", this._path);\n        validateFirebaseDataArg(\"OnDisconnect.set\", value, this._path, false);\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        repoOnDisconnectSet(this._repo, this._path, value, deferred.wrapCallback(()=>{}));\n        return deferred.promise;\n    }\n    /**\r\n     * Ensures the data at this location is set to the specified value and priority\r\n     * when the client is disconnected (due to closing the browser, navigating to a\r\n     * new page, or network issues).\r\n     *\r\n     * @param value - The value to be written to this location on disconnect (can\r\n     * be an object, array, string, number, boolean, or null).\r\n     * @param priority - The priority to be written (string, number, or null).\r\n     * @returns Resolves when synchronization to the Database is complete.\r\n     */ setWithPriority(value, priority) {\n        validateWritablePath(\"OnDisconnect.setWithPriority\", this._path);\n        validateFirebaseDataArg(\"OnDisconnect.setWithPriority\", value, this._path, false);\n        validatePriority(\"OnDisconnect.setWithPriority\", priority, false);\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        repoOnDisconnectSetWithPriority(this._repo, this._path, value, priority, deferred.wrapCallback(()=>{}));\n        return deferred.promise;\n    }\n    /**\r\n     * Writes multiple values at this location when the client is disconnected (due\r\n     * to closing the browser, navigating to a new page, or network issues).\r\n     *\r\n     * The `values` argument contains multiple property-value pairs that will be\r\n     * written to the Database together. Each child property can either be a simple\r\n     * property (for example, \"name\") or a relative path (for example, \"name/first\")\r\n     * from the current location to the data to update.\r\n     *\r\n     * As opposed to the `set()` method, `update()` can be use to selectively update\r\n     * only the referenced properties at the current location (instead of replacing\r\n     * all the child properties at the current location).\r\n     *\r\n     * @param values - Object containing multiple values.\r\n     * @returns Resolves when synchronization to the Database is complete.\r\n     */ update(values) {\n        validateWritablePath(\"OnDisconnect.update\", this._path);\n        validateFirebaseMergeDataArg(\"OnDisconnect.update\", values, this._path, false);\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        repoOnDisconnectUpdate(this._repo, this._path, values, deferred.wrapCallback(()=>{}));\n        return deferred.promise;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @internal\r\n */ class QueryImpl {\n    /**\r\n     * @hideconstructor\r\n     */ constructor(_repo, _path, _queryParams, _orderByCalled){\n        this._repo = _repo;\n        this._path = _path;\n        this._queryParams = _queryParams;\n        this._orderByCalled = _orderByCalled;\n    }\n    get key() {\n        if (pathIsEmpty(this._path)) {\n            return null;\n        } else {\n            return pathGetBack(this._path);\n        }\n    }\n    get ref() {\n        return new ReferenceImpl(this._repo, this._path);\n    }\n    get _queryIdentifier() {\n        const obj = queryParamsGetQueryObject(this._queryParams);\n        const id = ObjectToUniqueKey(obj);\n        return id === \"{}\" ? \"default\" : id;\n    }\n    /**\r\n     * An object representation of the query parameters used by this Query.\r\n     */ get _queryObject() {\n        return queryParamsGetQueryObject(this._queryParams);\n    }\n    isEqual(other) {\n        other = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(other);\n        if (!(other instanceof QueryImpl)) {\n            return false;\n        }\n        const sameRepo = this._repo === other._repo;\n        const samePath = pathEquals(this._path, other._path);\n        const sameQueryIdentifier = this._queryIdentifier === other._queryIdentifier;\n        return sameRepo && samePath && sameQueryIdentifier;\n    }\n    toJSON() {\n        return this.toString();\n    }\n    toString() {\n        return this._repo.toString() + pathToUrlEncodedString(this._path);\n    }\n}\n/**\r\n * Validates that no other order by call has been made\r\n */ function validateNoPreviousOrderByCall(query, fnName) {\n    if (query._orderByCalled === true) {\n        throw new Error(fnName + \": You can't combine multiple orderBy calls.\");\n    }\n}\n/**\r\n * Validates start/end values for queries.\r\n */ function validateQueryEndpoints(params) {\n    let startNode = null;\n    let endNode = null;\n    if (params.hasStart()) {\n        startNode = params.getIndexStartValue();\n    }\n    if (params.hasEnd()) {\n        endNode = params.getIndexEndValue();\n    }\n    if (params.getIndex() === KEY_INDEX) {\n        const tooManyArgsError = \"Query: When ordering by key, you may only pass one argument to \" + \"startAt(), endAt(), or equalTo().\";\n        const wrongArgTypeError = \"Query: When ordering by key, the argument passed to startAt(), startAfter(), \" + \"endAt(), endBefore(), or equalTo() must be a string.\";\n        if (params.hasStart()) {\n            const startName = params.getIndexStartName();\n            if (startName !== MIN_NAME) {\n                throw new Error(tooManyArgsError);\n            } else if (typeof startNode !== \"string\") {\n                throw new Error(wrongArgTypeError);\n            }\n        }\n        if (params.hasEnd()) {\n            const endName = params.getIndexEndName();\n            if (endName !== MAX_NAME) {\n                throw new Error(tooManyArgsError);\n            } else if (typeof endNode !== \"string\") {\n                throw new Error(wrongArgTypeError);\n            }\n        }\n    } else if (params.getIndex() === PRIORITY_INDEX) {\n        if (startNode != null && !isValidPriority(startNode) || endNode != null && !isValidPriority(endNode)) {\n            throw new Error(\"Query: When ordering by priority, the first argument passed to startAt(), \" + \"startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value \" + \"(null, a number, or a string).\");\n        }\n    } else {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(params.getIndex() instanceof PathIndex || params.getIndex() === VALUE_INDEX, \"unknown index type.\");\n        if (startNode != null && typeof startNode === \"object\" || endNode != null && typeof endNode === \"object\") {\n            throw new Error(\"Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or \" + \"equalTo() cannot be an object.\");\n        }\n    }\n}\n/**\r\n * Validates that limit* has been called with the correct combination of parameters\r\n */ function validateLimit(params) {\n    if (params.hasStart() && params.hasEnd() && params.hasLimit() && !params.hasAnchoredLimit()) {\n        throw new Error(\"Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use \" + \"limitToFirst() or limitToLast() instead.\");\n    }\n}\n/**\r\n * @internal\r\n */ class ReferenceImpl extends QueryImpl {\n    /** @hideconstructor */ constructor(repo, path){\n        super(repo, path, new QueryParams(), false);\n    }\n    get parent() {\n        const parentPath = pathParent(this._path);\n        return parentPath === null ? null : new ReferenceImpl(this._repo, parentPath);\n    }\n    get root() {\n        let ref = this;\n        while(ref.parent !== null){\n            ref = ref.parent;\n        }\n        return ref;\n    }\n}\n/**\r\n * A `DataSnapshot` contains data from a Database location.\r\n *\r\n * Any time you read data from the Database, you receive the data as a\r\n * `DataSnapshot`. A `DataSnapshot` is passed to the event callbacks you attach\r\n * with `on()` or `once()`. You can extract the contents of the snapshot as a\r\n * JavaScript object by calling the `val()` method. Alternatively, you can\r\n * traverse into the snapshot by calling `child()` to return child snapshots\r\n * (which you could then call `val()` on).\r\n *\r\n * A `DataSnapshot` is an efficiently generated, immutable copy of the data at\r\n * a Database location. It cannot be modified and will never change (to modify\r\n * data, you always call the `set()` method on a `Reference` directly).\r\n */ class DataSnapshot {\n    /**\r\n     * @param _node - A SnapshotNode to wrap.\r\n     * @param ref - The location this snapshot came from.\r\n     * @param _index - The iteration order for this snapshot\r\n     * @hideconstructor\r\n     */ constructor(_node, /**\r\n     * The location of this DataSnapshot.\r\n     */ ref, _index){\n        this._node = _node;\n        this.ref = ref;\n        this._index = _index;\n    }\n    /**\r\n     * Gets the priority value of the data in this `DataSnapshot`.\r\n     *\r\n     * Applications need not use priority but can order collections by\r\n     * ordinary properties (see\r\n     * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data |Sorting and filtering data}\r\n     * ).\r\n     */ get priority() {\n        // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)\n        return this._node.getPriority().val();\n    }\n    /**\r\n     * The key (last part of the path) of the location of this `DataSnapshot`.\r\n     *\r\n     * The last token in a Database location is considered its key. For example,\r\n     * \"ada\" is the key for the /users/ada/ node. Accessing the key on any\r\n     * `DataSnapshot` will return the key for the location that generated it.\r\n     * However, accessing the key on the root URL of a Database will return\r\n     * `null`.\r\n     */ get key() {\n        return this.ref.key;\n    }\n    /** Returns the number of child properties of this `DataSnapshot`. */ get size() {\n        return this._node.numChildren();\n    }\n    /**\r\n     * Gets another `DataSnapshot` for the location at the specified relative path.\r\n     *\r\n     * Passing a relative path to the `child()` method of a DataSnapshot returns\r\n     * another `DataSnapshot` for the location at the specified relative path. The\r\n     * relative path can either be a simple child name (for example, \"ada\") or a\r\n     * deeper, slash-separated path (for example, \"ada/name/first\"). If the child\r\n     * location has no data, an empty `DataSnapshot` (that is, a `DataSnapshot`\r\n     * whose value is `null`) is returned.\r\n     *\r\n     * @param path - A relative path to the location of child data.\r\n     */ child(path) {\n        const childPath = new Path(path);\n        const childRef = child(this.ref, path);\n        return new DataSnapshot(this._node.getChild(childPath), childRef, PRIORITY_INDEX);\n    }\n    /**\r\n     * Returns true if this `DataSnapshot` contains any data. It is slightly more\r\n     * efficient than using `snapshot.val() !== null`.\r\n     */ exists() {\n        return !this._node.isEmpty();\n    }\n    /**\r\n     * Exports the entire contents of the DataSnapshot as a JavaScript object.\r\n     *\r\n     * The `exportVal()` method is similar to `val()`, except priority information\r\n     * is included (if available), making it suitable for backing up your data.\r\n     *\r\n     * @returns The DataSnapshot's contents as a JavaScript value (Object,\r\n     *   Array, string, number, boolean, or `null`).\r\n     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    exportVal() {\n        return this._node.val(true);\n    }\n    /**\r\n     * Enumerates the top-level children in the `IteratedDataSnapshot`.\r\n     *\r\n     * Because of the way JavaScript objects work, the ordering of data in the\r\n     * JavaScript object returned by `val()` is not guaranteed to match the\r\n     * ordering on the server nor the ordering of `onChildAdded()` events. That is\r\n     * where `forEach()` comes in handy. It guarantees the children of a\r\n     * `DataSnapshot` will be iterated in their query order.\r\n     *\r\n     * If no explicit `orderBy*()` method is used, results are returned\r\n     * ordered by key (unless priorities are used, in which case, results are\r\n     * returned by priority).\r\n     *\r\n     * @param action - A function that will be called for each child DataSnapshot.\r\n     * The callback can return true to cancel further enumeration.\r\n     * @returns true if enumeration was canceled due to your callback returning\r\n     * true.\r\n     */ forEach(action) {\n        if (this._node.isLeafNode()) {\n            return false;\n        }\n        const childrenNode = this._node;\n        // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...\n        return !!childrenNode.forEachChild(this._index, (key, node)=>{\n            return action(new DataSnapshot(node, child(this.ref, key), PRIORITY_INDEX));\n        });\n    }\n    /**\r\n     * Returns true if the specified child path has (non-null) data.\r\n     *\r\n     * @param path - A relative path to the location of a potential child.\r\n     * @returns `true` if data exists at the specified child path; else\r\n     *  `false`.\r\n     */ hasChild(path) {\n        const childPath = new Path(path);\n        return !this._node.getChild(childPath).isEmpty();\n    }\n    /**\r\n     * Returns whether or not the `DataSnapshot` has any non-`null` child\r\n     * properties.\r\n     *\r\n     * You can use `hasChildren()` to determine if a `DataSnapshot` has any\r\n     * children. If it does, you can enumerate them using `forEach()`. If it\r\n     * doesn't, then either this snapshot contains a primitive value (which can be\r\n     * retrieved with `val()`) or it is empty (in which case, `val()` will return\r\n     * `null`).\r\n     *\r\n     * @returns true if this snapshot has any children; else false.\r\n     */ hasChildren() {\n        if (this._node.isLeafNode()) {\n            return false;\n        } else {\n            return !this._node.isEmpty();\n        }\n    }\n    /**\r\n     * Returns a JSON-serializable representation of this object.\r\n     */ toJSON() {\n        return this.exportVal();\n    }\n    /**\r\n     * Extracts a JavaScript value from a `DataSnapshot`.\r\n     *\r\n     * Depending on the data in a `DataSnapshot`, the `val()` method may return a\r\n     * scalar type (string, number, or boolean), an array, or an object. It may\r\n     * also return null, indicating that the `DataSnapshot` is empty (contains no\r\n     * data).\r\n     *\r\n     * @returns The DataSnapshot's contents as a JavaScript value (Object,\r\n     *   Array, string, number, boolean, or `null`).\r\n     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    val() {\n        return this._node.val();\n    }\n}\n/**\r\n *\r\n * Returns a `Reference` representing the location in the Database\r\n * corresponding to the provided path. If no path is provided, the `Reference`\r\n * will point to the root of the Database.\r\n *\r\n * @param db - The database instance to obtain a reference for.\r\n * @param path - Optional path representing the location the returned\r\n *   `Reference` will point. If not provided, the returned `Reference` will\r\n *   point to the root of the Database.\r\n * @returns If a path is provided, a `Reference`\r\n *   pointing to the provided path. Otherwise, a `Reference` pointing to the\r\n *   root of the Database.\r\n */ function ref(db, path) {\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(db);\n    db._checkNotDeleted(\"ref\");\n    return path !== undefined ? child(db._root, path) : db._root;\n}\n/**\r\n * Returns a `Reference` representing the location in the Database\r\n * corresponding to the provided Firebase URL.\r\n *\r\n * An exception is thrown if the URL is not a valid Firebase Database URL or it\r\n * has a different domain than the current `Database` instance.\r\n *\r\n * Note that all query parameters (`orderBy`, `limitToLast`, etc.) are ignored\r\n * and are not applied to the returned `Reference`.\r\n *\r\n * @param db - The database instance to obtain a reference for.\r\n * @param url - The Firebase URL at which the returned `Reference` will\r\n *   point.\r\n * @returns A `Reference` pointing to the provided\r\n *   Firebase URL.\r\n */ function refFromURL(db, url) {\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(db);\n    db._checkNotDeleted(\"refFromURL\");\n    const parsedURL = parseRepoInfo(url, db._repo.repoInfo_.nodeAdmin);\n    validateUrl(\"refFromURL\", parsedURL);\n    const repoInfo = parsedURL.repoInfo;\n    if (!db._repo.repoInfo_.isCustomHost() && repoInfo.host !== db._repo.repoInfo_.host) {\n        fatal(\"refFromURL\" + \": Host name does not match the current database: \" + \"(found \" + repoInfo.host + \" but expected \" + db._repo.repoInfo_.host + \")\");\n    }\n    return ref(db, parsedURL.path.toString());\n}\n/**\r\n * Gets a `Reference` for the location at the specified relative path.\r\n *\r\n * The relative path can either be a simple child name (for example, \"ada\") or\r\n * a deeper slash-separated path (for example, \"ada/name/first\").\r\n *\r\n * @param parent - The parent location.\r\n * @param path - A relative path from this location to the desired child\r\n *   location.\r\n * @returns The specified child location.\r\n */ function child(parent, path) {\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(parent);\n    if (pathGetFront(parent._path) === null) {\n        validateRootPathString(\"child\", \"path\", path, false);\n    } else {\n        validatePathString(\"child\", \"path\", path, false);\n    }\n    return new ReferenceImpl(parent._repo, pathChild(parent._path, path));\n}\n/**\r\n * Returns an `OnDisconnect` object - see\r\n * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}\r\n * for more information on how to use it.\r\n *\r\n * @param ref - The reference to add OnDisconnect triggers for.\r\n */ function onDisconnect(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return new OnDisconnect(ref._repo, ref._path);\n}\n/**\r\n * Generates a new child location using a unique key and returns its\r\n * `Reference`.\r\n *\r\n * This is the most common pattern for adding data to a collection of items.\r\n *\r\n * If you provide a value to `push()`, the value is written to the\r\n * generated location. If you don't pass a value, nothing is written to the\r\n * database and the child remains empty (but you can use the `Reference`\r\n * elsewhere).\r\n *\r\n * The unique keys generated by `push()` are ordered by the current time, so the\r\n * resulting list of items is chronologically sorted. The keys are also\r\n * designed to be unguessable (they contain 72 random bits of entropy).\r\n *\r\n * See {@link https://firebase.google.com/docs/database/web/lists-of-data#append_to_a_list_of_data | Append to a list of data}.\r\n * See {@link https://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html | The 2^120 Ways to Ensure Unique Identifiers}.\r\n *\r\n * @param parent - The parent location.\r\n * @param value - Optional value to be written at the generated location.\r\n * @returns Combined `Promise` and `Reference`; resolves when write is complete,\r\n * but can be used immediately as the `Reference` to the child location.\r\n */ function push(parent, value) {\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(parent);\n    validateWritablePath(\"push\", parent._path);\n    validateFirebaseDataArg(\"push\", value, parent._path, true);\n    const now = repoServerTime(parent._repo);\n    const name = nextPushId(now);\n    // push() returns a ThennableReference whose promise is fulfilled with a\n    // regular Reference. We use child() to create handles to two different\n    // references. The first is turned into a ThennableReference below by adding\n    // then() and catch() methods and is used as the return value of push(). The\n    // second remains a regular Reference and is used as the fulfilled value of\n    // the first ThennableReference.\n    const thennablePushRef = child(parent, name);\n    const pushRef = child(parent, name);\n    let promise;\n    if (value != null) {\n        promise = set(pushRef, value).then(()=>pushRef);\n    } else {\n        promise = Promise.resolve(pushRef);\n    }\n    thennablePushRef.then = promise.then.bind(promise);\n    thennablePushRef.catch = promise.then.bind(promise, undefined);\n    return thennablePushRef;\n}\n/**\r\n * Removes the data at this Database location.\r\n *\r\n * Any data at child locations will also be deleted.\r\n *\r\n * The effect of the remove will be visible immediately and the corresponding\r\n * event 'value' will be triggered. Synchronization of the remove to the\r\n * Firebase servers will also be started, and the returned Promise will resolve\r\n * when complete. If provided, the onComplete callback will be called\r\n * asynchronously after synchronization has finished.\r\n *\r\n * @param ref - The location to remove.\r\n * @returns Resolves when remove on server is complete.\r\n */ function remove(ref) {\n    validateWritablePath(\"remove\", ref._path);\n    return set(ref, null);\n}\n/**\r\n * Writes data to this Database location.\r\n *\r\n * This will overwrite any data at this location and all child locations.\r\n *\r\n * The effect of the write will be visible immediately, and the corresponding\r\n * events (\"value\", \"child_added\", etc.) will be triggered. Synchronization of\r\n * the data to the Firebase servers will also be started, and the returned\r\n * Promise will resolve when complete. If provided, the `onComplete` callback\r\n * will be called asynchronously after synchronization has finished.\r\n *\r\n * Passing `null` for the new value is equivalent to calling `remove()`; namely,\r\n * all data at this location and all child locations will be deleted.\r\n *\r\n * `set()` will remove any priority stored at this location, so if priority is\r\n * meant to be preserved, you need to use `setWithPriority()` instead.\r\n *\r\n * Note that modifying data with `set()` will cancel any pending transactions\r\n * at that location, so extreme care should be taken if mixing `set()` and\r\n * `transaction()` to modify the same data.\r\n *\r\n * A single `set()` will generate a single \"value\" event at the location where\r\n * the `set()` was performed.\r\n *\r\n * @param ref - The location to write to.\r\n * @param value - The value to be written (string, number, boolean, object,\r\n *   array, or null).\r\n * @returns Resolves when write to server is complete.\r\n */ function set(ref, value) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    validateWritablePath(\"set\", ref._path);\n    validateFirebaseDataArg(\"set\", value, ref._path, false);\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n    repoSetWithPriority(ref._repo, ref._path, value, /*priority=*/ null, deferred.wrapCallback(()=>{}));\n    return deferred.promise;\n}\n/**\r\n * Sets a priority for the data at this Database location.\r\n *\r\n * Applications need not use priority but can order collections by\r\n * ordinary properties (see\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}\r\n * ).\r\n *\r\n * @param ref - The location to write to.\r\n * @param priority - The priority to be written (string, number, or null).\r\n * @returns Resolves when write to server is complete.\r\n */ function setPriority(ref, priority) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    validateWritablePath(\"setPriority\", ref._path);\n    validatePriority(\"setPriority\", priority, false);\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n    repoSetWithPriority(ref._repo, pathChild(ref._path, \".priority\"), priority, null, deferred.wrapCallback(()=>{}));\n    return deferred.promise;\n}\n/**\r\n * Writes data the Database location. Like `set()` but also specifies the\r\n * priority for that data.\r\n *\r\n * Applications need not use priority but can order collections by\r\n * ordinary properties (see\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}\r\n * ).\r\n *\r\n * @param ref - The location to write to.\r\n * @param value - The value to be written (string, number, boolean, object,\r\n *   array, or null).\r\n * @param priority - The priority to be written (string, number, or null).\r\n * @returns Resolves when write to server is complete.\r\n */ function setWithPriority(ref, value, priority) {\n    validateWritablePath(\"setWithPriority\", ref._path);\n    validateFirebaseDataArg(\"setWithPriority\", value, ref._path, false);\n    validatePriority(\"setWithPriority\", priority, false);\n    if (ref.key === \".length\" || ref.key === \".keys\") {\n        throw \"setWithPriority failed: \" + ref.key + \" is a read-only object.\";\n    }\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n    repoSetWithPriority(ref._repo, ref._path, value, priority, deferred.wrapCallback(()=>{}));\n    return deferred.promise;\n}\n/**\r\n * Writes multiple values to the Database at once.\r\n *\r\n * The `values` argument contains multiple property-value pairs that will be\r\n * written to the Database together. Each child property can either be a simple\r\n * property (for example, \"name\") or a relative path (for example,\r\n * \"name/first\") from the current location to the data to update.\r\n *\r\n * As opposed to the `set()` method, `update()` can be use to selectively update\r\n * only the referenced properties at the current location (instead of replacing\r\n * all the child properties at the current location).\r\n *\r\n * The effect of the write will be visible immediately, and the corresponding\r\n * events ('value', 'child_added', etc.) will be triggered. Synchronization of\r\n * the data to the Firebase servers will also be started, and the returned\r\n * Promise will resolve when complete. If provided, the `onComplete` callback\r\n * will be called asynchronously after synchronization has finished.\r\n *\r\n * A single `update()` will generate a single \"value\" event at the location\r\n * where the `update()` was performed, regardless of how many children were\r\n * modified.\r\n *\r\n * Note that modifying data with `update()` will cancel any pending\r\n * transactions at that location, so extreme care should be taken if mixing\r\n * `update()` and `transaction()` to modify the same data.\r\n *\r\n * Passing `null` to `update()` will remove the data at this location.\r\n *\r\n * See\r\n * {@link https://firebase.googleblog.com/2015/09/introducing-multi-location-updates-and_86.html | Introducing multi-location updates and more}.\r\n *\r\n * @param ref - The location to write to.\r\n * @param values - Object containing multiple values.\r\n * @returns Resolves when update on server is complete.\r\n */ function update(ref, values) {\n    validateFirebaseMergeDataArg(\"update\", values, ref._path, false);\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n    repoUpdate(ref._repo, ref._path, values, deferred.wrapCallback(()=>{}));\n    return deferred.promise;\n}\n/**\r\n * Gets the most up-to-date result for this query.\r\n *\r\n * @param query - The query to run.\r\n * @returns A `Promise` which resolves to the resulting DataSnapshot if a value is\r\n * available, or rejects if the client is unable to return a value (e.g., if the\r\n * server is unreachable and there is nothing cached).\r\n */ function get(query) {\n    query = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(query);\n    const callbackContext = new CallbackContext(()=>{});\n    const container = new ValueEventRegistration(callbackContext);\n    return repoGetValue(query._repo, query, container).then((node)=>{\n        return new DataSnapshot(node, new ReferenceImpl(query._repo, query._path), query._queryParams.getIndex());\n    });\n}\n/**\r\n * Represents registration for 'value' events.\r\n */ class ValueEventRegistration {\n    constructor(callbackContext){\n        this.callbackContext = callbackContext;\n    }\n    respondsTo(eventType) {\n        return eventType === \"value\";\n    }\n    createEvent(change, query) {\n        const index = query._queryParams.getIndex();\n        return new DataEvent(\"value\", this, new DataSnapshot(change.snapshotNode, new ReferenceImpl(query._repo, query._path), index));\n    }\n    getEventRunner(eventData) {\n        if (eventData.getEventType() === \"cancel\") {\n            return ()=>this.callbackContext.onCancel(eventData.error);\n        } else {\n            return ()=>this.callbackContext.onValue(eventData.snapshot, null);\n        }\n    }\n    createCancelEvent(error, path) {\n        if (this.callbackContext.hasCancelCallback) {\n            return new CancelEvent(this, error, path);\n        } else {\n            return null;\n        }\n    }\n    matches(other) {\n        if (!(other instanceof ValueEventRegistration)) {\n            return false;\n        } else if (!other.callbackContext || !this.callbackContext) {\n            // If no callback specified, we consider it to match any callback.\n            return true;\n        } else {\n            return other.callbackContext.matches(this.callbackContext);\n        }\n    }\n    hasAnyCallback() {\n        return this.callbackContext !== null;\n    }\n}\n/**\r\n * Represents the registration of a child_x event.\r\n */ class ChildEventRegistration {\n    constructor(eventType, callbackContext){\n        this.eventType = eventType;\n        this.callbackContext = callbackContext;\n    }\n    respondsTo(eventType) {\n        let eventToCheck = eventType === \"children_added\" ? \"child_added\" : eventType;\n        eventToCheck = eventToCheck === \"children_removed\" ? \"child_removed\" : eventToCheck;\n        return this.eventType === eventToCheck;\n    }\n    createCancelEvent(error, path) {\n        if (this.callbackContext.hasCancelCallback) {\n            return new CancelEvent(this, error, path);\n        } else {\n            return null;\n        }\n    }\n    createEvent(change, query) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(change.childName != null, \"Child events should have a childName.\");\n        const childRef = child(new ReferenceImpl(query._repo, query._path), change.childName);\n        const index = query._queryParams.getIndex();\n        return new DataEvent(change.type, this, new DataSnapshot(change.snapshotNode, childRef, index), change.prevName);\n    }\n    getEventRunner(eventData) {\n        if (eventData.getEventType() === \"cancel\") {\n            return ()=>this.callbackContext.onCancel(eventData.error);\n        } else {\n            return ()=>this.callbackContext.onValue(eventData.snapshot, eventData.prevName);\n        }\n    }\n    matches(other) {\n        if (other instanceof ChildEventRegistration) {\n            return this.eventType === other.eventType && (!this.callbackContext || !other.callbackContext || this.callbackContext.matches(other.callbackContext));\n        }\n        return false;\n    }\n    hasAnyCallback() {\n        return !!this.callbackContext;\n    }\n}\nfunction addEventListener(query, eventType, callback, cancelCallbackOrListenOptions, options) {\n    let cancelCallback;\n    if (typeof cancelCallbackOrListenOptions === \"object\") {\n        cancelCallback = undefined;\n        options = cancelCallbackOrListenOptions;\n    }\n    if (typeof cancelCallbackOrListenOptions === \"function\") {\n        cancelCallback = cancelCallbackOrListenOptions;\n    }\n    if (options && options.onlyOnce) {\n        const userCallback = callback;\n        const onceCallback = (dataSnapshot, previousChildName)=>{\n            repoRemoveEventCallbackForQuery(query._repo, query, container);\n            userCallback(dataSnapshot, previousChildName);\n        };\n        onceCallback.userCallback = callback.userCallback;\n        onceCallback.context = callback.context;\n        callback = onceCallback;\n    }\n    const callbackContext = new CallbackContext(callback, cancelCallback || undefined);\n    const container = eventType === \"value\" ? new ValueEventRegistration(callbackContext) : new ChildEventRegistration(eventType, callbackContext);\n    repoAddEventCallbackForQuery(query._repo, query, container);\n    return ()=>repoRemoveEventCallbackForQuery(query._repo, query, container);\n}\nfunction onValue(query, callback, cancelCallbackOrListenOptions, options) {\n    return addEventListener(query, \"value\", callback, cancelCallbackOrListenOptions, options);\n}\nfunction onChildAdded(query, callback, cancelCallbackOrListenOptions, options) {\n    return addEventListener(query, \"child_added\", callback, cancelCallbackOrListenOptions, options);\n}\nfunction onChildChanged(query, callback, cancelCallbackOrListenOptions, options) {\n    return addEventListener(query, \"child_changed\", callback, cancelCallbackOrListenOptions, options);\n}\nfunction onChildMoved(query, callback, cancelCallbackOrListenOptions, options) {\n    return addEventListener(query, \"child_moved\", callback, cancelCallbackOrListenOptions, options);\n}\nfunction onChildRemoved(query, callback, cancelCallbackOrListenOptions, options) {\n    return addEventListener(query, \"child_removed\", callback, cancelCallbackOrListenOptions, options);\n}\n/**\r\n * Detaches a callback previously attached with the corresponding `on*()` (`onValue`, `onChildAdded`) listener.\r\n * Note: This is not the recommended way to remove a listener. Instead, please use the returned callback function from\r\n * the respective `on*` callbacks.\r\n *\r\n * Detach a callback previously attached with `on*()`. Calling `off()` on a parent listener\r\n * will not automatically remove listeners registered on child nodes, `off()`\r\n * must also be called on any child listeners to remove the callback.\r\n *\r\n * If a callback is not specified, all callbacks for the specified eventType\r\n * will be removed. Similarly, if no eventType is specified, all callbacks\r\n * for the `Reference` will be removed.\r\n *\r\n * Individual listeners can also be removed by invoking their unsubscribe\r\n * callbacks.\r\n *\r\n * @param query - The query that the listener was registered with.\r\n * @param eventType - One of the following strings: \"value\", \"child_added\",\r\n * \"child_changed\", \"child_removed\", or \"child_moved.\" If omitted, all callbacks\r\n * for the `Reference` will be removed.\r\n * @param callback - The callback function that was passed to `on()` or\r\n * `undefined` to remove all callbacks.\r\n */ function off(query, eventType, callback) {\n    let container = null;\n    const expCallback = callback ? new CallbackContext(callback) : null;\n    if (eventType === \"value\") {\n        container = new ValueEventRegistration(expCallback);\n    } else if (eventType) {\n        container = new ChildEventRegistration(eventType, expCallback);\n    }\n    repoRemoveEventCallbackForQuery(query._repo, query, container);\n}\n/**\r\n * A `QueryConstraint` is used to narrow the set of documents returned by a\r\n * Database query. `QueryConstraint`s are created by invoking {@link endAt},\r\n * {@link endBefore}, {@link startAt}, {@link startAfter}, {@link\r\n * limitToFirst}, {@link limitToLast}, {@link orderByChild},\r\n * {@link orderByChild}, {@link orderByKey} , {@link orderByPriority} ,\r\n * {@link orderByValue}  or {@link equalTo} and\r\n * can then be passed to {@link query} to create a new query instance that\r\n * also contains this `QueryConstraint`.\r\n */ class QueryConstraint {\n}\nclass QueryEndAtConstraint extends QueryConstraint {\n    constructor(_value, _key){\n        super();\n        this._value = _value;\n        this._key = _key;\n        this.type = \"endAt\";\n    }\n    _apply(query) {\n        validateFirebaseDataArg(\"endAt\", this._value, query._path, true);\n        const newParams = queryParamsEndAt(query._queryParams, this._value, this._key);\n        validateLimit(newParams);\n        validateQueryEndpoints(newParams);\n        if (query._queryParams.hasEnd()) {\n            throw new Error(\"endAt: Starting point was already set (by another call to endAt, \" + \"endBefore or equalTo).\");\n        }\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\n    }\n}\n/**\r\n * Creates a `QueryConstraint` with the specified ending point.\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The ending point is inclusive, so children with exactly the specified value\r\n * will be included in the query. The optional key argument can be used to\r\n * further limit the range of the query. If it is specified, then children that\r\n * have exactly the specified value must also have a key name less than or equal\r\n * to the specified key.\r\n *\r\n * You can read more about `endAt()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param value - The value to end at. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to end at, among the children with the previously\r\n * specified priority. This argument is only allowed if ordering by child,\r\n * value, or priority.\r\n */ function endAt(value, key) {\n    validateKey(\"endAt\", \"key\", key, true);\n    return new QueryEndAtConstraint(value, key);\n}\nclass QueryEndBeforeConstraint extends QueryConstraint {\n    constructor(_value, _key){\n        super();\n        this._value = _value;\n        this._key = _key;\n        this.type = \"endBefore\";\n    }\n    _apply(query) {\n        validateFirebaseDataArg(\"endBefore\", this._value, query._path, false);\n        const newParams = queryParamsEndBefore(query._queryParams, this._value, this._key);\n        validateLimit(newParams);\n        validateQueryEndpoints(newParams);\n        if (query._queryParams.hasEnd()) {\n            throw new Error(\"endBefore: Starting point was already set (by another call to endAt, \" + \"endBefore or equalTo).\");\n        }\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\n    }\n}\n/**\r\n * Creates a `QueryConstraint` with the specified ending point (exclusive).\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The ending point is exclusive. If only a value is provided, children\r\n * with a value less than the specified value will be included in the query.\r\n * If a key is specified, then children must have a value less than or equal\r\n * to the specified value and a key name less than the specified key.\r\n *\r\n * @param value - The value to end before. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to end before, among the children with the\r\n * previously specified priority. This argument is only allowed if ordering by\r\n * child, value, or priority.\r\n */ function endBefore(value, key) {\n    validateKey(\"endBefore\", \"key\", key, true);\n    return new QueryEndBeforeConstraint(value, key);\n}\nclass QueryStartAtConstraint extends QueryConstraint {\n    constructor(_value, _key){\n        super();\n        this._value = _value;\n        this._key = _key;\n        this.type = \"startAt\";\n    }\n    _apply(query) {\n        validateFirebaseDataArg(\"startAt\", this._value, query._path, true);\n        const newParams = queryParamsStartAt(query._queryParams, this._value, this._key);\n        validateLimit(newParams);\n        validateQueryEndpoints(newParams);\n        if (query._queryParams.hasStart()) {\n            throw new Error(\"startAt: Starting point was already set (by another call to startAt, \" + \"startBefore or equalTo).\");\n        }\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\n    }\n}\n/**\r\n * Creates a `QueryConstraint` with the specified starting point.\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The starting point is inclusive, so children with exactly the specified value\r\n * will be included in the query. The optional key argument can be used to\r\n * further limit the range of the query. If it is specified, then children that\r\n * have exactly the specified value must also have a key name greater than or\r\n * equal to the specified key.\r\n *\r\n * You can read more about `startAt()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param value - The value to start at. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to start at. This argument is only allowed if\r\n * ordering by child, value, or priority.\r\n */ function startAt(value = null, key) {\n    validateKey(\"startAt\", \"key\", key, true);\n    return new QueryStartAtConstraint(value, key);\n}\nclass QueryStartAfterConstraint extends QueryConstraint {\n    constructor(_value, _key){\n        super();\n        this._value = _value;\n        this._key = _key;\n        this.type = \"startAfter\";\n    }\n    _apply(query) {\n        validateFirebaseDataArg(\"startAfter\", this._value, query._path, false);\n        const newParams = queryParamsStartAfter(query._queryParams, this._value, this._key);\n        validateLimit(newParams);\n        validateQueryEndpoints(newParams);\n        if (query._queryParams.hasStart()) {\n            throw new Error(\"startAfter: Starting point was already set (by another call to startAt, \" + \"startAfter, or equalTo).\");\n        }\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\n    }\n}\n/**\r\n * Creates a `QueryConstraint` with the specified starting point (exclusive).\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The starting point is exclusive. If only a value is provided, children\r\n * with a value greater than the specified value will be included in the query.\r\n * If a key is specified, then children must have a value greater than or equal\r\n * to the specified value and a a key name greater than the specified key.\r\n *\r\n * @param value - The value to start after. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to start after. This argument is only allowed if\r\n * ordering by child, value, or priority.\r\n */ function startAfter(value, key) {\n    validateKey(\"startAfter\", \"key\", key, true);\n    return new QueryStartAfterConstraint(value, key);\n}\nclass QueryLimitToFirstConstraint extends QueryConstraint {\n    constructor(_limit){\n        super();\n        this._limit = _limit;\n        this.type = \"limitToFirst\";\n    }\n    _apply(query) {\n        if (query._queryParams.hasLimit()) {\n            throw new Error(\"limitToFirst: Limit was already set (by another call to limitToFirst \" + \"or limitToLast).\");\n        }\n        return new QueryImpl(query._repo, query._path, queryParamsLimitToFirst(query._queryParams, this._limit), query._orderByCalled);\n    }\n}\n/**\r\n * Creates a new `QueryConstraint` that if limited to the first specific number\r\n * of children.\r\n *\r\n * The `limitToFirst()` method is used to set a maximum number of children to be\r\n * synced for a given callback. If we set a limit of 100, we will initially only\r\n * receive up to 100 `child_added` events. If we have fewer than 100 messages\r\n * stored in our Database, a `child_added` event will fire for each message.\r\n * However, if we have over 100 messages, we will only receive a `child_added`\r\n * event for the first 100 ordered messages. As items change, we will receive\r\n * `child_removed` events for each item that drops out of the active list so\r\n * that the total number stays at 100.\r\n *\r\n * You can read more about `limitToFirst()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param limit - The maximum number of nodes to include in this query.\r\n */ function limitToFirst(limit) {\n    if (typeof limit !== \"number\" || Math.floor(limit) !== limit || limit <= 0) {\n        throw new Error(\"limitToFirst: First argument must be a positive integer.\");\n    }\n    return new QueryLimitToFirstConstraint(limit);\n}\nclass QueryLimitToLastConstraint extends QueryConstraint {\n    constructor(_limit){\n        super();\n        this._limit = _limit;\n        this.type = \"limitToLast\";\n    }\n    _apply(query) {\n        if (query._queryParams.hasLimit()) {\n            throw new Error(\"limitToLast: Limit was already set (by another call to limitToFirst \" + \"or limitToLast).\");\n        }\n        return new QueryImpl(query._repo, query._path, queryParamsLimitToLast(query._queryParams, this._limit), query._orderByCalled);\n    }\n}\n/**\r\n * Creates a new `QueryConstraint` that is limited to return only the last\r\n * specified number of children.\r\n *\r\n * The `limitToLast()` method is used to set a maximum number of children to be\r\n * synced for a given callback. If we set a limit of 100, we will initially only\r\n * receive up to 100 `child_added` events. If we have fewer than 100 messages\r\n * stored in our Database, a `child_added` event will fire for each message.\r\n * However, if we have over 100 messages, we will only receive a `child_added`\r\n * event for the last 100 ordered messages. As items change, we will receive\r\n * `child_removed` events for each item that drops out of the active list so\r\n * that the total number stays at 100.\r\n *\r\n * You can read more about `limitToLast()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param limit - The maximum number of nodes to include in this query.\r\n */ function limitToLast(limit) {\n    if (typeof limit !== \"number\" || Math.floor(limit) !== limit || limit <= 0) {\n        throw new Error(\"limitToLast: First argument must be a positive integer.\");\n    }\n    return new QueryLimitToLastConstraint(limit);\n}\nclass QueryOrderByChildConstraint extends QueryConstraint {\n    constructor(_path){\n        super();\n        this._path = _path;\n        this.type = \"orderByChild\";\n    }\n    _apply(query) {\n        validateNoPreviousOrderByCall(query, \"orderByChild\");\n        const parsedPath = new Path(this._path);\n        if (pathIsEmpty(parsedPath)) {\n            throw new Error(\"orderByChild: cannot pass in empty path. Use orderByValue() instead.\");\n        }\n        const index = new PathIndex(parsedPath);\n        const newParams = queryParamsOrderBy(query._queryParams, index);\n        validateQueryEndpoints(newParams);\n        return new QueryImpl(query._repo, query._path, newParams, /*orderByCalled=*/ true);\n    }\n}\n/**\r\n * Creates a new `QueryConstraint` that orders by the specified child key.\r\n *\r\n * Queries can only order by one key at a time. Calling `orderByChild()`\r\n * multiple times on the same query is an error.\r\n *\r\n * Firebase queries allow you to order your data by any child key on the fly.\r\n * However, if you know in advance what your indexes will be, you can define\r\n * them via the .indexOn rule in your Security Rules for better performance. See\r\n * the{@link https://firebase.google.com/docs/database/security/indexing-data}\r\n * rule for more information.\r\n *\r\n * You can read more about `orderByChild()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.\r\n *\r\n * @param path - The path to order by.\r\n */ function orderByChild(path) {\n    if (path === \"$key\") {\n        throw new Error('orderByChild: \"$key\" is invalid.  Use orderByKey() instead.');\n    } else if (path === \"$priority\") {\n        throw new Error('orderByChild: \"$priority\" is invalid.  Use orderByPriority() instead.');\n    } else if (path === \"$value\") {\n        throw new Error('orderByChild: \"$value\" is invalid.  Use orderByValue() instead.');\n    }\n    validatePathString(\"orderByChild\", \"path\", path, false);\n    return new QueryOrderByChildConstraint(path);\n}\nclass QueryOrderByKeyConstraint extends QueryConstraint {\n    constructor(){\n        super(...arguments);\n        this.type = \"orderByKey\";\n    }\n    _apply(query) {\n        validateNoPreviousOrderByCall(query, \"orderByKey\");\n        const newParams = queryParamsOrderBy(query._queryParams, KEY_INDEX);\n        validateQueryEndpoints(newParams);\n        return new QueryImpl(query._repo, query._path, newParams, /*orderByCalled=*/ true);\n    }\n}\n/**\r\n * Creates a new `QueryConstraint` that orders by the key.\r\n *\r\n * Sorts the results of a query by their (ascending) key values.\r\n *\r\n * You can read more about `orderByKey()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.\r\n */ function orderByKey() {\n    return new QueryOrderByKeyConstraint();\n}\nclass QueryOrderByPriorityConstraint extends QueryConstraint {\n    constructor(){\n        super(...arguments);\n        this.type = \"orderByPriority\";\n    }\n    _apply(query) {\n        validateNoPreviousOrderByCall(query, \"orderByPriority\");\n        const newParams = queryParamsOrderBy(query._queryParams, PRIORITY_INDEX);\n        validateQueryEndpoints(newParams);\n        return new QueryImpl(query._repo, query._path, newParams, /*orderByCalled=*/ true);\n    }\n}\n/**\r\n * Creates a new `QueryConstraint` that orders by priority.\r\n *\r\n * Applications need not use priority but can order collections by\r\n * ordinary properties (see\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}\r\n * for alternatives to priority.\r\n */ function orderByPriority() {\n    return new QueryOrderByPriorityConstraint();\n}\nclass QueryOrderByValueConstraint extends QueryConstraint {\n    constructor(){\n        super(...arguments);\n        this.type = \"orderByValue\";\n    }\n    _apply(query) {\n        validateNoPreviousOrderByCall(query, \"orderByValue\");\n        const newParams = queryParamsOrderBy(query._queryParams, VALUE_INDEX);\n        validateQueryEndpoints(newParams);\n        return new QueryImpl(query._repo, query._path, newParams, /*orderByCalled=*/ true);\n    }\n}\n/**\r\n * Creates a new `QueryConstraint` that orders by value.\r\n *\r\n * If the children of a query are all scalar values (string, number, or\r\n * boolean), you can order the results by their (ascending) values.\r\n *\r\n * You can read more about `orderByValue()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.\r\n */ function orderByValue() {\n    return new QueryOrderByValueConstraint();\n}\nclass QueryEqualToValueConstraint extends QueryConstraint {\n    constructor(_value, _key){\n        super();\n        this._value = _value;\n        this._key = _key;\n        this.type = \"equalTo\";\n    }\n    _apply(query) {\n        validateFirebaseDataArg(\"equalTo\", this._value, query._path, false);\n        if (query._queryParams.hasStart()) {\n            throw new Error(\"equalTo: Starting point was already set (by another call to startAt/startAfter or \" + \"equalTo).\");\n        }\n        if (query._queryParams.hasEnd()) {\n            throw new Error(\"equalTo: Ending point was already set (by another call to endAt/endBefore or \" + \"equalTo).\");\n        }\n        return new QueryEndAtConstraint(this._value, this._key)._apply(new QueryStartAtConstraint(this._value, this._key)._apply(query));\n    }\n}\n/**\r\n * Creates a `QueryConstraint` that includes children that match the specified\r\n * value.\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The optional key argument can be used to further limit the range of the\r\n * query. If it is specified, then children that have exactly the specified\r\n * value must also have exactly the specified key as their key name. This can be\r\n * used to filter result sets with many matches for the same value.\r\n *\r\n * You can read more about `equalTo()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param value - The value to match for. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to start at, among the children with the\r\n * previously specified priority. This argument is only allowed if ordering by\r\n * child, value, or priority.\r\n */ function equalTo(value, key) {\n    validateKey(\"equalTo\", \"key\", key, true);\n    return new QueryEqualToValueConstraint(value, key);\n}\n/**\r\n * Creates a new immutable instance of `Query` that is extended to also include\r\n * additional query constraints.\r\n *\r\n * @param query - The Query instance to use as a base for the new constraints.\r\n * @param queryConstraints - The list of `QueryConstraint`s to apply.\r\n * @throws if any of the provided query constraints cannot be combined with the\r\n * existing or new constraints.\r\n */ function query(query1, ...queryConstraints) {\n    let queryImpl = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(query1);\n    for (const constraint of queryConstraints){\n        queryImpl = constraint._apply(queryImpl);\n    }\n    return queryImpl;\n}\n/**\r\n * Define reference constructor in various modules\r\n *\r\n * We are doing this here to avoid several circular\r\n * dependency issues\r\n */ syncPointSetReferenceConstructor(ReferenceImpl);\nsyncTreeSetReferenceConstructor(ReferenceImpl);\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * This variable is also defined in the firebase Node.js Admin SDK. Before\r\n * modifying this definition, consult the definition in:\r\n *\r\n * https://github.com/firebase/firebase-admin-node\r\n *\r\n * and make sure the two are consistent.\r\n */ const FIREBASE_DATABASE_EMULATOR_HOST_VAR = \"FIREBASE_DATABASE_EMULATOR_HOST\";\n/**\r\n * Creates and caches `Repo` instances.\r\n */ const repos = {};\n/**\r\n * If true, any new `Repo` will be created to use `ReadonlyRestClient` (for testing purposes).\r\n */ let useRestClient = false;\n/**\r\n * Update an existing `Repo` in place to point to a new host/port.\r\n */ function repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider) {\n    repo.repoInfo_ = new RepoInfo(`${host}:${port}`, /* secure= */ false, repo.repoInfo_.namespace, repo.repoInfo_.webSocketOnly, repo.repoInfo_.nodeAdmin, repo.repoInfo_.persistenceKey, repo.repoInfo_.includeNamespaceInQueryParams, /*isUsingEmulator=*/ true);\n    if (tokenProvider) {\n        repo.authTokenProvider_ = tokenProvider;\n    }\n}\n/**\r\n * This function should only ever be called to CREATE a new database instance.\r\n * @internal\r\n */ function repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url, nodeAdmin) {\n    let dbUrl = url || app.options.databaseURL;\n    if (dbUrl === undefined) {\n        if (!app.options.projectId) {\n            fatal(\"Can't determine Firebase Database URL. Be sure to include \" + \" a Project ID when calling firebase.initializeApp().\");\n        }\n        log(\"Using default host for project \", app.options.projectId);\n        dbUrl = `${app.options.projectId}-default-rtdb.firebaseio.com`;\n    }\n    let parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);\n    let repoInfo = parsedUrl.repoInfo;\n    let isEmulator;\n    let dbEmulatorHost = undefined;\n    if (typeof process !== \"undefined\" && process.env) {\n        dbEmulatorHost = process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];\n    }\n    if (dbEmulatorHost) {\n        isEmulator = true;\n        dbUrl = `http://${dbEmulatorHost}?ns=${repoInfo.namespace}`;\n        parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);\n        repoInfo = parsedUrl.repoInfo;\n    } else {\n        isEmulator = !parsedUrl.repoInfo.secure;\n    }\n    const authTokenProvider = nodeAdmin && isEmulator ? new EmulatorTokenProvider(EmulatorTokenProvider.OWNER) : new FirebaseAuthTokenProvider(app.name, app.options, authProvider);\n    validateUrl(\"Invalid Firebase Database URL\", parsedUrl);\n    if (!pathIsEmpty(parsedUrl.path)) {\n        fatal(\"Database URL must point to the root of a Firebase Database \" + \"(not including a child path).\");\n    }\n    const repo = repoManagerCreateRepo(repoInfo, app, authTokenProvider, new AppCheckTokenProvider(app.name, appCheckProvider));\n    return new Database(repo, app);\n}\n/**\r\n * Remove the repo and make sure it is disconnected.\r\n *\r\n */ function repoManagerDeleteRepo(repo, appName) {\n    const appRepos = repos[appName];\n    // This should never happen...\n    if (!appRepos || appRepos[repo.key] !== repo) {\n        fatal(`Database ${appName}(${repo.repoInfo_}) has already been deleted.`);\n    }\n    repoInterrupt(repo);\n    delete appRepos[repo.key];\n}\n/**\r\n * Ensures a repo doesn't already exist and then creates one using the\r\n * provided app.\r\n *\r\n * @param repoInfo - The metadata about the Repo\r\n * @returns The Repo object for the specified server / repoName.\r\n */ function repoManagerCreateRepo(repoInfo, app, authTokenProvider, appCheckProvider) {\n    let appRepos = repos[app.name];\n    if (!appRepos) {\n        appRepos = {};\n        repos[app.name] = appRepos;\n    }\n    let repo = appRepos[repoInfo.toURLString()];\n    if (repo) {\n        fatal(\"Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.\");\n    }\n    repo = new Repo(repoInfo, useRestClient, authTokenProvider, appCheckProvider);\n    appRepos[repoInfo.toURLString()] = repo;\n    return repo;\n}\n/**\r\n * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.\r\n */ function repoManagerForceRestClient(forceRestClient) {\n    useRestClient = forceRestClient;\n}\n/**\r\n * Class representing a Firebase Realtime Database.\r\n */ class Database {\n    /** @hideconstructor */ constructor(_repoInternal, /** The {@link @firebase/app#FirebaseApp} associated with this Realtime Database instance. */ app){\n        this._repoInternal = _repoInternal;\n        this.app = app;\n        /** Represents a `Database` instance. */ this[\"type\"] = \"database\";\n        /** Track if the instance has been used (root or repo accessed) */ this._instanceStarted = false;\n    }\n    get _repo() {\n        if (!this._instanceStarted) {\n            repoStart(this._repoInternal, this.app.options.appId, this.app.options[\"databaseAuthVariableOverride\"]);\n            this._instanceStarted = true;\n        }\n        return this._repoInternal;\n    }\n    get _root() {\n        if (!this._rootInternal) {\n            this._rootInternal = new ReferenceImpl(this._repo, newEmptyPath());\n        }\n        return this._rootInternal;\n    }\n    _delete() {\n        if (this._rootInternal !== null) {\n            repoManagerDeleteRepo(this._repo, this.app.name);\n            this._repoInternal = null;\n            this._rootInternal = null;\n        }\n        return Promise.resolve();\n    }\n    _checkNotDeleted(apiName) {\n        if (this._rootInternal === null) {\n            fatal(\"Cannot call \" + apiName + \" on a deleted database.\");\n        }\n    }\n}\nfunction checkTransportInit() {\n    if (TransportManager.IS_TRANSPORT_INITIALIZED) {\n        warn(\"Transport has already been initialized. Please call this function before calling ref or setting up a listener\");\n    }\n}\n/**\r\n * Force the use of websockets instead of longPolling.\r\n */ function forceWebSockets() {\n    checkTransportInit();\n    BrowserPollConnection.forceDisallow();\n}\n/**\r\n * Force the use of longPolling instead of websockets. This will be ignored if websocket protocol is used in databaseURL.\r\n */ function forceLongPolling() {\n    checkTransportInit();\n    WebSocketConnection.forceDisallow();\n    BrowserPollConnection.forceAllow();\n}\n/**\r\n * Returns the instance of the Realtime Database SDK that is associated\r\n * with the provided {@link @firebase/app#FirebaseApp}. Initializes a new instance with\r\n * with default settings if no instance exists or if the existing instance uses\r\n * a custom database URL.\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} instance that the returned Realtime\r\n * Database instance is associated with.\r\n * @param url - The URL of the Realtime Database instance to connect to. If not\r\n * provided, the SDK connects to the default instance of the Firebase App.\r\n * @returns The `Database` instance of the provided app.\r\n */ function getDatabase(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_3__.getApp)(), url) {\n    const db = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_3__._getProvider)(app, \"database\").getImmediate({\n        identifier: url\n    });\n    if (!db._instanceStarted) {\n        const emulator = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getDefaultEmulatorHostnameAndPort)(\"database\");\n        if (emulator) {\n            connectDatabaseEmulator(db, ...emulator);\n        }\n    }\n    return db;\n}\n/**\r\n * Modify the provided instance to communicate with the Realtime Database\r\n * emulator.\r\n *\r\n * <p>Note: This method must be called before performing any other operation.\r\n *\r\n * @param db - The instance to modify.\r\n * @param host - The emulator host (ex: localhost)\r\n * @param port - The emulator port (ex: 8080)\r\n * @param options.mockUserToken - the mock auth token to use for unit testing Security Rules\r\n */ function connectDatabaseEmulator(db, host, port, options = {}) {\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(db);\n    db._checkNotDeleted(\"useEmulator\");\n    if (db._instanceStarted) {\n        fatal(\"Cannot call useEmulator() after instance has already been initialized.\");\n    }\n    const repo = db._repoInternal;\n    let tokenProvider = undefined;\n    if (repo.repoInfo_.nodeAdmin) {\n        if (options.mockUserToken) {\n            fatal('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the \"firebase\" package instead of \"firebase-admin\".');\n        }\n        tokenProvider = new EmulatorTokenProvider(EmulatorTokenProvider.OWNER);\n    } else if (options.mockUserToken) {\n        const token = typeof options.mockUserToken === \"string\" ? options.mockUserToken : (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.createMockUserToken)(options.mockUserToken, db.app.options.projectId);\n        tokenProvider = new EmulatorTokenProvider(token);\n    }\n    // Modify the repo to apply emulator settings\n    repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider);\n}\n/**\r\n * Disconnects from the server (all Database operations will be completed\r\n * offline).\r\n *\r\n * The client automatically maintains a persistent connection to the Database\r\n * server, which will remain active indefinitely and reconnect when\r\n * disconnected. However, the `goOffline()` and `goOnline()` methods may be used\r\n * to control the client connection in cases where a persistent connection is\r\n * undesirable.\r\n *\r\n * While offline, the client will no longer receive data updates from the\r\n * Database. However, all Database operations performed locally will continue to\r\n * immediately fire events, allowing your application to continue behaving\r\n * normally. Additionally, each operation performed locally will automatically\r\n * be queued and retried upon reconnection to the Database server.\r\n *\r\n * To reconnect to the Database and begin receiving remote events, see\r\n * `goOnline()`.\r\n *\r\n * @param db - The instance to disconnect.\r\n */ function goOffline(db) {\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(db);\n    db._checkNotDeleted(\"goOffline\");\n    repoInterrupt(db._repo);\n}\n/**\r\n * Reconnects to the server and synchronizes the offline Database state\r\n * with the server state.\r\n *\r\n * This method should be used after disabling the active connection with\r\n * `goOffline()`. Once reconnected, the client will transmit the proper data\r\n * and fire the appropriate events so that your client \"catches up\"\r\n * automatically.\r\n *\r\n * @param db - The instance to reconnect.\r\n */ function goOnline(db) {\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(db);\n    db._checkNotDeleted(\"goOnline\");\n    repoResume(db._repo);\n}\nfunction enableLogging(logger, persistent) {\n    enableLogging$1(logger, persistent);\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function registerDatabase(variant) {\n    setSDKVersion(_firebase_app__WEBPACK_IMPORTED_MODULE_3__.SDK_VERSION);\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_3__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_4__.Component(\"database\", (container, { instanceIdentifier: url })=>{\n        const app = container.getProvider(\"app\").getImmediate();\n        const authProvider = container.getProvider(\"auth-internal\");\n        const appCheckProvider = container.getProvider(\"app-check-internal\");\n        return repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url);\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */ ).setMultipleInstances(true));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_3__.registerVersion)(name, version, variant);\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_3__.registerVersion)(name, version, \"esm2017\");\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const SERVER_TIMESTAMP = {\n    \".sv\": \"timestamp\"\n};\n/**\r\n * Returns a placeholder value for auto-populating the current timestamp (time\r\n * since the Unix epoch, in milliseconds) as determined by the Firebase\r\n * servers.\r\n */ function serverTimestamp() {\n    return SERVER_TIMESTAMP;\n}\n/**\r\n * Returns a placeholder value that can be used to atomically increment the\r\n * current database value by the provided delta.\r\n *\r\n * @param delta - the amount to modify the current value atomically.\r\n * @returns A placeholder value for modifying data atomically server-side.\r\n */ function increment(delta) {\n    return {\n        \".sv\": {\n            \"increment\": delta\n        }\n    };\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A type for the resolve value of {@link runTransaction}.\r\n */ class TransactionResult {\n    /** @hideconstructor */ constructor(/** Whether the transaction was successfully committed. */ committed, /** The resulting data snapshot. */ snapshot){\n        this.committed = committed;\n        this.snapshot = snapshot;\n    }\n    /** Returns a JSON-serializable representation of this object. */ toJSON() {\n        return {\n            committed: this.committed,\n            snapshot: this.snapshot.toJSON()\n        };\n    }\n}\n/**\r\n * Atomically modifies the data at this location.\r\n *\r\n * Atomically modify the data at this location. Unlike a normal `set()`, which\r\n * just overwrites the data regardless of its previous value, `runTransaction()` is\r\n * used to modify the existing value to a new value, ensuring there are no\r\n * conflicts with other clients writing to the same location at the same time.\r\n *\r\n * To accomplish this, you pass `runTransaction()` an update function which is\r\n * used to transform the current value into a new value. If another client\r\n * writes to the location before your new value is successfully written, your\r\n * update function will be called again with the new current value, and the\r\n * write will be retried. This will happen repeatedly until your write succeeds\r\n * without conflict or you abort the transaction by not returning a value from\r\n * your update function.\r\n *\r\n * Note: Modifying data with `set()` will cancel any pending transactions at\r\n * that location, so extreme care should be taken if mixing `set()` and\r\n * `runTransaction()` to update the same data.\r\n *\r\n * Note: When using transactions with Security and Firebase Rules in place, be\r\n * aware that a client needs `.read` access in addition to `.write` access in\r\n * order to perform a transaction. This is because the client-side nature of\r\n * transactions requires the client to read the data in order to transactionally\r\n * update it.\r\n *\r\n * @param ref - The location to atomically modify.\r\n * @param transactionUpdate - A developer-supplied function which will be passed\r\n * the current data stored at this location (as a JavaScript object). The\r\n * function should return the new value it would like written (as a JavaScript\r\n * object). If `undefined` is returned (i.e. you return with no arguments) the\r\n * transaction will be aborted and the data at this location will not be\r\n * modified.\r\n * @param options - An options object to configure transactions.\r\n * @returns A `Promise` that can optionally be used instead of the `onComplete`\r\n * callback to handle success and failure.\r\n */ function runTransaction(ref, // eslint-disable-next-line @typescript-eslint/no-explicit-any\ntransactionUpdate, options) {\n    var _a;\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    validateWritablePath(\"Reference.transaction\", ref._path);\n    if (ref.key === \".length\" || ref.key === \".keys\") {\n        throw \"Reference.transaction failed: \" + ref.key + \" is a read-only object.\";\n    }\n    const applyLocally = (_a = options === null || options === void 0 ? void 0 : options.applyLocally) !== null && _a !== void 0 ? _a : true;\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n    const promiseComplete = (error, committed, node)=>{\n        let dataSnapshot = null;\n        if (error) {\n            deferred.reject(error);\n        } else {\n            dataSnapshot = new DataSnapshot(node, new ReferenceImpl(ref._repo, ref._path), PRIORITY_INDEX);\n            deferred.resolve(new TransactionResult(committed, dataSnapshot));\n        }\n    };\n    // Add a watch to make sure we get server updates.\n    const unwatcher = onValue(ref, ()=>{});\n    repoStartTransaction(ref._repo, ref._path, transactionUpdate, promiseComplete, unwatcher, applyLocally);\n    return deferred.promise;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ PersistentConnection;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nPersistentConnection.prototype.simpleListen = function(pathString, onComplete) {\n    this.sendRequest(\"q\", {\n        p: pathString\n    }, onComplete);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nPersistentConnection.prototype.echo = function(data, onEcho) {\n    this.sendRequest(\"echo\", {\n        d: data\n    }, onEcho);\n};\n// RealTimeConnection properties that we use in tests.\nConnection;\n/**\r\n * @internal\r\n */ const hijackHash = function(newHash) {\n    const oldPut = PersistentConnection.prototype.put;\n    PersistentConnection.prototype.put = function(pathString, data, onComplete, hash) {\n        if (hash !== undefined) {\n            hash = newHash();\n        }\n        oldPut.call(this, pathString, data, onComplete, hash);\n    };\n    return function() {\n        PersistentConnection.prototype.put = oldPut;\n    };\n};\nRepoInfo;\n/**\r\n * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.\r\n * @internal\r\n */ const forceRestClient = function(forceRestClient) {\n    repoManagerForceRestClient(forceRestClient);\n};\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Used by console to create a database based on the app,\r\n * passed database URL and a custom auth implementation.\r\n * @internal\r\n * @param app - A valid FirebaseApp-like object\r\n * @param url - A valid Firebase databaseURL\r\n * @param version - custom version e.g. firebase-admin version\r\n * @param customAppCheckImpl - custom app check implementation\r\n * @param customAuthImpl - custom auth implementation\r\n */ function _initStandalone({ app, url, version, customAuthImpl, customAppCheckImpl, nodeAdmin = false }) {\n    setSDKVersion(version);\n    /**\r\n     * ComponentContainer('database-standalone') is just a placeholder that doesn't perform\r\n     * any actual function.\r\n     */ const componentContainer = new _firebase_component__WEBPACK_IMPORTED_MODULE_4__.ComponentContainer(\"database-standalone\");\n    const authProvider = new _firebase_component__WEBPACK_IMPORTED_MODULE_4__.Provider(\"auth-internal\", componentContainer);\n    let appCheckProvider;\n    if (customAppCheckImpl) {\n        appCheckProvider = new _firebase_component__WEBPACK_IMPORTED_MODULE_4__.Provider(\"app-check-internal\", componentContainer);\n        appCheckProvider.setComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_4__.Component(\"app-check-internal\", ()=>customAppCheckImpl, \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n    }\n    authProvider.setComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_4__.Component(\"auth-internal\", ()=>customAuthImpl, \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n    return repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url, nodeAdmin);\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ setWebSocketImpl(faye_websocket__WEBPACK_IMPORTED_MODULE_0__.Client);\nregisterDatabase(\"node\");\n //# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3Qvbm9kZS1lc20vaW5kZXgubm9kZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDaVU7QUFDcFQ7QUFDb0U7QUFDMUM7QUFFOUU7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTXFDLG1CQUFtQjtBQUN6QixNQUFNQyxnQkFBZ0I7QUFDdEIsTUFBTUMsMEJBQTBCO0FBQ2hDLE1BQU1DLGdCQUFnQjtBQUN0QixNQUFNQyxZQUFZO0FBQ2xCLDhFQUE4RTtBQUM5RSwyQkFBMkI7QUFDM0IsTUFBTUMsa0JBQWtCO0FBQ3hCLE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyx1QkFBdUI7QUFDN0IsTUFBTUMsd0JBQXdCO0FBQzlCLE1BQU1DLFlBQVk7QUFDbEIsTUFBTUMsZUFBZTtBQUVyQjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Ozs7Ozs7Q0FRQyxHQUNELE1BQU1DO0lBQ0Y7O0tBRUMsR0FDREMsWUFBWUMsV0FBVyxDQUFFO1FBQ3JCLElBQUksQ0FBQ0EsV0FBVyxHQUFHQTtRQUNuQixzRUFBc0U7UUFDdEUsSUFBSSxDQUFDQyxPQUFPLEdBQUc7SUFDbkI7SUFDQTs7O0tBR0MsR0FDREMsSUFBSUMsR0FBRyxFQUFFQyxLQUFLLEVBQUU7UUFDWixJQUFJQSxTQUFTLE1BQU07WUFDZixJQUFJLENBQUNKLFdBQVcsQ0FBQ0ssVUFBVSxDQUFDLElBQUksQ0FBQ0MsYUFBYSxDQUFDSDtRQUNuRCxPQUNLO1lBQ0QsSUFBSSxDQUFDSCxXQUFXLENBQUNPLE9BQU8sQ0FBQyxJQUFJLENBQUNELGFBQWEsQ0FBQ0gsTUFBTXBELHlEQUFTQSxDQUFDcUQ7UUFDaEU7SUFDSjtJQUNBOztLQUVDLEdBQ0RJLElBQUlMLEdBQUcsRUFBRTtRQUNMLE1BQU1NLFlBQVksSUFBSSxDQUFDVCxX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a0JBQWtCLFNBQVVBLGVBQWU7SUFDN0NELDJCQUEyQkM7QUFDL0I7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTb0MsZ0JBQWdCLEVBQUVsRCxHQUFHLEVBQUV6MkMsR0FBRyxFQUFFak4sT0FBTyxFQUFFNm1ELGNBQWMsRUFBRUMsa0JBQWtCLEVBQUUzb0QsWUFBWSxLQUFLLEVBQUU7SUFDakc0QixjQUFjQztJQUNkOzs7S0FHQyxHQUNELE1BQU0rbUQscUJBQXFCLElBQUl4ekQsbUVBQWtCQSxDQUFDO0lBQ2xELE1BQU1vd0QsZUFBZSxJQUFJbndELHlEQUFRQSxDQUFDLGlCQUFpQnV6RDtJQUNuRCxJQUFJL2hEO0lBQ0osSUFBSThoRCxvQkFBb0I7UUFDcEI5aEQsbUJBQW1CLElBQUl4Uix5REFBUUEsQ0FBQyxzQkFBc0J1ekQ7UUFDdEQvaEQsaUJBQWlCZ2lELFlBQVksQ0FBQyxJQUFJMXpELDBEQUFTQSxDQUFDLHNCQUFzQixJQUFNd3pELG9CQUFvQixVQUFVLHlCQUF5QjtJQUNuSTtJQUNBbkQsYUFBYXFELFlBQVksQ0FBQyxJQUFJMXpELDBEQUFTQSxDQUFDLGlCQUFpQixJQUFNdXpELGdCQUFnQixVQUFVLHlCQUF5QjtJQUNsSCxPQUFPcEQsMkJBQTJCQyxLQUFLQyxjQUFjMytDLGtCQUFrQmlJLEtBQUs5TztBQUNoRjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEbUMsaUJBQWlCbFAsa0RBQWdCO0FBQ2pDcTBELGlCQUFpQjtBQUUyNEIsQ0FDNTVCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZyZWUtbmV4dGpzLWFkbWluLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcz8xNzg3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBXZWJzb2NrZXQgZnJvbSAnZmF5ZS13ZWJzb2NrZXQnO1xuaW1wb3J0IHsgc3RyaW5naWZ5LCBqc29uRXZhbCwgY29udGFpbnMsIGFzc2VydCwgaXNOb2RlU2RrLCBzdHJpbmdUb0J5dGVBcnJheSwgU2hhMSwgYmFzZTY0LCBkZWVwQ29weSwgYmFzZTY0RW5jb2RlLCBpc01vYmlsZUNvcmRvdmEsIHN0cmluZ0xlbmd0aCwgRGVmZXJyZWQsIHNhZmVHZXQsIGlzQWRtaW4sIGlzVmFsaWRGb3JtYXQsIGlzRW1wdHksIGlzUmVhY3ROYXRpdmUsIGFzc2VydGlvbkVycm9yLCBtYXAsIHF1ZXJ5c3RyaW5nLCBlcnJvclByZWZpeCwgZ2V0TW9kdWxhckluc3RhbmNlLCBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQsIGNyZWF0ZU1vY2tVc2VyVG9rZW4gfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBMb2dnZXIsIExvZ0xldmVsIH0gZnJvbSAnQGZpcmViYXNlL2xvZ2dlcic7XG5pbXBvcnQgeyBfZ2V0UHJvdmlkZXIsIGdldEFwcCwgU0RLX1ZFUlNJT04gYXMgU0RLX1ZFUlNJT04kMSwgX3JlZ2lzdGVyQ29tcG9uZW50LCByZWdpc3RlclZlcnNpb24gfSBmcm9tICdAZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50Q29udGFpbmVyLCBQcm92aWRlciB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBQUk9UT0NPTF9WRVJTSU9OID0gJzUnO1xyXG5jb25zdCBWRVJTSU9OX1BBUkFNID0gJ3YnO1xyXG5jb25zdCBUUkFOU1BPUlRfU0VTU0lPTl9QQVJBTSA9ICdzJztcclxuY29uc3QgUkVGRVJFUl9QQVJBTSA9ICdyJztcclxuY29uc3QgRk9SR0VfUkVGID0gJ2YnO1xyXG4vLyBNYXRjaGVzIGNvbnNvbGUuZmlyZWJhc2UuZ29vZ2xlLmNvbSwgZmlyZWJhc2UtY29uc29sZS0qLmNvcnAuZ29vZ2xlLmNvbSBhbmRcclxuLy8gZmlyZWJhc2UuY29ycC5nb29nbGUuY29tXHJcbmNvbnN0IEZPUkdFX0RPTUFJTl9SRSA9IC8oY29uc29sZVxcLmZpcmViYXNlfGZpcmViYXNlLWNvbnNvbGUtXFx3K1xcLmNvcnB8ZmlyZWJhc2VcXC5jb3JwKVxcLmdvb2dsZVxcLmNvbS87XHJcbmNvbnN0IExBU1RfU0VTU0lPTl9QQVJBTSA9ICdscyc7XHJcbmNvbnN0IEFQUExJQ0FUSU9OX0lEX1BBUkFNID0gJ3AnO1xyXG5jb25zdCBBUFBfQ0hFQ0tfVE9LRU5fUEFSQU0gPSAnYWMnO1xyXG5jb25zdCBXRUJTT0NLRVQgPSAnd2Vic29ja2V0JztcclxuY29uc3QgTE9OR19QT0xMSU5HID0gJ2xvbmdfcG9sbGluZyc7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBXcmFwcyBhIERPTSBTdG9yYWdlIG9iamVjdCBhbmQ6XHJcbiAqIC0gYXV0b21hdGljYWxseSBlbmNvZGUgb2JqZWN0cyBhcyBKU09OIHN0cmluZ3MgYmVmb3JlIHN0b3JpbmcgdGhlbSB0byBhbGxvdyB1cyB0byBzdG9yZSBhcmJpdHJhcnkgdHlwZXMuXHJcbiAqIC0gcHJlZml4ZXMgbmFtZXMgd2l0aCBcImZpcmViYXNlOlwiIHRvIGF2b2lkIGNvbGxpc2lvbnMgd2l0aCBhcHAgZGF0YS5cclxuICpcclxuICogV2UgYXV0b21hdGljYWxseSAoc2VlIHN0b3JhZ2UuanMpIGNyZWF0ZSB0d28gc3VjaCB3cmFwcGVycywgb25lIGZvciBzZXNzaW9uU3RvcmFnZSxcclxuICogYW5kIG9uZSBmb3IgbG9jYWxTdG9yYWdlLlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgRE9NU3RvcmFnZVdyYXBwZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZG9tU3RvcmFnZV8gLSBUaGUgdW5kZXJseWluZyBzdG9yYWdlIG9iamVjdCAoZS5nLiBsb2NhbFN0b3JhZ2Ugb3Igc2Vzc2lvblN0b3JhZ2UpXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGRvbVN0b3JhZ2VfKSB7XHJcbiAgICAgICAgdGhpcy5kb21TdG9yYWdlXyA9IGRvbVN0b3JhZ2VfO1xyXG4gICAgICAgIC8vIFVzZSBhIHByZWZpeCB0byBhdm9pZCBjb2xsaXNpb25zIHdpdGggb3RoZXIgc3R1ZmYgc2F2ZWQgYnkgdGhlIGFwcC5cclxuICAgICAgICB0aGlzLnByZWZpeF8gPSAnZmlyZWJhc2U6JztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gc2F2ZSB0aGUgdmFsdWUgdW5kZXJcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBiZWluZyBzdG9yZWQsIG9yIG51bGwgdG8gcmVtb3ZlIHRoZSBrZXkuXHJcbiAgICAgKi9cclxuICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5kb21TdG9yYWdlXy5yZW1vdmVJdGVtKHRoaXMucHJlZml4ZWROYW1lXyhrZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tU3RvcmFnZV8uc2V0SXRlbSh0aGlzLnByZWZpeGVkTmFtZV8oa2V5KSwgc3RyaW5naWZ5KHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgdGhhdCB3YXMgc3RvcmVkIHVuZGVyIHRoaXMga2V5LCBvciBudWxsXHJcbiAgICAgKi9cclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICBjb25zdCBzdG9yZWRWYWwgPSB0aGlzLmRvbVN0b3JhZ2VfLmdldEl0ZW0odGhpcy5wcmVmaXhlZE5hbWVfKGtleSkpO1xyXG4gICAgICAgIGlmIChzdG9yZWRWYWwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqc29uRXZhbChzdG9yZWRWYWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZShrZXkpIHtcclxuICAgICAgICB0aGlzLmRvbVN0b3JhZ2VfLnJlbW92ZUl0ZW0odGhpcy5wcmVmaXhlZE5hbWVfKGtleSkpO1xyXG4gICAgfVxyXG4gICAgcHJlZml4ZWROYW1lXyhuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlZml4XyArIG5hbWU7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb21TdG9yYWdlXy50b1N0cmluZygpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBpbi1tZW1vcnkgc3RvcmFnZSBpbXBsZW1lbnRhdGlvbiB0aGF0IG1hdGNoZXMgdGhlIEFQSSBvZiBET01TdG9yYWdlV3JhcHBlclxyXG4gKiAoVE9ETzogY3JlYXRlIGludGVyZmFjZSBmb3IgYm90aCB0byBpbXBsZW1lbnQpLlxyXG4gKi9cclxuY2xhc3MgTWVtb3J5U3RvcmFnZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmNhY2hlXyA9IHt9O1xyXG4gICAgICAgIHRoaXMuaXNJbk1lbW9yeVN0b3JhZ2UgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jYWNoZV9ba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGVfW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5zKHRoaXMuY2FjaGVfLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlX1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJlbW92ZShrZXkpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5jYWNoZV9ba2V5XTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSGVscGVyIHRvIGNyZWF0ZSBhIERPTVN0b3JhZ2VXcmFwcGVyIG9yIGVsc2UgZmFsbCBiYWNrIHRvIE1lbW9yeVN0b3JhZ2UuXHJcbiAqIFRPRE86IE9uY2UgTWVtb3J5U3RvcmFnZSBhbmQgRE9NU3RvcmFnZVdyYXBwZXIgaGF2ZSBhIHNoYXJlZCBpbnRlcmZhY2UgdGhpcyBtZXRob2QgYW5ub3RhdGlvbiBzaG91bGQgY2hhbmdlXHJcbiAqIHRvIHJlZmxlY3QgdGhpcyB0eXBlXHJcbiAqXHJcbiAqIEBwYXJhbSBkb21TdG9yYWdlTmFtZSAtIE5hbWUgb2YgdGhlIHVuZGVybHlpbmcgc3RvcmFnZSBvYmplY3RcclxuICogICAoZS5nLiAnbG9jYWxTdG9yYWdlJyBvciAnc2Vzc2lvblN0b3JhZ2UnKS5cclxuICogQHJldHVybnMgVHVybmluZyBvZmYgdHlwZSBpbmZvcm1hdGlvbiB1bnRpbCBhIGNvbW1vbiBpbnRlcmZhY2UgaXMgZGVmaW5lZC5cclxuICovXHJcbmNvbnN0IGNyZWF0ZVN0b3JhZ2Vmb3IgPSBmdW5jdGlvbiAoZG9tU3RvcmFnZU5hbWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gTk9URToganVzdCBhY2Nlc3NpbmcgXCJsb2NhbFN0b3JhZ2VcIiBvciBcIndpbmRvd1snbG9jYWxTdG9yYWdlJ11cIiBtYXkgdGhyb3cgYSBzZWN1cml0eSBleGNlcHRpb24sXHJcbiAgICAgICAgLy8gc28gaXQgbXVzdCBiZSBpbnNpZGUgdGhlIHRyeS9jYXRjaC5cclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvd1tkb21TdG9yYWdlTmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gdGVzdCBjYWNoZS4gSnVzdCBiZWNhdXNlIGl0J3MgaGVyZSBkb2Vzbid0IG1lYW4gaXQgd29ya3NcclxuICAgICAgICAgICAgY29uc3QgZG9tU3RvcmFnZSA9IHdpbmRvd1tkb21TdG9yYWdlTmFtZV07XHJcbiAgICAgICAgICAgIGRvbVN0b3JhZ2Uuc2V0SXRlbSgnZmlyZWJhc2U6c2VudGluZWwnLCAnY2FjaGUnKTtcclxuICAgICAgICAgICAgZG9tU3RvcmFnZS5yZW1vdmVJdGVtKCdmaXJlYmFzZTpzZW50aW5lbCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERPTVN0b3JhZ2VXcmFwcGVyKGRvbVN0b3JhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7IH1cclxuICAgIC8vIEZhaWxlZCB0byBjcmVhdGUgd3JhcHBlci4gIEp1c3QgcmV0dXJuIGluLW1lbW9yeSBzdG9yYWdlLlxyXG4gICAgLy8gVE9ETzogbG9nP1xyXG4gICAgcmV0dXJuIG5ldyBNZW1vcnlTdG9yYWdlKCk7XHJcbn07XHJcbi8qKiBBIHN0b3JhZ2Ugb2JqZWN0IHRoYXQgbGFzdHMgYWNyb3NzIHNlc3Npb25zICovXHJcbmNvbnN0IFBlcnNpc3RlbnRTdG9yYWdlID0gY3JlYXRlU3RvcmFnZWZvcignbG9jYWxTdG9yYWdlJyk7XHJcbi8qKiBBIHN0b3JhZ2Ugb2JqZWN0IHRoYXQgb25seSBsYXN0cyBvbmUgc2Vzc2lvbiAqL1xyXG5jb25zdCBTZXNzaW9uU3RvcmFnZSA9IGNyZWF0ZVN0b3JhZ2Vmb3IoJ3Nlc3Npb25TdG9yYWdlJyk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGxvZ0NsaWVudCA9IG5ldyBMb2dnZXIoJ0BmaXJlYmFzZS9kYXRhYmFzZScpO1xyXG4vKipcclxuICogUmV0dXJucyBhIGxvY2FsbHktdW5pcXVlIElEIChnZW5lcmF0ZWQgYnkganVzdCBpbmNyZW1lbnRpbmcgdXAgZnJvbSAwIGVhY2ggdGltZSBpdHMgY2FsbGVkKS5cclxuICovXHJcbmNvbnN0IExVSURHZW5lcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgbGV0IGlkID0gMTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGlkKys7XHJcbiAgICB9O1xyXG59KSgpO1xyXG4vKipcclxuICogU2hhMSBoYXNoIG9mIHRoZSBpbnB1dCBzdHJpbmdcclxuICogQHBhcmFtIHN0ciAtIFRoZSBzdHJpbmcgdG8gaGFzaFxyXG4gKiBAcmV0dXJucyB7IXN0cmluZ30gVGhlIHJlc3VsdGluZyBoYXNoXHJcbiAqL1xyXG5jb25zdCBzaGExID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgY29uc3QgdXRmOEJ5dGVzID0gc3RyaW5nVG9CeXRlQXJyYXkoc3RyKTtcclxuICAgIGNvbnN0IHNoYTEgPSBuZXcgU2hhMSgpO1xyXG4gICAgc2hhMS51cGRhdGUodXRmOEJ5dGVzKTtcclxuICAgIGNvbnN0IHNoYTFCeXRlcyA9IHNoYTEuZGlnZXN0KCk7XHJcbiAgICByZXR1cm4gYmFzZTY0LmVuY29kZUJ5dGVBcnJheShzaGExQnl0ZXMpO1xyXG59O1xyXG5jb25zdCBidWlsZExvZ01lc3NhZ2VfID0gZnVuY3Rpb24gKC4uLnZhckFyZ3MpIHtcclxuICAgIGxldCBtZXNzYWdlID0gJyc7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhckFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBhcmcgPSB2YXJBcmdzW2ldO1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykgfHxcclxuICAgICAgICAgICAgKGFyZyAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgYXJnLmxlbmd0aCA9PT0gJ251bWJlcicpKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYnVpbGRMb2dNZXNzYWdlXy5hcHBseShudWxsLCBhcmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBtZXNzYWdlICs9IHN0cmluZ2lmeShhcmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBhcmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lc3NhZ2UgKz0gJyAnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1lc3NhZ2U7XHJcbn07XHJcbi8qKlxyXG4gKiBVc2UgdGhpcyBmb3IgYWxsIGRlYnVnIG1lc3NhZ2VzIGluIEZpcmViYXNlLlxyXG4gKi9cclxubGV0IGxvZ2dlciA9IG51bGw7XHJcbi8qKlxyXG4gKiBGbGFnIHRvIGNoZWNrIGZvciBsb2cgYXZhaWxhYmlsaXR5IG9uIGZpcnN0IGxvZyBtZXNzYWdlXHJcbiAqL1xyXG5sZXQgZmlyc3RMb2dfID0gdHJ1ZTtcclxuLyoqXHJcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBGaXJlYmFzZS5lbmFibGVMb2dnaW5nIChkZWZpbmVkIGhlcmUgdG8gYnJlYWsgZGVwZW5kZW5jaWVzKVxyXG4gKiBAcGFyYW0gbG9nZ2VyXyAtIEEgZmxhZyB0byB0dXJuIG9uIGxvZ2dpbmcsIG9yIGEgY3VzdG9tIGxvZ2dlclxyXG4gKiBAcGFyYW0gcGVyc2lzdGVudCAtIFdoZXRoZXIgb3Igbm90IHRvIHBlcnNpc3QgbG9nZ2luZyBzZXR0aW5ncyBhY3Jvc3MgcmVmcmVzaGVzXHJcbiAqL1xyXG5jb25zdCBlbmFibGVMb2dnaW5nJDEgPSBmdW5jdGlvbiAobG9nZ2VyXywgcGVyc2lzdGVudCkge1xyXG4gICAgYXNzZXJ0KCFwZXJzaXN0ZW50IHx8IGxvZ2dlcl8gPT09IHRydWUgfHwgbG9nZ2VyXyA9PT0gZmFsc2UsIFwiQ2FuJ3QgdHVybiBvbiBjdXN0b20gbG9nZ2VycyBwZXJzaXN0ZW50bHkuXCIpO1xyXG4gICAgaWYgKGxvZ2dlcl8gPT09IHRydWUpIHtcclxuICAgICAgICBsb2dDbGllbnQubG9nTGV2ZWwgPSBMb2dMZXZlbC5WRVJCT1NFO1xyXG4gICAgICAgIGxvZ2dlciA9IGxvZ0NsaWVudC5sb2cuYmluZChsb2dDbGllbnQpO1xyXG4gICAgICAgIGlmIChwZXJzaXN0ZW50KSB7XHJcbiAgICAgICAgICAgIFNlc3Npb25TdG9yYWdlLnNldCgnbG9nZ2luZ19lbmFibGVkJywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGxvZ2dlcl8gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBsb2dnZXIgPSBsb2dnZXJfO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbG9nZ2VyID0gbnVsbDtcclxuICAgICAgICBTZXNzaW9uU3RvcmFnZS5yZW1vdmUoJ2xvZ2dpbmdfZW5hYmxlZCcpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBsb2cgPSBmdW5jdGlvbiAoLi4udmFyQXJncykge1xyXG4gICAgaWYgKGZpcnN0TG9nXyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIGZpcnN0TG9nXyA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChsb2dnZXIgPT09IG51bGwgJiYgU2Vzc2lvblN0b3JhZ2UuZ2V0KCdsb2dnaW5nX2VuYWJsZWQnKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBlbmFibGVMb2dnaW5nJDEodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGxvZ2dlcikge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBidWlsZExvZ01lc3NhZ2VfLmFwcGx5KG51bGwsIHZhckFyZ3MpO1xyXG4gICAgICAgIGxvZ2dlcihtZXNzYWdlKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgbG9nV3JhcHBlciA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4udmFyQXJncykge1xyXG4gICAgICAgIGxvZyhwcmVmaXgsIC4uLnZhckFyZ3MpO1xyXG4gICAgfTtcclxufTtcclxuY29uc3QgZXJyb3IgPSBmdW5jdGlvbiAoLi4udmFyQXJncykge1xyXG4gICAgY29uc3QgbWVzc2FnZSA9ICdGSVJFQkFTRSBJTlRFUk5BTCBFUlJPUjogJyArIGJ1aWxkTG9nTWVzc2FnZV8oLi4udmFyQXJncyk7XHJcbiAgICBsb2dDbGllbnQuZXJyb3IobWVzc2FnZSk7XHJcbn07XHJcbmNvbnN0IGZhdGFsID0gZnVuY3Rpb24gKC4uLnZhckFyZ3MpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2UgPSBgRklSRUJBU0UgRkFUQUwgRVJST1I6ICR7YnVpbGRMb2dNZXNzYWdlXyguLi52YXJBcmdzKX1gO1xyXG4gICAgbG9nQ2xpZW50LmVycm9yKG1lc3NhZ2UpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG59O1xyXG5jb25zdCB3YXJuID0gZnVuY3Rpb24gKC4uLnZhckFyZ3MpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2UgPSAnRklSRUJBU0UgV0FSTklORzogJyArIGJ1aWxkTG9nTWVzc2FnZV8oLi4udmFyQXJncyk7XHJcbiAgICBsb2dDbGllbnQud2FybihtZXNzYWdlKTtcclxufTtcclxuLyoqXHJcbiAqIExvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb250YWluaW5nIHBhZ2UgdXNlcyBodHRwcy4gQ2FsbGVkIHdoZW4gYSBjYWxsIHRvIG5ldyBGaXJlYmFzZVxyXG4gKiBkb2VzIG5vdCB1c2UgaHR0cHMuXHJcbiAqL1xyXG5jb25zdCB3YXJuSWZQYWdlSXNTZWN1cmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBCZSB2ZXJ5IGNhcmVmdWwgYWNjZXNzaW5nIGJyb3dzZXIgZ2xvYmFscy4gV2hvIGtub3dzIHdoYXQgbWF5IG9yIG1heSBub3QgZXhpc3QuXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24gJiZcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgJiZcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cHM6JykgIT09IC0xKSB7XHJcbiAgICAgICAgd2FybignSW5zZWN1cmUgRmlyZWJhc2UgYWNjZXNzIGZyb20gYSBzZWN1cmUgcGFnZS4gJyArXHJcbiAgICAgICAgICAgICdQbGVhc2UgdXNlIGh0dHBzIGluIGNhbGxzIHRvIG5ldyBGaXJlYmFzZSgpLicpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGRhdGEgaXMgTmFOLCBvciArLy0gSW5maW5pdHkuXHJcbiAqL1xyXG5jb25zdCBpc0ludmFsaWRKU09OTnVtYmVyID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIHJldHVybiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgKGRhdGEgIT09IGRhdGEgfHwgLy8gTmFOXHJcbiAgICAgICAgICAgIGRhdGEgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fFxyXG4gICAgICAgICAgICBkYXRhID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpKTtcclxufTtcclxuY29uc3QgZXhlY3V0ZVdoZW5ET01SZWFkeSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgaWYgKGlzTm9kZVNkaygpIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcclxuICAgICAgICBmbigpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gTW9kZWxlZCBhZnRlciBqUXVlcnkuIFRyeSBET01Db250ZW50TG9hZGVkIGFuZCBvbnJlYWR5c3RhdGVjaGFuZ2UgKHdoaWNoXHJcbiAgICAgICAgLy8gZmlyZSBiZWZvcmUgb25sb2FkKSwgYnV0IGZhbGwgYmFjayB0byBvbmxvYWQuXHJcbiAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHdyYXBwZWRGbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5KSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHdyYXBwZWRGbiwgTWF0aC5mbG9vcigxMCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZm4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHdyYXBwZWRGbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBvbmxvYWQuXHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgd3JhcHBlZEZuLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XHJcbiAgICAgICAgICAgIC8vIElFLlxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICBkb2N1bWVudC5hdHRhY2hFdmVudCgnb25yZWFkeXN0YXRlY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVkRm4oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIG9ubG9hZC5cclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgd2luZG93LmF0dGFjaEV2ZW50KCdvbmxvYWQnLCB3cmFwcGVkRm4pO1xyXG4gICAgICAgICAgICAvLyBqUXVlcnkgaGFzIGFuIGV4dHJhIGhhY2sgZm9yIElFIHRoYXQgd2UgY291bGQgZW1wbG95IChiYXNlZCBvblxyXG4gICAgICAgICAgICAvLyBodHRwOi8vamF2YXNjcmlwdC5ud2JveC5jb20vSUVDb250ZW50TG9hZGVkLykgQnV0IGl0IGxvb2tzIHJlYWxseSBvbGQuXHJcbiAgICAgICAgICAgIC8vIEknbSBob3Bpbmcgd2UgZG9uJ3QgbmVlZCBpdC5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBNaW5pbXVtIGtleSBuYW1lLiBJbnZhbGlkIGZvciBhY3R1YWwgZGF0YSwgdXNlZCBhcyBhIG1hcmtlciB0byBzb3J0IGJlZm9yZSBhbnkgdmFsaWQgbmFtZXNcclxuICovXHJcbmNvbnN0IE1JTl9OQU1FID0gJ1tNSU5fTkFNRV0nO1xyXG4vKipcclxuICogTWF4aW11bSBrZXkgbmFtZS4gSW52YWxpZCBmb3IgYWN0dWFsIGRhdGEsIHVzZWQgYXMgYSBtYXJrZXIgdG8gc29ydCBhYm92ZSBhbnkgdmFsaWQgbmFtZXNcclxuICovXHJcbmNvbnN0IE1BWF9OQU1FID0gJ1tNQVhfTkFNRV0nO1xyXG4vKipcclxuICogQ29tcGFyZXMgdmFsaWQgRmlyZWJhc2Uga2V5IG5hbWVzLCBwbHVzIG1pbiBhbmQgbWF4IG5hbWVcclxuICovXHJcbmNvbnN0IG5hbWVDb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgIGlmIChhID09PSBiKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhID09PSBNSU5fTkFNRSB8fCBiID09PSBNQVhfTkFNRSkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGIgPT09IE1JTl9OQU1FIHx8IGEgPT09IE1BWF9OQU1FKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBhQXNJbnQgPSB0cnlQYXJzZUludChhKSwgYkFzSW50ID0gdHJ5UGFyc2VJbnQoYik7XHJcbiAgICAgICAgaWYgKGFBc0ludCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoYkFzSW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYUFzSW50IC0gYkFzSW50ID09PSAwID8gYS5sZW5ndGggLSBiLmxlbmd0aCA6IGFBc0ludCAtIGJBc0ludDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChiQXNJbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQHJldHVybnMgeyFudW1iZXJ9IGNvbXBhcmlzb24gcmVzdWx0LlxyXG4gKi9cclxuY29uc3Qgc3RyaW5nQ29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYSA8IGIpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxufTtcclxuY29uc3QgcmVxdWlyZUtleSA9IGZ1bmN0aW9uIChrZXksIG9iaikge1xyXG4gICAgaWYgKG9iaiAmJiBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ialtrZXldO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGtleSAoJyArIGtleSArICcpIGluIG9iamVjdDogJyArIHN0cmluZ2lmeShvYmopKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgT2JqZWN0VG9VbmlxdWVLZXkgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShvYmopO1xyXG4gICAgfVxyXG4gICAgY29uc3Qga2V5cyA9IFtdO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxyXG4gICAgZm9yIChjb25zdCBrIGluIG9iaikge1xyXG4gICAgICAgIGtleXMucHVzaChrKTtcclxuICAgIH1cclxuICAgIC8vIEV4cG9ydCBhcyBqc29uLCBidXQgd2l0aCB0aGUga2V5cyBzb3J0ZWQuXHJcbiAgICBrZXlzLnNvcnQoKTtcclxuICAgIGxldCBrZXkgPSAneyc7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoaSAhPT0gMCkge1xyXG4gICAgICAgICAgICBrZXkgKz0gJywnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBrZXkgKz0gc3RyaW5naWZ5KGtleXNbaV0pO1xyXG4gICAgICAgIGtleSArPSAnOic7XHJcbiAgICAgICAga2V5ICs9IE9iamVjdFRvVW5pcXVlS2V5KG9ialtrZXlzW2ldXSk7XHJcbiAgICB9XHJcbiAgICBrZXkgKz0gJ30nO1xyXG4gICAgcmV0dXJuIGtleTtcclxufTtcclxuLyoqXHJcbiAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIGEgbnVtYmVyIG9mIHNtYWxsZXIgc2VnbWVudHMgb2YgbWF4aW11bSBzaXplXHJcbiAqIEBwYXJhbSBzdHIgLSBUaGUgc3RyaW5nXHJcbiAqIEBwYXJhbSBzZWdzaXplIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJzIGluIHRoZSBzdHJpbmcuXHJcbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcsIHNwbGl0IGludG8gYXBwcm9wcmlhdGVseS1zaXplZCBjaHVua3NcclxuICovXHJcbmNvbnN0IHNwbGl0U3RyaW5nQnlTaXplID0gZnVuY3Rpb24gKHN0ciwgc2Vnc2l6ZSkge1xyXG4gICAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcclxuICAgIGlmIChsZW4gPD0gc2Vnc2l6ZSkge1xyXG4gICAgICAgIHJldHVybiBbc3RyXTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRhdGFTZWdzID0gW107XHJcbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IGxlbjsgYyArPSBzZWdzaXplKSB7XHJcbiAgICAgICAgaWYgKGMgKyBzZWdzaXplID4gbGVuKSB7XHJcbiAgICAgICAgICAgIGRhdGFTZWdzLnB1c2goc3RyLnN1YnN0cmluZyhjLCBsZW4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGFTZWdzLnB1c2goc3RyLnN1YnN0cmluZyhjLCBjICsgc2Vnc2l6ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhU2VncztcclxufTtcclxuLyoqXHJcbiAqIEFwcGx5IGEgZnVuY3Rpb24gdG8gZWFjaCAoa2V5LCB2YWx1ZSkgcGFpciBpbiBhbiBvYmplY3Qgb3JcclxuICogYXBwbHkgYSBmdW5jdGlvbiB0byBlYWNoIChpbmRleCwgdmFsdWUpIHBhaXIgaW4gYW4gYXJyYXlcclxuICogQHBhcmFtIG9iaiAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyXHJcbiAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiB0byBhcHBseVxyXG4gKi9cclxuZnVuY3Rpb24gZWFjaChvYmosIGZuKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgZm4oa2V5LCBvYmpba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBCb3Jyb3dlZCBmcm9tIGh0dHA6Ly9oZy5zZWNvbmRsaWZlLmNvbS9sbHNkL3NyYy90aXAvanMvdHlwZWRhcnJheS5qcyAoTUlUIExpY2Vuc2UpXHJcbiAqIEkgbWFkZSBvbmUgbW9kaWZpY2F0aW9uIGF0IHRoZSBlbmQgYW5kIHJlbW92ZWQgdGhlIE5hTiAvIEluZmluaXR5XHJcbiAqIGhhbmRsaW5nIChzaW5jZSBpdCBzZWVtZWQgYnJva2VuIFtjYXVzZWQgYW4gb3ZlcmZsb3ddIGFuZCB3ZSBkb24ndCBuZWVkIGl0KS4gIFNlZSBNSkwgY29tbWVudHMuXHJcbiAqIEBwYXJhbSB2IC0gQSBkb3VibGVcclxuICpcclxuICovXHJcbmNvbnN0IGRvdWJsZVRvSUVFRTc1NFN0cmluZyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICBhc3NlcnQoIWlzSW52YWxpZEpTT05OdW1iZXIodiksICdJbnZhbGlkIEpTT04gbnVtYmVyJyk7IC8vIE1KTFxyXG4gICAgY29uc3QgZWJpdHMgPSAxMSwgZmJpdHMgPSA1MjtcclxuICAgIGNvbnN0IGJpYXMgPSAoMSA8PCAoZWJpdHMgLSAxKSkgLSAxO1xyXG4gICAgbGV0IHMsIGUsIGYsIGxuLCBpO1xyXG4gICAgLy8gQ29tcHV0ZSBzaWduLCBleHBvbmVudCwgZnJhY3Rpb25cclxuICAgIC8vIFNraXAgTmFOIC8gSW5maW5pdHkgaGFuZGxpbmcgLS1NSkwuXHJcbiAgICBpZiAodiA9PT0gMCkge1xyXG4gICAgICAgIGUgPSAwO1xyXG4gICAgICAgIGYgPSAwO1xyXG4gICAgICAgIHMgPSAxIC8gdiA9PT0gLUluZmluaXR5ID8gMSA6IDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzID0gdiA8IDA7XHJcbiAgICAgICAgdiA9IE1hdGguYWJzKHYpO1xyXG4gICAgICAgIGlmICh2ID49IE1hdGgucG93KDIsIDEgLSBiaWFzKSkge1xyXG4gICAgICAgICAgICAvLyBOb3JtYWxpemVkXHJcbiAgICAgICAgICAgIGxuID0gTWF0aC5taW4oTWF0aC5mbG9vcihNYXRoLmxvZyh2KSAvIE1hdGguTE4yKSwgYmlhcyk7XHJcbiAgICAgICAgICAgIGUgPSBsbiArIGJpYXM7XHJcbiAgICAgICAgICAgIGYgPSBNYXRoLnJvdW5kKHYgKiBNYXRoLnBvdygyLCBmYml0cyAtIGxuKSAtIE1hdGgucG93KDIsIGZiaXRzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEZW5vcm1hbGl6ZWRcclxuICAgICAgICAgICAgZSA9IDA7XHJcbiAgICAgICAgICAgIGYgPSBNYXRoLnJvdW5kKHYgLyBNYXRoLnBvdygyLCAxIC0gYmlhcyAtIGZiaXRzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gUGFjayBzaWduLCBleHBvbmVudCwgZnJhY3Rpb25cclxuICAgIGNvbnN0IGJpdHMgPSBbXTtcclxuICAgIGZvciAoaSA9IGZiaXRzOyBpOyBpIC09IDEpIHtcclxuICAgICAgICBiaXRzLnB1c2goZiAlIDIgPyAxIDogMCk7XHJcbiAgICAgICAgZiA9IE1hdGguZmxvb3IoZiAvIDIpO1xyXG4gICAgfVxyXG4gICAgZm9yIChpID0gZWJpdHM7IGk7IGkgLT0gMSkge1xyXG4gICAgICAgIGJpdHMucHVzaChlICUgMiA/IDEgOiAwKTtcclxuICAgICAgICBlID0gTWF0aC5mbG9vcihlIC8gMik7XHJcbiAgICB9XHJcbiAgICBiaXRzLnB1c2gocyA/IDEgOiAwKTtcclxuICAgIGJpdHMucmV2ZXJzZSgpO1xyXG4gICAgY29uc3Qgc3RyID0gYml0cy5qb2luKCcnKTtcclxuICAgIC8vIFJldHVybiB0aGUgZGF0YSBhcyBhIGhleCBzdHJpbmcuIC0tTUpMXHJcbiAgICBsZXQgaGV4Qnl0ZVN0cmluZyA9ICcnO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpICs9IDgpIHtcclxuICAgICAgICBsZXQgaGV4Qnl0ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSwgOCksIDIpLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICBpZiAoaGV4Qnl0ZS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgaGV4Qnl0ZSA9ICcwJyArIGhleEJ5dGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhleEJ5dGVTdHJpbmcgPSBoZXhCeXRlU3RyaW5nICsgaGV4Qnl0ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBoZXhCeXRlU3RyaW5nLnRvTG93ZXJDYXNlKCk7XHJcbn07XHJcbi8qKlxyXG4gKiBVc2VkIHRvIGRldGVjdCBpZiB3ZSdyZSBpbiBhIENocm9tZSBjb250ZW50IHNjcmlwdCAod2hpY2ggZXhlY3V0ZXMgaW4gYW5cclxuICogaXNvbGF0ZWQgZW52aXJvbm1lbnQgd2hlcmUgbG9uZy1wb2xsaW5nIGRvZXNuJ3Qgd29yaykuXHJcbiAqL1xyXG5jb25zdCBpc0Nocm9tZUV4dGVuc2lvbkNvbnRlbnRTY3JpcHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gISEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICB3aW5kb3dbJ2Nocm9tZSddICYmXHJcbiAgICAgICAgd2luZG93WydjaHJvbWUnXVsnZXh0ZW5zaW9uJ10gJiZcclxuICAgICAgICAhL15jaHJvbWUvLnRlc3Qod2luZG93LmxvY2F0aW9uLmhyZWYpKTtcclxufTtcclxuLyoqXHJcbiAqIFVzZWQgdG8gZGV0ZWN0IGlmIHdlJ3JlIGluIGEgV2luZG93cyA4IFN0b3JlIGFwcC5cclxuICovXHJcbmNvbnN0IGlzV2luZG93c1N0b3JlQXBwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gQ2hlY2sgZm9yIHRoZSBwcmVzZW5jZSBvZiBhIGNvdXBsZSBXaW5SVCBnbG9iYWxzXHJcbiAgICByZXR1cm4gdHlwZW9mIFdpbmRvd3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiBXaW5kb3dzLlVJID09PSAnb2JqZWN0JztcclxufTtcclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgc2VydmVyIGVycm9yIGNvZGUgdG8gYSBKYXZhc2NyaXB0IEVycm9yXHJcbiAqL1xyXG5mdW5jdGlvbiBlcnJvckZvclNlcnZlckNvZGUoY29kZSwgcXVlcnkpIHtcclxuICAgIGxldCByZWFzb24gPSAnVW5rbm93biBFcnJvcic7XHJcbiAgICBpZiAoY29kZSA9PT0gJ3Rvb19iaWcnKSB7XHJcbiAgICAgICAgcmVhc29uID1cclxuICAgICAgICAgICAgJ1RoZSBkYXRhIHJlcXVlc3RlZCBleGNlZWRzIHRoZSBtYXhpbXVtIHNpemUgJyArXHJcbiAgICAgICAgICAgICAgICAndGhhdCBjYW4gYmUgYWNjZXNzZWQgd2l0aCBhIHNpbmdsZSByZXF1ZXN0Lic7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb2RlID09PSAncGVybWlzc2lvbl9kZW5pZWQnKSB7XHJcbiAgICAgICAgcmVhc29uID0gXCJDbGllbnQgZG9lc24ndCBoYXZlIHBlcm1pc3Npb24gdG8gYWNjZXNzIHRoZSBkZXNpcmVkIGRhdGEuXCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb2RlID09PSAndW5hdmFpbGFibGUnKSB7XHJcbiAgICAgICAgcmVhc29uID0gJ1RoZSBzZXJ2aWNlIGlzIHVuYXZhaWxhYmxlJztcclxuICAgIH1cclxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGNvZGUgKyAnIGF0ICcgKyBxdWVyeS5fcGF0aC50b1N0cmluZygpICsgJzogJyArIHJlYXNvbik7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgZXJyb3IuY29kZSA9IGNvZGUudG9VcHBlckNhc2UoKTtcclxuICAgIHJldHVybiBlcnJvcjtcclxufVxyXG4vKipcclxuICogVXNlZCB0byB0ZXN0IGZvciBpbnRlZ2VyLWxvb2tpbmcgc3RyaW5nc1xyXG4gKi9cclxuY29uc3QgSU5URUdFUl9SRUdFWFBfID0gbmV3IFJlZ0V4cCgnXi0/KDAqKVxcXFxkezEsMTB9JCcpO1xyXG4vKipcclxuICogRm9yIHVzZSBpbiBrZXlzLCB0aGUgbWluaW11bSBwb3NzaWJsZSAzMi1iaXQgaW50ZWdlci5cclxuICovXHJcbmNvbnN0IElOVEVHRVJfMzJfTUlOID0gLTIxNDc0ODM2NDg7XHJcbi8qKlxyXG4gKiBGb3IgdXNlIGluIGt5ZXMsIHRoZSBtYXhpbXVtIHBvc3NpYmxlIDMyLWJpdCBpbnRlZ2VyLlxyXG4gKi9cclxuY29uc3QgSU5URUdFUl8zMl9NQVggPSAyMTQ3NDgzNjQ3O1xyXG4vKipcclxuICogSWYgdGhlIHN0cmluZyBjb250YWlucyBhIDMyLWJpdCBpbnRlZ2VyLCByZXR1cm4gaXQuICBFbHNlIHJldHVybiBudWxsLlxyXG4gKi9cclxuY29uc3QgdHJ5UGFyc2VJbnQgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICBpZiAoSU5URUdFUl9SRUdFWFBfLnRlc3Qoc3RyKSkge1xyXG4gICAgICAgIGNvbnN0IGludFZhbCA9IE51bWJlcihzdHIpO1xyXG4gICAgICAgIGlmIChpbnRWYWwgPj0gSU5URUdFUl8zMl9NSU4gJiYgaW50VmFsIDw9IElOVEVHRVJfMzJfTUFYKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRWYWw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gcnVuIHNvbWUgY29kZSBidXQgY2F0Y2ggYW55IGV4Y2VwdGlvbnMgYW5kIHJlLXRocm93IHRoZW0gbGF0ZXIuXHJcbiAqIFVzZWZ1bCBmb3IgcHJldmVudGluZyB1c2VyIGNhbGxiYWNrcyBmcm9tIGJyZWFraW5nIGludGVybmFsIGNvZGUuXHJcbiAqXHJcbiAqIFJlLXRocm93aW5nIHRoZSBleGNlcHRpb24gZnJvbSBhIHNldFRpbWVvdXQgaXMgYSBsaXR0bGUgZXZpbCwgYnV0IGl0J3MgdmVyeVxyXG4gKiBjb252ZW5pZW50ICh3ZSBkb24ndCBoYXZlIHRvIHRyeSB0byBmaWd1cmUgb3V0IHdoZW4gaXMgYSBzYWZlIHBvaW50IHRvXHJcbiAqIHJlLXRocm93IGl0KSwgYW5kIHRoZSBiZWhhdmlvciBzZWVtcyByZWFzb25hYmxlOlxyXG4gKlxyXG4gKiAqIElmIHlvdSBhcmVuJ3QgcGF1c2luZyBvbiBleGNlcHRpb25zLCB5b3UgZ2V0IGFuIGVycm9yIGluIHRoZSBjb25zb2xlIHdpdGhcclxuICogICB0aGUgY29ycmVjdCBzdGFjayB0cmFjZS5cclxuICogKiBJZiB5b3UncmUgcGF1c2luZyBvbiBhbGwgZXhjZXB0aW9ucywgdGhlIGRlYnVnZ2VyIHdpbGwgcGF1c2Ugb24geW91clxyXG4gKiAgIGV4Y2VwdGlvbiBhbmQgdGhlbiBhZ2FpbiB3aGVuIHdlIHJldGhyb3cgaXQuXHJcbiAqICogSWYgeW91J3JlIG9ubHkgcGF1c2luZyBvbiB1bmNhdWdodCBleGNlcHRpb25zLCB0aGUgZGVidWdnZXIgd2lsbCBvbmx5IHBhdXNlXHJcbiAqICAgb24gdXMgcmUtdGhyb3dpbmcgaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSBmbiAtIFRoZSBjb2RlIHRvIGd1YXJkLlxyXG4gKi9cclxuY29uc3QgZXhjZXB0aW9uR3VhcmQgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZm4oKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gUmUtdGhyb3cgZXhjZXB0aW9uIHdoZW4gaXQncyBzYWZlLlxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBJdCB1c2VkIHRvIGJlIHRoYXQgXCJ0aHJvdyBlXCIgd291bGQgcmVzdWx0IGluIGEgZ29vZCBjb25zb2xlIGVycm9yIHdpdGhcclxuICAgICAgICAgICAgLy8gcmVsZXZhbnQgY29udGV4dCwgYnV0IGFzIG9mIENocm9tZSAzOSwgeW91IGp1c3QgZ2V0IHRoZSBmaXJlYmFzZS5qc1xyXG4gICAgICAgICAgICAvLyBmaWxlL2xpbmUgbnVtYmVyIHdoZXJlIHdlIHJlLXRocm93IGl0LCB3aGljaCBpcyB1c2VsZXNzLiBTbyB3ZSBsb2dcclxuICAgICAgICAgICAgLy8gZS5zdGFjayBleHBsaWNpdGx5LlxyXG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IGUuc3RhY2sgfHwgJyc7XHJcbiAgICAgICAgICAgIHdhcm4oJ0V4Y2VwdGlvbiB3YXMgdGhyb3duIGJ5IHVzZXIgY2FsbGJhY2suJywgc3RhY2spO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH0sIE1hdGguZmxvb3IoMCkpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgd2UgdGhpbmsgd2UncmUgY3VycmVudGx5IGJlaW5nIGNyYXdsZWQuXHJcbiAqL1xyXG5jb25zdCBiZWluZ0NyYXdsZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCB1c2VyQWdlbnQgPSAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICB3aW5kb3dbJ25hdmlnYXRvciddICYmXHJcbiAgICAgICAgd2luZG93WyduYXZpZ2F0b3InXVsndXNlckFnZW50J10pIHx8XHJcbiAgICAgICAgJyc7XHJcbiAgICAvLyBGb3Igbm93IHdlIHdoaXRlbGlzdCB0aGUgbW9zdCBwb3B1bGFyIGNyYXdsZXJzLiAgV2Ugc2hvdWxkIHJlZmluZSB0aGlzIHRvIGJlIHRoZSBzZXQgb2YgY3Jhd2xlcnMgd2VcclxuICAgIC8vIGJlbGlldmUgdG8gc3VwcG9ydCBKYXZhU2NyaXB0L0FKQVggcmVuZGVyaW5nLlxyXG4gICAgLy8gTk9URTogR29vZ2xlIFdlYm1hc3RlciBUb29scyBkb2Vzbid0IHJlYWxseSBiZWxvbmcsIGJ1dCB0aGVpciBcIlRoaXMgaXMgaG93IGEgdmlzaXRvciB0byB5b3VyIHdlYnNpdGVcclxuICAgIC8vIHdvdWxkIGhhdmUgc2VlbiB0aGUgcGFnZVwiIGlzIGZsYWt5IGlmIHdlIGRvbid0IHRyZWF0IGl0IGFzIGEgY3Jhd2xlci5cclxuICAgIHJldHVybiAodXNlckFnZW50LnNlYXJjaCgvZ29vZ2xlYm90fGdvb2dsZSB3ZWJtYXN0ZXIgdG9vbHN8YmluZ2JvdHx5YWhvbyEgc2x1cnB8YmFpZHVzcGlkZXJ8eWFuZGV4Ym90fGR1Y2tkdWNrYm90L2kpID49IDApO1xyXG59O1xyXG4vKipcclxuICogU2FtZSBhcyBzZXRUaW1lb3V0KCkgZXhjZXB0IG9uIE5vZGUuSlMgaXQgd2lsbCAvbm90LyBwcmV2ZW50IHRoZSBwcm9jZXNzIGZyb20gZXhpdGluZy5cclxuICpcclxuICogSXQgaXMgcmVtb3ZlZCB3aXRoIGNsZWFyVGltZW91dCgpIGFzIG5vcm1hbC5cclxuICpcclxuICogQHBhcmFtIGZuIC0gRnVuY3Rpb24gdG8gcnVuLlxyXG4gKiBAcGFyYW0gdGltZSAtIE1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBydW5uaW5nLlxyXG4gKiBAcmV0dXJucyBUaGUgc2V0VGltZW91dCgpIHJldHVybiB2YWx1ZS5cclxuICovXHJcbmNvbnN0IHNldFRpbWVvdXROb25CbG9ja2luZyA9IGZ1bmN0aW9uIChmbiwgdGltZSkge1xyXG4gICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoZm4sIHRpbWUpO1xyXG4gICAgLy8gTm90ZTogYXQgdGhlIHRpbWUgb2YgdGhpcyBjb21tZW50LCB1bnJlZlRpbWVyIGlzIHVuZGVyIHRoZSB1bnN0YWJsZSBzZXQgb2YgQVBJcy4gUnVuIHdpdGggLS11bnN0YWJsZSB0byBlbmFibGUgdGhlIEFQSS5cclxuICAgIGlmICh0eXBlb2YgdGltZW91dCA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAvLyBAdHMtaWdub3JlIElzIG9ubHkgZGVmaW5lZCBpbiBEZW5vIGVudmlyb25tZW50cy5cclxuICAgICAgICB0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAvLyBAdHMtaWdub3JlIERlbm8gYW5kIHVucmVmVGltZXIgYXJlIG9ubHkgZGVmaW5lZCBpbiBEZW5vIGVudmlyb25tZW50cy5cclxuICAgICAgICBEZW5vWyd1bnJlZlRpbWVyJ10pIHtcclxuICAgICAgICAvLyBAdHMtaWdub3JlIERlbm8gYW5kIHVucmVmVGltZXIgYXJlIG9ubHkgZGVmaW5lZCBpbiBEZW5vIGVudmlyb25tZW50cy5cclxuICAgICAgICBEZW5vLnVucmVmVGltZXIodGltZW91dCk7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB0aW1lb3V0ID09PSAnb2JqZWN0JyAmJiB0aW1lb3V0Wyd1bnJlZiddKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICB0aW1lb3V0Wyd1bnJlZiddKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGltZW91dDtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgY2xhc3MgdGhhdCBob2xkcyBtZXRhZGF0YSBhYm91dCBhIFJlcG8gb2JqZWN0XHJcbiAqL1xyXG5jbGFzcyBSZXBvSW5mbyB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBob3N0IC0gSG9zdG5hbWUgcG9ydGlvbiBvZiB0aGUgdXJsIGZvciB0aGUgcmVwb1xyXG4gICAgICogQHBhcmFtIHNlY3VyZSAtIFdoZXRoZXIgb3Igbm90IHRoaXMgcmVwbyBpcyBhY2Nlc3NlZCBvdmVyIHNzbFxyXG4gICAgICogQHBhcmFtIG5hbWVzcGFjZSAtIFRoZSBuYW1lc3BhY2UgcmVwcmVzZW50ZWQgYnkgdGhlIHJlcG9cclxuICAgICAqIEBwYXJhbSB3ZWJTb2NrZXRPbmx5IC0gV2hldGhlciB0byBwcmVmZXIgd2Vic29ja2V0cyBvdmVyIGFsbCBvdGhlciB0cmFuc3BvcnRzICh1c2VkIGJ5IE5lc3QpLlxyXG4gICAgICogQHBhcmFtIG5vZGVBZG1pbiAtIFdoZXRoZXIgdGhpcyBpbnN0YW5jZSB1c2VzIEFkbWluIFNESyBjcmVkZW50aWFsc1xyXG4gICAgICogQHBhcmFtIHBlcnNpc3RlbmNlS2V5IC0gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgc2Vzc2lvbiBwZXJzaXN0ZW5jZSBzdG9yYWdlIGtleVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihob3N0LCBzZWN1cmUsIG5hbWVzcGFjZSwgd2ViU29ja2V0T25seSwgbm9kZUFkbWluID0gZmFsc2UsIHBlcnNpc3RlbmNlS2V5ID0gJycsIGluY2x1ZGVOYW1lc3BhY2VJblF1ZXJ5UGFyYW1zID0gZmFsc2UsIGlzVXNpbmdFbXVsYXRvciA9IGZhbHNlKSB7XHJcbiAgICAgICAgdGhpcy5zZWN1cmUgPSBzZWN1cmU7XHJcbiAgICAgICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XHJcbiAgICAgICAgdGhpcy53ZWJTb2NrZXRPbmx5ID0gd2ViU29ja2V0T25seTtcclxuICAgICAgICB0aGlzLm5vZGVBZG1pbiA9IG5vZGVBZG1pbjtcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlS2V5ID0gcGVyc2lzdGVuY2VLZXk7XHJcbiAgICAgICAgdGhpcy5pbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtcyA9IGluY2x1ZGVOYW1lc3BhY2VJblF1ZXJ5UGFyYW1zO1xyXG4gICAgICAgIHRoaXMuaXNVc2luZ0VtdWxhdG9yID0gaXNVc2luZ0VtdWxhdG9yO1xyXG4gICAgICAgIHRoaXMuX2hvc3QgPSBob3N0LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgdGhpcy5fZG9tYWluID0gdGhpcy5faG9zdC5zdWJzdHIodGhpcy5faG9zdC5pbmRleE9mKCcuJykgKyAxKTtcclxuICAgICAgICB0aGlzLmludGVybmFsSG9zdCA9XHJcbiAgICAgICAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLmdldCgnaG9zdDonICsgaG9zdCkgfHwgdGhpcy5faG9zdDtcclxuICAgIH1cclxuICAgIGlzQ2FjaGVhYmxlSG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEhvc3Quc3Vic3RyKDAsIDIpID09PSAncy0nO1xyXG4gICAgfVxyXG4gICAgaXNDdXN0b21Ib3N0KCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5fZG9tYWluICE9PSAnZmlyZWJhc2Vpby5jb20nICYmXHJcbiAgICAgICAgICAgIHRoaXMuX2RvbWFpbiAhPT0gJ2ZpcmViYXNlaW8tZGVtby5jb20nKTtcclxuICAgIH1cclxuICAgIGdldCBob3N0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ob3N0O1xyXG4gICAgfVxyXG4gICAgc2V0IGhvc3QobmV3SG9zdCkge1xyXG4gICAgICAgIGlmIChuZXdIb3N0ICE9PSB0aGlzLmludGVybmFsSG9zdCkge1xyXG4gICAgICAgICAgICB0aGlzLmludGVybmFsSG9zdCA9IG5ld0hvc3Q7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2FjaGVhYmxlSG9zdCgpKSB7XHJcbiAgICAgICAgICAgICAgICBQZXJzaXN0ZW50U3RvcmFnZS5zZXQoJ2hvc3Q6JyArIHRoaXMuX2hvc3QsIHRoaXMuaW50ZXJuYWxIb3N0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGxldCBzdHIgPSB0aGlzLnRvVVJMU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKHRoaXMucGVyc2lzdGVuY2VLZXkpIHtcclxuICAgICAgICAgICAgc3RyICs9ICc8JyArIHRoaXMucGVyc2lzdGVuY2VLZXkgKyAnPic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcbiAgICB0b1VSTFN0cmluZygpIHtcclxuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHRoaXMuc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJztcclxuICAgICAgICBjb25zdCBxdWVyeSA9IHRoaXMuaW5jbHVkZU5hbWVzcGFjZUluUXVlcnlQYXJhbXNcclxuICAgICAgICAgICAgPyBgP25zPSR7dGhpcy5uYW1lc3BhY2V9YFxyXG4gICAgICAgICAgICA6ICcnO1xyXG4gICAgICAgIHJldHVybiBgJHtwcm90b2NvbH0ke3RoaXMuaG9zdH0vJHtxdWVyeX1gO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcG9JbmZvTmVlZHNRdWVyeVBhcmFtKHJlcG9JbmZvKSB7XHJcbiAgICByZXR1cm4gKHJlcG9JbmZvLmhvc3QgIT09IHJlcG9JbmZvLmludGVybmFsSG9zdCB8fFxyXG4gICAgICAgIHJlcG9JbmZvLmlzQ3VzdG9tSG9zdCgpIHx8XHJcbiAgICAgICAgcmVwb0luZm8uaW5jbHVkZU5hbWVzcGFjZUluUXVlcnlQYXJhbXMpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB3ZWJzb2NrZXQgVVJMIGZvciB0aGlzIHJlcG9cclxuICogQHBhcmFtIHJlcG9JbmZvIC0gUmVwb0luZm8gb2JqZWN0XHJcbiAqIEBwYXJhbSB0eXBlIC0gb2YgY29ubmVjdGlvblxyXG4gKiBAcGFyYW0gcGFyYW1zIC0gbGlzdFxyXG4gKiBAcmV0dXJucyBUaGUgVVJMIGZvciB0aGlzIHJlcG9cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9JbmZvQ29ubmVjdGlvblVSTChyZXBvSW5mbywgdHlwZSwgcGFyYW1zKSB7XHJcbiAgICBhc3NlcnQodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnLCAndHlwZW9mIHR5cGUgbXVzdCA9PSBzdHJpbmcnKTtcclxuICAgIGFzc2VydCh0eXBlb2YgcGFyYW1zID09PSAnb2JqZWN0JywgJ3R5cGVvZiBwYXJhbXMgbXVzdCA9PSBvYmplY3QnKTtcclxuICAgIGxldCBjb25uVVJMO1xyXG4gICAgaWYgKHR5cGUgPT09IFdFQlNPQ0tFVCkge1xyXG4gICAgICAgIGNvbm5VUkwgPVxyXG4gICAgICAgICAgICAocmVwb0luZm8uc2VjdXJlID8gJ3dzczovLycgOiAnd3M6Ly8nKSArIHJlcG9JbmZvLmludGVybmFsSG9zdCArICcvLndzPyc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlID09PSBMT05HX1BPTExJTkcpIHtcclxuICAgICAgICBjb25uVVJMID1cclxuICAgICAgICAgICAgKHJlcG9JbmZvLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLycpICtcclxuICAgICAgICAgICAgICAgIHJlcG9JbmZvLmludGVybmFsSG9zdCArXHJcbiAgICAgICAgICAgICAgICAnLy5scD8nO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNvbm5lY3Rpb24gdHlwZTogJyArIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlcG9JbmZvTmVlZHNRdWVyeVBhcmFtKHJlcG9JbmZvKSkge1xyXG4gICAgICAgIHBhcmFtc1snbnMnXSA9IHJlcG9JbmZvLm5hbWVzcGFjZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhaXJzID0gW107XHJcbiAgICBlYWNoKHBhcmFtcywgKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICBwYWlycy5wdXNoKGtleSArICc9JyArIHZhbHVlKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNvbm5VUkwgKyBwYWlycy5qb2luKCcmJyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRyYWNrcyBhIGNvbGxlY3Rpb24gb2Ygc3RhdHMuXHJcbiAqL1xyXG5jbGFzcyBTdGF0c0NvbGxlY3Rpb24ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jb3VudGVyc18gPSB7fTtcclxuICAgIH1cclxuICAgIGluY3JlbWVudENvdW50ZXIobmFtZSwgYW1vdW50ID0gMSkge1xyXG4gICAgICAgIGlmICghY29udGFpbnModGhpcy5jb3VudGVyc18sIG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnRlcnNfW25hbWVdID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb3VudGVyc19bbmFtZV0gKz0gYW1vdW50O1xyXG4gICAgfVxyXG4gICAgZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiBkZWVwQ29weSh0aGlzLmNvdW50ZXJzXyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgY29sbGVjdGlvbnMgPSB7fTtcclxuY29uc3QgcmVwb3J0ZXJzID0ge307XHJcbmZ1bmN0aW9uIHN0YXRzTWFuYWdlckdldENvbGxlY3Rpb24ocmVwb0luZm8pIHtcclxuICAgIGNvbnN0IGhhc2hTdHJpbmcgPSByZXBvSW5mby50b1N0cmluZygpO1xyXG4gICAgaWYgKCFjb2xsZWN0aW9uc1toYXNoU3RyaW5nXSkge1xyXG4gICAgICAgIGNvbGxlY3Rpb25zW2hhc2hTdHJpbmddID0gbmV3IFN0YXRzQ29sbGVjdGlvbigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbGxlY3Rpb25zW2hhc2hTdHJpbmddO1xyXG59XHJcbmZ1bmN0aW9uIHN0YXRzTWFuYWdlckdldE9yQ3JlYXRlUmVwb3J0ZXIocmVwb0luZm8sIGNyZWF0b3JGdW5jdGlvbikge1xyXG4gICAgY29uc3QgaGFzaFN0cmluZyA9IHJlcG9JbmZvLnRvU3RyaW5nKCk7XHJcbiAgICBpZiAoIXJlcG9ydGVyc1toYXNoU3RyaW5nXSkge1xyXG4gICAgICAgIHJlcG9ydGVyc1toYXNoU3RyaW5nXSA9IGNyZWF0b3JGdW5jdGlvbigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcG9ydGVyc1toYXNoU3RyaW5nXTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogVGhlIHNlbXZlciAod3d3LnNlbXZlci5vcmcpIHZlcnNpb24gb2YgdGhlIFNESy4gKi9cclxubGV0IFNES19WRVJTSU9OID0gJyc7XHJcbi8qKlxyXG4gKiBTREtfVkVSU0lPTiBzaG91bGQgYmUgc2V0IGJlZm9yZSBhbnkgZGF0YWJhc2UgaW5zdGFuY2UgaXMgY3JlYXRlZFxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHNldFNES1ZlcnNpb24odmVyc2lvbikge1xyXG4gICAgU0RLX1ZFUlNJT04gPSB2ZXJzaW9uO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IFdFQlNPQ0tFVF9NQVhfRlJBTUVfU0laRSA9IDE2Mzg0O1xyXG5jb25zdCBXRUJTT0NLRVRfS0VFUEFMSVZFX0lOVEVSVkFMID0gNDUwMDA7XHJcbmxldCBXZWJTb2NrZXRJbXBsID0gbnVsbDtcclxuaWYgKHR5cGVvZiBNb3pXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBXZWJTb2NrZXRJbXBsID0gTW96V2ViU29ja2V0O1xyXG59XHJcbmVsc2UgaWYgKHR5cGVvZiBXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBXZWJTb2NrZXRJbXBsID0gV2ViU29ja2V0O1xyXG59XHJcbmZ1bmN0aW9uIHNldFdlYlNvY2tldEltcGwoaW1wbCkge1xyXG4gICAgV2ViU29ja2V0SW1wbCA9IGltcGw7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyB3ZWJzb2NrZXQgY29ubmVjdGlvbiB3aXRoIHRoZSBnaXZlbiBjYWxsYmFja3MuXHJcbiAqL1xyXG5jbGFzcyBXZWJTb2NrZXRDb25uZWN0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbm5JZCBpZGVudGlmaWVyIGZvciB0aGlzIHRyYW5zcG9ydFxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvIFRoZSBpbmZvIGZvciB0aGUgd2Vic29ja2V0IGVuZHBvaW50LlxyXG4gICAgICogQHBhcmFtIGFwcGxpY2F0aW9uSWQgVGhlIEZpcmViYXNlIEFwcCBJRCBmb3IgdGhpcyBwcm9qZWN0LlxyXG4gICAgICogQHBhcmFtIGFwcENoZWNrVG9rZW4gVGhlIEFwcCBDaGVjayBUb2tlbiBmb3IgdGhpcyBjbGllbnQuXHJcbiAgICAgKiBAcGFyYW0gYXV0aFRva2VuIFRoZSBBdXRoIFRva2VuIGZvciB0aGlzIGNsaWVudC5cclxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnRTZXNzaW9uSWQgT3B0aW9uYWwgdHJhbnNwb3J0U2Vzc2lvbklkIGlmIHRoaXMgaXMgY29ubmVjdGluZ1xyXG4gICAgICogdG8gYW4gZXhpc3RpbmcgdHJhbnNwb3J0IHNlc3Npb25cclxuICAgICAqIEBwYXJhbSBsYXN0U2Vzc2lvbklkIE9wdGlvbmFsIGxhc3RTZXNzaW9uSWQgaWYgdGhlcmUgd2FzIGEgcHJldmlvdXNcclxuICAgICAqIGNvbm5lY3Rpb25cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY29ubklkLCByZXBvSW5mbywgYXBwbGljYXRpb25JZCwgYXBwQ2hlY2tUb2tlbiwgYXV0aFRva2VuLCB0cmFuc3BvcnRTZXNzaW9uSWQsIGxhc3RTZXNzaW9uSWQpIHtcclxuICAgICAgICB0aGlzLmNvbm5JZCA9IGNvbm5JZDtcclxuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSWQgPSBhcHBsaWNhdGlvbklkO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlbiA9IGFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW4gPSBhdXRoVG9rZW47XHJcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5mcmFtZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudG90YWxGcmFtZXMgPSAwO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ID0gMDtcclxuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9nXyA9IGxvZ1dyYXBwZXIodGhpcy5jb25uSWQpO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfID0gc3RhdHNNYW5hZ2VyR2V0Q29sbGVjdGlvbihyZXBvSW5mbyk7XHJcbiAgICAgICAgdGhpcy5jb25uVVJMID0gV2ViU29ja2V0Q29ubmVjdGlvbi5jb25uZWN0aW9uVVJMXyhyZXBvSW5mbywgdHJhbnNwb3J0U2Vzc2lvbklkLCBsYXN0U2Vzc2lvbklkLCBhcHBDaGVja1Rva2VuLCBhcHBsaWNhdGlvbklkKTtcclxuICAgICAgICB0aGlzLm5vZGVBZG1pbiA9IHJlcG9JbmZvLm5vZGVBZG1pbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvIC0gVGhlIGluZm8gZm9yIHRoZSB3ZWJzb2NrZXQgZW5kcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0U2Vzc2lvbklkIC0gT3B0aW9uYWwgdHJhbnNwb3J0U2Vzc2lvbklkIGlmIHRoaXMgaXMgY29ubmVjdGluZyB0byBhbiBleGlzdGluZyB0cmFuc3BvcnRcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uXHJcbiAgICAgKiBAcGFyYW0gbGFzdFNlc3Npb25JZCAtIE9wdGlvbmFsIGxhc3RTZXNzaW9uSWQgaWYgdGhlcmUgd2FzIGEgcHJldmlvdXMgY29ubmVjdGlvblxyXG4gICAgICogQHJldHVybnMgY29ubmVjdGlvbiB1cmxcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNvbm5lY3Rpb25VUkxfKHJlcG9JbmZvLCB0cmFuc3BvcnRTZXNzaW9uSWQsIGxhc3RTZXNzaW9uSWQsIGFwcENoZWNrVG9rZW4sIGFwcGxpY2F0aW9uSWQpIHtcclxuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSB7fTtcclxuICAgICAgICB1cmxQYXJhbXNbVkVSU0lPTl9QQVJBTV0gPSBQUk9UT0NPTF9WRVJTSU9OO1xyXG4gICAgICAgIGlmICghaXNOb2RlU2RrKCkgJiZcclxuICAgICAgICAgICAgdHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICBsb2NhdGlvbi5ob3N0bmFtZSAmJlxyXG4gICAgICAgICAgICBGT1JHRV9ET01BSU5fUkUudGVzdChsb2NhdGlvbi5ob3N0bmFtZSkpIHtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW1JFRkVSRVJfUEFSQU1dID0gRk9SR0VfUkVGO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhbnNwb3J0U2Vzc2lvbklkKSB7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tUUkFOU1BPUlRfU0VTU0lPTl9QQVJBTV0gPSB0cmFuc3BvcnRTZXNzaW9uSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYXN0U2Vzc2lvbklkKSB7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tMQVNUX1NFU1NJT05fUEFSQU1dID0gbGFzdFNlc3Npb25JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwcENoZWNrVG9rZW4pIHtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0FQUF9DSEVDS19UT0tFTl9QQVJBTV0gPSBhcHBDaGVja1Rva2VuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXBwbGljYXRpb25JZCkge1xyXG4gICAgICAgICAgICB1cmxQYXJhbXNbQVBQTElDQVRJT05fSURfUEFSQU1dID0gYXBwbGljYXRpb25JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcG9JbmZvQ29ubmVjdGlvblVSTChyZXBvSW5mbywgV0VCU09DS0VULCB1cmxQYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlIC0gQ2FsbGJhY2sgd2hlbiBtZXNzYWdlcyBhcnJpdmVcclxuICAgICAqIEBwYXJhbSBvbkRpc2Nvbm5lY3QgLSBDYWxsYmFjayB3aXRoIGNvbm5lY3Rpb24gbG9zdC5cclxuICAgICAqL1xyXG4gICAgb3Blbihvbk1lc3NhZ2UsIG9uRGlzY29ubmVjdCkge1xyXG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gb25EaXNjb25uZWN0O1xyXG4gICAgICAgIHRoaXMub25NZXNzYWdlID0gb25NZXNzYWdlO1xyXG4gICAgICAgIHRoaXMubG9nXygnV2Vic29ja2V0IGNvbm5lY3RpbmcgdG8gJyArIHRoaXMuY29ublVSTCk7XHJcbiAgICAgICAgdGhpcy5ldmVyQ29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIC8vIEFzc3VtZSBmYWlsdXJlIHVudGlsIHByb3ZlbiBvdGhlcndpc2UuXHJcbiAgICAgICAgUGVyc2lzdGVudFN0b3JhZ2Uuc2V0KCdwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZScsIHRydWUpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCBvcHRpb25zO1xyXG4gICAgICAgICAgICBpZiAoaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZSA9IHRoaXMubm9kZUFkbWluID8gJ0FkbWluTm9kZScgOiAnTm9kZSc7XHJcbiAgICAgICAgICAgICAgICAvLyBVQSBGb3JtYXQ6IEZpcmViYXNlLzx3aXJlX3Byb3RvY29sPi88c2RrX3ZlcnNpb24+LzxwbGF0Zm9ybT4vPGRldmljZT5cclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6IGBGaXJlYmFzZS8ke1BST1RPQ09MX1ZFUlNJT059LyR7U0RLX1ZFUlNJT059LyR7cHJvY2Vzcy5wbGF0Zm9ybX0vJHtkZXZpY2V9YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1gtRmlyZWJhc2UtR01QSUQnOiB0aGlzLmFwcGxpY2F0aW9uSWQgfHwgJydcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdXNpbmcgTm9kZSB3aXRoIGFkbWluIGNyZWRzLCBBcHBDaGVjay1yZWxhdGVkIGNoZWNrcyBhcmUgdW5uZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgd2Ugc2VuZCB0aGUgY3JlZGVudGlhbHMgaGVyZSBldmVuIGlmIHRoZXkgYXJlbid0IGFkbWluIGNyZWRlbnRpYWxzLCB3aGljaCBpc1xyXG4gICAgICAgICAgICAgICAgLy8gbm90IGEgcHJvYmxlbS5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGhlYWRlciBpcyBqdXN0IHVzZWQgdG8gYnlwYXNzIGFwcGNoZWNrLCBhbmQgdGhlIHRva2VuIHNob3VsZCBzdGlsbCBiZSBzZW50XHJcbiAgICAgICAgICAgICAgICAvLyB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBvbmNlIGl0IGlzIGVzdGFibGlzaGVkLlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0aFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dGhpcy5hdXRoVG9rZW59YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFwcENoZWNrVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ1gtRmlyZWJhc2UtQXBwQ2hlY2snXSA9IHRoaXMuYXBwQ2hlY2tUb2tlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFBsdW1iIGFwcHJvcHJpYXRlIGh0dHBfcHJveHkgZW52aXJvbm1lbnQgdmFyaWFibGUgaW50byBmYXllLXdlYnNvY2tldCBpZiBpdCBleGlzdHMuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbnYgPSBwcm9jZXNzWydlbnYnXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gdGhpcy5jb25uVVJMLmluZGV4T2YoJ3dzczovLycpID09PSAwXHJcbiAgICAgICAgICAgICAgICAgICAgPyBlbnZbJ0hUVFBTX1BST1hZJ10gfHwgZW52WydodHRwc19wcm94eSddXHJcbiAgICAgICAgICAgICAgICAgICAgOiBlbnZbJ0hUVFBfUFJPWFknXSB8fCBlbnZbJ2h0dHBfcHJveHknXTtcclxuICAgICAgICAgICAgICAgIGlmIChwcm94eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbJ3Byb3h5J10gPSB7IG9yaWdpbjogcHJveHkgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm15U29jayA9IG5ldyBXZWJTb2NrZXRJbXBsKHRoaXMuY29ublVSTCwgW10sIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0Vycm9yIGluc3RhbnRpYXRpbmcgV2ViU29ja2V0LicpO1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGUubWVzc2FnZSB8fCBlLmRhdGE7XHJcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubXlTb2NrLm9ub3BlbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdXZWJzb2NrZXQgY29ubmVjdGVkLicpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZXJDb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubXlTb2NrLm9uY2xvc2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2Vic29ja2V0IGNvbm5lY3Rpb24gd2FzIGRpc2Nvbm5lY3RlZC4nKTtcclxuICAgICAgICAgICAgdGhpcy5teVNvY2sgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5teVNvY2sub25tZXNzYWdlID0gbSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSW5jb21pbmdGcmFtZShtKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubXlTb2NrLm9uZXJyb3IgPSBlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdXZWJTb2NrZXQgZXJyb3IuICBDbG9zaW5nIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZS5tZXNzYWdlIHx8IGUuZGF0YTtcclxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub25DbG9zZWRfKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTm8tb3AgZm9yIHdlYnNvY2tldHMsIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcgb25jZSB0aGUgY29ubmVjdGlvbiBpcyBjb25maXJtZWQgYXMgb3BlblxyXG4gICAgICovXHJcbiAgICBzdGFydCgpIHsgfVxyXG4gICAgc3RhdGljIGZvcmNlRGlzYWxsb3coKSB7XHJcbiAgICAgICAgV2ViU29ja2V0Q29ubmVjdGlvbi5mb3JjZURpc2FsbG93XyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaXNBdmFpbGFibGUoKSB7XHJcbiAgICAgICAgbGV0IGlzT2xkQW5kcm9pZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZEFuZHJvaWRSZWdleCA9IC9BbmRyb2lkIChbMC05XXswLH1cXC5bMC05XXswLH0pLztcclxuICAgICAgICAgICAgY29uc3Qgb2xkQW5kcm9pZE1hdGNoID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChvbGRBbmRyb2lkUmVnZXgpO1xyXG4gICAgICAgICAgICBpZiAob2xkQW5kcm9pZE1hdGNoICYmIG9sZEFuZHJvaWRNYXRjaC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChvbGRBbmRyb2lkTWF0Y2hbMV0pIDwgNC40KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNPbGRBbmRyb2lkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKCFpc09sZEFuZHJvaWQgJiZcclxuICAgICAgICAgICAgV2ViU29ja2V0SW1wbCAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAhV2ViU29ja2V0Q29ubmVjdGlvbi5mb3JjZURpc2FsbG93Xyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB3ZSBwcmV2aW91c2x5IGZhaWxlZCB0byBjb25uZWN0IHdpdGggdGhpcyB0cmFuc3BvcnQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBwcmV2aW91c2x5RmFpbGVkKCkge1xyXG4gICAgICAgIC8vIElmIG91ciBwZXJzaXN0ZW50IHN0b3JhZ2UgaXMgYWN0dWFsbHkgb25seSBpbi1tZW1vcnkgc3RvcmFnZSxcclxuICAgICAgICAvLyB3ZSBkZWZhdWx0IHRvIGFzc3VtaW5nIHRoYXQgaXQgcHJldmlvdXNseSBmYWlsZWQgdG8gYmUgc2FmZS5cclxuICAgICAgICByZXR1cm4gKFBlcnNpc3RlbnRTdG9yYWdlLmlzSW5NZW1vcnlTdG9yYWdlIHx8XHJcbiAgICAgICAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLmdldCgncHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmUnKSA9PT0gdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBtYXJrQ29ubmVjdGlvbkhlYWx0aHkoKSB7XHJcbiAgICAgICAgUGVyc2lzdGVudFN0b3JhZ2UucmVtb3ZlKCdwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZScpO1xyXG4gICAgfVxyXG4gICAgYXBwZW5kRnJhbWVfKGRhdGEpIHtcclxuICAgICAgICB0aGlzLmZyYW1lcy5wdXNoKGRhdGEpO1xyXG4gICAgICAgIGlmICh0aGlzLmZyYW1lcy5sZW5ndGggPT09IHRoaXMudG90YWxGcmFtZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgZnVsbE1lc3MgPSB0aGlzLmZyYW1lcy5qb2luKCcnKTtcclxuICAgICAgICAgICAgdGhpcy5mcmFtZXMgPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBqc29uTWVzcyA9IGpzb25FdmFsKGZ1bGxNZXNzKTtcclxuICAgICAgICAgICAgLy9oYW5kbGUgdGhlIG1lc3NhZ2VcclxuICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2UoanNvbk1lc3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGZyYW1lQ291bnQgLSBUaGUgbnVtYmVyIG9mIGZyYW1lcyB3ZSBhcmUgZXhwZWN0aW5nIGZyb20gdGhlIHNlcnZlclxyXG4gICAgICovXHJcbiAgICBoYW5kbGVOZXdGcmFtZUNvdW50XyhmcmFtZUNvdW50KSB7XHJcbiAgICAgICAgdGhpcy50b3RhbEZyYW1lcyA9IGZyYW1lQ291bnQ7XHJcbiAgICAgICAgdGhpcy5mcmFtZXMgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gcGFyc2UgYSBmcmFtZSBjb3VudCBvdXQgb2Ygc29tZSB0ZXh0LiBJZiBpdCBjYW4ndCwgYXNzdW1lcyBhIHZhbHVlIG9mIDFcclxuICAgICAqIEByZXR1cm5zIEFueSByZW1haW5pbmcgZGF0YSB0byBiZSBwcm9jZXNzLCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmVcclxuICAgICAqL1xyXG4gICAgZXh0cmFjdEZyYW1lQ291bnRfKGRhdGEpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5mcmFtZXMgPT09IG51bGwsICdXZSBhbHJlYWR5IGhhdmUgYSBmcmFtZSBidWZmZXInKTtcclxuICAgICAgICAvLyBUT0RPOiBUaGUgc2VydmVyIGlzIG9ubHkgc3VwcG9zZWQgdG8gc2VuZCB1cCB0byA5OTk5IGZyYW1lcyAoaS5lLiBsZW5ndGggPD0gNCksIGJ1dCB0aGF0IGlzbid0IGJlaW5nIGVuZm9yY2VkXHJcbiAgICAgICAgLy8gY3VycmVudGx5LiAgU28gYWxsb3dpbmcgbGFyZ2VyIGZyYW1lIGNvdW50cyAobGVuZ3RoIDw9IDYpLiAgU2VlIGh0dHBzOi8vYXBwLmFzYW5hLmNvbS8wL3NlYXJjaC84Njg4NTk4OTk4MzgwLzgyMzc2MDgwNDI1MDhcclxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPD0gNikge1xyXG4gICAgICAgICAgICBjb25zdCBmcmFtZUNvdW50ID0gTnVtYmVyKGRhdGEpO1xyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKGZyYW1lQ291bnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU5ld0ZyYW1lQ291bnRfKGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oYW5kbGVOZXdGcmFtZUNvdW50XygxKTtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvY2VzcyBhIHdlYnNvY2tldCBmcmFtZSB0aGF0IGhhcyBhcnJpdmVkIGZyb20gdGhlIHNlcnZlci5cclxuICAgICAqIEBwYXJhbSBtZXNzIC0gVGhlIGZyYW1lIGRhdGFcclxuICAgICAqL1xyXG4gICAgaGFuZGxlSW5jb21pbmdGcmFtZShtZXNzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubXlTb2NrID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gQ2hyb21lIGFwcGFyZW50bHkgZGVsaXZlcnMgaW5jb21pbmcgcGFja2V0cyBldmVuIGFmdGVyIHdlIC5jbG9zZSgpIHRoZSBjb25uZWN0aW9uIHNvbWV0aW1lcy5cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IG1lc3NbJ2RhdGEnXTtcclxuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgKz0gZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5zdGF0c18uaW5jcmVtZW50Q291bnRlcignYnl0ZXNfcmVjZWl2ZWQnLCBkYXRhLmxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5yZXNldEtlZXBBbGl2ZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmZyYW1lcyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyB3ZSdyZSBidWZmZXJpbmdcclxuICAgICAgICAgICAgdGhpcy5hcHBlbmRGcmFtZV8oZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0cnkgdG8gcGFyc2Ugb3V0IGEgZnJhbWUgY291bnQsIG90aGVyd2lzZSwgYXNzdW1lIDEgYW5kIHByb2Nlc3MgaXRcclxuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nRGF0YSA9IHRoaXMuZXh0cmFjdEZyYW1lQ291bnRfKGRhdGEpO1xyXG4gICAgICAgICAgICBpZiAocmVtYWluaW5nRGF0YSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRGcmFtZV8ocmVtYWluaW5nRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBzZXJ2ZXJcclxuICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIEpTT04gb2JqZWN0IHRvIHRyYW5zbWl0XHJcbiAgICAgKi9cclxuICAgIHNlbmQoZGF0YSkge1xyXG4gICAgICAgIHRoaXMucmVzZXRLZWVwQWxpdmUoKTtcclxuICAgICAgICBjb25zdCBkYXRhU3RyID0gc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ICs9IGRhdGFTdHIubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfLmluY3JlbWVudENvdW50ZXIoJ2J5dGVzX3NlbnQnLCBkYXRhU3RyLmxlbmd0aCk7XHJcbiAgICAgICAgLy9XZSBjYW4gb25seSBmaXQgYSBjZXJ0YWluIGFtb3VudCBpbiBlYWNoIHdlYnNvY2tldCBmcmFtZSwgc28gd2UgbmVlZCB0byBzcGxpdCB0aGlzIHJlcXVlc3RcclxuICAgICAgICAvL3VwIGludG8gbXVsdGlwbGUgcGllY2VzIGlmIGl0IGRvZXNuJ3QgZml0IGluIG9uZSByZXF1ZXN0LlxyXG4gICAgICAgIGNvbnN0IGRhdGFTZWdzID0gc3BsaXRTdHJpbmdCeVNpemUoZGF0YVN0ciwgV0VCU09DS0VUX01BWF9GUkFNRV9TSVpFKTtcclxuICAgICAgICAvL1NlbmQgdGhlIGxlbmd0aCBoZWFkZXJcclxuICAgICAgICBpZiAoZGF0YVNlZ3MubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRTdHJpbmdfKFN0cmluZyhkYXRhU2Vncy5sZW5ndGgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9TZW5kIHRoZSBhY3R1YWwgZGF0YSBpbiBzZWdtZW50cy5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFN0cmluZ18oZGF0YVNlZ3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNodXRkb3duXygpIHtcclxuICAgICAgICB0aGlzLmlzQ2xvc2VkXyA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMua2VlcGFsaXZlVGltZXIpIHtcclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBhbGl2ZVRpbWVyKTtcclxuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm15U29jaykge1xyXG4gICAgICAgICAgICB0aGlzLm15U29jay5jbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm15U29jayA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25DbG9zZWRfKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0Nsb3NlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdXZWJTb2NrZXQgaXMgY2xvc2luZyBpdHNlbGYnKTtcclxuICAgICAgICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcclxuICAgICAgICAgICAgLy8gc2luY2UgdGhpcyBpcyBhbiBpbnRlcm5hbCBjbG9zZSwgdHJpZ2dlciB0aGUgY2xvc2UgbGlzdGVuZXJcclxuICAgICAgICAgICAgaWYgKHRoaXMub25EaXNjb25uZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCh0aGlzLmV2ZXJDb25uZWN0ZWRfKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZXJuYWwtZmFjaW5nIGNsb3NlIGhhbmRsZXIuXHJcbiAgICAgKiBDbG9zZSB0aGUgd2Vic29ja2V0IGFuZCBraWxsIHRoZSBjb25uZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2ViU29ja2V0IGlzIGJlaW5nIGNsb3NlZCcpO1xyXG4gICAgICAgICAgICB0aGlzLnNodXRkb3duXygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogS2lsbCB0aGUgY3VycmVudCBrZWVwYWxpdmUgdGltZXIgYW5kIHN0YXJ0IGEgbmV3IG9uZSwgdG8gZW5zdXJlIHRoYXQgaXQgYWx3YXlzIGZpcmVzIE4gc2Vjb25kcyBhZnRlclxyXG4gICAgICogdGhlIGxhc3QgYWN0aXZpdHkuXHJcbiAgICAgKi9cclxuICAgIHJlc2V0S2VlcEFsaXZlKCkge1xyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5rZWVwYWxpdmVUaW1lcik7XHJcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgICAgICAgLy9JZiB0aGVyZSBoYXMgYmVlbiBubyB3ZWJzb2NrZXQgYWN0aXZpdHkgZm9yIGEgd2hpbGUsIHNlbmQgYSBuby1vcFxyXG4gICAgICAgICAgICBpZiAodGhpcy5teVNvY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFN0cmluZ18oJzAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlc2V0S2VlcEFsaXZlKCk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcihXRUJTT0NLRVRfS0VFUEFMSVZFX0lOVEVSVkFMKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgYSBzdHJpbmcgb3ZlciB0aGUgd2Vic29ja2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdHIgLSBTdHJpbmcgdG8gc2VuZC5cclxuICAgICAqL1xyXG4gICAgc2VuZFN0cmluZ18oc3RyKSB7XHJcbiAgICAgICAgLy8gRmlyZWZveCBzZWVtcyB0byBzb21ldGltZXMgdGhyb3cgZXhjZXB0aW9ucyAoTlNfRVJST1JfVU5FWFBFQ1RFRCkgZnJvbSB3ZWJzb2NrZXQgLnNlbmQoKVxyXG4gICAgICAgIC8vIGNhbGxzIGZvciBzb21lIHVua25vd24gcmVhc29uLiAgV2UgdHJlYXQgdGhlc2UgYXMgYW4gZXJyb3IgYW5kIGRpc2Nvbm5lY3QuXHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vYXBwLmFzYW5hLmNvbS8wLzU4OTI2MTExNDAyMjkyLzY4MDIxMzQwMjUwNDEwXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5teVNvY2suc2VuZChzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0V4Y2VwdGlvbiB0aHJvd24gZnJvbSBXZWJTb2NrZXQuc2VuZCgpOicsIGUubWVzc2FnZSB8fCBlLmRhdGEsICdDbG9zaW5nIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5vbkNsb3NlZF8uYmluZCh0aGlzKSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBOdW1iZXIgb2YgcmVzcG9uc2UgYmVmb3JlIHdlIGNvbnNpZGVyIHRoZSBjb25uZWN0aW9uIFwiaGVhbHRoeS5cIlxyXG4gKi9cclxuV2ViU29ja2V0Q29ubmVjdGlvbi5yZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5ID0gMjtcclxuLyoqXHJcbiAqIFRpbWUgdG8gd2FpdCBmb3IgdGhlIGNvbm5lY3Rpb24gdGUgYmVjb21lIGhlYWx0aHkgYmVmb3JlIGdpdmluZyB1cC5cclxuICovXHJcbldlYlNvY2tldENvbm5lY3Rpb24uaGVhbHRoeVRpbWVvdXQgPSAzMDAwMDtcblxuY29uc3QgbmFtZSA9IFwiQGZpcmViYXNlL2RhdGFiYXNlXCI7XG5jb25zdCB2ZXJzaW9uID0gXCIxLjAuNVwiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQWJzdHJhY3Rpb24gYXJvdW5kIEFwcENoZWNrJ3MgdG9rZW4gZmV0Y2hpbmcgY2FwYWJpbGl0aWVzLlxyXG4gKi9cclxuY2xhc3MgQXBwQ2hlY2tUb2tlblByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcE5hbWVfLCBhcHBDaGVja1Byb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5hcHBOYW1lXyA9IGFwcE5hbWVfO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tQcm92aWRlciA9IGFwcENoZWNrUHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVjayA9IGFwcENoZWNrUHJvdmlkZXIgPT09IG51bGwgfHwgYXBwQ2hlY2tQcm92aWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXBwQ2hlY2tQcm92aWRlci5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcclxuICAgICAgICBpZiAoIXRoaXMuYXBwQ2hlY2spIHtcclxuICAgICAgICAgICAgYXBwQ2hlY2tQcm92aWRlciA9PT0gbnVsbCB8fCBhcHBDaGVja1Byb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHBDaGVja1Byb3ZpZGVyLmdldCgpLnRoZW4oYXBwQ2hlY2sgPT4gKHRoaXMuYXBwQ2hlY2sgPSBhcHBDaGVjaykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldFRva2VuKGZvcmNlUmVmcmVzaCkge1xyXG4gICAgICAgIGlmICghdGhpcy5hcHBDaGVjaykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydCBkZWxheWVkIGluaXRpYWxpemF0aW9uIG9mIEZpcmViYXNlQXBwQ2hlY2suIFRoaXMgYWxsb3dzIG91clxyXG4gICAgICAgICAgICAgICAgLy8gY3VzdG9tZXJzIHRvIGluaXRpYWxpemUgdGhlIFJUREIgU0RLIGJlZm9yZSBpbml0aWFsaXppbmcgRmlyZWJhc2VcclxuICAgICAgICAgICAgICAgIC8vIEFwcENoZWNrIGFuZCBlbnN1cmVzIHRoYXQgYWxsIHJlcXVlc3RzIGFyZSBhdXRoZW50aWNhdGVkIGlmIGEgdG9rZW5cclxuICAgICAgICAgICAgICAgIC8vIGJlY29tZXMgYXZhaWxhYmxlIGJlZm9yZSB0aGUgdGltb2VvdXQgYmVsb3cgZXhwaXJlcy5cclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFwcENoZWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwQ2hlY2suZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKTtcclxuICAgIH1cclxuICAgIGFkZFRva2VuQ2hhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy5hcHBDaGVja1Byb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KCkudGhlbihhcHBDaGVjayA9PiBhcHBDaGVjay5hZGRUb2tlbkxpc3RlbmVyKGxpc3RlbmVyKSk7XHJcbiAgICB9XHJcbiAgICBub3RpZnlGb3JJbnZhbGlkVG9rZW4oKSB7XHJcbiAgICAgICAgd2FybihgUHJvdmlkZWQgQXBwQ2hlY2sgY3JlZGVudGlhbHMgZm9yIHRoZSBhcHAgbmFtZWQgXCIke3RoaXMuYXBwTmFtZV99XCIgYCArXHJcbiAgICAgICAgICAgICdhcmUgaW52YWxpZC4gVGhpcyB1c3VhbGx5IGluZGljYXRlcyB5b3VyIGFwcCB3YXMgbm90IGluaXRpYWxpemVkIGNvcnJlY3RseS4nKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQWJzdHJhY3Rpb24gYXJvdW5kIEZpcmViYXNlQXBwJ3MgdG9rZW4gZmV0Y2hpbmcgY2FwYWJpbGl0aWVzLlxyXG4gKi9cclxuY2xhc3MgRmlyZWJhc2VBdXRoVG9rZW5Qcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHBOYW1lXywgZmlyZWJhc2VPcHRpb25zXywgYXV0aFByb3ZpZGVyXykge1xyXG4gICAgICAgIHRoaXMuYXBwTmFtZV8gPSBhcHBOYW1lXztcclxuICAgICAgICB0aGlzLmZpcmViYXNlT3B0aW9uc18gPSBmaXJlYmFzZU9wdGlvbnNfO1xyXG4gICAgICAgIHRoaXMuYXV0aFByb3ZpZGVyXyA9IGF1dGhQcm92aWRlcl87XHJcbiAgICAgICAgdGhpcy5hdXRoXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hdXRoXyA9IGF1dGhQcm92aWRlcl8uZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmF1dGhfKSB7XHJcbiAgICAgICAgICAgIGF1dGhQcm92aWRlcl8ub25Jbml0KGF1dGggPT4gKHRoaXMuYXV0aF8gPSBhdXRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmF1dGhfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0IGRlbGF5ZWQgaW5pdGlhbGl6YXRpb24gb2YgRmlyZWJhc2VBdXRoLiBUaGlzIGFsbG93cyBvdXJcclxuICAgICAgICAgICAgICAgIC8vIGN1c3RvbWVycyB0byBpbml0aWFsaXplIHRoZSBSVERCIFNESyBiZWZvcmUgaW5pdGlhbGl6aW5nIEZpcmViYXNlXHJcbiAgICAgICAgICAgICAgICAvLyBBdXRoIGFuZCBlbnN1cmVzIHRoYXQgYWxsIHJlcXVlc3RzIGFyZSBhdXRoZW50aWNhdGVkIGlmIGEgdG9rZW5cclxuICAgICAgICAgICAgICAgIC8vIGJlY29tZXMgYXZhaWxhYmxlIGJlZm9yZSB0aGUgdGltb2VvdXQgYmVsb3cgZXhwaXJlcy5cclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1dGhfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aF8uZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKS5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IE5lZWQgdG8gZmlndXJlIG91dCBhbGwgdGhlIGNhc2VzIHRoaXMgaXMgcmFpc2VkIGFuZCB3aGV0aGVyXHJcbiAgICAgICAgICAgIC8vIHRoaXMgbWFrZXMgc2Vuc2UuXHJcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5jb2RlID09PSAnYXV0aC90b2tlbi1ub3QtaW5pdGlhbGl6ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBsb2coJ0dvdCBhdXRoL3Rva2VuLW5vdC1pbml0aWFsaXplZCBlcnJvci4gIFRyZWF0aW5nIGFzIG51bGwgdG9rZW4uJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFkZFRva2VuQ2hhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICAvLyBUT0RPOiBXZSBtaWdodCB3YW50IHRvIHdyYXAgdGhlIGxpc3RlbmVyIGFuZCBjYWxsIGl0IHdpdGggbm8gYXJncyB0b1xyXG4gICAgICAgIC8vIGF2b2lkIGEgbGVha3kgYWJzdHJhY3Rpb24sIGJ1dCB0aGF0IG1ha2VzIHJlbW92aW5nIHRoZSBsaXN0ZW5lciBoYXJkZXIuXHJcbiAgICAgICAgaWYgKHRoaXMuYXV0aF8pIHtcclxuICAgICAgICAgICAgdGhpcy5hdXRoXy5hZGRBdXRoVG9rZW5MaXN0ZW5lcihsaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhQcm92aWRlcl9cclxuICAgICAgICAgICAgICAgIC5nZXQoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oYXV0aCA9PiBhdXRoLmFkZEF1dGhUb2tlbkxpc3RlbmVyKGxpc3RlbmVyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlVG9rZW5DaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMuYXV0aFByb3ZpZGVyX1xyXG4gICAgICAgICAgICAuZ2V0KClcclxuICAgICAgICAgICAgLnRoZW4oYXV0aCA9PiBhdXRoLnJlbW92ZUF1dGhUb2tlbkxpc3RlbmVyKGxpc3RlbmVyKSk7XHJcbiAgICB9XHJcbiAgICBub3RpZnlGb3JJbnZhbGlkVG9rZW4oKSB7XHJcbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9ICdQcm92aWRlZCBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyBmb3IgdGhlIGFwcCBuYW1lZCBcIicgK1xyXG4gICAgICAgICAgICB0aGlzLmFwcE5hbWVfICtcclxuICAgICAgICAgICAgJ1wiIGFyZSBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgaW5kaWNhdGVzIHlvdXIgYXBwIHdhcyBub3QgJyArXHJcbiAgICAgICAgICAgICdpbml0aWFsaXplZCBjb3JyZWN0bHkuICc7XHJcbiAgICAgICAgaWYgKCdjcmVkZW50aWFsJyBpbiB0aGlzLmZpcmViYXNlT3B0aW9uc18pIHtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XHJcbiAgICAgICAgICAgICAgICAnTWFrZSBzdXJlIHRoZSBcImNyZWRlbnRpYWxcIiBwcm9wZXJ0eSBwcm92aWRlZCB0byBpbml0aWFsaXplQXBwKCkgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2lzIGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoZSBzcGVjaWZpZWQgXCJkYXRhYmFzZVVSTFwiIGFuZCBpcyBmcm9tIHRoZSBjb3JyZWN0ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdwcm9qZWN0Lic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdzZXJ2aWNlQWNjb3VudCcgaW4gdGhpcy5maXJlYmFzZU9wdGlvbnNfKSB7XHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPVxyXG4gICAgICAgICAgICAgICAgJ01ha2Ugc3VyZSB0aGUgXCJzZXJ2aWNlQWNjb3VudFwiIHByb3BlcnR5IHByb3ZpZGVkIHRvIGluaXRpYWxpemVBcHAoKSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaXMgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhlIHNwZWNpZmllZCBcImRhdGFiYXNlVVJMXCIgYW5kIGlzIGZyb20gdGhlIGNvcnJlY3QgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3Byb2plY3QuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPVxyXG4gICAgICAgICAgICAgICAgJ01ha2Ugc3VyZSB0aGUgXCJhcGlLZXlcIiBhbmQgXCJkYXRhYmFzZVVSTFwiIHByb3BlcnRpZXMgcHJvdmlkZWQgdG8gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2luaXRpYWxpemVBcHAoKSBtYXRjaCB0aGUgdmFsdWVzIHByb3ZpZGVkIGZvciB5b3VyIGFwcCBhdCAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9jb25zb2xlLmZpcmViYXNlLmdvb2dsZS5jb20vLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdhcm4oZXJyb3JNZXNzYWdlKTtcclxuICAgIH1cclxufVxyXG4vKiBBdXRoVG9rZW5Qcm92aWRlciB0aGF0IHN1cHBsaWVzIGEgY29uc3RhbnQgdG9rZW4uIFVzZWQgYnkgQWRtaW4gU0RLIG9yIG1vY2tVc2VyVG9rZW4gd2l0aCBlbXVsYXRvcnMuICovXHJcbmNsYXNzIEVtdWxhdG9yVG9rZW5Qcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhY2Nlc3NUb2tlbikge1xyXG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbjtcclxuICAgIH1cclxuICAgIGdldFRva2VuKGZvcmNlUmVmcmVzaCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xyXG4gICAgICAgICAgICBhY2Nlc3NUb2tlbjogdGhpcy5hY2Nlc3NUb2tlblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIC8vIEludm9rZSB0aGUgbGlzdGVuZXIgaW1tZWRpYXRlbHkgdG8gbWF0Y2ggdGhlIGJlaGF2aW9yIGluIEZpcmViYXNlIEF1dGhcclxuICAgICAgICAvLyAoc2VlIHBhY2thZ2VzL2F1dGgvc3JjL2F1dGguanMjTDE4MDcpXHJcbiAgICAgICAgbGlzdGVuZXIodGhpcy5hY2Nlc3NUb2tlbik7XHJcbiAgICB9XHJcbiAgICByZW1vdmVUb2tlbkNoYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7IH1cclxuICAgIG5vdGlmeUZvckludmFsaWRUb2tlbigpIHsgfVxyXG59XHJcbi8qKiBBIHN0cmluZyB0aGF0IGlzIHRyZWF0ZWQgYXMgYW4gYWRtaW4gYWNjZXNzIHRva2VuIGJ5IHRoZSBSVERCIGVtdWxhdG9yLiBVc2VkIGJ5IEFkbWluIFNESy4gKi9cclxuRW11bGF0b3JUb2tlblByb3ZpZGVyLk9XTkVSID0gJ293bmVyJztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgZW5zdXJlcyB0aGUgcGFja2V0cyBmcm9tIHRoZSBzZXJ2ZXIgYXJyaXZlIGluIG9yZGVyXHJcbiAqIFRoaXMgY2xhc3MgdGFrZXMgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgYW5kIGVuc3VyZXMgaXQgZ2V0cyBwYXNzZWQgaW50byB0aGUgY2FsbGJhY2tzIGluIG9yZGVyLlxyXG4gKi9cclxuY2xhc3MgUGFja2V0UmVjZWl2ZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlX1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihvbk1lc3NhZ2VfKSB7XHJcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2VfID0gb25NZXNzYWdlXztcclxuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRSZXNwb25zZU51bSA9IDA7XHJcbiAgICAgICAgdGhpcy5jbG9zZUFmdGVyUmVzcG9uc2UgPSAtMTtcclxuICAgICAgICB0aGlzLm9uQ2xvc2UgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgY2xvc2VBZnRlcihyZXNwb25zZU51bSwgY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSA9IHJlc3BvbnNlTnVtO1xyXG4gICAgICAgIHRoaXMub25DbG9zZSA9IGNhbGxiYWNrO1xyXG4gICAgICAgIGlmICh0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSA8IHRoaXMuY3VycmVudFJlc3BvbnNlTnVtKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRWFjaCBtZXNzYWdlIGZyb20gdGhlIHNlcnZlciBjb21lcyB3aXRoIGEgcmVzcG9uc2UgbnVtYmVyLCBhbmQgYW4gYXJyYXkgb2YgZGF0YS4gVGhlIHJlc3BvbnNlTnVtYmVyXHJcbiAgICAgKiBhbGxvd3MgdXMgdG8gZW5zdXJlIHRoYXQgd2UgcHJvY2VzcyB0aGVtIGluIHRoZSByaWdodCBvcmRlciwgc2luY2Ugd2UgY2FuJ3QgYmUgZ3VhcmFudGVlZCB0aGF0IGFsbFxyXG4gICAgICogYnJvd3NlcnMgd2lsbCByZXNwb25kIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSByZXF1ZXN0cyB3ZSBzZW50XHJcbiAgICAgKi9cclxuICAgIGhhbmRsZVJlc3BvbnNlKHJlcXVlc3ROdW0sIGRhdGEpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXNbcmVxdWVzdE51bV0gPSBkYXRhO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLnBlbmRpbmdSZXNwb25zZXNbdGhpcy5jdXJyZW50UmVzcG9uc2VOdW1dKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvUHJvY2VzcyA9IHRoaXMucGVuZGluZ1Jlc3BvbnNlc1t0aGlzLmN1cnJlbnRSZXNwb25zZU51bV07XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXNwb25zZXNbdGhpcy5jdXJyZW50UmVzcG9uc2VOdW1dO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvUHJvY2Vzcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvUHJvY2Vzc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbkd1YXJkKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2VfKHRvUHJvY2Vzc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFJlc3BvbnNlTnVtID09PSB0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25DbG9zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNwb25zZU51bSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBVUkwgcXVlcnkgcGFyYW1ldGVycyBhc3NvY2lhdGVkIHdpdGggbG9uZ3BvbGxpbmdcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfU1RBUlRfUEFSQU0gPSAnc3RhcnQnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9DTE9TRV9DT01NQU5EID0gJ2Nsb3NlJztcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfQ09NTUFORF9DQl9OQU1FID0gJ3BMUENvbW1hbmQnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9EQVRBX0NCX05BTUUgPSAncFJUTFBDQic7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNID0gJ2lkJztcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfUFdfUEFSQU0gPSAncHcnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9TRVJJQUxfUEFSQU0gPSAnc2VyJztcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfQ0FMTEJBQ0tfSURfUEFSQU0gPSAnY2InO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UX05VTV9QQVJBTSA9ICdzZWcnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UU19JTl9QQUNLRVQgPSAndHMnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9EQVRBX1BBUkFNID0gJ2QnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9ESVNDT05OX0ZSQU1FX1JFUVVFU1RfUEFSQU0gPSAnZGZyYW1lJztcclxuLy9EYXRhIHNpemUgY29uc3RhbnRzLlxyXG4vL1RPRE86IFBlcmY6IHRoZSBtYXhpbXVtIGxlbmd0aCBhY3R1YWxseSBkaWZmZXJzIGZyb20gYnJvd3NlciB0byBicm93c2VyLlxyXG4vLyBXZSBzaG91bGQgY2hlY2sgd2hhdCBicm93c2VyIHdlJ3JlIG9uIGFuZCBzZXQgYWNjb3JkaW5nbHkuXHJcbmNvbnN0IE1BWF9VUkxfREFUQV9TSVpFID0gMTg3MDtcclxuY29uc3QgU0VHX0hFQURFUl9TSVpFID0gMzA7IC8vaWU6ICZzZWc9ODI5OTIzNCZ0cz05ODIzODkxMjMmZD1cclxuY29uc3QgTUFYX1BBWUxPQURfU0laRSA9IE1BWF9VUkxfREFUQV9TSVpFIC0gU0VHX0hFQURFUl9TSVpFO1xyXG4vKipcclxuICogS2VlcGFsaXZlIHBlcmlvZFxyXG4gKiBzZW5kIGEgZnJlc2ggcmVxdWVzdCBhdCBtaW5pbXVtIGV2ZXJ5IDI1IHNlY29uZHMuIE9wZXJhIGhhcyBhIG1heGltdW0gcmVxdWVzdFxyXG4gKiBsZW5ndGggb2YgMzAgc2Vjb25kcyB0aGF0IHdlIGNhbid0IGV4Y2VlZC5cclxuICovXHJcbmNvbnN0IEtFRVBBTElWRV9SRVFVRVNUX0lOVEVSVkFMID0gMjUwMDA7XHJcbi8qKlxyXG4gKiBIb3cgbG9uZyB0byB3YWl0IGJlZm9yZSBhYm9ydGluZyBhIGxvbmctcG9sbGluZyBjb25uZWN0aW9uIGF0dGVtcHQuXHJcbiAqL1xyXG5jb25zdCBMUF9DT05ORUNUX1RJTUVPVVQgPSAzMDAwMDtcclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgbWFuYWdlcyBhIHNpbmdsZSBsb25nLXBvbGxpbmcgY29ubmVjdGlvbi5cclxuICovXHJcbmNsYXNzIEJyb3dzZXJQb2xsQ29ubmVjdGlvbiB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBjb25uSWQgQW4gaWRlbnRpZmllciBmb3IgdGhpcyBjb25uZWN0aW9uLCB1c2VkIGZvciBsb2dnaW5nXHJcbiAgICAgKiBAcGFyYW0gcmVwb0luZm8gVGhlIGluZm8gZm9yIHRoZSBlbmRwb2ludCB0byBzZW5kIGRhdGEgdG8uXHJcbiAgICAgKiBAcGFyYW0gYXBwbGljYXRpb25JZCBUaGUgRmlyZWJhc2UgQXBwIElEIGZvciB0aGlzIHByb2plY3QuXHJcbiAgICAgKiBAcGFyYW0gYXBwQ2hlY2tUb2tlbiBUaGUgQXBwQ2hlY2sgdG9rZW4gZm9yIHRoaXMgY2xpZW50LlxyXG4gICAgICogQHBhcmFtIGF1dGhUb2tlbiBUaGUgQXV0aFRva2VuIHRvIHVzZSBmb3IgdGhpcyBjb25uZWN0aW9uLlxyXG4gICAgICogQHBhcmFtIHRyYW5zcG9ydFNlc3Npb25JZCBPcHRpb25hbCB0cmFuc3BvcnRTZXNzaW9uaWQgaWYgd2UgYXJlXHJcbiAgICAgKiByZWNvbm5lY3RpbmcgZm9yIGFuIGV4aXN0aW5nIHRyYW5zcG9ydCBzZXNzaW9uXHJcbiAgICAgKiBAcGFyYW0gbGFzdFNlc3Npb25JZCBPcHRpb25hbCBsYXN0U2Vzc2lvbklkIGlmIHRoZSBQZXJzaXN0ZW50Q29ubmVjdGlvbiBoYXNcclxuICAgICAqIGFscmVhZHkgY3JlYXRlZCBhIGNvbm5lY3Rpb24gcHJldmlvdXNseVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25uSWQsIHJlcG9JbmZvLCBhcHBsaWNhdGlvbklkLCBhcHBDaGVja1Rva2VuLCBhdXRoVG9rZW4sIHRyYW5zcG9ydFNlc3Npb25JZCwgbGFzdFNlc3Npb25JZCkge1xyXG4gICAgICAgIHRoaXMuY29ubklkID0gY29ubklkO1xyXG4gICAgICAgIHRoaXMucmVwb0luZm8gPSByZXBvSW5mbztcclxuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSWQgPSBhcHBsaWNhdGlvbklkO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlbiA9IGFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW4gPSBhdXRoVG9rZW47XHJcbiAgICAgICAgdGhpcy50cmFuc3BvcnRTZXNzaW9uSWQgPSB0cmFuc3BvcnRTZXNzaW9uSWQ7XHJcbiAgICAgICAgdGhpcy5sYXN0U2Vzc2lvbklkID0gbGFzdFNlc3Npb25JZDtcclxuICAgICAgICB0aGlzLmJ5dGVzU2VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5ieXRlc1JlY2VpdmVkID0gMDtcclxuICAgICAgICB0aGlzLmV2ZXJDb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sb2dfID0gbG9nV3JhcHBlcihjb25uSWQpO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfID0gc3RhdHNNYW5hZ2VyR2V0Q29sbGVjdGlvbihyZXBvSW5mbyk7XHJcbiAgICAgICAgdGhpcy51cmxGbiA9IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgLy8gQWx3YXlzIGFkZCB0aGUgdG9rZW4gaWYgd2UgaGF2ZSBvbmUuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcENoZWNrVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtc1tBUFBfQ0hFQ0tfVE9LRU5fUEFSQU1dID0gdGhpcy5hcHBDaGVja1Rva2VuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXBvSW5mb0Nvbm5lY3Rpb25VUkwocmVwb0luZm8sIExPTkdfUE9MTElORywgcGFyYW1zKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlIC0gQ2FsbGJhY2sgd2hlbiBtZXNzYWdlcyBhcnJpdmVcclxuICAgICAqIEBwYXJhbSBvbkRpc2Nvbm5lY3QgLSBDYWxsYmFjayB3aXRoIGNvbm5lY3Rpb24gbG9zdC5cclxuICAgICAqL1xyXG4gICAgb3Blbihvbk1lc3NhZ2UsIG9uRGlzY29ubmVjdCkge1xyXG4gICAgICAgIHRoaXMuY3VyU2VnbWVudE51bSA9IDA7XHJcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gb25EaXNjb25uZWN0O1xyXG4gICAgICAgIHRoaXMubXlQYWNrZXRPcmRlcmVyID0gbmV3IFBhY2tldFJlY2VpdmVyKG9uTWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5pc0Nsb3NlZF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnVGltZWQgb3V0IHRyeWluZyB0byBjb25uZWN0LicpO1xyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY2xlYXIgdGhlIGhvc3QgY2FjaGVcclxuICAgICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcihMUF9DT05ORUNUX1RJTUVPVVQpKTtcclxuICAgICAgICAvLyBFbnN1cmUgd2UgZGVsYXkgdGhlIGNyZWF0aW9uIG9mIHRoZSBpZnJhbWUgdW50aWwgdGhlIERPTSBpcyBsb2FkZWQuXHJcbiAgICAgICAgZXhlY3V0ZVdoZW5ET01SZWFkeSgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkXykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vU2V0IHVwIGEgY2FsbGJhY2sgdGhhdCBnZXRzIHRyaWdnZXJlZCBvbmNlIGEgY29ubmVjdGlvbiBpcyBzZXQgdXAuXHJcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyID0gbmV3IEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyKCguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbY29tbWFuZCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNF0gPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyhhcmdzKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zY3JpcHRUYWdIb2xkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIHdlIGNsb3NlZCB0aGUgY29ubmVjdGlvbi5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyQ29ubmVjdGVkXyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZCA9PT0gRklSRUJBU0VfTE9OR1BPTExfU1RBUlRfUEFSQU0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlkID0gYXJnMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhc3N3b3JkID0gYXJnMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbW1hbmQgPT09IEZJUkVCQVNFX0xPTkdQT0xMX0NMT1NFX0NPTU1BTkQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjbGVhciB0aGUgaG9zdCBjYWNoZS4gV2UgZ290IGEgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLCBzbyB3ZSBrbm93IGl0J3MgcmVhY2hhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlbid0IGV4cGVjdGluZyBhbnkgbW9yZSBkYXRhIChvdGhlciB0aGFuIHdoYXQgdGhlIHNlcnZlcidzIGFscmVhZHkgaW4gdGhlIHByb2Nlc3Mgb2Ygc2VuZGluZyB1c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdWdoIG91ciBhbHJlYWR5IG9wZW4gcG9sbHMpLCBzbyBkb24ndCBzZW5kIGFueSBtb3JlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5zZW5kTmV3UG9sbHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJnMSBpbiB0aGlzIGNhc2UgaXMgdGhlIGxhc3QgcmVzcG9uc2UgbnVtYmVyIHNlbnQgYnkgdGhlIHNlcnZlci4gV2Ugc2hvdWxkIHRyeSB0byByZWNlaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBvZiB0aGUgcmVzcG9uc2VzIHVwIHRvIHRoaXMgb25lIGJlZm9yZSBjbG9zaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXlQYWNrZXRPcmRlcmVyLmNsb3NlQWZ0ZXIoYXJnMSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIGNvbW1hbmQgcmVjZWl2ZWQ6ICcgKyBjb21tYW5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtwTiwgZGF0YV0gPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyhhcmdzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXlQYWNrZXRPcmRlcmVyLmhhbmRsZVJlc3BvbnNlKHBOLCBkYXRhKTtcclxuICAgICAgICAgICAgfSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcclxuICAgICAgICAgICAgfSwgdGhpcy51cmxGbik7XHJcbiAgICAgICAgICAgIC8vU2VuZCB0aGUgaW5pdGlhbCByZXF1ZXN0IHRvIGNvbm5lY3QuIFRoZSBzZXJpYWwgbnVtYmVyIGlzIHNpbXBseSB0byBrZWVwIHRoZSBicm93c2VyIGZyb20gcHVsbGluZyBwcmV2aW91cyByZXN1bHRzXHJcbiAgICAgICAgICAgIC8vZnJvbSBjYWNoZS5cclxuICAgICAgICAgICAgY29uc3QgdXJsUGFyYW1zID0ge307XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9TVEFSVF9QQVJBTV0gPSAndCc7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9TRVJJQUxfUEFSQU1dID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2NyaXB0VGFnSG9sZGVyLnVuaXF1ZUNhbGxiYWNrSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0NBTExCQUNLX0lEX1BBUkFNXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tWRVJTSU9OX1BBUkFNXSA9IFBST1RPQ09MX1ZFUlNJT047XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydFNlc3Npb25JZCkge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW1RSQU5TUE9SVF9TRVNTSU9OX1BBUkFNXSA9IHRoaXMudHJhbnNwb3J0U2Vzc2lvbklkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3RTZXNzaW9uSWQpIHtcclxuICAgICAgICAgICAgICAgIHVybFBhcmFtc1tMQVNUX1NFU1NJT05fUEFSQU1dID0gdGhpcy5sYXN0U2Vzc2lvbklkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcGxpY2F0aW9uSWQpIHtcclxuICAgICAgICAgICAgICAgIHVybFBhcmFtc1tBUFBMSUNBVElPTl9JRF9QQVJBTV0gPSB0aGlzLmFwcGxpY2F0aW9uSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW0FQUF9DSEVDS19UT0tFTl9QQVJBTV0gPSB0aGlzLmFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uLmhvc3RuYW1lICYmXHJcbiAgICAgICAgICAgICAgICBGT1JHRV9ET01BSU5fUkUudGVzdChsb2NhdGlvbi5ob3N0bmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHVybFBhcmFtc1tSRUZFUkVSX1BBUkFNXSA9IEZPUkdFX1JFRjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjb25uZWN0VVJMID0gdGhpcy51cmxGbih1cmxQYXJhbXMpO1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0Nvbm5lY3RpbmcgdmlhIGxvbmctcG9sbCB0byAnICsgY29ubmVjdFVSTCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyLmFkZFRhZyhjb25uZWN0VVJMLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvKiBkbyBub3RoaW5nICovXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsIHRoaXMgd2hlbiBhIGhhbmRzaGFrZSBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSBhbmQgd2Ugd2FudCB0byBjb25zaWRlciB0aGUgY29ubmVjdGlvbiBlc3RhYmxpc2hlZFxyXG4gICAgICovXHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5zdGFydExvbmdQb2xsKHRoaXMuaWQsIHRoaXMucGFzc3dvcmQpO1xyXG4gICAgICAgIHRoaXMuYWRkRGlzY29ubmVjdFBpbmdGcmFtZSh0aGlzLmlkLCB0aGlzLnBhc3N3b3JkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9yY2VzIGxvbmcgcG9sbGluZyB0byBiZSBjb25zaWRlcmVkIGFzIGEgcG90ZW50aWFsIHRyYW5zcG9ydFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZm9yY2VBbGxvdygpIHtcclxuICAgICAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VBbGxvd18gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JjZXMgbG9uZ3BvbGxpbmcgdG8gbm90IGJlIGNvbnNpZGVyZWQgYXMgYSBwb3RlbnRpYWwgdHJhbnNwb3J0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmb3JjZURpc2FsbG93KCkge1xyXG4gICAgICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZURpc2FsbG93XyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBTdGF0aWMgbWV0aG9kLCB1c2Ugc3RyaW5nIGxpdGVyYWwgc28gaXQgY2FuIGJlIGFjY2Vzc2VkIGluIGEgZ2VuZXJpYyB3YXlcclxuICAgIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcclxuICAgICAgICBpZiAoaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VBbGxvd18pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBJbiBSZWFjdC1OYXRpdmUgdGhlcmUncyBub3JtYWxseSBubyAnZG9jdW1lbnQnLCBidXQgaWYgeW91IGRlYnVnIGEgUmVhY3QtTmF0aXZlIGFwcCBpblxyXG4gICAgICAgICAgICAvLyB0aGUgQ2hyb21lIGRlYnVnZ2VyLCAnZG9jdW1lbnQnIGlzIGRlZmluZWQsIGJ1dCBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzIG51bGwgKDIwMTUvMDYvMDgpLlxyXG4gICAgICAgICAgICByZXR1cm4gKCFCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvd18gJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgIWlzQ2hyb21lRXh0ZW5zaW9uQ29udGVudFNjcmlwdCgpICYmXHJcbiAgICAgICAgICAgICAgICAhaXNXaW5kb3dzU3RvcmVBcHAoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBOby1vcCBmb3IgcG9sbGluZ1xyXG4gICAgICovXHJcbiAgICBtYXJrQ29ubmVjdGlvbkhlYWx0aHkoKSB7IH1cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgcG9sbGluZyBhbmQgY2xlYW5zIHVwIHRoZSBpZnJhbWVcclxuICAgICAqL1xyXG4gICAgc2h1dGRvd25fKCkge1xyXG4gICAgICAgIHRoaXMuaXNDbG9zZWRfID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5zY3JpcHRUYWdIb2xkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIuY2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL3JlbW92ZSB0aGUgZGlzY29ubmVjdCBmcmFtZSwgd2hpY2ggd2lsbCB0cmlnZ2VyIGFuIFhIUiBjYWxsIHRvIHRoZSBzZXJ2ZXIgdG8gdGVsbCBpdCB3ZSdyZSBsZWF2aW5nLlxyXG4gICAgICAgIGlmICh0aGlzLm15RGlzY29ubkZyYW1lKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5teURpc2Nvbm5GcmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0VGltZW91dFRpbWVyXykge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhpcyB0cmFuc3BvcnQgaXMgY2xvc2VkXHJcbiAgICAgKi9cclxuICAgIG9uQ2xvc2VkXygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnTG9uZ3BvbGwgaXMgY2xvc2luZyBpdHNlbGYnKTtcclxuICAgICAgICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub25EaXNjb25uZWN0Xykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfKHRoaXMuZXZlckNvbm5lY3RlZF8pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZXJuYWwtZmFjaW5nIGNsb3NlIGhhbmRsZXIuIFJlYWxUaW1lIGhhcyByZXF1ZXN0ZWQgd2Ugc2h1dCBkb3duLiBLaWxsIG91ciBjb25uZWN0aW9uIGFuZCB0ZWxsIHRoZSBzZXJ2ZXJcclxuICAgICAqIHRoYXQgd2UndmUgbGVmdC5cclxuICAgICAqL1xyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2xvc2VkXykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0xvbmdwb2xsIGlzIGJlaW5nIGNsb3NlZC4nKTtcclxuICAgICAgICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgdGhlIEpTT04gb2JqZWN0IGRvd24gdG8gdGhlIHNlcnZlci4gSXQgd2lsbCBuZWVkIHRvIGJlIHN0cmluZ2lmaWVkLCBiYXNlNjQgZW5jb2RlZCwgYW5kIHRoZW5cclxuICAgICAqIGJyb2tlbiBpbnRvIGNodW5rcyAoc2luY2UgVVJMcyBoYXZlIGEgc21hbGwgbWF4aW11bSBsZW5ndGgpLlxyXG4gICAgICogQHBhcmFtIGRhdGEgLSBUaGUgSlNPTiBkYXRhIHRvIHRyYW5zbWl0LlxyXG4gICAgICovXHJcbiAgICBzZW5kKGRhdGEpIHtcclxuICAgICAgICBjb25zdCBkYXRhU3RyID0gc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ICs9IGRhdGFTdHIubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfLmluY3JlbWVudENvdW50ZXIoJ2J5dGVzX3NlbnQnLCBkYXRhU3RyLmxlbmd0aCk7XHJcbiAgICAgICAgLy9maXJzdCwgbGV0cyBnZXQgdGhlIGJhc2U2NC1lbmNvZGVkIGRhdGFcclxuICAgICAgICBjb25zdCBiYXNlNjRkYXRhID0gYmFzZTY0RW5jb2RlKGRhdGFTdHIpO1xyXG4gICAgICAgIC8vV2UgY2FuIG9ubHkgZml0IGEgY2VydGFpbiBhbW91bnQgaW4gZWFjaCBVUkwsIHNvIHdlIG5lZWQgdG8gc3BsaXQgdGhpcyByZXF1ZXN0XHJcbiAgICAgICAgLy91cCBpbnRvIG11bHRpcGxlIHBpZWNlcyBpZiBpdCBkb2Vzbid0IGZpdCBpbiBvbmUgcmVxdWVzdC5cclxuICAgICAgICBjb25zdCBkYXRhU2VncyA9IHNwbGl0U3RyaW5nQnlTaXplKGJhc2U2NGRhdGEsIE1BWF9QQVlMT0FEX1NJWkUpO1xyXG4gICAgICAgIC8vRW5xdWV1ZSBlYWNoIHNlZ21lbnQgZm9yIHRyYW5zbWlzc2lvbi4gV2UgYXNzaWduIGVhY2ggY2h1bmsgYSBzZXF1ZW50aWFsIElEIGFuZCBhIHRvdGFsIG51bWJlclxyXG4gICAgICAgIC8vb2Ygc2VnbWVudHMgc28gdGhhdCB3ZSBjYW4gcmVhc3NlbWJsZSB0aGUgcGFja2V0IG9uIHRoZSBzZXJ2ZXIuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5lbnF1ZXVlU2VnbWVudCh0aGlzLmN1clNlZ21lbnROdW0sIGRhdGFTZWdzLmxlbmd0aCwgZGF0YVNlZ3NbaV0pO1xyXG4gICAgICAgICAgICB0aGlzLmN1clNlZ21lbnROdW0rKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgaG93IHdlIG5vdGlmeSB0aGUgc2VydmVyIHRoYXQgd2UncmUgbGVhdmluZy5cclxuICAgICAqIFdlIGFyZW4ndCBhYmxlIHRvIHNlbmQgcmVxdWVzdHMgd2l0aCBESFRNTCBvbiBhIHdpbmRvdyBjbG9zZSBldmVudCwgYnV0IHdlIGNhblxyXG4gICAgICogdHJpZ2dlciBYSFIgcmVxdWVzdHMgaW4gc29tZSBicm93c2VycyAoZXZlcnl0aGluZyBidXQgT3BlcmEgYmFzaWNhbGx5KS5cclxuICAgICAqL1xyXG4gICAgYWRkRGlzY29ubmVjdFBpbmdGcmFtZShpZCwgcHcpIHtcclxuICAgICAgICBpZiAoaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm15RGlzY29ubkZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XHJcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0ge307XHJcbiAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0RJU0NPTk5fRlJBTUVfUkVRVUVTVF9QQVJBTV0gPSAndCc7XHJcbiAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNXSA9IGlkO1xyXG4gICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTV0gPSBwdztcclxuICAgICAgICB0aGlzLm15RGlzY29ubkZyYW1lLnNyYyA9IHRoaXMudXJsRm4odXJsUGFyYW1zKTtcclxuICAgICAgICB0aGlzLm15RGlzY29ubkZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLm15RGlzY29ubkZyYW1lKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byB0cmFjayB0aGUgYnl0ZXMgcmVjZWl2ZWQgYnkgdGhpcyBjbGllbnRcclxuICAgICAqL1xyXG4gICAgaW5jcmVtZW50SW5jb21pbmdCeXRlc18oYXJncykge1xyXG4gICAgICAgIC8vIFRPRE86IFRoaXMgaXMgYW4gYW5ub3lpbmcgcGVyZiBoaXQganVzdCB0byB0cmFjayB0aGUgbnVtYmVyIG9mIGluY29taW5nIGJ5dGVzLiAgTWF5YmUgaXQgc2hvdWxkIGJlIG9wdC1pbi5cclxuICAgICAgICBjb25zdCBieXRlc1JlY2VpdmVkID0gc3RyaW5naWZ5KGFyZ3MpLmxlbmd0aDtcclxuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgKz0gYnl0ZXNSZWNlaXZlZDtcclxuICAgICAgICB0aGlzLnN0YXRzXy5pbmNyZW1lbnRDb3VudGVyKCdieXRlc19yZWNlaXZlZCcsIGJ5dGVzUmVjZWl2ZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICogQSB3cmFwcGVyIGFyb3VuZCBhbiBpZnJhbWUgdGhhdCBpcyB1c2VkIGFzIGEgbG9uZy1wb2xsaW5nIHNjcmlwdCBob2xkZXIuXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbmNsYXNzIEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbW1hbmRDQiAtIFRoZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiBjb250cm9sIGNvbW1hbmRzIGFyZSByZWNldmllZCBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlQ0IgLSBUaGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gcmVzcG9uc2VzIGFycml2ZSBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0gb25EaXNjb25uZWN0IC0gVGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoaXMgdGFnIGhvbGRlciBpcyBjbG9zZWRcclxuICAgICAqIEBwYXJhbSB1cmxGbiAtIEEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyB0aGUgVVJMIG9mIHRoZSBlbmRwb2ludCB0byBzZW5kIGRhdGEgdG8uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmRDQiwgb25NZXNzYWdlQ0IsIG9uRGlzY29ubmVjdCwgdXJsRm4pIHtcclxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCA9IG9uRGlzY29ubmVjdDtcclxuICAgICAgICB0aGlzLnVybEZuID0gdXJsRm47XHJcbiAgICAgICAgLy9XZSBtYWludGFpbiBhIGNvdW50IG9mIGFsbCBvZiB0aGUgb3V0c3RhbmRpbmcgcmVxdWVzdHMsIGJlY2F1c2UgaWYgd2UgaGF2ZSB0b28gbWFueSBhY3RpdmUgYXQgb25jZSBpdCBjYW4gY2F1c2VcclxuICAgICAgICAvL3Byb2JsZW1zIGluIHNvbWUgYnJvd3NlcnMuXHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1JlcXVlc3RzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIC8vQSBxdWV1ZSBvZiB0aGUgcGVuZGluZyBzZWdtZW50cyB3YWl0aW5nIGZvciB0cmFuc21pc3Npb24gdG8gdGhlIHNlcnZlci5cclxuICAgICAgICB0aGlzLnBlbmRpbmdTZWdzID0gW107XHJcbiAgICAgICAgLy9BIHNlcmlhbCBudW1iZXIuIFdlIHVzZSB0aGlzIGZvciB0d28gdGhpbmdzOlxyXG4gICAgICAgIC8vIDEpIEEgd2F5IHRvIGVuc3VyZSB0aGUgYnJvd3NlciBkb2Vzbid0IGNhY2hlIHJlc3BvbnNlcyB0byBwb2xsc1xyXG4gICAgICAgIC8vIDIpIEEgd2F5IHRvIG1ha2UgdGhlIHNlcnZlciBhd2FyZSB3aGVuIGxvbmctcG9sbHMgYXJyaXZlIGluIGEgZGlmZmVyZW50IG9yZGVyIHRoYW4gd2Ugc3RhcnRlZCB0aGVtLiBUaGVcclxuICAgICAgICAvLyAgICBzZXJ2ZXIgbmVlZHMgdG8gcmVsZWFzZSBib3RoIHBvbGxzIGluIHRoaXMgY2FzZSBvciBpdCB3aWxsIGNhdXNlIHByb2JsZW1zIGluIE9wZXJhIHNpbmNlIE9wZXJhIGNhbiBvbmx5IGV4ZWN1dGVcclxuICAgICAgICAvLyAgICBKU09OUCBjb2RlIGluIHRoZSBvcmRlciBpdCB3YXMgYWRkZWQgdG8gdGhlIGlmcmFtZS5cclxuICAgICAgICB0aGlzLmN1cnJlbnRTZXJpYWwgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDApO1xyXG4gICAgICAgIC8vIFRoaXMgZ2V0cyBzZXQgdG8gZmFsc2Ugd2hlbiB3ZSdyZSBcImNsb3NpbmcgZG93blwiIHRoZSBjb25uZWN0aW9uIChlLmcuIHdlJ3JlIHN3aXRjaGluZyB0cmFuc3BvcnRzIGJ1dCB0aGVyZSdzIHN0aWxsXHJcbiAgICAgICAgLy8gaW5jb21pbmcgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgdGhhdCB3ZSdyZSB3YWl0aW5nIGZvcikuXHJcbiAgICAgICAgdGhpcy5zZW5kTmV3UG9sbHMgPSB0cnVlO1xyXG4gICAgICAgIGlmICghaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgLy9FYWNoIHNjcmlwdCBob2xkZXIgcmVnaXN0ZXJzIGEgY291cGxlIG9mIHVuaXF1ZWx5IG5hbWVkIGNhbGxiYWNrcyB3aXRoIHRoZSB3aW5kb3cuIFRoZXNlIGFyZSBjYWxsZWQgZnJvbSB0aGVcclxuICAgICAgICAgICAgLy9pZnJhbWVzIHdoZXJlIHdlIHB1dCB0aGUgbG9uZy1wb2xsaW5nIHNjcmlwdCB0YWdzLiBXZSBoYXZlIHR3byBjYWxsYmFja3M6XHJcbiAgICAgICAgICAgIC8vICAgMSkgQ29tbWFuZCBDYWxsYmFjayAtIFRyaWdnZXJlZCBmb3IgY29udHJvbCBpc3N1ZXMsIGxpa2Ugc3RhcnRpbmcgYSBjb25uZWN0aW9uLlxyXG4gICAgICAgICAgICAvLyAgIDIpIE1lc3NhZ2UgQ2FsbGJhY2sgLSBUcmlnZ2VyZWQgd2hlbiBuZXcgZGF0YSBhcnJpdmVzLlxyXG4gICAgICAgICAgICB0aGlzLnVuaXF1ZUNhbGxiYWNrSWRlbnRpZmllciA9IExVSURHZW5lcmF0b3IoKTtcclxuICAgICAgICAgICAgd2luZG93W0ZJUkVCQVNFX0xPTkdQT0xMX0NPTU1BTkRfQ0JfTkFNRSArIHRoaXMudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyXSA9IGNvbW1hbmRDQjtcclxuICAgICAgICAgICAgd2luZG93W0ZJUkVCQVNFX0xPTkdQT0xMX0RBVEFfQ0JfTkFNRSArIHRoaXMudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyXSA9XHJcbiAgICAgICAgICAgICAgICBvbk1lc3NhZ2VDQjtcclxuICAgICAgICAgICAgLy9DcmVhdGUgYW4gaWZyYW1lIGZvciB1cyB0byBhZGQgc2NyaXB0IHRhZ3MgdG8uXHJcbiAgICAgICAgICAgIHRoaXMubXlJRnJhbWUgPSBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlci5jcmVhdGVJRnJhbWVfKCk7XHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgaWZyYW1lJ3MgY29udGVudHMuXHJcbiAgICAgICAgICAgIGxldCBzY3JpcHQgPSAnJztcclxuICAgICAgICAgICAgLy8gaWYgd2Ugc2V0IGEgamF2YXNjcmlwdCB1cmwsIGl0J3MgSUUgYW5kIHdlIG5lZWQgdG8gc2V0IHRoZSBkb2N1bWVudCBkb21haW4uIFRoZSBqYXZhc2NyaXB0IHVybCBpcyBzdWZmaWNpZW50XHJcbiAgICAgICAgICAgIC8vIGZvciBpZTksIGJ1dCBpZTggbmVlZHMgdG8gZG8gaXQgYWdhaW4gaW4gdGhlIGRvY3VtZW50IGl0c2VsZi5cclxuICAgICAgICAgICAgaWYgKHRoaXMubXlJRnJhbWUuc3JjICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLm15SUZyYW1lLnNyYy5zdWJzdHIoMCwgJ2phdmFzY3JpcHQ6Jy5sZW5ndGgpID09PSAnamF2YXNjcmlwdDonKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RG9tYWluID0gZG9jdW1lbnQuZG9tYWluO1xyXG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gJzxzY3JpcHQ+ZG9jdW1lbnQuZG9tYWluPVwiJyArIGN1cnJlbnREb21haW4gKyAnXCI7PC9zY3JpcHQ+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBpZnJhbWVDb250ZW50cyA9ICc8aHRtbD48Ym9keT4nICsgc2NyaXB0ICsgJzwvYm9keT48L2h0bWw+JztcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLm9wZW4oKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLndyaXRlKGlmcmFtZUNvbnRlbnRzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGxvZygnZnJhbWUgd3JpdGluZyBleGNlcHRpb24nKTtcclxuICAgICAgICAgICAgICAgIGlmIChlLnN0YWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nKGUuc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbG9nKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRDQiA9IGNvbW1hbmRDQjtcclxuICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2VDQiA9IG9uTWVzc2FnZUNCO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRWFjaCBicm93c2VyIGhhcyBpdHMgb3duIGZ1bm55IHdheSB0byBoYW5kbGUgaWZyYW1lcy4gSGVyZSB3ZSBtdXNoIHRoZW0gYWxsIHRvZ2V0aGVyIGludG8gb25lIG9iamVjdCB0aGF0IEkgY2FuXHJcbiAgICAgKiBhY3R1YWxseSB1c2UuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVJRnJhbWVfKCkge1xyXG4gICAgICAgIGNvbnN0IGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xyXG4gICAgICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGluIG9yZGVyIHRvIGluaXRpYWxpemUgdGhlIGRvY3VtZW50IGluc2lkZSB0aGUgaWZyYW1lXHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgZG9jdW1lbnQuZG9tYWluIGhhcyBiZWVuIG1vZGlmaWVkIGluIElFLCB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IsIGFuZCB3ZSBuZWVkIHRvIHNldCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGRvbWFpbiBvZiB0aGUgaWZyYW1lJ3MgZG9jdW1lbnQgbWFudWFsbHkuIFdlIGNhbiBkbyB0aGlzIHZpYSBhIGphdmFzY3JpcHQ6IHVybCBhcyB0aGUgc3JjIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBub3RlIHRoYXQgd2UgbXVzdCBkbyB0aGlzICphZnRlciogdGhlIGlmcmFtZSBoYXMgYmVlbiBhcHBlbmRlZCB0byB0aGUgcGFnZS4gT3RoZXJ3aXNlIGl0IGRvZXNuJ3Qgd29yay5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcclxuICAgICAgICAgICAgICAgIGlmICghYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwb2xvZ2llcyBmb3IgdGhlIGxvZy1zcGFtLCBJIG5lZWQgdG8gZG8gc29tZXRoaW5nIHRvIGtlZXAgY2xvc3VyZSBmcm9tIG9wdGltaXppbmcgb3V0IHRoZSBhc3NpZ25tZW50IGFib3ZlLlxyXG4gICAgICAgICAgICAgICAgICAgIGxvZygnTm8gSUUgZG9tYWluIHNldHRpbmcgcmVxdWlyZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZG9tYWluID0gZG9jdW1lbnQuZG9tYWluO1xyXG4gICAgICAgICAgICAgICAgaWZyYW1lLnNyYyA9XHJcbiAgICAgICAgICAgICAgICAgICAgXCJqYXZhc2NyaXB0OnZvaWQoKGZ1bmN0aW9uKCl7ZG9jdW1lbnQub3BlbigpO2RvY3VtZW50LmRvbWFpbj0nXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIic7ZG9jdW1lbnQuY2xvc2UoKTt9KSgpKVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBMb25nUG9sbENvbm5lY3Rpb24gYXR0ZW1wdHMgdG8gZGVsYXkgaW5pdGlhbGl6YXRpb24gdW50aWwgdGhlIGRvY3VtZW50IGlzIHJlYWR5LCBzbyBob3BlZnVsbHkgdGhpc1xyXG4gICAgICAgICAgICAvLyBuZXZlciBnZXRzIGhpdC5cclxuICAgICAgICAgICAgdGhyb3cgJ0RvY3VtZW50IGJvZHkgaGFzIG5vdCBpbml0aWFsaXplZC4gV2FpdCB0byBpbml0aWFsaXplIEZpcmViYXNlIHVudGlsIGFmdGVyIHRoZSBkb2N1bWVudCBpcyByZWFkeS4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHZXQgdGhlIGRvY3VtZW50IG9mIHRoZSBpZnJhbWUgaW4gYSBicm93c2VyLXNwZWNpZmljIHdheS5cclxuICAgICAgICBpZiAoaWZyYW1lLmNvbnRlbnREb2N1bWVudCkge1xyXG4gICAgICAgICAgICBpZnJhbWUuZG9jID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudDsgLy8gRmlyZWZveCwgT3BlcmEsIFNhZmFyaVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpZnJhbWUuY29udGVudFdpbmRvdykge1xyXG4gICAgICAgICAgICBpZnJhbWUuZG9jID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7IC8vIEludGVybmV0IEV4cGxvcmVyXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlmcmFtZS5kb2N1bWVudCkge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICBpZnJhbWUuZG9jID0gaWZyYW1lLmRvY3VtZW50OyAvL290aGVycz9cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlmcmFtZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FuY2VsIGFsbCBvdXRzdGFuZGluZyBxdWVyaWVzIGFuZCByZW1vdmUgdGhlIGZyYW1lLlxyXG4gICAgICovXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICAvL01hcmsgdGhpcyBpZnJhbWUgYXMgZGVhZCwgc28gbm8gbmV3IHJlcXVlc3RzIGFyZSBzZW50LlxyXG4gICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5teUlGcmFtZSkge1xyXG4gICAgICAgICAgICAvL1dlIGhhdmUgdG8gYWN0dWFsbHkgcmVtb3ZlIGFsbCBvZiB0aGUgaHRtbCBpbnNpZGUgdGhpcyBpZnJhbWUgYmVmb3JlIHJlbW92aW5nIGl0IGZyb20gdGhlXHJcbiAgICAgICAgICAgIC8vd2luZG93LCBvciBJRSB3aWxsIGNvbnRpbnVlIGxvYWRpbmcgYW5kIGV4ZWN1dGluZyB0aGUgc2NyaXB0IHRhZ3Mgd2UndmUgYWxyZWFkeSBhZGRlZCwgd2hpY2hcclxuICAgICAgICAgICAgLy9jYW4gbGVhZCB0byBzb21lIGVycm9ycyBiZWluZyB0aHJvd24uIFNldHRpbmcgdGV4dENvbnRlbnQgc2VlbXMgdG8gYmUgdGhlIHNhZmVzdCB3YXkgdG8gZG8gdGhpcy5cclxuICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2MuYm9keS50ZXh0Q29udGVudCA9ICcnO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm15SUZyYW1lICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLm15SUZyYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm15SUZyYW1lID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgTWF0aC5mbG9vcigwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByb3RlY3QgZnJvbSBiZWluZyBjYWxsZWQgcmVjdXJzaXZlbHkuXHJcbiAgICAgICAgY29uc3Qgb25EaXNjb25uZWN0ID0gdGhpcy5vbkRpc2Nvbm5lY3Q7XHJcbiAgICAgICAgaWYgKG9uRGlzY29ubmVjdCkge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCA9IG51bGw7XHJcbiAgICAgICAgICAgIG9uRGlzY29ubmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWN0dWFsbHkgc3RhcnQgdGhlIGxvbmctcG9sbGluZyBzZXNzaW9uIGJ5IGFkZGluZyB0aGUgZmlyc3Qgc2NyaXB0IHRhZyhzKSB0byB0aGUgaWZyYW1lLlxyXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoaXMgY29ubmVjdGlvblxyXG4gICAgICogQHBhcmFtIHB3IC0gVGhlIHBhc3N3b3JkIGZvciB0aGlzIGNvbm5lY3Rpb25cclxuICAgICAqL1xyXG4gICAgc3RhcnRMb25nUG9sbChpZCwgcHcpIHtcclxuICAgICAgICB0aGlzLm15SUQgPSBpZDtcclxuICAgICAgICB0aGlzLm15UFcgPSBwdztcclxuICAgICAgICB0aGlzLmFsaXZlID0gdHJ1ZTtcclxuICAgICAgICAvL3NlbmQgdGhlIGluaXRpYWwgcmVxdWVzdC4gSWYgdGhlcmUgYXJlIHJlcXVlc3RzIHF1ZXVlZCwgbWFrZSBzdXJlIHRoYXQgd2UgdHJhbnNtaXQgYXMgbWFueSBhcyB3ZSBhcmUgY3VycmVudGx5IGFibGUgdG8uXHJcbiAgICAgICAgd2hpbGUgKHRoaXMubmV3UmVxdWVzdF8oKSkgeyB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgY2FsbGVkIGFueSB0aW1lIHNvbWVvbmUgbWlnaHQgd2FudCBhIHNjcmlwdCB0YWcgdG8gYmUgYWRkZWQuIEl0IGFkZHMgYSBzY3JpcHQgdGFnIHdoZW4gdGhlcmUgYXJlbid0XHJcbiAgICAgKiB0b28gbWFueSBvdXRzdGFuZGluZyByZXF1ZXN0cyBhbmQgd2UgYXJlIHN0aWxsIGFsaXZlLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZXJlIGFyZSBvdXRzdGFuZGluZyBwYWNrZXQgc2VnbWVudHMgdG8gc2VuZCwgaXQgc2VuZHMgb25lLiBJZiB0aGVyZSBhcmVuJ3QsIGl0IHNlbmRzIGEgbG9uZy1wb2xsIGFueXdheXMgaWZcclxuICAgICAqIG5lZWRlZC5cclxuICAgICAqL1xyXG4gICAgbmV3UmVxdWVzdF8oKSB7XHJcbiAgICAgICAgLy8gV2Uga2VlcCBvbmUgb3V0c3RhbmRpbmcgcmVxdWVzdCBvcGVuIGFsbCB0aGUgdGltZSB0byByZWNlaXZlIGRhdGEsIGJ1dCBpZiB3ZSBuZWVkIHRvIHNlbmQgZGF0YVxyXG4gICAgICAgIC8vIChwZW5kaW5nU2Vncy5sZW5ndGggPiAwKSB0aGVuIHdlIGNyZWF0ZSBhIG5ldyByZXF1ZXN0IHRvIHNlbmQgdGhlIGRhdGEuICBUaGUgc2VydmVyIHdpbGwgYXV0b21hdGljYWxseVxyXG4gICAgICAgIC8vIGNsb3NlIHRoZSBvbGQgcmVxdWVzdC5cclxuICAgICAgICBpZiAodGhpcy5hbGl2ZSAmJlxyXG4gICAgICAgICAgICB0aGlzLnNlbmROZXdQb2xscyAmJlxyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMuc2l6ZSA8ICh0aGlzLnBlbmRpbmdTZWdzLmxlbmd0aCA+IDAgPyAyIDogMSkpIHtcclxuICAgICAgICAgICAgLy9jb25zdHJ1Y3Qgb3VyIHVybFxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZXJpYWwrKztcclxuICAgICAgICAgICAgY29uc3QgdXJsUGFyYW1zID0ge307XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9JRF9QQVJBTV0gPSB0aGlzLm15SUQ7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTV0gPSB0aGlzLm15UFc7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9TRVJJQUxfUEFSQU1dID0gdGhpcy5jdXJyZW50U2VyaWFsO1xyXG4gICAgICAgICAgICBsZXQgdGhlVVJMID0gdGhpcy51cmxGbih1cmxQYXJhbXMpO1xyXG4gICAgICAgICAgICAvL05vdyBhZGQgYXMgbXVjaCBkYXRhIGFzIHdlIGNhbi5cclxuICAgICAgICAgICAgbGV0IGN1ckRhdGFTdHJpbmcgPSAnJztcclxuICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wZW5kaW5nU2Vncy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAvL2ZpcnN0LCBsZXRzIHNlZSBpZiB0aGUgbmV4dCBzZWdtZW50IHdpbGwgZml0LlxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFNlZyA9IHRoaXMucGVuZGluZ1NlZ3NbMF07XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNlZy5kLmxlbmd0aCArXHJcbiAgICAgICAgICAgICAgICAgICAgU0VHX0hFQURFUl9TSVpFICtcclxuICAgICAgICAgICAgICAgICAgICBjdXJEYXRhU3RyaW5nLmxlbmd0aCA8PVxyXG4gICAgICAgICAgICAgICAgICAgIE1BWF9VUkxfREFUQV9TSVpFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9ncmVhdCwgdGhlIHNlZ21lbnQgd2lsbCBmaXQuIExldHMgYXBwZW5kIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRoZVNlZyA9IHRoaXMucGVuZGluZ1NlZ3Muc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJEYXRhU3RyaW5nID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyRGF0YVN0cmluZyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRklSRUJBU0VfTE9OR1BPTExfU0VHTUVOVF9OVU1fUEFSQU0gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPScgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlU2VnLnNlZyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRklSRUJBU0VfTE9OR1BPTExfU0VHTUVOVFNfSU5fUEFDS0VUICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJz0nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZVNlZy50cyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRklSRUJBU0VfTE9OR1BPTExfREFUQV9QQVJBTSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc9JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVTZWcuZDtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGVVUkwgPSB0aGVVUkwgKyBjdXJEYXRhU3RyaW5nO1xyXG4gICAgICAgICAgICB0aGlzLmFkZExvbmdQb2xsVGFnXyh0aGVVUkwsIHRoaXMuY3VycmVudFNlcmlhbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUXVldWUgYSBwYWNrZXQgZm9yIHRyYW5zbWlzc2lvbiB0byB0aGUgc2VydmVyLlxyXG4gICAgICogQHBhcmFtIHNlZ251bSAtIEEgc2VxdWVudGlhbCBpZCBmb3IgdGhpcyBwYWNrZXQgc2VnbWVudCB1c2VkIGZvciByZWFzc2VtYmx5XHJcbiAgICAgKiBAcGFyYW0gdG90YWxzZWdzIC0gVGhlIHRvdGFsIG51bWJlciBvZiBzZWdtZW50cyBpbiB0aGlzIHBhY2tldFxyXG4gICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSBmb3IgdGhpcyBzZWdtZW50LlxyXG4gICAgICovXHJcbiAgICBlbnF1ZXVlU2VnbWVudChzZWdudW0sIHRvdGFsc2VncywgZGF0YSkge1xyXG4gICAgICAgIC8vYWRkIHRoaXMgdG8gdGhlIHF1ZXVlIG9mIHNlZ21lbnRzIHRvIHNlbmQuXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nU2Vncy5wdXNoKHsgc2VnOiBzZWdudW0sIHRzOiB0b3RhbHNlZ3MsIGQ6IGRhdGEgfSk7XHJcbiAgICAgICAgLy9zZW5kIHRoZSBkYXRhIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGlzbid0IGFscmVhZHkgZGF0YSBiZWluZyB0cmFuc21pdHRlZCwgdW5sZXNzXHJcbiAgICAgICAgLy9zdGFydExvbmdQb2xsIGhhc24ndCBiZWVuIGNhbGxlZCB5ZXQuXHJcbiAgICAgICAgaWYgKHRoaXMuYWxpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXdSZXF1ZXN0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NyaXB0IHRhZyBmb3IgYSByZWd1bGFyIGxvbmctcG9sbCByZXF1ZXN0LlxyXG4gICAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgb2YgdGhlIHNjcmlwdCB0YWcuXHJcbiAgICAgKiBAcGFyYW0gc2VyaWFsIC0gVGhlIHNlcmlhbCBudW1iZXIgb2YgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIGFkZExvbmdQb2xsVGFnXyh1cmwsIHNlcmlhbCkge1xyXG4gICAgICAgIC8vcmVtZW1iZXIgdGhhdCB3ZSBzZW50IHRoaXMgcmVxdWVzdC5cclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMuYWRkKHNlcmlhbCk7XHJcbiAgICAgICAgY29uc3QgZG9OZXdSZXF1ZXN0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMuZGVsZXRlKHNlcmlhbCk7XHJcbiAgICAgICAgICAgIHRoaXMubmV3UmVxdWVzdF8oKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIElmIHRoaXMgcmVxdWVzdCBkb2Vzbid0IHJldHVybiBvbiBpdHMgb3duIGFjY29yZCAoYnkgdGhlIHNlcnZlciBzZW5kaW5nIHVzIHNvbWUgZGF0YSksIHdlJ2xsXHJcbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IG9uZSBhZnRlciB0aGUgS0VFUEFMSVZFIGludGVydmFsIHRvIG1ha2Ugc3VyZSB3ZSBhbHdheXMga2VlcCBhIGZyZXNoIHJlcXVlc3Qgb3Blbi5cclxuICAgICAgICBjb25zdCBrZWVwYWxpdmVUaW1lb3V0ID0gc2V0VGltZW91dChkb05ld1JlcXVlc3QsIE1hdGguZmxvb3IoS0VFUEFMSVZFX1JFUVVFU1RfSU5URVJWQUwpKTtcclxuICAgICAgICBjb25zdCByZWFkeVN0YXRlQ0IgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFJlcXVlc3QgY29tcGxldGVkLiAgQ2FuY2VsIHRoZSBrZWVwYWxpdmUuXHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChrZWVwYWxpdmVUaW1lb3V0KTtcclxuICAgICAgICAgICAgLy8gVHJpZ2dlciBhIG5ldyByZXF1ZXN0IHNvIHdlIGNhbiBjb250aW51ZSByZWNlaXZpbmcgZGF0YS5cclxuICAgICAgICAgICAgZG9OZXdSZXF1ZXN0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmFkZFRhZyh1cmwsIHJlYWR5U3RhdGVDQik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbiBhcmJpdHJhcnkgc2NyaXB0IHRhZyB0byB0aGUgaWZyYW1lLlxyXG4gICAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgZm9yIHRoZSBzY3JpcHQgdGFnIHNvdXJjZS5cclxuICAgICAqIEBwYXJhbSBsb2FkQ0IgLSBBIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCBvbmNlIHRoZSBzY3JpcHQgaGFzIGxvYWRlZC5cclxuICAgICAqL1xyXG4gICAgYWRkVGFnKHVybCwgbG9hZENCKSB7XHJcbiAgICAgICAgaWYgKGlzTm9kZVNkaygpKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIHRoaXMuZG9Ob2RlTG9uZ1BvbGwodXJsLCBsb2FkQ0IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGFscmVhZHkgY2xvc2VkLCBkb24ndCBhZGQgdGhpcyBwb2xsXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNlbmROZXdQb2xscykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NjcmlwdCA9IHRoaXMubXlJRnJhbWUuZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0LmFzeW5jID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQuc3JjID0gdXJsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0Lm9ubG9hZCA9IG5ld1NjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcnN0YXRlID0gbmV3U2NyaXB0LnJlYWR5U3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJzdGF0ZSB8fCByc3RhdGUgPT09ICdsb2FkZWQnIHx8IHJzdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0Lm9ubG9hZCA9IG5ld1NjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdTY3JpcHQucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuZXdTY3JpcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkQ0IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKCdMb25nLXBvbGwgc2NyaXB0IGZhaWxlZCB0byBsb2FkOiAnICsgdXJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kTmV3UG9sbHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2MuYm9keS5hcHBlbmRDaGlsZChuZXdTY3JpcHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3ZSBzaG91bGQgbWFrZSB0aGlzIGVycm9yIHZpc2libGUgc29tZWhvd1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBNYXRoLmZsb29yKDEpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEN1cnJlbnRseSBzaW1wbGlzdGljLCB0aGlzIGNsYXNzIG1hbmFnZXMgd2hhdCB0cmFuc3BvcnQgYSBDb25uZWN0aW9uIHNob3VsZCB1c2UgYXQgdmFyaW91cyBzdGFnZXMgb2YgaXRzXHJcbiAqIGxpZmVjeWNsZS5cclxuICpcclxuICogSXQgc3RhcnRzIHdpdGggbG9uZ3BvbGxpbmcgaW4gYSBicm93c2VyLCBhbmQgaHR0cHBvbGxpbmcgb24gbm9kZS4gSXQgdGhlbiB1cGdyYWRlcyB0byB3ZWJzb2NrZXRzIGlmXHJcbiAqIHRoZXkgYXJlIGF2YWlsYWJsZS5cclxuICovXHJcbmNsYXNzIFRyYW5zcG9ydE1hbmFnZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcmVwb0luZm8gLSBNZXRhZGF0YSBhcm91bmQgdGhlIG5hbWVzcGFjZSB3ZSdyZSBjb25uZWN0aW5nIHRvXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHJlcG9JbmZvKSB7XHJcbiAgICAgICAgdGhpcy5pbml0VHJhbnNwb3J0c18ocmVwb0luZm8pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBBTExfVFJBTlNQT1JUUygpIHtcclxuICAgICAgICByZXR1cm4gW0Jyb3dzZXJQb2xsQ29ubmVjdGlvbiwgV2ViU29ja2V0Q29ubmVjdGlvbl07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciB0cmFuc3BvcnQgaGFzIGJlZW4gc2VsZWN0ZWQgdG8gZW5zdXJlIFdlYlNvY2tldENvbm5lY3Rpb24gb3IgQnJvd3NlclBvbGxDb25uZWN0aW9uIGFyZSBub3QgY2FsbGVkIGFmdGVyXHJcbiAgICAgKiBUcmFuc3BvcnRNYW5hZ2VyIGhhcyBhbHJlYWR5IHNldCB1cCB0cmFuc3BvcnRzX1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IElTX1RSQU5TUE9SVF9JTklUSUFMSVpFRCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxUcmFuc3BvcnRJbml0aWFsaXplZF87XHJcbiAgICB9XHJcbiAgICBpbml0VHJhbnNwb3J0c18ocmVwb0luZm8pIHtcclxuICAgICAgICBjb25zdCBpc1dlYlNvY2tldHNBdmFpbGFibGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uICYmIFdlYlNvY2tldENvbm5lY3Rpb25bJ2lzQXZhaWxhYmxlJ10oKTtcclxuICAgICAgICBsZXQgaXNTa2lwUG9sbENvbm5lY3Rpb24gPSBpc1dlYlNvY2tldHNBdmFpbGFibGUgJiYgIVdlYlNvY2tldENvbm5lY3Rpb24ucHJldmlvdXNseUZhaWxlZCgpO1xyXG4gICAgICAgIGlmIChyZXBvSW5mby53ZWJTb2NrZXRPbmx5KSB7XHJcbiAgICAgICAgICAgIGlmICghaXNXZWJTb2NrZXRzQXZhaWxhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKFwid3NzOi8vIFVSTCB1c2VkLCBidXQgYnJvd3NlciBpc24ndCBrbm93biB0byBzdXBwb3J0IHdlYnNvY2tldHMuICBUcnlpbmcgYW55d2F5LlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpc1NraXBQb2xsQ29ubmVjdGlvbiA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1NraXBQb2xsQ29ubmVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydHNfID0gW1dlYlNvY2tldENvbm5lY3Rpb25dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0cyA9ICh0aGlzLnRyYW5zcG9ydHNfID0gW10pO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRyYW5zcG9ydCBvZiBUcmFuc3BvcnRNYW5hZ2VyLkFMTF9UUkFOU1BPUlRTKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNwb3J0ICYmIHRyYW5zcG9ydFsnaXNBdmFpbGFibGUnXSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0cy5wdXNoKHRyYW5zcG9ydCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVHJhbnNwb3J0TWFuYWdlci5nbG9iYWxUcmFuc3BvcnRJbml0aWFsaXplZF8gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgaW5pdGlhbCB0cmFuc3BvcnQgdG8gdXNlXHJcbiAgICAgKi9cclxuICAgIGluaXRpYWxUcmFuc3BvcnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0c18ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRzX1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIG5leHQgdHJhbnNwb3J0LCBvciBudWxsXHJcbiAgICAgKi9cclxuICAgIHVwZ3JhZGVUcmFuc3BvcnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0c18ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRzX1sxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSBUcmFuc3BvcnRNYW5hZ2VyIGhhcyBhbHJlYWR5IGNob3NlbiBhIHRyYW5zcG9ydCB0byB1c2VcclxuVHJhbnNwb3J0TWFuYWdlci5nbG9iYWxUcmFuc3BvcnRJbml0aWFsaXplZF8gPSBmYWxzZTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gQWJvcnQgdXBncmFkZSBhdHRlbXB0IGlmIGl0IHRha2VzIGxvbmdlciB0aGFuIDYwcy5cclxuY29uc3QgVVBHUkFERV9USU1FT1VUID0gNjAwMDA7XHJcbi8vIEZvciBzb21lIHRyYW5zcG9ydHMgKFdlYlNvY2tldHMpLCB3ZSBuZWVkIHRvIFwidmFsaWRhdGVcIiB0aGUgdHJhbnNwb3J0IGJ5IGV4Y2hhbmdpbmcgYSBmZXcgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcy5cclxuLy8gSWYgd2UgaGF2ZW4ndCBzZW50IGVub3VnaCByZXF1ZXN0cyB3aXRoaW4gNXMsIHdlJ2xsIHN0YXJ0IHNlbmRpbmcgbm9vcCBwaW5nIHJlcXVlc3RzLlxyXG5jb25zdCBERUxBWV9CRUZPUkVfU0VORElOR19FWFRSQV9SRVFVRVNUUyA9IDUwMDA7XHJcbi8vIElmIHRoZSBpbml0aWFsIGRhdGEgc2VudCB0cmlnZ2VycyBhIGxvdCBvZiBiYW5kd2lkdGggKGkuZS4gaXQncyBhIGxhcmdlIHB1dCBvciBhIGxpc3RlbiBmb3IgYSBsYXJnZSBhbW91bnQgb2YgZGF0YSlcclxuLy8gdGhlbiB3ZSBtYXkgbm90IGJlIGFibGUgdG8gZXhjaGFuZ2Ugb3VyIHBpbmcvcG9uZyByZXF1ZXN0cyB3aXRoaW4gdGhlIGhlYWx0aHkgdGltZW91dC4gIFNvIGlmIHdlIHJlYWNoIHRoZSB0aW1lb3V0XHJcbi8vIGJ1dCB3ZSd2ZSBzZW50L3JlY2VpdmVkIGVub3VnaCBieXRlcywgd2UgZG9uJ3QgY2FuY2VsIHRoZSBjb25uZWN0aW9uLlxyXG5jb25zdCBCWVRFU19TRU5UX0hFQUxUSFlfT1ZFUlJJREUgPSAxMCAqIDEwMjQ7XHJcbmNvbnN0IEJZVEVTX1JFQ0VJVkVEX0hFQUxUSFlfT1ZFUlJJREUgPSAxMDAgKiAxMDI0O1xyXG5jb25zdCBNRVNTQUdFX1RZUEUgPSAndCc7XHJcbmNvbnN0IE1FU1NBR0VfREFUQSA9ICdkJztcclxuY29uc3QgQ09OVFJPTF9TSFVURE9XTiA9ICdzJztcclxuY29uc3QgQ09OVFJPTF9SRVNFVCA9ICdyJztcclxuY29uc3QgQ09OVFJPTF9FUlJPUiA9ICdlJztcclxuY29uc3QgQ09OVFJPTF9QT05HID0gJ28nO1xyXG5jb25zdCBTV0lUQ0hfQUNLID0gJ2EnO1xyXG5jb25zdCBFTkRfVFJBTlNNSVNTSU9OID0gJ24nO1xyXG5jb25zdCBQSU5HID0gJ3AnO1xyXG5jb25zdCBTRVJWRVJfSEVMTE8gPSAnaCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWwtdGltZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgdXNpbmcgd2hpY2hldmVyIG1ldGhvZCB3b3Jrc1xyXG4gKiBiZXN0IGluIHRoZSBjdXJyZW50IGJyb3dzZXIuXHJcbiAqL1xyXG5jbGFzcyBDb25uZWN0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGlkIC0gYW4gaWQgZm9yIHRoaXMgY29ubmVjdGlvblxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvXyAtIHRoZSBpbmZvIGZvciB0aGUgZW5kcG9pbnQgdG8gY29ubmVjdCB0b1xyXG4gICAgICogQHBhcmFtIGFwcGxpY2F0aW9uSWRfIC0gdGhlIEZpcmViYXNlIEFwcCBJRCBmb3IgdGhpcyBwcm9qZWN0XHJcbiAgICAgKiBAcGFyYW0gYXBwQ2hlY2tUb2tlbl8gLSBUaGUgQXBwIENoZWNrIFRva2VuIGZvciB0aGlzIGRldmljZS5cclxuICAgICAqIEBwYXJhbSBhdXRoVG9rZW5fIC0gVGhlIGF1dGggdG9rZW4gZm9yIHRoaXMgc2Vzc2lvbi5cclxuICAgICAqIEBwYXJhbSBvbk1lc3NhZ2VfIC0gdGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIGEgc2VydmVyLXB1c2ggbWVzc2FnZSBhcnJpdmVzXHJcbiAgICAgKiBAcGFyYW0gb25SZWFkeV8gLSB0aGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhpcyBjb25uZWN0aW9uIGlzIHJlYWR5IHRvIHNlbmQgbWVzc2FnZXMuXHJcbiAgICAgKiBAcGFyYW0gb25EaXNjb25uZWN0XyAtIHRoZSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiBhIGNvbm5lY3Rpb24gd2FzIGxvc3RcclxuICAgICAqIEBwYXJhbSBvbktpbGxfIC0gdGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoaXMgY29ubmVjdGlvbiBoYXMgcGVybWFuZW50bHkgc2h1dCBkb3duLlxyXG4gICAgICogQHBhcmFtIGxhc3RTZXNzaW9uSWQgLSBsYXN0IHNlc3Npb24gaWQgaW4gcGVyc2lzdGVudCBjb25uZWN0aW9uLiBpcyB1c2VkIHRvIGNsZWFuIHVwIG9sZCBzZXNzaW9uIGluIHJlYWwtdGltZSBzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaWQsIHJlcG9JbmZvXywgYXBwbGljYXRpb25JZF8sIGFwcENoZWNrVG9rZW5fLCBhdXRoVG9rZW5fLCBvbk1lc3NhZ2VfLCBvblJlYWR5Xywgb25EaXNjb25uZWN0Xywgb25LaWxsXywgbGFzdFNlc3Npb25JZCkge1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLnJlcG9JbmZvXyA9IHJlcG9JbmZvXztcclxuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSWRfID0gYXBwbGljYXRpb25JZF87XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuXyA9IGFwcENoZWNrVG9rZW5fO1xyXG4gICAgICAgIHRoaXMuYXV0aFRva2VuXyA9IGF1dGhUb2tlbl87XHJcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2VfID0gb25NZXNzYWdlXztcclxuICAgICAgICB0aGlzLm9uUmVhZHlfID0gb25SZWFkeV87XHJcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gb25EaXNjb25uZWN0XztcclxuICAgICAgICB0aGlzLm9uS2lsbF8gPSBvbktpbGxfO1xyXG4gICAgICAgIHRoaXMubGFzdFNlc3Npb25JZCA9IGxhc3RTZXNzaW9uSWQ7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0RhdGFNZXNzYWdlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3RhdGVfID0gMCAvKiBSZWFsdGltZVN0YXRlLkNPTk5FQ1RJTkcgKi87XHJcbiAgICAgICAgdGhpcy5sb2dfID0gbG9nV3JhcHBlcignYzonICsgdGhpcy5pZCArICc6Jyk7XHJcbiAgICAgICAgdGhpcy50cmFuc3BvcnRNYW5hZ2VyXyA9IG5ldyBUcmFuc3BvcnRNYW5hZ2VyKHJlcG9JbmZvXyk7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdDb25uZWN0aW9uIGNyZWF0ZWQnKTtcclxuICAgICAgICB0aGlzLnN0YXJ0XygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgYSBjb25uZWN0aW9uIGF0dGVtcHRcclxuICAgICAqL1xyXG4gICAgc3RhcnRfKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLnRyYW5zcG9ydE1hbmFnZXJfLmluaXRpYWxUcmFuc3BvcnQoKTtcclxuICAgICAgICB0aGlzLmNvbm5fID0gbmV3IGNvbm4odGhpcy5uZXh0VHJhbnNwb3J0SWRfKCksIHRoaXMucmVwb0luZm9fLCB0aGlzLmFwcGxpY2F0aW9uSWRfLCB0aGlzLmFwcENoZWNrVG9rZW5fLCB0aGlzLmF1dGhUb2tlbl8sIG51bGwsIHRoaXMubGFzdFNlc3Npb25JZCk7XHJcbiAgICAgICAgLy8gRm9yIGNlcnRhaW4gdHJhbnNwb3J0cyAoV2ViU29ja2V0cyksIHdlIG5lZWQgdG8gc2VuZCBhbmQgcmVjZWl2ZSBzZXZlcmFsIG1lc3NhZ2VzIGJhY2sgYW5kIGZvcnRoIGJlZm9yZSB3ZVxyXG4gICAgICAgIC8vIGNhbiBjb25zaWRlciB0aGUgdHJhbnNwb3J0IGhlYWx0aHkuXHJcbiAgICAgICAgdGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfID0gY29ublsncmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeSddIHx8IDA7XHJcbiAgICAgICAgY29uc3Qgb25NZXNzYWdlUmVjZWl2ZWQgPSB0aGlzLmNvbm5SZWNlaXZlcl8odGhpcy5jb25uXyk7XHJcbiAgICAgICAgY29uc3Qgb25Db25uZWN0aW9uTG9zdCA9IHRoaXMuZGlzY29ublJlY2VpdmVyXyh0aGlzLmNvbm5fKTtcclxuICAgICAgICB0aGlzLnR4XyA9IHRoaXMuY29ubl87XHJcbiAgICAgICAgdGhpcy5yeF8gPSB0aGlzLmNvbm5fO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IGZhbHNlO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogRmlyZWZveCBkb2Vzbid0IGxpa2Ugd2hlbiBjb2RlIGZyb20gb25lIGlmcmFtZSB0cmllcyB0byBjcmVhdGUgYW5vdGhlciBpZnJhbWUgYnkgd2F5IG9mIHRoZSBwYXJlbnQgZnJhbWUuXHJcbiAgICAgICAgICogVGhpcyBjYW4gb2NjdXIgaW4gdGhlIGNhc2Ugb2YgYSByZWRpcmVjdCwgaS5lLiB3ZSBndWVzc2VkIHdyb25nIG9uIHdoYXQgc2VydmVyIHRvIGNvbm5lY3QgdG8gYW5kIHJlY2VpdmVkIGEgcmVzZXQuXHJcbiAgICAgICAgICogU29tZWhvdywgc2V0VGltZW91dCBzZWVtcyB0byBtYWtlIHRoaXMgb2suIFRoYXQgZG9lc24ndCBtYWtlIHNlbnNlIGZyb20gYSBzZWN1cml0eSBwZXJzcGVjdGl2ZSwgc2luY2UgeW91IHNob3VsZFxyXG4gICAgICAgICAqIHN0aWxsIGhhdmUgdGhlIGNvbnRleHQgb2YgeW91ciBvcmlnaW5hdGluZyBmcmFtZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgLy8gdGhpcy5jb25uXyBnZXRzIHNldCB0byBudWxsIGluIHNvbWUgb2YgdGhlIHRlc3RzLiBDaGVjayB0byBtYWtlIHN1cmUgaXQgc3RpbGwgZXhpc3RzIGJlZm9yZSB1c2luZyBpdFxyXG4gICAgICAgICAgICB0aGlzLmNvbm5fICYmIHRoaXMuY29ubl8ub3Blbihvbk1lc3NhZ2VSZWNlaXZlZCwgb25Db25uZWN0aW9uTG9zdCk7XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcigwKSk7XHJcbiAgICAgICAgY29uc3QgaGVhbHRoeVRpbWVvdXRNUyA9IGNvbm5bJ2hlYWx0aHlUaW1lb3V0J10gfHwgMDtcclxuICAgICAgICBpZiAoaGVhbHRoeVRpbWVvdXRNUyA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFsdGh5VGltZW91dF8gPSBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFsdGh5VGltZW91dF8gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSGVhbHRoeV8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uXyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5fLmJ5dGVzUmVjZWl2ZWQgPiBCWVRFU19SRUNFSVZFRF9IRUFMVEhZX09WRVJSSURFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nXygnQ29ubmVjdGlvbiBleGNlZWRlZCBoZWFsdGh5IHRpbWVvdXQgYnV0IGhhcyByZWNlaXZlZCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubl8uYnl0ZXNSZWNlaXZlZCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzLiAgTWFya2luZyBjb25uZWN0aW9uIGhlYWx0aHkuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubl8ubWFya0Nvbm5lY3Rpb25IZWFsdGh5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29ubl8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uXy5ieXRlc1NlbnQgPiBCWVRFU19TRU5UX0hFQUxUSFlfT1ZFUlJJREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdDb25uZWN0aW9uIGV4Y2VlZGVkIGhlYWx0aHkgdGltZW91dCBidXQgaGFzIHNlbnQgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5fLmJ5dGVzU2VudCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzLiAgTGVhdmluZyBjb25uZWN0aW9uIGFsaXZlLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBXZSBkb24ndCB3YW50IHRvIG1hcmsgaXQgaGVhbHRoeSwgc2luY2Ugd2UgaGF2ZSBubyBndWFyYW50ZWUgdGhhdCB0aGUgYnl0ZXMgaGF2ZSBtYWRlIGl0IHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzZXJ2ZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ0Nsb3NpbmcgdW5oZWFsdGh5IGNvbm5lY3Rpb24gYWZ0ZXIgdGltZW91dC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIH0sIE1hdGguZmxvb3IoaGVhbHRoeVRpbWVvdXRNUykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG5leHRUcmFuc3BvcnRJZF8oKSB7XHJcbiAgICAgICAgcmV0dXJuICdjOicgKyB0aGlzLmlkICsgJzonICsgdGhpcy5jb25uZWN0aW9uQ291bnQrKztcclxuICAgIH1cclxuICAgIGRpc2Nvbm5SZWNlaXZlcl8oY29ubikge1xyXG4gICAgICAgIHJldHVybiBldmVyQ29ubmVjdGVkID0+IHtcclxuICAgICAgICAgICAgaWYgKGNvbm4gPT09IHRoaXMuY29ubl8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uTG9zdF8oZXZlckNvbm5lY3RlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29ubiA9PT0gdGhpcy5zZWNvbmRhcnlDb25uXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdTZWNvbmRhcnkgY29ubmVjdGlvbiBsb3N0LicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblNlY29uZGFyeUNvbm5lY3Rpb25Mb3N0XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdjbG9zaW5nIGFuIG9sZCBjb25uZWN0aW9uJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29ublJlY2VpdmVyXyhjb25uKSB7XHJcbiAgICAgICAgcmV0dXJuIChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlXyAhPT0gMiAvKiBSZWFsdGltZVN0YXRlLkRJU0NPTk5FQ1RFRCAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbm4gPT09IHRoaXMucnhfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblByaW1hcnlNZXNzYWdlUmVjZWl2ZWRfKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29ubiA9PT0gdGhpcy5zZWNvbmRhcnlDb25uXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25TZWNvbmRhcnlNZXNzYWdlUmVjZWl2ZWRfKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdtZXNzYWdlIG9uIG9sZCBjb25uZWN0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZGF0YU1zZyAtIEFuIGFyYml0cmFyeSBkYXRhIG1lc3NhZ2UgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyXHJcbiAgICAgKi9cclxuICAgIHNlbmRSZXF1ZXN0KGRhdGFNc2cpIHtcclxuICAgICAgICAvLyB3cmFwIGluIGEgZGF0YSBtZXNzYWdlIGVudmVsb3BlIGFuZCBzZW5kIGl0IG9uXHJcbiAgICAgICAgY29uc3QgbXNnID0geyB0OiAnZCcsIGQ6IGRhdGFNc2cgfTtcclxuICAgICAgICB0aGlzLnNlbmREYXRhXyhtc2cpO1xyXG4gICAgfVxyXG4gICAgdHJ5Q2xlYW51cENvbm5lY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fICYmIHRoaXMucnhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnY2xlYW5pbmcgdXAgYW5kIHByb21vdGluZyBhIGNvbm5lY3Rpb246ICcgKyB0aGlzLnNlY29uZGFyeUNvbm5fLmNvbm5JZCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubl8gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xyXG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gdGhlIHNlcnZlciB3aWxsIHNodXRkb3duIHRoZSBvbGQgY29ubmVjdGlvblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uU2Vjb25kYXJ5Q29udHJvbF8oY29udHJvbERhdGEpIHtcclxuICAgICAgICBpZiAoTUVTU0FHRV9UWVBFIGluIGNvbnRyb2xEYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNtZCA9IGNvbnRyb2xEYXRhW01FU1NBR0VfVFlQRV07XHJcbiAgICAgICAgICAgIGlmIChjbWQgPT09IFNXSVRDSF9BQ0spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBncmFkZUlmU2Vjb25kYXJ5SGVhbHRoeV8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfUkVTRVQpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1vc3QgbGlrZWx5IHRoZSBzZXNzaW9uIHdhc24ndCB2YWxpZC4gQWJhbmRvbiB0aGUgc3dpdGNoIGF0dGVtcHRcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnR290IGEgcmVzZXQgb24gc2Vjb25kYXJ5LCBjbG9zaW5nIGl0Jyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIGFscmVhZHkgdXNpbmcgdGhpcyBjb25uZWN0aW9uIGZvciBzb21ldGhpbmcsIHRoYW4gd2UgbmVlZCB0byBmdWxseSBjbG9zZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yeF8gPT09IHRoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1BPTkcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnZ290IHBvbmcgb24gc2Vjb25kYXJ5LicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlSZXNwb25zZXNSZXF1aXJlZF8tLTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBncmFkZUlmU2Vjb25kYXJ5SGVhbHRoeV8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uU2Vjb25kYXJ5TWVzc2FnZVJlY2VpdmVkXyhwYXJzZWREYXRhKSB7XHJcbiAgICAgICAgY29uc3QgbGF5ZXIgPSByZXF1aXJlS2V5KCd0JywgcGFyc2VkRGF0YSk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHJlcXVpcmVLZXkoJ2QnLCBwYXJzZWREYXRhKTtcclxuICAgICAgICBpZiAobGF5ZXIgPT09ICdjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uU2Vjb25kYXJ5Q29udHJvbF8oZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxheWVyID09PSAnZCcpIHtcclxuICAgICAgICAgICAgLy8gZ290IGEgZGF0YSBtZXNzYWdlLCBidXQgd2UncmUgc3RpbGwgc2Vjb25kIGNvbm5lY3Rpb24uIE5lZWQgdG8gYnVmZmVyIGl0IHVwXHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RhdGFNZXNzYWdlcy5wdXNoKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByb3RvY29sIGxheWVyOiAnICsgbGF5ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZ3JhZGVJZlNlY29uZGFyeUhlYWx0aHlfKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlY29uZGFyeVJlc3BvbnNlc1JlcXVpcmVkXyA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnU2Vjb25kYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS4nKTtcclxuICAgICAgICAgICAgdGhpcy5pc0hlYWx0aHlfID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5tYXJrQ29ubmVjdGlvbkhlYWx0aHkoKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZWVkV2l0aFVwZ3JhZGVfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBTZW5kIGEgcGluZyB0byBtYWtlIHN1cmUgdGhlIGNvbm5lY3Rpb24gaXMgaGVhbHRoeS5cclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdzZW5kaW5nIHBpbmcgb24gc2Vjb25kYXJ5LicpO1xyXG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLnNlbmQoeyB0OiAnYycsIGQ6IHsgdDogUElORywgZDoge30gfSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm9jZWVkV2l0aFVwZ3JhZGVfKCkge1xyXG4gICAgICAgIC8vIHRlbGwgdGhpcyBjb25uZWN0aW9uIHRvIGNvbnNpZGVyIGl0c2VsZiBvcGVuXHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5zdGFydCgpO1xyXG4gICAgICAgIC8vIHNlbmQgYWNrXHJcbiAgICAgICAgdGhpcy5sb2dfKCdzZW5kaW5nIGNsaWVudCBhY2sgb24gc2Vjb25kYXJ5Jyk7XHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5zZW5kKHsgdDogJ2MnLCBkOiB7IHQ6IFNXSVRDSF9BQ0ssIGQ6IHt9IH0gfSk7XHJcbiAgICAgICAgLy8gc2VuZCBlbmQgcGFja2V0IG9uIHByaW1hcnkgdHJhbnNwb3J0LCBzd2l0Y2ggdG8gc2VuZGluZyBvbiB0aGlzIG9uZVxyXG4gICAgICAgIC8vIGNhbiByZWNlaXZlIG9uIHRoaXMgb25lLCBidWZmZXIgcmVzcG9uc2VzIHVudGlsIGVuZCByZWNlaXZlZCBvbiBwcmltYXJ5IHRyYW5zcG9ydFxyXG4gICAgICAgIHRoaXMubG9nXygnRW5kaW5nIHRyYW5zbWlzc2lvbiBvbiBwcmltYXJ5Jyk7XHJcbiAgICAgICAgdGhpcy5jb25uXy5zZW5kKHsgdDogJ2MnLCBkOiB7IHQ6IEVORF9UUkFOU01JU1NJT04sIGQ6IHt9IH0gfSk7XHJcbiAgICAgICAgdGhpcy50eF8gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xyXG4gICAgICAgIHRoaXMudHJ5Q2xlYW51cENvbm5lY3Rpb24oKTtcclxuICAgIH1cclxuICAgIG9uUHJpbWFyeU1lc3NhZ2VSZWNlaXZlZF8ocGFyc2VkRGF0YSkge1xyXG4gICAgICAgIC8vIE11c3QgcmVmZXIgdG8gcGFyc2VkRGF0YSBwcm9wZXJ0aWVzIGluIHF1b3Rlcywgc28gY2xvc3VyZSBkb2Vzbid0IHRvdWNoIHRoZW0uXHJcbiAgICAgICAgY29uc3QgbGF5ZXIgPSByZXF1aXJlS2V5KCd0JywgcGFyc2VkRGF0YSk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHJlcXVpcmVLZXkoJ2QnLCBwYXJzZWREYXRhKTtcclxuICAgICAgICBpZiAobGF5ZXIgPT09ICdjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uQ29udHJvbF8oZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxheWVyID09PSAnZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkRhdGFNZXNzYWdlXyhkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkRhdGFNZXNzYWdlXyhtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5vblByaW1hcnlSZXNwb25zZV8oKTtcclxuICAgICAgICAvLyBXZSBkb24ndCBkbyBhbnl0aGluZyB3aXRoIGRhdGEgbWVzc2FnZXMsIGp1c3Qga2ljayB0aGVtIHVwIGEgbGV2ZWxcclxuICAgICAgICB0aGlzLm9uTWVzc2FnZV8obWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICBvblByaW1hcnlSZXNwb25zZV8oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSGVhbHRoeV8pIHtcclxuICAgICAgICAgICAgdGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfLS07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByaW1hcnlSZXNwb25zZXNSZXF1aXJlZF8gPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdQcmltYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS4nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5fLm1hcmtDb25uZWN0aW9uSGVhbHRoeSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25Db250cm9sXyhjb250cm9sRGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNtZCA9IHJlcXVpcmVLZXkoTUVTU0FHRV9UWVBFLCBjb250cm9sRGF0YSk7XHJcbiAgICAgICAgaWYgKE1FU1NBR0VfREFUQSBpbiBjb250cm9sRGF0YSkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gY29udHJvbERhdGFbTUVTU0FHRV9EQVRBXTtcclxuICAgICAgICAgICAgaWYgKGNtZCA9PT0gU0VSVkVSX0hFTExPKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kc2hha2VQYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7fSwgcGF5bG9hZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXBvSW5mb18uaXNVc2luZ0VtdWxhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBvbiBjb25uZWN0aW5nLCB0aGUgZW11bGF0b3Igd2lsbCBwYXNzIHRoZSBob3N0bmFtZSB0aGF0IGl0J3MgYXdhcmUgb2YsIGJ1dCB3ZSBwcmVmZXIgdGhlIHVzZXIncyBzZXQgaG9zdG5hbWUgdmlhIGBjb25uZWN0RGF0YWJhc2VFbXVsYXRvcmAgb3ZlciB3aGF0IHRoZSBlbXVsYXRvciBwYXNzZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZHNoYWtlUGF5bG9hZC5oID0gdGhpcy5yZXBvSW5mb18uaG9zdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMub25IYW5kc2hha2VfKGhhbmRzaGFrZVBheWxvYWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gRU5EX1RSQU5TTUlTU0lPTikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdyZWN2ZCBlbmQgdHJhbnNtaXNzaW9uIG9uIHByaW1hcnknKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucnhfID0gdGhpcy5zZWNvbmRhcnlDb25uXztcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkRhdGFNZXNzYWdlXyh0aGlzLnBlbmRpbmdEYXRhTWVzc2FnZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeUNsZWFudXBDb25uZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1NIVVRET1dOKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdhcyBwcmV2aW91c2x5IHRoZSAnb25LaWxsJyBjYWxsYmFjayBwYXNzZWQgdG8gdGhlIGxvd2VyLWxldmVsIGNvbm5lY3Rpb25cclxuICAgICAgICAgICAgICAgIC8vIHBheWxvYWQgaW4gdGhpcyBjYXNlIGlzIHRoZSByZWFzb24gZm9yIHRoZSBzaHV0ZG93bi4gR2VuZXJhbGx5IGEgaHVtYW4tcmVhZGFibGUgZXJyb3JcclxuICAgICAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uU2h1dGRvd25fKHBheWxvYWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gQ09OVFJPTF9SRVNFVCkge1xyXG4gICAgICAgICAgICAgICAgLy8gcGF5bG9hZCBpbiB0aGlzIGNhc2UgaXMgdGhlIGhvc3Qgd2Ugc2hvdWxkIGNvbnRhY3RcclxuICAgICAgICAgICAgICAgIHRoaXMub25SZXNldF8ocGF5bG9hZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX0VSUk9SKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcignU2VydmVyIEVycm9yOiAnICsgcGF5bG9hZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1BPTkcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnZ290IHBvbmcgb24gcHJpbWFyeS4nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub25QcmltYXJ5UmVzcG9uc2VfKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRQaW5nT25QcmltYXJ5SWZOZWNlc3NhcnlfKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcignVW5rbm93biBjb250cm9sIHBhY2tldCBjb21tYW5kOiAnICsgY21kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGhhbmRzaGFrZSAtIFRoZSBoYW5kc2hha2UgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgb25IYW5kc2hha2VfKGhhbmRzaGFrZSkge1xyXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IGhhbmRzaGFrZS50cztcclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gaGFuZHNoYWtlLnY7XHJcbiAgICAgICAgY29uc3QgaG9zdCA9IGhhbmRzaGFrZS5oO1xyXG4gICAgICAgIHRoaXMuc2Vzc2lvbklkID0gaGFuZHNoYWtlLnM7XHJcbiAgICAgICAgdGhpcy5yZXBvSW5mb18uaG9zdCA9IGhvc3Q7XHJcbiAgICAgICAgLy8gaWYgd2UndmUgYWxyZWFkeSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24sIHRoZW4gZG9uJ3QgYm90aGVyIHRyeWluZyB0byBwcm9ncmVzcyBmdXJ0aGVyXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfID09PSAwIC8qIFJlYWx0aW1lU3RhdGUuQ09OTkVDVElORyAqLykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5fLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uRXN0YWJsaXNoZWRfKHRoaXMuY29ubl8sIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgIGlmIChQUk9UT0NPTF9WRVJTSU9OICE9PSB2ZXJzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKCdQcm90b2NvbCB2ZXJzaW9uIG1pc21hdGNoIGRldGVjdGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVE9ETzogZG8gd2Ugd2FudCB0byB1cGdyYWRlPyB3aGVuPyBtYXliZSBhIGRlbGF5P1xyXG4gICAgICAgICAgICB0aGlzLnRyeVN0YXJ0VXBncmFkZV8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0cnlTdGFydFVwZ3JhZGVfKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLnRyYW5zcG9ydE1hbmFnZXJfLnVwZ3JhZGVUcmFuc3BvcnQoKTtcclxuICAgICAgICBpZiAoY29ubikge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VXBncmFkZV8oY29ubik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhcnRVcGdyYWRlXyhjb25uKSB7XHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXyA9IG5ldyBjb25uKHRoaXMubmV4dFRyYW5zcG9ydElkXygpLCB0aGlzLnJlcG9JbmZvXywgdGhpcy5hcHBsaWNhdGlvbklkXywgdGhpcy5hcHBDaGVja1Rva2VuXywgdGhpcy5hdXRoVG9rZW5fLCB0aGlzLnNlc3Npb25JZCk7XHJcbiAgICAgICAgLy8gRm9yIGNlcnRhaW4gdHJhbnNwb3J0cyAoV2ViU29ja2V0cyksIHdlIG5lZWQgdG8gc2VuZCBhbmQgcmVjZWl2ZSBzZXZlcmFsIG1lc3NhZ2VzIGJhY2sgYW5kIGZvcnRoIGJlZm9yZSB3ZVxyXG4gICAgICAgIC8vIGNhbiBjb25zaWRlciB0aGUgdHJhbnNwb3J0IGhlYWx0aHkuXHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlSZXNwb25zZXNSZXF1aXJlZF8gPVxyXG4gICAgICAgICAgICBjb25uWydyZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5J10gfHwgMDtcclxuICAgICAgICBjb25zdCBvbk1lc3NhZ2UgPSB0aGlzLmNvbm5SZWNlaXZlcl8odGhpcy5zZWNvbmRhcnlDb25uXyk7XHJcbiAgICAgICAgY29uc3Qgb25EaXNjb25uZWN0ID0gdGhpcy5kaXNjb25uUmVjZWl2ZXJfKHRoaXMuc2Vjb25kYXJ5Q29ubl8pO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8ub3Blbihvbk1lc3NhZ2UsIG9uRGlzY29ubmVjdCk7XHJcbiAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBzdWNjZXNzZnVsbHkgdXBncmFkZWQgYWZ0ZXIgVVBHUkFERV9USU1FT1VULCBnaXZlIHVwIGFuZCBraWxsIHRoZSBzZWNvbmRhcnkuXHJcbiAgICAgICAgc2V0VGltZW91dE5vbkJsb2NraW5nKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnVGltZWQgb3V0IHRyeWluZyB0byB1cGdyYWRlLicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcihVUEdSQURFX1RJTUVPVVQpKTtcclxuICAgIH1cclxuICAgIG9uUmVzZXRfKGhvc3QpIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ1Jlc2V0IHBhY2tldCByZWNlaXZlZC4gIE5ldyBob3N0OiAnICsgaG9zdCk7XHJcbiAgICAgICAgdGhpcy5yZXBvSW5mb18uaG9zdCA9IGhvc3Q7XHJcbiAgICAgICAgLy8gVE9ETzogaWYgd2UncmUgYWxyZWFkeSBcImNvbm5lY3RlZFwiLCB3ZSBuZWVkIHRvIHRyaWdnZXIgYSBkaXNjb25uZWN0IGF0IHRoZSBuZXh0IGxheWVyIHVwLlxyXG4gICAgICAgIC8vIFdlIGRvbid0IGN1cnJlbnRseSBzdXBwb3J0IHJlc2V0cyBhZnRlciB0aGUgY29ubmVjdGlvbiBoYXMgYWxyZWFkeSBiZWVuIGVzdGFibGlzaGVkXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfID09PSAxIC8qIFJlYWx0aW1lU3RhdGUuQ09OTkVDVEVEICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIENsb3NlIHdoYXRldmVyIGNvbm5lY3Rpb25zIHdlIGhhdmUgb3BlbiBhbmQgc3RhcnQgYWdhaW4uXHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uc18oKTtcclxuICAgICAgICAgICAgdGhpcy5zdGFydF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZF8oY29ubiwgdGltZXN0YW1wKSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdSZWFsdGltZSBjb25uZWN0aW9uIGVzdGFibGlzaGVkLicpO1xyXG4gICAgICAgIHRoaXMuY29ubl8gPSBjb25uO1xyXG4gICAgICAgIHRoaXMuc3RhdGVfID0gMSAvKiBSZWFsdGltZVN0YXRlLkNPTk5FQ1RFRCAqLztcclxuICAgICAgICBpZiAodGhpcy5vblJlYWR5Xykge1xyXG4gICAgICAgICAgICB0aGlzLm9uUmVhZHlfKHRpbWVzdGFtcCwgdGhpcy5zZXNzaW9uSWQpO1xyXG4gICAgICAgICAgICB0aGlzLm9uUmVhZHlfID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgYWZ0ZXIgNSBzZWNvbmRzIHdlIGhhdmVuJ3Qgc2VudCBlbm91Z2ggcmVxdWVzdHMgdG8gdGhlIHNlcnZlciB0byBnZXQgdGhlIGNvbm5lY3Rpb24gaGVhbHRoeSxcclxuICAgICAgICAvLyBzZW5kIHNvbWUgcGluZ3MuXHJcbiAgICAgICAgaWYgKHRoaXMucHJpbWFyeVJlc3BvbnNlc1JlcXVpcmVkXyA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1ByaW1hcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LicpO1xyXG4gICAgICAgICAgICB0aGlzLmlzSGVhbHRoeV8gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dE5vbkJsb2NraW5nKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFBpbmdPblByaW1hcnlJZk5lY2Vzc2FyeV8oKTtcclxuICAgICAgICAgICAgfSwgTWF0aC5mbG9vcihERUxBWV9CRUZPUkVfU0VORElOR19FWFRSQV9SRVFVRVNUUykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNlbmRQaW5nT25QcmltYXJ5SWZOZWNlc3NhcnlfKCkge1xyXG4gICAgICAgIC8vIElmIHRoZSBjb25uZWN0aW9uIGlzbid0IGNvbnNpZGVyZWQgaGVhbHRoeSB5ZXQsIHdlJ2xsIHNlbmQgYSBub29wIHBpbmcgcGFja2V0IHJlcXVlc3QuXHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSGVhbHRoeV8gJiYgdGhpcy5zdGF0ZV8gPT09IDEgLyogUmVhbHRpbWVTdGF0ZS5DT05ORUNURUQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdzZW5kaW5nIHBpbmcgb24gcHJpbWFyeS4nKTtcclxuICAgICAgICAgICAgdGhpcy5zZW5kRGF0YV8oeyB0OiAnYycsIGQ6IHsgdDogUElORywgZDoge30gfSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvblNlY29uZGFyeUNvbm5lY3Rpb25Mb3N0XygpIHtcclxuICAgICAgICBjb25zdCBjb25uID0gdGhpcy5zZWNvbmRhcnlDb25uXztcclxuICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy50eF8gPT09IGNvbm4gfHwgdGhpcy5yeF8gPT09IGNvbm4pIHtcclxuICAgICAgICAgICAgLy8gd2UgYXJlIHJlbHlpbmcgb24gdGhpcyBjb25uZWN0aW9uIGFscmVhZHkgaW4gc29tZSBjYXBhY2l0eS4gVGhlcmVmb3JlLCBhIGZhaWx1cmUgaXMgcmVhbFxyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZXZlckNvbm5lY3RlZCAtIFdoZXRoZXIgb3Igbm90IHRoZSBjb25uZWN0aW9uIGV2ZXIgcmVhY2hlZCBhIHNlcnZlci4gVXNlZCB0byBkZXRlcm1pbmUgaWZcclxuICAgICAqIHdlIHNob3VsZCBmbHVzaCB0aGUgaG9zdCBjYWNoZVxyXG4gICAgICovXHJcbiAgICBvbkNvbm5lY3Rpb25Mb3N0XyhldmVyQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgdGhpcy5jb25uXyA9IG51bGw7XHJcbiAgICAgICAgLy8gTk9URTogSUYgeW91J3JlIHNlZWluZyBhIEZpcmVmb3ggZXJyb3IgZm9yIHRoaXMgbGluZSwgSSB0aGluayBpdCBtaWdodCBiZSBiZWNhdXNlIGl0J3MgZ2V0dGluZ1xyXG4gICAgICAgIC8vIGNhbGxlZCBvbiB3aW5kb3cgY2xvc2UgYW5kIFJlYWx0aW1lU3RhdGUuQ09OTkVDVElORyBpcyBubyBsb25nZXIgZGVmaW5lZC4gIEp1c3QgYSBndWVzcy5cclxuICAgICAgICBpZiAoIWV2ZXJDb25uZWN0ZWQgJiYgdGhpcy5zdGF0ZV8gPT09IDAgLyogUmVhbHRpbWVTdGF0ZS5DT05ORUNUSU5HICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnUmVhbHRpbWUgY29ubmVjdGlvbiBmYWlsZWQuJyk7XHJcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGZhaWxlZCB0byBjb25uZWN0IGF0IGFsbCwgY2xlYXIgYW55IGNhY2hlZCBlbnRyeSBmb3IgdGhpcyBuYW1lc3BhY2UgaW4gY2FzZSB0aGUgbWFjaGluZSB3ZW50IGF3YXlcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVwb0luZm9fLmlzQ2FjaGVhYmxlSG9zdCgpKSB7XHJcbiAgICAgICAgICAgICAgICBQZXJzaXN0ZW50U3RvcmFnZS5yZW1vdmUoJ2hvc3Q6JyArIHRoaXMucmVwb0luZm9fLmhvc3QpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGludGVybmFsIGhvc3QgdG8gd2hhdCB3ZSB3b3VsZCBzaG93IHRoZSB1c2VyLCBpLmUuIDxucz4uZmlyZWJhc2Vpby5jb21cclxuICAgICAgICAgICAgICAgIHRoaXMucmVwb0luZm9fLmludGVybmFsSG9zdCA9IHRoaXMucmVwb0luZm9fLmhvc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZV8gPT09IDEgLyogUmVhbHRpbWVTdGF0ZS5DT05ORUNURUQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdSZWFsdGltZSBjb25uZWN0aW9uIGxvc3QuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgIH1cclxuICAgIG9uQ29ubmVjdGlvblNodXRkb3duXyhyZWFzb24pIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ0Nvbm5lY3Rpb24gc2h1dGRvd24gY29tbWFuZCByZWNlaXZlZC4gU2h1dHRpbmcgZG93bi4uLicpO1xyXG4gICAgICAgIGlmICh0aGlzLm9uS2lsbF8pIHtcclxuICAgICAgICAgICAgdGhpcy5vbktpbGxfKHJlYXNvbik7XHJcbiAgICAgICAgICAgIHRoaXMub25LaWxsXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3Qgd2FudCB0byBmaXJlIG9uRGlzY29ubmVjdCAoa2lsbCBpcyBhIGRpZmZlcmVudCBjYXNlKSxcclxuICAgICAgICAvLyBzbyBjbGVhciB0aGUgY2FsbGJhY2suXHJcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICB9XHJcbiAgICBzZW5kRGF0YV8oZGF0YSkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlXyAhPT0gMSAvKiBSZWFsdGltZVN0YXRlLkNPTk5FQ1RFRCAqLykge1xyXG4gICAgICAgICAgICB0aHJvdyAnQ29ubmVjdGlvbiBpcyBub3QgY29ubmVjdGVkJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudHhfLnNlbmQoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhbnMgdXAgdGhpcyBjb25uZWN0aW9uLCBjYWxsaW5nIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3NcclxuICAgICAqL1xyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfICE9PSAyIC8qIFJlYWx0aW1lU3RhdGUuRElTQ09OTkVDVEVEICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnQ2xvc2luZyByZWFsdGltZSBjb25uZWN0aW9uLicpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlXyA9IDIgLyogUmVhbHRpbWVTdGF0ZS5ESVNDT05ORUNURUQgKi87XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uc18oKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub25EaXNjb25uZWN0Xykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xvc2VDb25uZWN0aW9uc18oKSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdTaHV0dGluZyBkb3duIGFsbCBjb25uZWN0aW9ucycpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubl8uY2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNlY29uZGFyeUNvbm5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8uY2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmhlYWx0aHlUaW1lb3V0Xykge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oZWFsdGh5VGltZW91dF8pO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWx0aHlUaW1lb3V0XyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBJbnRlcmZhY2UgZGVmaW5pbmcgdGhlIHNldCBvZiBhY3Rpb25zIHRoYXQgY2FuIGJlIHBlcmZvcm1lZCBhZ2FpbnN0IHRoZSBGaXJlYmFzZSBzZXJ2ZXJcclxuICogKGJhc2ljYWxseSBjb3JyZXNwb25kcyB0byBvdXIgd2lyZSBwcm90b2NvbCkuXHJcbiAqXHJcbiAqIEBpbnRlcmZhY2VcclxuICovXHJcbmNsYXNzIFNlcnZlckFjdGlvbnMge1xyXG4gICAgcHV0KHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHsgfVxyXG4gICAgbWVyZ2UocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCkgeyB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZnJlc2hlcyB0aGUgYXV0aCB0b2tlbiBmb3IgdGhlIGN1cnJlbnQgY29ubmVjdGlvbi5cclxuICAgICAqIEBwYXJhbSB0b2tlbiAtIFRoZSBhdXRoZW50aWNhdGlvbiB0b2tlblxyXG4gICAgICovXHJcbiAgICByZWZyZXNoQXV0aFRva2VuKHRva2VuKSB7IH1cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIHRoZSBhcHAgY2hlY2sgdG9rZW4gZm9yIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gdG9rZW4gVGhlIGFwcCBjaGVjayB0b2tlblxyXG4gICAgICovXHJcbiAgICByZWZyZXNoQXBwQ2hlY2tUb2tlbih0b2tlbikgeyB9XHJcbiAgICBvbkRpc2Nvbm5lY3RQdXQocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkgeyB9XHJcbiAgICBvbkRpc2Nvbm5lY3RNZXJnZShwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKSB7IH1cclxuICAgIG9uRGlzY29ubmVjdENhbmNlbChwYXRoU3RyaW5nLCBvbkNvbXBsZXRlKSB7IH1cclxuICAgIHJlcG9ydFN0YXRzKHN0YXRzKSB7IH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQmFzZSBjbGFzcyB0byBiZSB1c2VkIGlmIHlvdSB3YW50IHRvIGVtaXQgZXZlbnRzLiBDYWxsIHRoZSBjb25zdHJ1Y3RvciB3aXRoXHJcbiAqIHRoZSBzZXQgb2YgYWxsb3dlZCBldmVudCBuYW1lcy5cclxuICovXHJcbmNsYXNzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhbGxvd2VkRXZlbnRzXykge1xyXG4gICAgICAgIHRoaXMuYWxsb3dlZEV2ZW50c18gPSBhbGxvd2VkRXZlbnRzXztcclxuICAgICAgICB0aGlzLmxpc3RlbmVyc18gPSB7fTtcclxuICAgICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShhbGxvd2VkRXZlbnRzXykgJiYgYWxsb3dlZEV2ZW50c18ubGVuZ3RoID4gMCwgJ1JlcXVpcmVzIGEgbm9uLWVtcHR5IGFycmF5Jyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRvIGJlIGNhbGxlZCBieSBkZXJpdmVkIGNsYXNzZXMgdG8gdHJpZ2dlciBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIHRyaWdnZXIoZXZlbnRUeXBlLCAuLi52YXJBcmdzKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0pKSB7XHJcbiAgICAgICAgICAgIC8vIENsb25lIHRoZSBsaXN0LCBzaW5jZSBjYWxsYmFja3MgY291bGQgYWRkL3JlbW92ZSBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IFsuLi50aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbGJhY2suYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIHZhckFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb24oZXZlbnRUeXBlLCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGVFdmVudFR5cGVfKGV2ZW50VHlwZSk7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0gPSB0aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXSB8fCBbXTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXS5wdXNoKHsgY2FsbGJhY2ssIGNvbnRleHQgfSk7XHJcbiAgICAgICAgY29uc3QgZXZlbnREYXRhID0gdGhpcy5nZXRJbml0aWFsRXZlbnQoZXZlbnRUeXBlKTtcclxuICAgICAgICBpZiAoZXZlbnREYXRhKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KGNvbnRleHQsIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb2ZmKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLnZhbGlkYXRlRXZlbnRUeXBlXyhldmVudFR5cGUpO1xyXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdIHx8IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uY2FsbGJhY2sgPT09IGNhbGxiYWNrICYmXHJcbiAgICAgICAgICAgICAgICAoIWNvbnRleHQgfHwgY29udGV4dCA9PT0gbGlzdGVuZXJzW2ldLmNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVFdmVudFR5cGVfKGV2ZW50VHlwZSkge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLmFsbG93ZWRFdmVudHNfLmZpbmQoZXQgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZXQgPT09IGV2ZW50VHlwZTtcclxuICAgICAgICB9KSwgJ1Vua25vd24gZXZlbnQ6ICcgKyBldmVudFR5cGUpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBNb25pdG9ycyBvbmxpbmUgc3RhdGUgKGFzIHJlcG9ydGVkIGJ5IHdpbmRvdy5vbmxpbmUvb2ZmbGluZSBldmVudHMpLlxyXG4gKlxyXG4gKiBUaGUgZXhwZWN0YXRpb24gaXMgdGhhdCB0aGlzIGNvdWxkIGhhdmUgbWFueSBmYWxzZSBwb3NpdGl2ZXMgKHRoaW5rcyB3ZSBhcmUgb25saW5lXHJcbiAqIHdoZW4gd2UncmUgbm90KSwgYnV0IG5vIGZhbHNlIG5lZ2F0aXZlcy4gIFNvIHdlIGNhbiBzYWZlbHkgdXNlIGl0IHRvIGRldGVybWluZSB3aGVuXHJcbiAqIHdlIGRlZmluaXRlbHkgY2Fubm90IHJlYWNoIHRoZSBpbnRlcm5ldC5cclxuICovXHJcbmNsYXNzIE9ubGluZU1vbml0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoWydvbmxpbmUnXSk7XHJcbiAgICAgICAgdGhpcy5vbmxpbmVfID0gdHJ1ZTtcclxuICAgICAgICAvLyBXZSd2ZSBoYWQgcmVwZWF0ZWQgY29tcGxhaW50cyB0aGF0IENvcmRvdmEgYXBwcyBjYW4gZ2V0IHN0dWNrIFwib2ZmbGluZVwiLCBlLmcuXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9mb3J1bS5pb25pY2ZyYW1ld29yay5jb20vdC9maXJlYmFzZS1jb25uZWN0aW9uLWlzLWxvc3QtYW5kLW5ldmVyLWNvbWUtYmFjay80MzgxMFxyXG4gICAgICAgIC8vIEl0IHdvdWxkIHNlZW0gdGhhdCB0aGUgJ29ubGluZScgZXZlbnQgZG9lcyBub3QgYWx3YXlzIGZpcmUgY29uc2lzdGVudGx5LiBTbyB3ZSBkaXNhYmxlIGl0XHJcbiAgICAgICAgLy8gZm9yIENvcmRvdmEuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgIWlzTW9iaWxlQ29yZG92YSgpKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub25saW5lXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25saW5lXyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdvbmxpbmUnLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ubGluZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ubGluZV8gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ29ubGluZScsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE9ubGluZU1vbml0b3IoKTtcclxuICAgIH1cclxuICAgIGdldEluaXRpYWxFdmVudChldmVudFR5cGUpIHtcclxuICAgICAgICBhc3NlcnQoZXZlbnRUeXBlID09PSAnb25saW5lJywgJ1Vua25vd24gZXZlbnQgdHlwZTogJyArIGV2ZW50VHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLm9ubGluZV9dO1xyXG4gICAgfVxyXG4gICAgY3VycmVudGx5T25saW5lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9ubGluZV87XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIE1heGltdW0ga2V5IGRlcHRoLiAqL1xyXG5jb25zdCBNQVhfUEFUSF9ERVBUSCA9IDMyO1xyXG4vKiogTWF4aW11bSBudW1iZXIgb2YgKFVURjgpIGJ5dGVzIGluIGEgRmlyZWJhc2UgcGF0aC4gKi9cclxuY29uc3QgTUFYX1BBVEhfTEVOR1RIX0JZVEVTID0gNzY4O1xyXG4vKipcclxuICogQW4gaW1tdXRhYmxlIG9iamVjdCByZXByZXNlbnRpbmcgYSBwYXJzZWQgcGF0aC4gIEl0J3MgaW1tdXRhYmxlIHNvIHRoYXQgeW91XHJcbiAqIGNhbiBwYXNzIHRoZW0gYXJvdW5kIHRvIG90aGVyIGZ1bmN0aW9ucyB3aXRob3V0IHdvcnJ5aW5nIGFib3V0IHRoZW0gY2hhbmdpbmdcclxuICogaXQuXHJcbiAqL1xyXG5jbGFzcyBQYXRoIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHBhdGhPclN0cmluZyAtIFBhdGggc3RyaW5nIHRvIHBhcnNlLCBvciBhbm90aGVyIHBhdGgsIG9yIHRoZSByYXdcclxuICAgICAqIHRva2VucyBhcnJheVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoT3JTdHJpbmcsIHBpZWNlTnVtKSB7XHJcbiAgICAgICAgaWYgKHBpZWNlTnVtID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgdGhpcy5waWVjZXNfID0gcGF0aE9yU3RyaW5nLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBlbXB0eSBwaWVjZXMuXHJcbiAgICAgICAgICAgIGxldCBjb3B5VG8gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGllY2VzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGllY2VzX1tpXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5waWVjZXNfW2NvcHlUb10gPSB0aGlzLnBpZWNlc19baV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29weVRvKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5waWVjZXNfLmxlbmd0aCA9IGNvcHlUbztcclxuICAgICAgICAgICAgdGhpcy5waWVjZU51bV8gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5waWVjZXNfID0gcGF0aE9yU3RyaW5nO1xyXG4gICAgICAgICAgICB0aGlzLnBpZWNlTnVtXyA9IHBpZWNlTnVtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGxldCBwYXRoU3RyaW5nID0gJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMucGllY2VOdW1fOyBpIDwgdGhpcy5waWVjZXNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBpZWNlc19baV0gIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nICs9ICcvJyArIHRoaXMucGllY2VzX1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aFN0cmluZyB8fCAnLyc7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV3RW1wdHlQYXRoKCkge1xyXG4gICAgcmV0dXJuIG5ldyBQYXRoKCcnKTtcclxufVxyXG5mdW5jdGlvbiBwYXRoR2V0RnJvbnQocGF0aCkge1xyXG4gICAgaWYgKHBhdGgucGllY2VOdW1fID49IHBhdGgucGllY2VzXy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoLnBpZWNlc19bcGF0aC5waWVjZU51bV9dO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoaXMgcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aEdldExlbmd0aChwYXRoKSB7XHJcbiAgICByZXR1cm4gcGF0aC5waWVjZXNfLmxlbmd0aCAtIHBhdGgucGllY2VOdW1fO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhQb3BGcm9udChwYXRoKSB7XHJcbiAgICBsZXQgcGllY2VOdW0gPSBwYXRoLnBpZWNlTnVtXztcclxuICAgIGlmIChwaWVjZU51bSA8IHBhdGgucGllY2VzXy5sZW5ndGgpIHtcclxuICAgICAgICBwaWVjZU51bSsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBQYXRoKHBhdGgucGllY2VzXywgcGllY2VOdW0pO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhHZXRCYWNrKHBhdGgpIHtcclxuICAgIGlmIChwYXRoLnBpZWNlTnVtXyA8IHBhdGgucGllY2VzXy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gcGF0aC5waWVjZXNfW3BhdGgucGllY2VzXy5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhUb1VybEVuY29kZWRTdHJpbmcocGF0aCkge1xyXG4gICAgbGV0IHBhdGhTdHJpbmcgPSAnJztcclxuICAgIGZvciAobGV0IGkgPSBwYXRoLnBpZWNlTnVtXzsgaSA8IHBhdGgucGllY2VzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChwYXRoLnBpZWNlc19baV0gIT09ICcnKSB7XHJcbiAgICAgICAgICAgIHBhdGhTdHJpbmcgKz0gJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhwYXRoLnBpZWNlc19baV0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aFN0cmluZyB8fCAnLyc7XHJcbn1cclxuLyoqXHJcbiAqIFNoYWxsb3cgY29weSBvZiB0aGUgcGFydHMgb2YgdGhlIHBhdGguXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXRoU2xpY2UocGF0aCwgYmVnaW4gPSAwKSB7XHJcbiAgICByZXR1cm4gcGF0aC5waWVjZXNfLnNsaWNlKHBhdGgucGllY2VOdW1fICsgYmVnaW4pO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhQYXJlbnQocGF0aCkge1xyXG4gICAgaWYgKHBhdGgucGllY2VOdW1fID49IHBhdGgucGllY2VzXy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHBpZWNlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IHBhdGgucGllY2VOdW1fOyBpIDwgcGF0aC5waWVjZXNfLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgIHBpZWNlcy5wdXNoKHBhdGgucGllY2VzX1tpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFBhdGgocGllY2VzLCAwKTtcclxufVxyXG5mdW5jdGlvbiBwYXRoQ2hpbGQocGF0aCwgY2hpbGRQYXRoT2JqKSB7XHJcbiAgICBjb25zdCBwaWVjZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSBwYXRoLnBpZWNlTnVtXzsgaSA8IHBhdGgucGllY2VzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHBpZWNlcy5wdXNoKHBhdGgucGllY2VzX1tpXSk7XHJcbiAgICB9XHJcbiAgICBpZiAoY2hpbGRQYXRoT2JqIGluc3RhbmNlb2YgUGF0aCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBjaGlsZFBhdGhPYmoucGllY2VOdW1fOyBpIDwgY2hpbGRQYXRoT2JqLnBpZWNlc18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcGllY2VzLnB1c2goY2hpbGRQYXRoT2JqLnBpZWNlc19baV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUGllY2VzID0gY2hpbGRQYXRoT2JqLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZFBpZWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRQaWVjZXNbaV0ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcGllY2VzLnB1c2goY2hpbGRQaWVjZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBQYXRoKHBpZWNlcywgMCk7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlcmUgYXJlIG5vIHNlZ21lbnRzIGluIHRoaXMgcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aElzRW1wdHkocGF0aCkge1xyXG4gICAgcmV0dXJuIHBhdGgucGllY2VOdW1fID49IHBhdGgucGllY2VzXy5sZW5ndGg7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFRoZSBwYXRoIGZyb20gb3V0ZXJQYXRoIHRvIGlubmVyUGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gbmV3UmVsYXRpdmVQYXRoKG91dGVyUGF0aCwgaW5uZXJQYXRoKSB7XHJcbiAgICBjb25zdCBvdXRlciA9IHBhdGhHZXRGcm9udChvdXRlclBhdGgpLCBpbm5lciA9IHBhdGhHZXRGcm9udChpbm5lclBhdGgpO1xyXG4gICAgaWYgKG91dGVyID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGlubmVyUGF0aDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG91dGVyID09PSBpbm5lcikge1xyXG4gICAgICAgIHJldHVybiBuZXdSZWxhdGl2ZVBhdGgocGF0aFBvcEZyb250KG91dGVyUGF0aCksIHBhdGhQb3BGcm9udChpbm5lclBhdGgpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSU5URVJOQUwgRVJST1I6IGlubmVyUGF0aCAoJyArXHJcbiAgICAgICAgICAgIGlubmVyUGF0aCArXHJcbiAgICAgICAgICAgICcpIGlzIG5vdCB3aXRoaW4gJyArXHJcbiAgICAgICAgICAgICdvdXRlclBhdGggKCcgK1xyXG4gICAgICAgICAgICBvdXRlclBhdGggK1xyXG4gICAgICAgICAgICAnKScpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyAtMSwgMCwgMSBpZiBsZWZ0IGlzIGxlc3MsIGVxdWFsLCBvciBncmVhdGVyIHRoYW4gdGhlIHJpZ2h0LlxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aENvbXBhcmUobGVmdCwgcmlnaHQpIHtcclxuICAgIGNvbnN0IGxlZnRLZXlzID0gcGF0aFNsaWNlKGxlZnQsIDApO1xyXG4gICAgY29uc3QgcmlnaHRLZXlzID0gcGF0aFNsaWNlKHJpZ2h0LCAwKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEtleXMubGVuZ3RoICYmIGkgPCByaWdodEtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjbXAgPSBuYW1lQ29tcGFyZShsZWZ0S2V5c1tpXSwgcmlnaHRLZXlzW2ldKTtcclxuICAgICAgICBpZiAoY21wICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGxlZnRLZXlzLmxlbmd0aCA9PT0gcmlnaHRLZXlzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlZnRLZXlzLmxlbmd0aCA8IHJpZ2h0S2V5cy5sZW5ndGggPyAtMSA6IDE7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgcGF0aHMgYXJlIHRoZSBzYW1lLlxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aEVxdWFscyhwYXRoLCBvdGhlcikge1xyXG4gICAgaWYgKHBhdGhHZXRMZW5ndGgocGF0aCkgIT09IHBhdGhHZXRMZW5ndGgob3RoZXIpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IHBhdGgucGllY2VOdW1fLCBqID0gb3RoZXIucGllY2VOdW1fOyBpIDw9IHBhdGgucGllY2VzXy5sZW5ndGg7IGkrKywgaisrKSB7XHJcbiAgICAgICAgaWYgKHBhdGgucGllY2VzX1tpXSAhPT0gb3RoZXIucGllY2VzX1tqXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBwYXRoIGlzIGEgcGFyZW50IG9mIChvciB0aGUgc2FtZSBhcykgb3RoZXJcclxuICovXHJcbmZ1bmN0aW9uIHBhdGhDb250YWlucyhwYXRoLCBvdGhlcikge1xyXG4gICAgbGV0IGkgPSBwYXRoLnBpZWNlTnVtXztcclxuICAgIGxldCBqID0gb3RoZXIucGllY2VOdW1fO1xyXG4gICAgaWYgKHBhdGhHZXRMZW5ndGgocGF0aCkgPiBwYXRoR2V0TGVuZ3RoKG90aGVyKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHdoaWxlIChpIDwgcGF0aC5waWVjZXNfLmxlbmd0aCkge1xyXG4gICAgICAgIGlmIChwYXRoLnBpZWNlc19baV0gIT09IG90aGVyLnBpZWNlc19bal0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICArK2k7XHJcbiAgICAgICAgKytqO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIER5bmFtaWMgKG11dGFibGUpIHBhdGggdXNlZCB0byBjb3VudCBwYXRoIGxlbmd0aHMuXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3MgaXMgdXNlZCB0byBlZmZpY2llbnRseSBjaGVjayBwYXRocyBmb3IgdmFsaWRcclxuICogbGVuZ3RoIChpbiBVVEY4IGJ5dGVzKSBhbmQgZGVwdGggKHVzZWQgaW4gcGF0aCB2YWxpZGF0aW9uKS5cclxuICpcclxuICogVGhyb3dzIEVycm9yIGV4Y2VwdGlvbiBpZiBwYXRoIGlzIGV2ZXIgaW52YWxpZC5cclxuICpcclxuICogVGhlIGRlZmluaXRpb24gb2YgYSBwYXRoIGFsd2F5cyBiZWdpbnMgd2l0aCAnLycuXHJcbiAqL1xyXG5jbGFzcyBWYWxpZGF0aW9uUGF0aCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gSW5pdGlhbCBQYXRoLlxyXG4gICAgICogQHBhcmFtIGVycm9yUHJlZml4XyAtIFByZWZpeCBmb3IgYW55IGVycm9yIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoLCBlcnJvclByZWZpeF8pIHtcclxuICAgICAgICB0aGlzLmVycm9yUHJlZml4XyA9IGVycm9yUHJlZml4XztcclxuICAgICAgICB0aGlzLnBhcnRzXyA9IHBhdGhTbGljZShwYXRoLCAwKTtcclxuICAgICAgICAvKiogSW5pdGlhbGl6ZSB0byBudW1iZXIgb2YgJy8nIGNoYXJzIG5lZWRlZCBpbiBwYXRoLiAqL1xyXG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aF8gPSBNYXRoLm1heCgxLCB0aGlzLnBhcnRzXy5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJ0c18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoXyArPSBzdHJpbmdMZW5ndGgodGhpcy5wYXJ0c19baV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWxpZGF0aW9uUGF0aENoZWNrVmFsaWQodGhpcyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGlvblBhdGhQdXNoKHZhbGlkYXRpb25QYXRoLCBjaGlsZCkge1xyXG4gICAgLy8gQ291bnQgdGhlIG5lZWRlZCAnLydcclxuICAgIGlmICh2YWxpZGF0aW9uUGF0aC5wYXJ0c18ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHZhbGlkYXRpb25QYXRoLmJ5dGVMZW5ndGhfICs9IDE7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0aW9uUGF0aC5wYXJ0c18ucHVzaChjaGlsZCk7XHJcbiAgICB2YWxpZGF0aW9uUGF0aC5ieXRlTGVuZ3RoXyArPSBzdHJpbmdMZW5ndGgoY2hpbGQpO1xyXG4gICAgdmFsaWRhdGlvblBhdGhDaGVja1ZhbGlkKHZhbGlkYXRpb25QYXRoKTtcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0aW9uUGF0aFBvcCh2YWxpZGF0aW9uUGF0aCkge1xyXG4gICAgY29uc3QgbGFzdCA9IHZhbGlkYXRpb25QYXRoLnBhcnRzXy5wb3AoKTtcclxuICAgIHZhbGlkYXRpb25QYXRoLmJ5dGVMZW5ndGhfIC09IHN0cmluZ0xlbmd0aChsYXN0KTtcclxuICAgIC8vIFVuLWNvdW50IHRoZSBwcmV2aW91cyAnLydcclxuICAgIGlmICh2YWxpZGF0aW9uUGF0aC5wYXJ0c18ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHZhbGlkYXRpb25QYXRoLmJ5dGVMZW5ndGhfIC09IDE7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGlvblBhdGhDaGVja1ZhbGlkKHZhbGlkYXRpb25QYXRoKSB7XHJcbiAgICBpZiAodmFsaWRhdGlvblBhdGguYnl0ZUxlbmd0aF8gPiBNQVhfUEFUSF9MRU5HVEhfQllURVMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodmFsaWRhdGlvblBhdGguZXJyb3JQcmVmaXhfICtcclxuICAgICAgICAgICAgJ2hhcyBhIGtleSBwYXRoIGxvbmdlciB0aGFuICcgK1xyXG4gICAgICAgICAgICBNQVhfUEFUSF9MRU5HVEhfQllURVMgK1xyXG4gICAgICAgICAgICAnIGJ5dGVzICgnICtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGguYnl0ZUxlbmd0aF8gK1xyXG4gICAgICAgICAgICAnKS4nKTtcclxuICAgIH1cclxuICAgIGlmICh2YWxpZGF0aW9uUGF0aC5wYXJ0c18ubGVuZ3RoID4gTUFYX1BBVEhfREVQVEgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodmFsaWRhdGlvblBhdGguZXJyb3JQcmVmaXhfICtcclxuICAgICAgICAgICAgJ3BhdGggc3BlY2lmaWVkIGV4Y2VlZHMgdGhlIG1heGltdW0gZGVwdGggdGhhdCBjYW4gYmUgd3JpdHRlbiAoJyArXHJcbiAgICAgICAgICAgIE1BWF9QQVRIX0RFUFRIICtcclxuICAgICAgICAgICAgJykgb3Igb2JqZWN0IGNvbnRhaW5zIGEgY3ljbGUgJyArXHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25QYXRoVG9FcnJvclN0cmluZyh2YWxpZGF0aW9uUGF0aCkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTdHJpbmcgZm9yIHVzZSBpbiBlcnJvciBtZXNzYWdlcyAtIHVzZXMgJy4nIG5vdGF0aW9uIGZvciBwYXRoLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHZhbGlkYXRpb25QYXRoKSB7XHJcbiAgICBpZiAodmFsaWRhdGlvblBhdGgucGFydHNfLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIHJldHVybiBcImluIHByb3BlcnR5ICdcIiArIHZhbGlkYXRpb25QYXRoLnBhcnRzXy5qb2luKCcuJykgKyBcIidcIjtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBWaXNpYmlsaXR5TW9uaXRvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihbJ3Zpc2libGUnXSk7XHJcbiAgICAgICAgbGV0IGhpZGRlbjtcclxuICAgICAgICBsZXQgdmlzaWJpbGl0eUNoYW5nZTtcclxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudFsnaGlkZGVuJ10gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPcGVyYSAxMi4xMCBhbmQgRmlyZWZveCAxOCBhbmQgbGF0ZXIgc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICd2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICdoaWRkZW4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudFsnbW96SGlkZGVuJ10gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ21venZpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ21vekhpZGRlbic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Wydtc0hpZGRlbiddICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICdtc3Zpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ21zSGlkZGVuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnRbJ3dlYmtpdEhpZGRlbiddICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICd3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICd3ZWJraXRIaWRkZW4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEluaXRpYWxseSwgd2UgYWx3YXlzIGFzc3VtZSB3ZSBhcmUgdmlzaWJsZS4gVGhpcyBlbnN1cmVzIHRoYXQgaW4gYnJvd3NlcnNcclxuICAgICAgICAvLyB3aXRob3V0IHBhZ2UgdmlzaWJpbGl0eSBzdXBwb3J0IG9yIGluIGNhc2VzIHdoZXJlIHdlIGFyZSBuZXZlciB2aXNpYmxlXHJcbiAgICAgICAgLy8gKGUuZy4gY2hyb21lIGV4dGVuc2lvbiksIHdlIGFjdCBhcyBpZiB3ZSBhcmUgdmlzaWJsZSwgaS5lLiBkb24ndCBkZWxheVxyXG4gICAgICAgIC8vIHJlY29ubmVjdHNcclxuICAgICAgICB0aGlzLnZpc2libGVfID0gdHJ1ZTtcclxuICAgICAgICBpZiAodmlzaWJpbGl0eUNoYW5nZSkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHZpc2liaWxpdHlDaGFuZ2UsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpc2libGUgPSAhZG9jdW1lbnRbaGlkZGVuXTtcclxuICAgICAgICAgICAgICAgIGlmICh2aXNpYmxlICE9PSB0aGlzLnZpc2libGVfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlXyA9IHZpc2libGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd2aXNpYmxlJywgdmlzaWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWaXNpYmlsaXR5TW9uaXRvcigpO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5pdGlhbEV2ZW50KGV2ZW50VHlwZSkge1xyXG4gICAgICAgIGFzc2VydChldmVudFR5cGUgPT09ICd2aXNpYmxlJywgJ1Vua25vd24gZXZlbnQgdHlwZTogJyArIGV2ZW50VHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLnZpc2libGVfXTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBSRUNPTk5FQ1RfTUlOX0RFTEFZID0gMTAwMDtcclxuY29uc3QgUkVDT05ORUNUX01BWF9ERUxBWV9ERUZBVUxUID0gNjAgKiA1ICogMTAwMDsgLy8gNSBtaW51dGVzIGluIG1pbGxpc2Vjb25kcyAoQ2FzZTogMTg1OClcclxuY29uc3QgUkVDT05ORUNUX01BWF9ERUxBWV9GT1JfQURNSU5TID0gMzAgKiAxMDAwOyAvLyAzMCBzZWNvbmRzIGZvciBhZG1pbiBjbGllbnRzIChsaWtlbHkgdG8gYmUgYSBiYWNrZW5kIHNlcnZlcilcclxuY29uc3QgUkVDT05ORUNUX0RFTEFZX01VTFRJUExJRVIgPSAxLjM7XHJcbmNvbnN0IFJFQ09OTkVDVF9ERUxBWV9SRVNFVF9USU1FT1VUID0gMzAwMDA7IC8vIFJlc2V0IGRlbGF5IGJhY2sgdG8gTUlOX0RFTEFZIGFmdGVyIGJlaW5nIGNvbm5lY3RlZCBmb3IgMzBzZWMuXHJcbmNvbnN0IFNFUlZFUl9LSUxMX0lOVEVSUlVQVF9SRUFTT04gPSAnc2VydmVyX2tpbGwnO1xyXG4vLyBJZiBhdXRoIGZhaWxzIHJlcGVhdGVkbHksIHdlJ2xsIGFzc3VtZSBzb21ldGhpbmcgaXMgd3JvbmcgYW5kIGxvZyBhIHdhcm5pbmcgLyBiYWNrIG9mZi5cclxuY29uc3QgSU5WQUxJRF9UT0tFTl9USFJFU0hPTEQgPSAzO1xyXG4vKipcclxuICogRmlyZWJhc2UgY29ubmVjdGlvbi4gIEFic3RyYWN0cyB3aXJlIHByb3RvY29sIGFuZCBoYW5kbGVzIHJlY29ubmVjdGluZy5cclxuICpcclxuICogTk9URTogQWxsIEpTT04gb2JqZWN0cyBzZW50IHRvIHRoZSByZWFsdGltZSBjb25uZWN0aW9uIG11c3QgaGF2ZSBwcm9wZXJ0eSBuYW1lcyBlbmNsb3NlZFxyXG4gKiBpbiBxdW90ZXMgdG8gbWFrZSBzdXJlIHRoZSBjbG9zdXJlIGNvbXBpbGVyIGRvZXMgbm90IG1pbmlmeSB0aGVtLlxyXG4gKi9cclxuY2xhc3MgUGVyc2lzdGVudENvbm5lY3Rpb24gZXh0ZW5kcyBTZXJ2ZXJBY3Rpb25zIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvXyAtIERhdGEgYWJvdXQgdGhlIG5hbWVzcGFjZSB3ZSBhcmUgY29ubmVjdGluZyB0b1xyXG4gICAgICogQHBhcmFtIGFwcGxpY2F0aW9uSWRfIC0gVGhlIEZpcmViYXNlIEFwcCBJRCBmb3IgdGhpcyBwcm9qZWN0XHJcbiAgICAgKiBAcGFyYW0gb25EYXRhVXBkYXRlXyAtIEEgY2FsbGJhY2sgZm9yIG5ldyBkYXRhIGZyb20gdGhlIHNlcnZlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihyZXBvSW5mb18sIGFwcGxpY2F0aW9uSWRfLCBvbkRhdGFVcGRhdGVfLCBvbkNvbm5lY3RTdGF0dXNfLCBvblNlcnZlckluZm9VcGRhdGVfLCBhdXRoVG9rZW5Qcm92aWRlcl8sIGFwcENoZWNrVG9rZW5Qcm92aWRlcl8sIGF1dGhPdmVycmlkZV8pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xyXG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25JZF8gPSBhcHBsaWNhdGlvbklkXztcclxuICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8gPSBvbkRhdGFVcGRhdGVfO1xyXG4gICAgICAgIHRoaXMub25Db25uZWN0U3RhdHVzXyA9IG9uQ29ubmVjdFN0YXR1c187XHJcbiAgICAgICAgdGhpcy5vblNlcnZlckluZm9VcGRhdGVfID0gb25TZXJ2ZXJJbmZvVXBkYXRlXztcclxuICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXyA9IGF1dGhUb2tlblByb3ZpZGVyXztcclxuICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5Qcm92aWRlcl8gPSBhcHBDaGVja1Rva2VuUHJvdmlkZXJfO1xyXG4gICAgICAgIHRoaXMuYXV0aE92ZXJyaWRlXyA9IGF1dGhPdmVycmlkZV87XHJcbiAgICAgICAgLy8gVXNlZCBmb3IgZGlhZ25vc3RpYyBsb2dnaW5nLlxyXG4gICAgICAgIHRoaXMuaWQgPSBQZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0UGVyc2lzdGVudENvbm5lY3Rpb25JZF8rKztcclxuICAgICAgICB0aGlzLmxvZ18gPSBsb2dXcmFwcGVyKCdwOicgKyB0aGlzLmlkICsgJzonKTtcclxuICAgICAgICB0aGlzLmludGVycnVwdFJlYXNvbnNfID0ge307XHJcbiAgICAgICAgdGhpcy5saXN0ZW5zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRzXyA9IFtdO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdHZXRzXyA9IFtdO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8gPSAwO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdHZXRDb3VudF8gPSAwO1xyXG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01JTl9ERUxBWTtcclxuICAgICAgICB0aGlzLm1heFJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NQVhfREVMQVlfREVGQVVMVDtcclxuICAgICAgICB0aGlzLnNlY3VyaXR5RGVidWdDYWxsYmFja18gPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGFzdFNlc3Npb25JZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZpc2libGVfID0gZmFsc2U7XHJcbiAgICAgICAgLy8gQmVmb3JlIHdlIGdldCBjb25uZWN0ZWQsIHdlIGtlZXAgYSBxdWV1ZSBvZiBwZW5kaW5nIG1lc3NhZ2VzIHRvIHNlbmQuXHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0Q0JIYXNoXyA9IHt9O1xyXG4gICAgICAgIHRoaXMucmVxdWVzdE51bWJlcl8gPSAwO1xyXG4gICAgICAgIHRoaXMucmVhbHRpbWVfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlbl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID0gMDtcclxuICAgICAgICB0aGlzLmludmFsaWRBcHBDaGVja1Rva2VuQ291bnRfID0gMDtcclxuICAgICAgICB0aGlzLmZpcnN0Q29ubmVjdGlvbl8gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25BdHRlbXB0VGltZV8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfID0gbnVsbDtcclxuICAgICAgICBpZiAoYXV0aE92ZXJyaWRlXyAmJiAhaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoIG92ZXJyaWRlIHNwZWNpZmllZCBpbiBvcHRpb25zLCBidXQgbm90IHN1cHBvcnRlZCBvbiBub24gTm9kZS5qcyBwbGF0Zm9ybXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgVmlzaWJpbGl0eU1vbml0b3IuZ2V0SW5zdGFuY2UoKS5vbigndmlzaWJsZScsIHRoaXMub25WaXNpYmxlXywgdGhpcyk7XHJcbiAgICAgICAgaWYgKHJlcG9JbmZvXy5ob3N0LmluZGV4T2YoJ2ZibG9jYWwnKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgT25saW5lTW9uaXRvci5nZXRJbnN0YW5jZSgpLm9uKCdvbmxpbmUnLCB0aGlzLm9uT25saW5lXywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZFJlcXVlc3QoYWN0aW9uLCBib2R5LCBvblJlc3BvbnNlKSB7XHJcbiAgICAgICAgY29uc3QgY3VyUmVxTnVtID0gKyt0aGlzLnJlcXVlc3ROdW1iZXJfO1xyXG4gICAgICAgIGNvbnN0IG1zZyA9IHsgcjogY3VyUmVxTnVtLCBhOiBhY3Rpb24sIGI6IGJvZHkgfTtcclxuICAgICAgICB0aGlzLmxvZ18oc3RyaW5naWZ5KG1zZykpO1xyXG4gICAgICAgIGFzc2VydCh0aGlzLmNvbm5lY3RlZF8sIFwic2VuZFJlcXVlc3QgY2FsbCB3aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWQgbm90IGFsbG93ZWQuXCIpO1xyXG4gICAgICAgIHRoaXMucmVhbHRpbWVfLnNlbmRSZXF1ZXN0KG1zZyk7XHJcbiAgICAgICAgaWYgKG9uUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Q0JIYXNoX1tjdXJSZXFOdW1dID0gb25SZXNwb25zZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQocXVlcnkpIHtcclxuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uXygpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgcDogcXVlcnkuX3BhdGgudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgcTogcXVlcnkuX3F1ZXJ5T2JqZWN0XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBvdXRzdGFuZGluZ0dldCA9IHtcclxuICAgICAgICAgICAgYWN0aW9uOiAnZycsXHJcbiAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gbWVzc2FnZVsnZCddO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VbJ3MnXSA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocGF5bG9hZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QocGF5bG9hZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdHZXRzXy5wdXNoKG91dHN0YW5kaW5nR2V0KTtcclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nR2V0Q291bnRfKys7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm91dHN0YW5kaW5nR2V0c18ubGVuZ3RoIC0gMTtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZEdldF8oaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxuICAgIGxpc3RlbihxdWVyeSwgY3VycmVudEhhc2hGbiwgdGFnLCBvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgdGhpcy5pbml0Q29ubmVjdGlvbl8oKTtcclxuICAgICAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICBjb25zdCBwYXRoU3RyaW5nID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmxvZ18oJ0xpc3RlbiBjYWxsZWQgZm9yICcgKyBwYXRoU3RyaW5nICsgJyAnICsgcXVlcnlJZCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbnMuaGFzKHBhdGhTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVucy5zZXQocGF0aFN0cmluZywgbmV3IE1hcCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0KHF1ZXJ5Ll9xdWVyeVBhcmFtcy5pc0RlZmF1bHQoKSB8fCAhcXVlcnkuX3F1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpLCAnbGlzdGVuKCkgY2FsbGVkIGZvciBub24tZGVmYXVsdCBidXQgY29tcGxldGUgcXVlcnknKTtcclxuICAgICAgICBhc3NlcnQoIXRoaXMubGlzdGVucy5nZXQocGF0aFN0cmluZykuaGFzKHF1ZXJ5SWQpLCBgbGlzdGVuKCkgY2FsbGVkIHR3aWNlIGZvciBzYW1lIHBhdGgvcXVlcnlJZC5gKTtcclxuICAgICAgICBjb25zdCBsaXN0ZW5TcGVjID0ge1xyXG4gICAgICAgICAgICBvbkNvbXBsZXRlLFxyXG4gICAgICAgICAgICBoYXNoRm46IGN1cnJlbnRIYXNoRm4sXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICB0YWdcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubGlzdGVucy5nZXQocGF0aFN0cmluZykuc2V0KHF1ZXJ5SWQsIGxpc3RlblNwZWMpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kTGlzdGVuXyhsaXN0ZW5TcGVjKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kR2V0XyhpbmRleCkge1xyXG4gICAgICAgIGNvbnN0IGdldCA9IHRoaXMub3V0c3RhbmRpbmdHZXRzX1tpbmRleF07XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCgnZycsIGdldC5yZXF1ZXN0LCAobWVzc2FnZSkgPT4ge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vdXRzdGFuZGluZ0dldHNfW2luZGV4XTtcclxuICAgICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ0dldENvdW50Xy0tO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRzdGFuZGluZ0dldENvdW50XyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ0dldHNfID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGdldC5vbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICBnZXQub25Db21wbGV0ZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2VuZExpc3Rlbl8obGlzdGVuU3BlYykge1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gbGlzdGVuU3BlYy5xdWVyeTtcclxuICAgICAgICBjb25zdCBwYXRoU3RyaW5nID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICB0aGlzLmxvZ18oJ0xpc3RlbiBvbiAnICsgcGF0aFN0cmluZyArICcgZm9yICcgKyBxdWVyeUlkKTtcclxuICAgICAgICBjb25zdCByZXEgPSB7IC8qcGF0aCovIHA6IHBhdGhTdHJpbmcgfTtcclxuICAgICAgICBjb25zdCBhY3Rpb24gPSAncSc7XHJcbiAgICAgICAgLy8gT25seSBib3RoZXIgdG8gc2VuZCBxdWVyeSBpZiBpdCdzIG5vbi1kZWZhdWx0LlxyXG4gICAgICAgIGlmIChsaXN0ZW5TcGVjLnRhZykge1xyXG4gICAgICAgICAgICByZXFbJ3EnXSA9IHF1ZXJ5Ll9xdWVyeU9iamVjdDtcclxuICAgICAgICAgICAgcmVxWyd0J10gPSBsaXN0ZW5TcGVjLnRhZztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVxWyAvKmhhc2gqLydoJ10gPSBsaXN0ZW5TcGVjLmhhc2hGbigpO1xyXG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoYWN0aW9uLCByZXEsIChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBtZXNzYWdlWyAvKmRhdGEqLydkJ107XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IG1lc3NhZ2VbIC8qc3RhdHVzKi8ncyddO1xyXG4gICAgICAgICAgICAvLyBwcmludCB3YXJuaW5ncyBpbiBhbnkgY2FzZS4uLlxyXG4gICAgICAgICAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi53YXJuT25MaXN0ZW5XYXJuaW5nc18ocGF5bG9hZCwgcXVlcnkpO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TGlzdGVuU3BlYyA9IHRoaXMubGlzdGVucy5nZXQocGF0aFN0cmluZykgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVucy5nZXQocGF0aFN0cmluZykuZ2V0KHF1ZXJ5SWQpO1xyXG4gICAgICAgICAgICAvLyBvbmx5IHRyaWdnZXIgYWN0aW9ucyBpZiB0aGUgbGlzdGVuIGhhc24ndCBiZWVuIHJlbW92ZWQgYW5kIHJlYWRkZWRcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaXN0ZW5TcGVjID09PSBsaXN0ZW5TcGVjKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ2xpc3RlbiByZXNwb25zZScsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gJ29rJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuXyhwYXRoU3RyaW5nLCBxdWVyeUlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5TcGVjLm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5TcGVjLm9uQ29tcGxldGUoc3RhdHVzLCBwYXlsb2FkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHdhcm5Pbkxpc3Rlbldhcm5pbmdzXyhwYXlsb2FkLCBxdWVyeSkge1xyXG4gICAgICAgIGlmIChwYXlsb2FkICYmIHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JyAmJiBjb250YWlucyhwYXlsb2FkLCAndycpKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIGNvbnN0IHdhcm5pbmdzID0gc2FmZUdldChwYXlsb2FkLCAndycpO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh3YXJuaW5ncykgJiYgfndhcm5pbmdzLmluZGV4T2YoJ25vX2luZGV4JykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4U3BlYyA9ICdcIi5pbmRleE9uXCI6IFwiJyArIHF1ZXJ5Ll9xdWVyeVBhcmFtcy5nZXRJbmRleCgpLnRvU3RyaW5nKCkgKyAnXCInO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhQYXRoID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFVzaW5nIGFuIHVuc3BlY2lmaWVkIGluZGV4LiBZb3VyIGRhdGEgd2lsbCBiZSBkb3dubG9hZGVkIGFuZCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgZmlsdGVyZWQgb24gdGhlIGNsaWVudC4gQ29uc2lkZXIgYWRkaW5nICR7aW5kZXhTcGVjfSBhdCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgJHtpbmRleFBhdGh9IHRvIHlvdXIgc2VjdXJpdHkgcnVsZXMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZnJlc2hBdXRoVG9rZW4odG9rZW4pIHtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbl8gPSB0b2tlbjtcclxuICAgICAgICB0aGlzLmxvZ18oJ0F1dGggdG9rZW4gcmVmcmVzaGVkJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0aFRva2VuXykge1xyXG4gICAgICAgICAgICB0aGlzLnRyeUF1dGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vSWYgd2UncmUgY29ubmVjdGVkIHdlIHdhbnQgdG8gbGV0IHRoZSBzZXJ2ZXIga25vdyB0byB1bmF1dGhlbnRpY2F0ZSB1cy4gSWYgd2UncmUgbm90IGNvbm5lY3RlZCwgc2ltcGx5IGRlbGV0ZVxyXG4gICAgICAgICAgICAvL3RoZSBjcmVkZW50aWFsIHNvIHdlIGRvbnQgYmVjb21lIGF1dGhlbnRpY2F0ZWQgbmV4dCB0aW1lIHdlIGNvbm5lY3QuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoJ3VuYXV0aCcsIHt9LCAoKSA9PiB7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVkdWNlUmVjb25uZWN0RGVsYXlJZkFkbWluQ3JlZGVudGlhbF8odG9rZW4pO1xyXG4gICAgfVxyXG4gICAgcmVkdWNlUmVjb25uZWN0RGVsYXlJZkFkbWluQ3JlZGVudGlhbF8oY3JlZGVudGlhbCkge1xyXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXNuJ3QgaW50ZW5kZWQgdG8gYmUgYnVsbGV0cHJvb2YgKGEgbWFsaWNpb3VzIGRldmVsb3BlciBjYW4gYWx3YXlzIGp1c3QgbW9kaWZ5IHRoZSBjbGllbnQpLlxyXG4gICAgICAgIC8vIEFkZGl0aW9uYWxseSwgd2UgZG9uJ3QgYm90aGVyIHJlc2V0dGluZyB0aGUgbWF4IGRlbGF5IGJhY2sgdG8gdGhlIGRlZmF1bHQgaWYgYXV0aCBmYWlscyAvIGV4cGlyZXMuXHJcbiAgICAgICAgY29uc3QgaXNGaXJlYmFzZVNlY3JldCA9IGNyZWRlbnRpYWwgJiYgY3JlZGVudGlhbC5sZW5ndGggPT09IDQwO1xyXG4gICAgICAgIGlmIChpc0ZpcmViYXNlU2VjcmV0IHx8IGlzQWRtaW4oY3JlZGVudGlhbCkpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdBZG1pbiBhdXRoIGNyZWRlbnRpYWwgZGV0ZWN0ZWQuICBSZWR1Y2luZyBtYXggcmVjb25uZWN0IHRpbWUuJyk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4UmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01BWF9ERUxBWV9GT1JfQURNSU5TO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZnJlc2hBcHBDaGVja1Rva2VuKHRva2VuKSB7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuXyA9IHRva2VuO1xyXG4gICAgICAgIHRoaXMubG9nXygnQXBwIGNoZWNrIHRva2VuIHJlZnJlc2hlZCcpO1xyXG4gICAgICAgIGlmICh0aGlzLmFwcENoZWNrVG9rZW5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJ5QXBwQ2hlY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vSWYgd2UncmUgY29ubmVjdGVkIHdlIHdhbnQgdG8gbGV0IHRoZSBzZXJ2ZXIga25vdyB0byB1bmF1dGhlbnRpY2F0ZSB1cy5cclxuICAgICAgICAgICAgLy9JZiB3ZSdyZSBub3QgY29ubmVjdGVkLCBzaW1wbHkgZGVsZXRlIHRoZSBjcmVkZW50aWFsIHNvIHdlIGRvbnQgYmVjb21lXHJcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0ZWQgbmV4dCB0aW1lIHdlIGNvbm5lY3QuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoJ3VuYXBwZWNrJywge30sICgpID0+IHsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF0dGVtcHRzIHRvIGF1dGhlbnRpY2F0ZSB3aXRoIHRoZSBnaXZlbiBjcmVkZW50aWFscy4gSWYgdGhlIGF1dGhlbnRpY2F0aW9uIGF0dGVtcHQgZmFpbHMsIGl0J3MgdHJpZ2dlcmVkIGxpa2VcclxuICAgICAqIGEgYXV0aCByZXZva2VkICh0aGUgY29ubmVjdGlvbiBpcyBjbG9zZWQpLlxyXG4gICAgICovXHJcbiAgICB0cnlBdXRoKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8gJiYgdGhpcy5hdXRoVG9rZW5fKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5hdXRoVG9rZW5fO1xyXG4gICAgICAgICAgICBjb25zdCBhdXRoTWV0aG9kID0gaXNWYWxpZEZvcm1hdCh0b2tlbikgPyAnYXV0aCcgOiAnZ2F1dGgnO1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0RGF0YSA9IHsgY3JlZDogdG9rZW4gfTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYXV0aE92ZXJyaWRlXyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdERhdGFbJ25vYXV0aCddID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5hdXRoT3ZlcnJpZGVfID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdERhdGFbJ2F1dGh2YXInXSA9IHRoaXMuYXV0aE92ZXJyaWRlXztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGF1dGhNZXRob2QsIHJlcXVlc3REYXRhLCAocmVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSByZXNbIC8qc3RhdHVzKi8ncyddO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlc1sgLypkYXRhKi8nZCddIHx8ICdlcnJvcic7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRoVG9rZW5fID09PSB0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXJzIHJlY29ubmVjdCBhbmQgZm9yY2UgcmVmcmVzaCBmb3IgYXV0aCB0b2tlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQXV0aFJldm9rZWRfKHN0YXR1cywgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF0dGVtcHRzIHRvIGF1dGhlbnRpY2F0ZSB3aXRoIHRoZSBnaXZlbiB0b2tlbi4gSWYgdGhlIGF1dGhlbnRpY2F0aW9uXHJcbiAgICAgKiBhdHRlbXB0IGZhaWxzLCBpdCdzIHRyaWdnZXJlZCBsaWtlIHRoZSB0b2tlbiB3YXMgcmV2b2tlZCAodGhlIGNvbm5lY3Rpb24gaXNcclxuICAgICAqIGNsb3NlZCkuXHJcbiAgICAgKi9cclxuICAgIHRyeUFwcENoZWNrKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8gJiYgdGhpcy5hcHBDaGVja1Rva2VuXykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KCdhcHBjaGVjaycsIHsgJ3Rva2VuJzogdGhpcy5hcHBDaGVja1Rva2VuXyB9LCAocmVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSByZXNbIC8qc3RhdHVzKi8ncyddO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlc1sgLypkYXRhKi8nZCddIHx8ICdlcnJvcic7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkQXBwQ2hlY2tUb2tlbkNvdW50XyA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQXBwQ2hlY2tSZXZva2VkXyhzdGF0dXMsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbmhlcml0RG9jXHJcbiAgICAgKi9cclxuICAgIHVubGlzdGVuKHF1ZXJ5LCB0YWcpIHtcclxuICAgICAgICBjb25zdCBwYXRoU3RyaW5nID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICB0aGlzLmxvZ18oJ1VubGlzdGVuIGNhbGxlZCBmb3IgJyArIHBhdGhTdHJpbmcgKyAnICcgKyBxdWVyeUlkKTtcclxuICAgICAgICBhc3NlcnQocXVlcnkuX3F1ZXJ5UGFyYW1zLmlzRGVmYXVsdCgpIHx8ICFxdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCksICd1bmxpc3RlbigpIGNhbGxlZCBmb3Igbm9uLWRlZmF1bHQgYnV0IGNvbXBsZXRlIHF1ZXJ5Jyk7XHJcbiAgICAgICAgY29uc3QgbGlzdGVuID0gdGhpcy5yZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpO1xyXG4gICAgICAgIGlmIChsaXN0ZW4gJiYgdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFVubGlzdGVuXyhwYXRoU3RyaW5nLCBxdWVyeUlkLCBxdWVyeS5fcXVlcnlPYmplY3QsIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZFVubGlzdGVuXyhwYXRoU3RyaW5nLCBxdWVyeUlkLCBxdWVyeU9iaiwgdGFnKSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdVbmxpc3RlbiBvbiAnICsgcGF0aFN0cmluZyArICcgZm9yICcgKyBxdWVyeUlkKTtcclxuICAgICAgICBjb25zdCByZXEgPSB7IC8qcGF0aCovIHA6IHBhdGhTdHJpbmcgfTtcclxuICAgICAgICBjb25zdCBhY3Rpb24gPSAnbic7XHJcbiAgICAgICAgLy8gT25seSBib3RoZXIgc2VuZGluZyBxdWVyeUlkIGlmIGl0J3Mgbm9uLWRlZmF1bHQuXHJcbiAgICAgICAgaWYgKHRhZykge1xyXG4gICAgICAgICAgICByZXFbJ3EnXSA9IHF1ZXJ5T2JqO1xyXG4gICAgICAgICAgICByZXFbJ3QnXSA9IHRhZztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcSk7XHJcbiAgICB9XHJcbiAgICBvbkRpc2Nvbm5lY3RQdXQocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkge1xyXG4gICAgICAgIHRoaXMuaW5pdENvbm5lY3Rpb25fKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRPbkRpc2Nvbm5lY3RfKCdvJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdFJlcXVlc3RRdWV1ZV8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnbycsXHJcbiAgICAgICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkRpc2Nvbm5lY3RNZXJnZShwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgdGhpcy5pbml0Q29ubmVjdGlvbl8oKTtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uRGlzY29ubmVjdF8oJ29tJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdFJlcXVlc3RRdWV1ZV8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnb20nLFxyXG4gICAgICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgICAgIG9uQ29tcGxldGVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25EaXNjb25uZWN0Q2FuY2VsKHBhdGhTdHJpbmcsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uXygpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kT25EaXNjb25uZWN0Xygnb2MnLCBwYXRoU3RyaW5nLCBudWxsLCBvbkNvbXBsZXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHBhdGhTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdvYycsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kT25EaXNjb25uZWN0XyhhY3Rpb24sIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0geyAvKnBhdGgqLyBwOiBwYXRoU3RyaW5nLCAvKmRhdGEqLyBkOiBkYXRhIH07XHJcbiAgICAgICAgdGhpcy5sb2dfKCdvbkRpc2Nvbm5lY3QgJyArIGFjdGlvbiwgcmVxdWVzdCk7XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcXVlc3QsIChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAob25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZShyZXNwb25zZVsgLypzdGF0dXMqLydzJ10sIHJlc3BvbnNlWyAvKiBkYXRhICovJ2QnXSk7XHJcbiAgICAgICAgICAgICAgICB9LCBNYXRoLmZsb29yKDApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcHV0KHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHtcclxuICAgICAgICB0aGlzLnB1dEludGVybmFsKCdwJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCk7XHJcbiAgICB9XHJcbiAgICBtZXJnZShwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7XHJcbiAgICAgICAgdGhpcy5wdXRJbnRlcm5hbCgnbScsIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpO1xyXG4gICAgfVxyXG4gICAgcHV0SW50ZXJuYWwoYWN0aW9uLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7XHJcbiAgICAgICAgdGhpcy5pbml0Q29ubmVjdGlvbl8oKTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAvKnBhdGgqLyBwOiBwYXRoU3RyaW5nLFxyXG4gICAgICAgICAgICAvKmRhdGEqLyBkOiBkYXRhXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoaGFzaCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RbIC8qaGFzaCovJ2gnXSA9IGhhc2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IE9ubHkga2VlcCB0cmFjayBvZiB0aGUgbW9zdCByZWNlbnQgcHV0IGZvciBhIGdpdmVuIHBhdGg/XHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dHNfLnB1c2goe1xyXG4gICAgICAgICAgICBhY3Rpb24sXHJcbiAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgIG9uQ29tcGxldGVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfKys7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm91dHN0YW5kaW5nUHV0c18ubGVuZ3RoIC0gMTtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFB1dF8oaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdCdWZmZXJpbmcgcHV0OiAnICsgcGF0aFN0cmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZFB1dF8oaW5kZXgpIHtcclxuICAgICAgICBjb25zdCBhY3Rpb24gPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLmFjdGlvbjtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2luZGV4XS5yZXF1ZXN0O1xyXG4gICAgICAgIGNvbnN0IG9uQ29tcGxldGUgPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLm9uQ29tcGxldGU7XHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2luZGV4XS5xdWV1ZWQgPSB0aGlzLmNvbm5lY3RlZF87XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcXVlc3QsIChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXyhhY3Rpb24gKyAnIHJlc3BvbnNlJywgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdO1xyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfLS07XHJcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGFycmF5IG9jY2FzaW9uYWxseS5cclxuICAgICAgICAgICAgaWYgKHRoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8gPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRzXyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKG1lc3NhZ2VbIC8qc3RhdHVzKi8ncyddLCBtZXNzYWdlWyAvKiBkYXRhICovJ2QnXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlcG9ydFN0YXRzKHN0YXRzKSB7XHJcbiAgICAgICAgLy8gSWYgd2UncmUgbm90IGNvbm5lY3RlZCwgd2UganVzdCBkcm9wIHRoZSBzdGF0cy5cclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IC8qY291bnRlcnMqLyBjOiBzdGF0cyB9O1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ3JlcG9ydFN0YXRzJywgcmVxdWVzdCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoLypzdGF0cyovICdzJywgcmVxdWVzdCwgcmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc3VsdFsgLypzdGF0dXMqLydzJ107XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICE9PSAnb2snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JSZWFzb24gPSByZXN1bHRbIC8qIGRhdGEgKi8nZCddO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nXygncmVwb3J0U3RhdHMnLCAnRXJyb3Igc2VuZGluZyBzdGF0czogJyArIGVycm9yUmVhc29uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25EYXRhTWVzc2FnZV8obWVzc2FnZSkge1xyXG4gICAgICAgIGlmICgncicgaW4gbWVzc2FnZSkge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgcmVzcG9uc2VcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdmcm9tIHNlcnZlcjogJyArIHN0cmluZ2lmeShtZXNzYWdlKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcU51bSA9IG1lc3NhZ2VbJ3InXTtcclxuICAgICAgICAgICAgY29uc3Qgb25SZXNwb25zZSA9IHRoaXMucmVxdWVzdENCSGFzaF9bcmVxTnVtXTtcclxuICAgICAgICAgICAgaWYgKG9uUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlcXVlc3RDQkhhc2hfW3JlcU51bV07XHJcbiAgICAgICAgICAgICAgICBvblJlc3BvbnNlKG1lc3NhZ2VbIC8qYm9keSovJ2InXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ2Vycm9yJyBpbiBtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdBIHNlcnZlci1zaWRlIGVycm9yIGhhcyBvY2N1cnJlZDogJyArIG1lc3NhZ2VbJ2Vycm9yJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdhJyBpbiBtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIC8vIGEgYW5kIGIgYXJlIGFjdGlvbiBhbmQgYm9keSwgcmVzcGVjdGl2ZWx5XHJcbiAgICAgICAgICAgIHRoaXMub25EYXRhUHVzaF8obWVzc2FnZVsnYSddLCBtZXNzYWdlWydiJ10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uRGF0YVB1c2hfKGFjdGlvbiwgYm9keSkge1xyXG4gICAgICAgIHRoaXMubG9nXygnaGFuZGxlU2VydmVyTWVzc2FnZScsIGFjdGlvbiwgYm9keSk7XHJcbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ2QnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyhib2R5WyAvKnBhdGgqLydwJ10sIGJvZHlbIC8qZGF0YSovJ2QnXSwgXHJcbiAgICAgICAgICAgIC8qaXNNZXJnZSovIGZhbHNlLCBib2R5Wyd0J10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdtJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8oYm9keVsgLypwYXRoKi8ncCddLCBib2R5WyAvKmRhdGEqLydkJ10sIFxyXG4gICAgICAgICAgICAvKmlzTWVyZ2U9Ki8gdHJ1ZSwgYm9keVsndCddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnYycpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkxpc3RlblJldm9rZWRfKGJvZHlbIC8qcGF0aCovJ3AnXSwgYm9keVsgLypxdWVyeSovJ3EnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ2FjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uQXV0aFJldm9rZWRfKGJvZHlbIC8qc3RhdHVzIGNvZGUqLydzJ10sIGJvZHlbIC8qIGV4cGxhbmF0aW9uICovJ2QnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ2FwYycpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkFwcENoZWNrUmV2b2tlZF8oYm9keVsgLypzdGF0dXMgY29kZSovJ3MnXSwgYm9keVsgLyogZXhwbGFuYXRpb24gKi8nZCddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnc2QnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25TZWN1cml0eURlYnVnUGFja2V0Xyhib2R5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVycm9yKCdVbnJlY29nbml6ZWQgYWN0aW9uIHJlY2VpdmVkIGZyb20gc2VydmVyOiAnICtcclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShhY3Rpb24pICtcclxuICAgICAgICAgICAgICAgICdcXG5BcmUgeW91IHVzaW5nIHRoZSBsYXRlc3QgY2xpZW50PycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uUmVhZHlfKHRpbWVzdGFtcCwgc2Vzc2lvbklkKSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdjb25uZWN0aW9uIHJlYWR5Jyk7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlVGltZXN0YW1wXyh0aW1lc3RhbXApO1xyXG4gICAgICAgIHRoaXMubGFzdFNlc3Npb25JZCA9IHNlc3Npb25JZDtcclxuICAgICAgICBpZiAodGhpcy5maXJzdENvbm5lY3Rpb25fKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZENvbm5lY3RTdGF0c18oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlU3RhdGVfKCk7XHJcbiAgICAgICAgdGhpcy5maXJzdENvbm5lY3Rpb25fID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vbkNvbm5lY3RTdGF0dXNfKHRydWUpO1xyXG4gICAgfVxyXG4gICAgc2NoZWR1bGVDb25uZWN0Xyh0aW1lb3V0KSB7XHJcbiAgICAgICAgYXNzZXJ0KCF0aGlzLnJlYWx0aW1lXywgXCJTY2hlZHVsaW5nIGEgY29ubmVjdCB3aGVuIHdlJ3JlIGFscmVhZHkgY29ubmVjdGVkL2luZz9cIik7XHJcbiAgICAgICAgaWYgKHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXykge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTk9URTogRXZlbiB3aGVuIHRpbWVvdXQgaXMgMCwgaXQncyBpbXBvcnRhbnQgdG8gZG8gYSBzZXRUaW1lb3V0IHRvIHdvcmsgYXJvdW5kIGFuIGluZnVyaWF0aW5nIFwiU2VjdXJpdHkgRXJyb3JcIiBpblxyXG4gICAgICAgIC8vIEZpcmVmb3ggd2hlbiB0cnlpbmcgdG8gd3JpdGUgdG8gb3VyIGxvbmctcG9sbGluZyBpZnJhbWUgaW4gc29tZSBzY2VuYXJpb3MgKGUuZy4gRm9yZ2Ugb3Igb3VyIHVuaXQgdGVzdHMpLlxyXG4gICAgICAgIHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25fKCk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcih0aW1lb3V0KSk7XHJcbiAgICB9XHJcbiAgICBpbml0Q29ubmVjdGlvbl8oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJlYWx0aW1lXyAmJiB0aGlzLmZpcnN0Q29ubmVjdGlvbl8pIHtcclxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUNvbm5lY3RfKDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uVmlzaWJsZV8odmlzaWJsZSkge1xyXG4gICAgICAgIC8vIE5PVEU6IFRhYmJpbmcgYXdheSBhbmQgYmFjayB0byBhIHdpbmRvdyB3aWxsIGRlZmVhdCBvdXIgcmVjb25uZWN0IGJhY2tvZmYsIGJ1dCBJIHRoaW5rIHRoYXQncyBmaW5lLlxyXG4gICAgICAgIGlmICh2aXNpYmxlICYmXHJcbiAgICAgICAgICAgICF0aGlzLnZpc2libGVfICYmXHJcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID09PSB0aGlzLm1heFJlY29ubmVjdERlbGF5Xykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1dpbmRvdyBiZWNhbWUgdmlzaWJsZS4gIFJlZHVjaW5nIGRlbGF5LicpO1xyXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFsdGltZV8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XygwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZpc2libGVfID0gdmlzaWJsZTtcclxuICAgIH1cclxuICAgIG9uT25saW5lXyhvbmxpbmUpIHtcclxuICAgICAgICBpZiAob25saW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnQnJvd3NlciB3ZW50IG9ubGluZS4nKTtcclxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVhbHRpbWVfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8oMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnQnJvd3NlciB3ZW50IG9mZmxpbmUuICBLaWxsaW5nIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWx0aW1lXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZV8uY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uUmVhbHRpbWVEaXNjb25uZWN0XygpIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ2RhdGEgY2xpZW50IGRpc2Nvbm5lY3RlZCcpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmVhbHRpbWVfID0gbnVsbDtcclxuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrbm93IGlmIG91ciBzZW50IHRyYW5zYWN0aW9ucyBzdWNjZWVkZWQgb3Igbm90LCB3ZSBuZWVkIHRvIGNhbmNlbCB0aGVtLlxyXG4gICAgICAgIHRoaXMuY2FuY2VsU2VudFRyYW5zYWN0aW9uc18oKTtcclxuICAgICAgICAvLyBDbGVhciBvdXQgdGhlIHBlbmRpbmcgcmVxdWVzdHMuXHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0Q0JIYXNoXyA9IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLnNob3VsZFJlY29ubmVjdF8oKSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudmlzaWJsZV8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXyhcIldpbmRvdyBpc24ndCB2aXNpYmxlLiAgRGVsYXlpbmcgcmVjb25uZWN0LlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gdGhpcy5tYXhSZWNvbm5lY3REZWxheV87XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uQXR0ZW1wdFRpbWVfID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8pIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGJlZW4gY29ubmVjdGVkIGxvbmcgZW5vdWdoLCByZXNldCByZWNvbm5lY3QgZGVsYXkgdG8gbWluaW11bS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RDb25uZWN0U3VjY2VlZGVkID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXztcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lU2luY2VMYXN0Q29ubmVjdFN1Y2NlZWRlZCA+IFJFQ09OTkVDVF9ERUxBWV9SRVNFVF9USU1FT1VUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RDb25uZWN0QXR0ZW1wdCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5sYXN0Q29ubmVjdGlvbkF0dGVtcHRUaW1lXztcclxuICAgICAgICAgICAgbGV0IHJlY29ubmVjdERlbGF5ID0gTWF0aC5tYXgoMCwgdGhpcy5yZWNvbm5lY3REZWxheV8gLSB0aW1lU2luY2VMYXN0Q29ubmVjdEF0dGVtcHQpO1xyXG4gICAgICAgICAgICByZWNvbm5lY3REZWxheSA9IE1hdGgucmFuZG9tKCkgKiByZWNvbm5lY3REZWxheTtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdUcnlpbmcgdG8gcmVjb25uZWN0IGluICcgKyByZWNvbm5lY3REZWxheSArICdtcycpO1xyXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8ocmVjb25uZWN0RGVsYXkpO1xyXG4gICAgICAgICAgICAvLyBBZGp1c3QgcmVjb25uZWN0IGRlbGF5IGZvciBuZXh0IHRpbWUuXHJcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gTWF0aC5taW4odGhpcy5tYXhSZWNvbm5lY3REZWxheV8sIHRoaXMucmVjb25uZWN0RGVsYXlfICogUkVDT05ORUNUX0RFTEFZX01VTFRJUExJRVIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9uQ29ubmVjdFN0YXR1c18oZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZXN0YWJsaXNoQ29ubmVjdGlvbl8oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkUmVjb25uZWN0XygpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnTWFraW5nIGEgY29ubmVjdGlvbiBhdHRlbXB0Jyk7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25BdHRlbXB0VGltZV8gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8gPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBvbkRhdGFNZXNzYWdlID0gdGhpcy5vbkRhdGFNZXNzYWdlXy5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCBvblJlYWR5ID0gdGhpcy5vblJlYWR5Xy5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCBvbkRpc2Nvbm5lY3QgPSB0aGlzLm9uUmVhbHRpbWVEaXNjb25uZWN0Xy5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCBjb25uSWQgPSB0aGlzLmlkICsgJzonICsgUGVyc2lzdGVudENvbm5lY3Rpb24ubmV4dENvbm5lY3Rpb25JZF8rKztcclxuICAgICAgICAgICAgY29uc3QgbGFzdFNlc3Npb25JZCA9IHRoaXMubGFzdFNlc3Npb25JZDtcclxuICAgICAgICAgICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBjb25uZWN0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgY2xvc2VGbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG9uRGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBzZW5kUmVxdWVzdEZuID0gZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNvbm5lY3Rpb24sIFwic2VuZFJlcXVlc3QgY2FsbCB3aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWQgbm90IGFsbG93ZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5zZW5kUmVxdWVzdChtc2cpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lXyA9IHtcclxuICAgICAgICAgICAgICAgIGNsb3NlOiBjbG9zZUZuLFxyXG4gICAgICAgICAgICAgICAgc2VuZFJlcXVlc3Q6IHNlbmRSZXF1ZXN0Rm5cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgZm9yY2VSZWZyZXNoID0gdGhpcy5mb3JjZVRva2VuUmVmcmVzaF87XHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCBmZXRjaCBhdXRoIGFuZCBhcHAgY2hlY2sgdG9rZW4sIGFuZCBlc3RhYmxpc2ggY29ubmVjdGlvbiBhZnRlclxyXG4gICAgICAgICAgICAgICAgLy8gZmV0Y2hpbmcgdGhlIHRva2VuIHdhcyBzdWNjZXNzZnVsXHJcbiAgICAgICAgICAgICAgICBjb25zdCBbYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlblByb3ZpZGVyXy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2coJ2dldFRva2VuKCkgY29tcGxldGVkLiBDcmVhdGluZyBjb25uZWN0aW9uLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aFRva2VuXyA9IGF1dGhUb2tlbiAmJiBhdXRoVG9rZW4uYWNjZXNzVG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuXyA9IGFwcENoZWNrVG9rZW4gJiYgYXBwQ2hlY2tUb2tlbi50b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24oY29ubklkLCB0aGlzLnJlcG9JbmZvXywgdGhpcy5hcHBsaWNhdGlvbklkXywgdGhpcy5hcHBDaGVja1Rva2VuXywgdGhpcy5hdXRoVG9rZW5fLCBvbkRhdGFNZXNzYWdlLCBvblJlYWR5LCBvbkRpc2Nvbm5lY3QsIFxyXG4gICAgICAgICAgICAgICAgICAgIC8qIG9uS2lsbD0gKi8gcmVhc29uID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihyZWFzb24gKyAnICgnICsgdGhpcy5yZXBvSW5mb18udG9TdHJpbmcoKSArICcpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJydXB0KFNFUlZFUl9LSUxMX0lOVEVSUlVQVF9SRUFTT04pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGxhc3RTZXNzaW9uSWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nKCdnZXRUb2tlbigpIGNvbXBsZXRlZCBidXQgd2FzIGNhbmNlbGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ0ZhaWxlZCB0byBnZXQgdG9rZW46ICcgKyBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVwb0luZm9fLm5vZGVBZG1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1heSBiZSBhIGNyaXRpY2FsIGVycm9yIGZvciB0aGUgQWRtaW4gTm9kZS5qcyBTREssIHNvIGxvZyBhIHdhcm5pbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBnZXRUb2tlbigpIG1heSBhbHNvIGp1c3QgaGF2ZSB0ZW1wb3JhcmlseSBmYWlsZWQsIHNvIHdlIHN0aWxsIHdhbnQgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWUgcmV0cnlpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjbG9zZUZuKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpbnRlcnJ1cHQocmVhc29uKSB7XHJcbiAgICAgICAgbG9nKCdJbnRlcnJ1cHRpbmcgY29ubmVjdGlvbiBmb3IgcmVhc29uOiAnICsgcmVhc29uKTtcclxuICAgICAgICB0aGlzLmludGVycnVwdFJlYXNvbnNfW3JlYXNvbl0gPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWx0aW1lXykge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lXy5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXykge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25SZWFsdGltZURpc2Nvbm5lY3RfKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN1bWUocmVhc29uKSB7XHJcbiAgICAgICAgbG9nKCdSZXN1bWluZyBjb25uZWN0aW9uIGZvciByZWFzb246ICcgKyByZWFzb24pO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmludGVycnVwdFJlYXNvbnNfW3JlYXNvbl07XHJcbiAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5pbnRlcnJ1cHRSZWFzb25zXykpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVhbHRpbWVfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8oMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYW5kbGVUaW1lc3RhbXBfKHRpbWVzdGFtcCkge1xyXG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGltZXN0YW1wIC0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgdGhpcy5vblNlcnZlckluZm9VcGRhdGVfKHsgc2VydmVyVGltZU9mZnNldDogZGVsdGEgfSk7XHJcbiAgICB9XHJcbiAgICBjYW5jZWxTZW50VHJhbnNhY3Rpb25zXygpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3V0c3RhbmRpbmdQdXRzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwdXQgPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baV07XHJcbiAgICAgICAgICAgIGlmIChwdXQgJiYgLypoYXNoKi8gJ2gnIGluIHB1dC5yZXF1ZXN0ICYmIHB1dC5xdWV1ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwdXQub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHB1dC5vbkNvbXBsZXRlKCdkaXNjb25uZWN0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2ldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dENvdW50Xy0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENsZWFuIHVwIGFycmF5IG9jY2FzaW9uYWxseS5cclxuICAgICAgICBpZiAodGhpcy5vdXRzdGFuZGluZ1B1dENvdW50XyA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0c18gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkxpc3RlblJldm9rZWRfKHBhdGhTdHJpbmcsIHF1ZXJ5KSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsaXN0ZW4gYW5kIG1hbnVmYWN0dXJlIGEgXCJwZXJtaXNzaW9uX2RlbmllZFwiIGVycm9yIGZvciB0aGUgZmFpbGVkIGxpc3Rlbi5cclxuICAgICAgICBsZXQgcXVlcnlJZDtcclxuICAgICAgICBpZiAoIXF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5SWQgPSAnZGVmYXVsdCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBxdWVyeUlkID0gcXVlcnkubWFwKHEgPT4gT2JqZWN0VG9VbmlxdWVLZXkocSkpLmpvaW4oJyQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGlzdGVuID0gdGhpcy5yZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpO1xyXG4gICAgICAgIGlmIChsaXN0ZW4gJiYgbGlzdGVuLm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgbGlzdGVuLm9uQ29tcGxldGUoJ3Blcm1pc3Npb25fZGVuaWVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlTGlzdGVuXyhwYXRoU3RyaW5nLCBxdWVyeUlkKSB7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFBhdGhTdHJpbmcgPSBuZXcgUGF0aChwYXRoU3RyaW5nKS50b1N0cmluZygpOyAvLyBub3JtYWxpemUgcGF0aC5cclxuICAgICAgICBsZXQgbGlzdGVuO1xyXG4gICAgICAgIGlmICh0aGlzLmxpc3RlbnMuaGFzKG5vcm1hbGl6ZWRQYXRoU3RyaW5nKSkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXAgPSB0aGlzLmxpc3RlbnMuZ2V0KG5vcm1hbGl6ZWRQYXRoU3RyaW5nKTtcclxuICAgICAgICAgICAgbGlzdGVuID0gbWFwLmdldChxdWVyeUlkKTtcclxuICAgICAgICAgICAgbWFwLmRlbGV0ZShxdWVyeUlkKTtcclxuICAgICAgICAgICAgaWYgKG1hcC5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbnMuZGVsZXRlKG5vcm1hbGl6ZWRQYXRoU3RyaW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gYWxsIGxpc3RlbnMgZm9yIHRoaXMgcGF0aCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWRcclxuICAgICAgICAgICAgbGlzdGVuID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGlzdGVuO1xyXG4gICAgfVxyXG4gICAgb25BdXRoUmV2b2tlZF8oc3RhdHVzQ29kZSwgZXhwbGFuYXRpb24pIHtcclxuICAgICAgICBsb2coJ0F1dGggdG9rZW4gcmV2b2tlZDogJyArIHN0YXR1c0NvZGUgKyAnLycgKyBleHBsYW5hdGlvbik7XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5fID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZvcmNlVG9rZW5SZWZyZXNoXyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5yZWFsdGltZV8uY2xvc2UoKTtcclxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gJ2ludmFsaWRfdG9rZW4nIHx8IHN0YXR1c0NvZGUgPT09ICdwZXJtaXNzaW9uX2RlbmllZCcpIHtcclxuICAgICAgICAgICAgLy8gV2UnbGwgd2FpdCBhIGNvdXBsZSB0aW1lcyBiZWZvcmUgbG9nZ2luZyB0aGUgd2FybmluZyAvIGluY3JlYXNpbmcgdGhlXHJcbiAgICAgICAgICAgIC8vIHJldHJ5IHBlcmlvZCBzaW5jZSBvYXV0aCB0b2tlbnMgd2lsbCByZXBvcnQgYXMgXCJpbnZhbGlkXCIgaWYgdGhleSdyZVxyXG4gICAgICAgICAgICAvLyBqdXN0IGV4cGlyZWQuIFBsdXMgdGhlcmUgbWF5IGJlIHRyYW5zaWVudCBpc3N1ZXMgdGhhdCByZXNvbHZlIHRoZW1zZWx2ZXMuXHJcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZEF1dGhUb2tlbkNvdW50XysrO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID49IElOVkFMSURfVE9LRU5fVEhSRVNIT0xEKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgYSBsb25nIHJlY29ubmVjdCBkZWxheSBiZWNhdXNlIHJlY292ZXJ5IGlzIHVubGlrZWx5XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NQVhfREVMQVlfRk9SX0FETUlOUztcclxuICAgICAgICAgICAgICAgIC8vIE5vdGlmeSB0aGUgYXV0aCB0b2tlbiBwcm92aWRlciB0aGF0IHRoZSB0b2tlbiBpcyBpbnZhbGlkLCB3aGljaCB3aWxsIGxvZ1xyXG4gICAgICAgICAgICAgICAgLy8gYSB3YXJuaW5nXHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXy5ub3RpZnlGb3JJbnZhbGlkVG9rZW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uQXBwQ2hlY2tSZXZva2VkXyhzdGF0dXNDb2RlLCBleHBsYW5hdGlvbikge1xyXG4gICAgICAgIGxvZygnQXBwIGNoZWNrIHRva2VuIHJldm9rZWQ6ICcgKyBzdGF0dXNDb2RlICsgJy8nICsgZXhwbGFuYXRpb24pO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlbl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gdHJ1ZTtcclxuICAgICAgICAvLyBOb3RlOiBXZSBkb24ndCBjbG9zZSB0aGUgY29ubmVjdGlvbiBhcyB0aGUgZGV2ZWxvcGVyIG1heSBub3QgaGF2ZVxyXG4gICAgICAgIC8vIGVuZm9yY2VtZW50IGVuYWJsZWQuIFRoZSBiYWNrZW5kIGNsb3NlcyBjb25uZWN0aW9ucyB3aXRoIGVuZm9yY2VtZW50cy5cclxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gJ2ludmFsaWRfdG9rZW4nIHx8IHN0YXR1c0NvZGUgPT09ICdwZXJtaXNzaW9uX2RlbmllZCcpIHtcclxuICAgICAgICAgICAgLy8gV2UnbGwgd2FpdCBhIGNvdXBsZSB0aW1lcyBiZWZvcmUgbG9nZ2luZyB0aGUgd2FybmluZyAvIGluY3JlYXNpbmcgdGhlXHJcbiAgICAgICAgICAgIC8vIHJldHJ5IHBlcmlvZCBzaW5jZSBvYXV0aCB0b2tlbnMgd2lsbCByZXBvcnQgYXMgXCJpbnZhbGlkXCIgaWYgdGhleSdyZVxyXG4gICAgICAgICAgICAvLyBqdXN0IGV4cGlyZWQuIFBsdXMgdGhlcmUgbWF5IGJlIHRyYW5zaWVudCBpc3N1ZXMgdGhhdCByZXNvbHZlIHRoZW1zZWx2ZXMuXHJcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZEFwcENoZWNrVG9rZW5Db3VudF8rKztcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW52YWxpZEFwcENoZWNrVG9rZW5Db3VudF8gPj0gSU5WQUxJRF9UT0tFTl9USFJFU0hPTEQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlblByb3ZpZGVyXy5ub3RpZnlGb3JJbnZhbGlkVG9rZW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uU2VjdXJpdHlEZWJ1Z1BhY2tldF8oYm9keSkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlY3VyaXR5RGVidWdDYWxsYmFja18pIHtcclxuICAgICAgICAgICAgdGhpcy5zZWN1cml0eURlYnVnQ2FsbGJhY2tfKGJvZHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCdtc2cnIGluIGJvZHkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGSVJFQkFTRTogJyArIGJvZHlbJ21zZyddLnJlcGxhY2UoJ1xcbicsICdcXG5GSVJFQkFTRTogJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzdG9yZVN0YXRlXygpIHtcclxuICAgICAgICAvL1JlLWF1dGhlbnRpY2F0ZSBvdXJzZWx2ZXMgaWYgd2UgaGF2ZSBhIGNyZWRlbnRpYWwgc3RvcmVkLlxyXG4gICAgICAgIHRoaXMudHJ5QXV0aCgpO1xyXG4gICAgICAgIHRoaXMudHJ5QXBwQ2hlY2soKTtcclxuICAgICAgICAvLyBQdXRzIGRlcGVuZCBvbiBoYXZpbmcgcmVjZWl2ZWQgdGhlIGNvcnJlc3BvbmRpbmcgZGF0YSB1cGRhdGUgZnJvbSB0aGUgc2VydmVyIGJlZm9yZSB0aGV5IGNvbXBsZXRlLCBzbyB3ZSBtdXN0XHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHNlbmQgbGlzdGVucyBiZWZvcmUgcHV0cy5cclxuICAgICAgICBmb3IgKGNvbnN0IHF1ZXJpZXMgb2YgdGhpcy5saXN0ZW5zLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuU3BlYyBvZiBxdWVyaWVzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRMaXN0ZW5fKGxpc3RlblNwZWMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRzdGFuZGluZ1B1dHNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHN0YW5kaW5nUHV0c19baV0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFB1dF8oaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRPbkRpc2Nvbm5lY3RfKHJlcXVlc3QuYWN0aW9uLCByZXF1ZXN0LnBhdGhTdHJpbmcsIHJlcXVlc3QuZGF0YSwgcmVxdWVzdC5vbkNvbXBsZXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm91dHN0YW5kaW5nR2V0c18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3V0c3RhbmRpbmdHZXRzX1tpXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kR2V0XyhpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZHMgY2xpZW50IHN0YXRzIGZvciBmaXJzdCBjb25uZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHNlbmRDb25uZWN0U3RhdHNfKCkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRzID0ge307XHJcbiAgICAgICAgbGV0IGNsaWVudE5hbWUgPSAnanMnO1xyXG4gICAgICAgIGlmIChpc05vZGVTZGsoKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZXBvSW5mb18ubm9kZUFkbWluKSB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnROYW1lID0gJ2FkbWluX25vZGUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2xpZW50TmFtZSA9ICdub2RlJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0c1snc2RrLicgKyBjbGllbnROYW1lICsgJy4nICsgU0RLX1ZFUlNJT04ucmVwbGFjZSgvXFwuL2csICctJyldID0gMTtcclxuICAgICAgICBpZiAoaXNNb2JpbGVDb3Jkb3ZhKCkpIHtcclxuICAgICAgICAgICAgc3RhdHNbJ2ZyYW1ld29yay5jb3Jkb3ZhJ10gPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcclxuICAgICAgICAgICAgc3RhdHNbJ2ZyYW1ld29yay5yZWFjdG5hdGl2ZSddID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXBvcnRTdGF0cyhzdGF0cyk7XHJcbiAgICB9XHJcbiAgICBzaG91bGRSZWNvbm5lY3RfKCkge1xyXG4gICAgICAgIGNvbnN0IG9ubGluZSA9IE9ubGluZU1vbml0b3IuZ2V0SW5zdGFuY2UoKS5jdXJyZW50bHlPbmxpbmUoKTtcclxuICAgICAgICByZXR1cm4gaXNFbXB0eSh0aGlzLmludGVycnVwdFJlYXNvbnNfKSAmJiBvbmxpbmU7XHJcbiAgICB9XHJcbn1cclxuUGVyc2lzdGVudENvbm5lY3Rpb24ubmV4dFBlcnNpc3RlbnRDb25uZWN0aW9uSWRfID0gMDtcclxuLyoqXHJcbiAqIENvdW50ZXIgZm9yIG51bWJlciBvZiBjb25uZWN0aW9ucyBjcmVhdGVkLiBNYWlubHkgdXNlZCBmb3IgdGFnZ2luZyBpbiB0aGUgbG9nc1xyXG4gKi9cclxuUGVyc2lzdGVudENvbm5lY3Rpb24ubmV4dENvbm5lY3Rpb25JZF8gPSAwO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBOYW1lZE5vZGUge1xyXG4gICAgY29uc3RydWN0b3IobmFtZSwgbm9kZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBXcmFwKG5hbWUsIG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShuYW1lLCBub2RlKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBJbmRleCB7XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIEEgc3RhbmRhbG9uZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvclxyXG4gICAgICogdGhpcyBpbmRleFxyXG4gICAgICovXHJcbiAgICBnZXRDb21wYXJlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUuYmluZCh0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBiZWZvcmUgYW5kIGFmdGVyIHZhbHVlIGZvciBhIG5vZGUsIGRldGVybWluZSBpZiB0aGUgaW5kZXhlZCB2YWx1ZSBoYXMgY2hhbmdlZC4gRXZlbiBpZiB0aGV5IGFyZSBkaWZmZXJlbnQsXHJcbiAgICAgKiBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGNoYW5nZXMgYXJlIGlzb2xhdGVkIHRvIHBhcnRzIG9mIHRoZSBzbmFwc2hvdCB0aGF0IGFyZSBub3QgaW5kZXhlZC5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgcG9ydGlvbiBvZiB0aGUgc25hcHNob3QgYmVpbmcgaW5kZXhlZCBjaGFuZ2VkIGJldHdlZW4gb2xkTm9kZSBhbmQgbmV3Tm9kZVxyXG4gICAgICovXHJcbiAgICBpbmRleGVkVmFsdWVDaGFuZ2VkKG9sZE5vZGUsIG5ld05vZGUpIHtcclxuICAgICAgICBjb25zdCBvbGRXcmFwcGVkID0gbmV3IE5hbWVkTm9kZShNSU5fTkFNRSwgb2xkTm9kZSk7XHJcbiAgICAgICAgY29uc3QgbmV3V3JhcHBlZCA9IG5ldyBOYW1lZE5vZGUoTUlOX05BTUUsIG5ld05vZGUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUob2xkV3JhcHBlZCwgbmV3V3JhcHBlZCkgIT09IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIGEgbm9kZSB3cmFwcGVyIHRoYXQgd2lsbCBzb3J0IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAgICogYW55IG90aGVyIG5vZGUgd3JhcHBlciwgdXNpbmcgdGhpcyBpbmRleFxyXG4gICAgICovXHJcbiAgICBtaW5Qb3N0KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NSU47XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IF9fRU1QVFlfTk9ERTtcclxuY2xhc3MgS2V5SW5kZXggZXh0ZW5kcyBJbmRleCB7XHJcbiAgICBzdGF0aWMgZ2V0IF9fRU1QVFlfTk9ERSgpIHtcclxuICAgICAgICByZXR1cm4gX19FTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHNldCBfX0VNUFRZX05PREUodmFsKSB7XHJcbiAgICAgICAgX19FTVBUWV9OT0RFID0gdmFsO1xyXG4gICAgfVxyXG4gICAgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIG5hbWVDb21wYXJlKGEubmFtZSwgYi5uYW1lKTtcclxuICAgIH1cclxuICAgIGlzRGVmaW5lZE9uKG5vZGUpIHtcclxuICAgICAgICAvLyBXZSBjb3VsZCBwcm9iYWJseSByZXR1cm4gdHJ1ZSBoZXJlIChzaW5jZSBldmVyeSBub2RlIGhhcyBhIGtleSksIGJ1dCBpdCdzIG5ldmVyIGNhbGxlZFxyXG4gICAgICAgIC8vIHNvIGp1c3QgbGVhdmluZyB1bmltcGxlbWVudGVkIGZvciBub3cuXHJcbiAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IoJ0tleUluZGV4LmlzRGVmaW5lZE9uIG5vdCBleHBlY3RlZCB0byBiZSBjYWxsZWQuJyk7XHJcbiAgICB9XHJcbiAgICBpbmRleGVkVmFsdWVDaGFuZ2VkKG9sZE5vZGUsIG5ld05vZGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFRoZSBrZXkgZm9yIGEgbm9kZSBuZXZlciBjaGFuZ2VzLlxyXG4gICAgfVxyXG4gICAgbWluUG9zdCgpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIHJldHVybiBOYW1lZE5vZGUuTUlOO1xyXG4gICAgfVxyXG4gICAgbWF4UG9zdCgpIHtcclxuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCByZWFsbHkgYmUgY3JlYXRlZCBvbmNlIGFuZCBjYWNoZWQgaW4gYSBzdGF0aWMgcHJvcGVydHksIGJ1dFxyXG4gICAgICAgIC8vIE5hbWVkTm9kZSBpc24ndCBkZWZpbmVkIHlldCwgc28gSSBjYW4ndCB1c2UgaXQgaW4gYSBzdGF0aWMuICBCbGVoLlxyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKE1BWF9OQU1FLCBfX0VNUFRZX05PREUpO1xyXG4gICAgfVxyXG4gICAgbWFrZVBvc3QoaW5kZXhWYWx1ZSwgbmFtZSkge1xyXG4gICAgICAgIGFzc2VydCh0eXBlb2YgaW5kZXhWYWx1ZSA9PT0gJ3N0cmluZycsICdLZXlJbmRleCBpbmRleFZhbHVlIG11c3QgYWx3YXlzIGJlIGEgc3RyaW5nLicpO1xyXG4gICAgICAgIC8vIFdlIGp1c3QgdXNlIGVtcHR5IG5vZGUsIGJ1dCBpdCdsbCBuZXZlciBiZSBjb21wYXJlZCwgc2luY2Ugb3VyIGNvbXBhcmF0b3Igb25seSBsb29rcyBhdCBuYW1lLlxyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKGluZGV4VmFsdWUsIF9fRU1QVFlfTk9ERSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgaW5jbHVzaW9uIGluIGEgcXVlcnkgc3BlY1xyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gJy5rZXknO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IEtFWV9JTkRFWCA9IG5ldyBLZXlJbmRleCgpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaXRlcmF0b3Igb3ZlciBhbiBMTFJCTm9kZS5cclxuICovXHJcbmNsYXNzIFNvcnRlZE1hcEl0ZXJhdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG5vZGUgLSBOb2RlIHRvIGl0ZXJhdGUuXHJcbiAgICAgKiBAcGFyYW0gaXNSZXZlcnNlXyAtIFdoZXRoZXIgb3Igbm90IHRvIGl0ZXJhdGUgaW4gcmV2ZXJzZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBzdGFydEtleSwgY29tcGFyYXRvciwgaXNSZXZlcnNlXywgcmVzdWx0R2VuZXJhdG9yXyA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLmlzUmV2ZXJzZV8gPSBpc1JldmVyc2VfO1xyXG4gICAgICAgIHRoaXMucmVzdWx0R2VuZXJhdG9yXyA9IHJlc3VsdEdlbmVyYXRvcl87XHJcbiAgICAgICAgdGhpcy5ub2RlU3RhY2tfID0gW107XHJcbiAgICAgICAgbGV0IGNtcCA9IDE7XHJcbiAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZTtcclxuICAgICAgICAgICAgY21wID0gc3RhcnRLZXkgPyBjb21wYXJhdG9yKG5vZGUua2V5LCBzdGFydEtleSkgOiAxO1xyXG4gICAgICAgICAgICAvLyBmbGlwIHRoZSBjb21wYXJpc29uIGlmIHdlJ3JlIGdvaW5nIGluIHJldmVyc2VcclxuICAgICAgICAgICAgaWYgKGlzUmV2ZXJzZV8pIHtcclxuICAgICAgICAgICAgICAgIGNtcCAqPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGxlc3MgdGhhbiBvdXIgc3RhcnQga2V5LiBpZ25vcmUgaXRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG5vZGUgaXMgZXhhY3RseSBlcXVhbCB0byBvdXIgc3RhcnQga2V5LiBQdXNoIGl0IG9uIHRoZSBzdGFjaywgYnV0IHN0b3AgaXRlcmF0aW5nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2tfLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBncmVhdGVyIHRoYW4gb3VyIHN0YXJ0IGtleSwgYWRkIGl0IHRvIHRoZSBzdGFjayBhbmQgbW92ZSB0byB0aGUgbmV4dCBvbmVcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrXy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXZlcnNlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldE5leHQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubm9kZVN0YWNrXy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlU3RhY2tfLnBvcCgpO1xyXG4gICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0R2VuZXJhdG9yXykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdEdlbmVyYXRvcl8obm9kZS5rZXksIG5vZGUudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0geyBrZXk6IG5vZGUua2V5LCB2YWx1ZTogbm9kZS52YWx1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc1JldmVyc2VfKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrXy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFja18ucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGhhc05leHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZVN0YWNrXy5sZW5ndGggPiAwO1xyXG4gICAgfVxyXG4gICAgcGVlaygpIHtcclxuICAgICAgICBpZiAodGhpcy5ub2RlU3RhY2tfLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZVN0YWNrX1t0aGlzLm5vZGVTdGFja18ubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0R2VuZXJhdG9yXykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRHZW5lcmF0b3JfKG5vZGUua2V5LCBub2RlLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGtleTogbm9kZS5rZXksIHZhbHVlOiBub2RlLnZhbHVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgbm9kZSBpbiBhIExlZnQtbGVhbmluZyBSZWQtQmxhY2sgdHJlZS5cclxuICovXHJcbmNsYXNzIExMUkJOb2RlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZS5cclxuICAgICAqIEBwYXJhbSBjb2xvciAtIFdoZXRoZXIgdGhpcyBub2RlIGlzIHJlZC5cclxuICAgICAqIEBwYXJhbSBsZWZ0IC0gTGVmdCBjaGlsZC5cclxuICAgICAqIEBwYXJhbSByaWdodCAtIFJpZ2h0IGNoaWxkLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yICE9IG51bGwgPyBjb2xvciA6IExMUkJOb2RlLlJFRDtcclxuICAgICAgICB0aGlzLmxlZnQgPVxyXG4gICAgICAgICAgICBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogU29ydGVkTWFwLkVNUFRZX05PREU7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9XHJcbiAgICAgICAgICAgIHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IFNvcnRlZE1hcC5FTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBub2RlLCBvcHRpb25hbGx5IHJlcGxhY2luZyBwaWVjZXMgb2YgaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIE5ldyBrZXkgZm9yIHRoZSBub2RlLCBvciBudWxsLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gTmV3IHZhbHVlIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cclxuICAgICAqIEBwYXJhbSBjb2xvciAtIE5ldyBjb2xvciBmb3IgdGhlIG5vZGUsIG9yIG51bGwuXHJcbiAgICAgKiBAcGFyYW0gbGVmdCAtIE5ldyBsZWZ0IGNoaWxkIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cclxuICAgICAqIEBwYXJhbSByaWdodCAtIE5ldyByaWdodCBjaGlsZCBmb3IgdGhlIG5vZGUsIG9yIG51bGwuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbm9kZSBjb3B5LlxyXG4gICAgICovXHJcbiAgICBjb3B5KGtleSwgdmFsdWUsIGNvbG9yLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5ICE9IG51bGwgPyBrZXkgOiB0aGlzLmtleSwgdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogdGhpcy52YWx1ZSwgY29sb3IgIT0gbnVsbCA/IGNvbG9yIDogdGhpcy5jb2xvciwgbGVmdCAhPSBudWxsID8gbGVmdCA6IHRoaXMubGVmdCwgcmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogdGhpcy5yaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSB0b3RhbCBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIHRyZWUuXHJcbiAgICAgKi9cclxuICAgIGNvdW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuY291bnQoKSArIDEgKyB0aGlzLnJpZ2h0LmNvdW50KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHRyZWUgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4ga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxyXG4gICAgICogZm9yIGVhY2ggbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoXHJcbiAgICAgKiAgIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVGhlIGZpcnN0IHRydXRoeSB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24sIG9yIHRoZSBsYXN0IGZhbHNleVxyXG4gICAgICogICB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb25cclxuICAgICAqL1xyXG4gICAgaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMubGVmdC5pbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikgfHxcclxuICAgICAgICAgICAgISFhY3Rpb24odGhpcy5rZXksIHRoaXMudmFsdWUpIHx8XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHQuaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIHRoZSB0cmVlIGluIHJldmVyc2Uga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxyXG4gICAgICogZm9yIGVhY2ggbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoXHJcbiAgICAgKiBub2RlLiAgSWYgaXQgcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdHJhdmVyc2FsIHdhcyBhYm9ydGVkLlxyXG4gICAgICovXHJcbiAgICByZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5yaWdodC5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikgfHxcclxuICAgICAgICAgICAgYWN0aW9uKHRoaXMua2V5LCB0aGlzLnZhbHVlKSB8fFxyXG4gICAgICAgICAgICB0aGlzLmxlZnQucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1pbmltdW0gbm9kZSBpbiB0aGUgdHJlZS5cclxuICAgICAqL1xyXG4gICAgbWluXygpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQubWluXygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1heGltdW0ga2V5IGluIHRoZSB0cmVlLlxyXG4gICAgICovXHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWluXygpLmtleTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1heGltdW0ga2V5IGluIHRoZSB0cmVlLlxyXG4gICAgICovXHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0Lm1heEtleSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSB0byBpbnNlcnQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBpbnNlcnQuXHJcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvciAtIENvbXBhcmF0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgd2l0aCB0aGUga2V5L3ZhbHVlIGFkZGVkLlxyXG4gICAgICovXHJcbiAgICBpbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIGxldCBuID0gdGhpcztcclxuICAgICAgICBjb25zdCBjbXAgPSBjb21wYXJhdG9yKGtleSwgbi5rZXkpO1xyXG4gICAgICAgIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0Lmluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIHZhbHVlLCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5pbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbi5maXhVcF8oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIHdpdGggdGhlIG1pbmltdW0ga2V5IHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZU1pbl8oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNvcnRlZE1hcC5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbiA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFuLmxlZnQuaXNSZWRfKCkgJiYgIW4ubGVmdC5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLm1vdmVSZWRMZWZ0XygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmVNaW5fKCksIG51bGwpO1xyXG4gICAgICAgIHJldHVybiBuLmZpeFVwXygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgaXRlbSB0byByZW1vdmUuXHJcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvciAtIENvbXBhcmF0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGl0ZW0gcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKGtleSwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIGxldCBuLCBzbWFsbGVzdDtcclxuICAgICAgICBuID0gdGhpcztcclxuICAgICAgICBpZiAoY29tcGFyYXRvcihrZXksIG4ua2V5KSA8IDApIHtcclxuICAgICAgICAgICAgaWYgKCFuLmxlZnQuaXNFbXB0eSgpICYmICFuLmxlZnQuaXNSZWRfKCkgJiYgIW4ubGVmdC5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgICAgICBuID0gbi5tb3ZlUmVkTGVmdF8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmUoa2V5LCBjb21wYXJhdG9yKSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobi5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodF8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW4ucmlnaHQuaXNFbXB0eSgpICYmICFuLnJpZ2h0LmlzUmVkXygpICYmICFuLnJpZ2h0LmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgICAgIG4gPSBuLm1vdmVSZWRSaWdodF8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvcihrZXksIG4ua2V5KSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG4ucmlnaHQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNvcnRlZE1hcC5FTVBUWV9OT0RFO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc21hbGxlc3QgPSBuLnJpZ2h0Lm1pbl8oKTtcclxuICAgICAgICAgICAgICAgICAgICBuID0gbi5jb3B5KHNtYWxsZXN0LmtleSwgc21hbGxlc3QudmFsdWUsIG51bGwsIG51bGwsIG4ucmlnaHQucmVtb3ZlTWluXygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG4ucmlnaHQucmVtb3ZlKGtleSwgY29tcGFyYXRvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbi5maXhVcF8oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGlzIGlzIGEgUkVEIG5vZGUuXHJcbiAgICAgKi9cclxuICAgIGlzUmVkXygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUgYWZ0ZXIgcGVyZm9ybWluZyBhbnkgbmVlZGVkIHJvdGF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgZml4VXBfKCkge1xyXG4gICAgICAgIGxldCBuID0gdGhpcztcclxuICAgICAgICBpZiAobi5yaWdodC5pc1JlZF8oKSAmJiAhbi5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZUxlZnRfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWRfKCkgJiYgbi5sZWZ0LmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgbiA9IG4ucm90YXRlUmlnaHRfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWRfKCkgJiYgbi5yaWdodC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXBfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgYWZ0ZXIgbW92ZVJlZExlZnQuXHJcbiAgICAgKi9cclxuICAgIG1vdmVSZWRMZWZ0XygpIHtcclxuICAgICAgICBsZXQgbiA9IHRoaXMuY29sb3JGbGlwXygpO1xyXG4gICAgICAgIGlmIChuLnJpZ2h0LmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0LnJvdGF0ZVJpZ2h0XygpKTtcclxuICAgICAgICAgICAgbiA9IG4ucm90YXRlTGVmdF8oKTtcclxuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwXygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIGFmdGVyIG1vdmVSZWRSaWdodC5cclxuICAgICAqL1xyXG4gICAgbW92ZVJlZFJpZ2h0XygpIHtcclxuICAgICAgICBsZXQgbiA9IHRoaXMuY29sb3JGbGlwXygpO1xyXG4gICAgICAgIGlmIChuLmxlZnQubGVmdC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodF8oKTtcclxuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwXygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIGFmdGVyIHJvdGF0ZUxlZnQuXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZUxlZnRfKCkge1xyXG4gICAgICAgIGNvbnN0IG5sID0gdGhpcy5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLlJFRCwgbnVsbCwgdGhpcy5yaWdodC5sZWZ0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG5sLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIGFmdGVyIHJvdGF0ZVJpZ2h0LlxyXG4gICAgICovXHJcbiAgICByb3RhdGVSaWdodF8oKSB7XHJcbiAgICAgICAgY29uc3QgbnIgPSB0aGlzLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuUkVELCB0aGlzLmxlZnQucmlnaHQsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuY29weShudWxsLCBudWxsLCB0aGlzLmNvbG9yLCBudWxsLCBucik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIE5ld3QgcmVlLCBhZnRlciBjb2xvckZsaXAuXHJcbiAgICAgKi9cclxuICAgIGNvbG9yRmxpcF8oKSB7XHJcbiAgICAgICAgY29uc3QgbGVmdCA9IHRoaXMubGVmdC5jb3B5KG51bGwsIG51bGwsICF0aGlzLmxlZnQuY29sb3IsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsICF0aGlzLnJpZ2h0LmNvbG9yLCBudWxsLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KG51bGwsIG51bGwsICF0aGlzLmNvbG9yLCBsZWZ0LCByaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZvciB0ZXN0aW5nLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgYWxsIGlzIHdlbGwuXHJcbiAgICAgKi9cclxuICAgIGNoZWNrTWF4RGVwdGhfKCkge1xyXG4gICAgICAgIGNvbnN0IGJsYWNrRGVwdGggPSB0aGlzLmNoZWNrXygpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLnBvdygyLjAsIGJsYWNrRGVwdGgpIDw9IHRoaXMuY291bnQoKSArIDE7XHJcbiAgICB9XHJcbiAgICBjaGVja18oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNSZWRfKCkgJiYgdGhpcy5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVkIG5vZGUgaGFzIHJlZCBjaGlsZCgnICsgdGhpcy5rZXkgKyAnLCcgKyB0aGlzLnZhbHVlICsgJyknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSaWdodCBjaGlsZCBvZiAoJyArIHRoaXMua2V5ICsgJywnICsgdGhpcy52YWx1ZSArICcpIGlzIHJlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBibGFja0RlcHRoID0gdGhpcy5sZWZ0LmNoZWNrXygpO1xyXG4gICAgICAgIGlmIChibGFja0RlcHRoICE9PSB0aGlzLnJpZ2h0LmNoZWNrXygpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmxhY2sgZGVwdGhzIGRpZmZlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJsYWNrRGVwdGggKyAodGhpcy5pc1JlZF8oKSA/IDAgOiAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuTExSQk5vZGUuUkVEID0gdHJ1ZTtcclxuTExSQk5vZGUuQkxBQ0sgPSBmYWxzZTtcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gZW1wdHkgbm9kZSAoYSBsZWFmIG5vZGUgaW4gdGhlIFJlZC1CbGFjayBUcmVlKS5cclxuICovXHJcbmNsYXNzIExMUkJFbXB0eU5vZGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBub2RlIGNvcHkuXHJcbiAgICAgKi9cclxuICAgIGNvcHkoa2V5LCB2YWx1ZSwgY29sb3IsIGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSB0cmVlLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5L3ZhbHVlIGFkZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBLZXkgdG8gYmUgYWRkZWQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBiZSBhZGRlZC5cclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIC0gQ29tcGFyYXRvci5cclxuICAgICAqIEByZXR1cm5zIE5ldyB0cmVlLCB3aXRoIGl0ZW0gYWRkZWQuXHJcbiAgICAgKi9cclxuICAgIGluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXksIHZhbHVlLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byByZW1vdmUuXHJcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvciAtIENvbXBhcmF0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgd2l0aCBpdGVtIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShrZXksIGNvbXBhcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBpbiB0aGUgdHJlZS5cclxuICAgICAqL1xyXG4gICAgY291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHRyZWUgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgKiBmb3IgZWFjaCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcclxuICAgICAqIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0cmF2ZXJzYWwgd2FzIGFib3J0ZWQuXHJcbiAgICAgKi9cclxuICAgIGlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgKiBmb3IgZWFjaCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcclxuICAgICAqIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0cmF2ZXJzYWwgd2FzIGFib3J0ZWQuXHJcbiAgICAgKi9cclxuICAgIHJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbWluS2V5KCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgbWF4S2V5KCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY2hlY2tfKCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoaXMgbm9kZSBpcyByZWQuXHJcbiAgICAgKi9cclxuICAgIGlzUmVkXygpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFuIGltbXV0YWJsZSBzb3J0ZWQgbWFwIGltcGxlbWVudGF0aW9uLCBiYXNlZCBvbiBhIExlZnQtbGVhbmluZyBSZWQtQmxhY2tcclxuICogdHJlZS5cclxuICovXHJcbmNsYXNzIFNvcnRlZE1hcCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yXyAtIEtleSBjb21wYXJhdG9yLlxyXG4gICAgICogQHBhcmFtIHJvb3RfIC0gT3B0aW9uYWwgcm9vdCBub2RlIGZvciB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJhdG9yXywgcm9vdF8gPSBTb3J0ZWRNYXAuRU1QVFlfTk9ERSkge1xyXG4gICAgICAgIHRoaXMuY29tcGFyYXRvcl8gPSBjb21wYXJhdG9yXztcclxuICAgICAgICB0aGlzLnJvb3RfID0gcm9vdF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXAsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgYWRkZWQgb3IgcmVwbGFjZWQuXHJcbiAgICAgKiAoVE9ETzogV2Ugc2hvdWxkIHBlcmhhcHMgcmVuYW1lIHRoaXMgbWV0aG9kIHRvICdwdXQnKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBLZXkgdG8gYmUgYWRkZWQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBiZSBhZGRlZC5cclxuICAgICAqIEByZXR1cm5zIE5ldyBtYXAsIHdpdGggaXRlbSBhZGRlZC5cclxuICAgICAqL1xyXG4gICAgaW5zZXJ0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3JfLCB0aGlzLnJvb3RfXHJcbiAgICAgICAgICAgIC5pbnNlcnQoa2V5LCB2YWx1ZSwgdGhpcy5jb21wYXJhdG9yXylcclxuICAgICAgICAgICAgLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hcCwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHJlbW92ZS5cclxuICAgICAqIEByZXR1cm5zIE5ldyBtYXAsIHdpdGggaXRlbSByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICByZW1vdmUoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXAodGhpcy5jb21wYXJhdG9yXywgdGhpcy5yb290X1xyXG4gICAgICAgICAgICAucmVtb3ZlKGtleSwgdGhpcy5jb21wYXJhdG9yXylcclxuICAgICAgICAgICAgLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4ga2V5LCBvciBudWxsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIGxvb2sgdXAuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4ga2V5LCBvciBudWxsIGlmIHRoZVxyXG4gICAgICoga2V5IGRvZXNuJ3QgZXhpc3QuXHJcbiAgICAgKi9cclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICBsZXQgY21wO1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5yb290XztcclxuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IHRoaXMuY29tcGFyYXRvcl8oa2V5LCBub2RlLmtleSk7XHJcbiAgICAgICAgICAgIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGtleSBvZiB0aGUgaXRlbSAqYmVmb3JlKiB0aGUgc3BlY2lmaWVkIGtleSwgb3IgbnVsbCBpZiBrZXkgaXMgdGhlIGZpcnN0IGl0ZW0uXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byBmaW5kIHRoZSBwcmVkZWNlc3NvciBvZlxyXG4gICAgICogQHJldHVybnMgVGhlIHByZWRlY2Vzc29yIGtleS5cclxuICAgICAqL1xyXG4gICAgZ2V0UHJlZGVjZXNzb3JLZXkoa2V5KSB7XHJcbiAgICAgICAgbGV0IGNtcCwgbm9kZSA9IHRoaXMucm9vdF8sIHJpZ2h0UGFyZW50ID0gbnVsbDtcclxuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IHRoaXMuY29tcGFyYXRvcl8oa2V5LCBub2RlLmtleSk7XHJcbiAgICAgICAgICAgIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5sZWZ0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFub2RlLnJpZ2h0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUua2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmlnaHRQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHRQYXJlbnQua2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGZpcnN0IGl0ZW0uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodFBhcmVudCA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBmaW5kIHByZWRlY2Vzc29yIGtleSBmb3IgYSBub25leGlzdGVudCBrZXkuICBXaGF0IGdpdmVzPycpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBtYXAgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8uaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdG90YWwgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIGNvdW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfLmNvdW50KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBtaW5pbXVtIGtleSBpbiB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8ubWluS2V5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBtYXhpbXVtIGtleSBpbiB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8ubWF4S2V5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyB0aGUgbWFwIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWRcclxuICAgICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLiAgSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XHJcbiAgICAgKiAgIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvblxyXG4gICAgICovXHJcbiAgICBpbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfLmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIHRoZSBtYXAgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgKiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXHJcbiAgICAgKiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci4gIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdHJhdmVyc2FsIHdhcyBhYm9ydGVkLlxyXG4gICAgICovXHJcbiAgICByZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfLnJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSBTb3J0ZWRNYXAuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlcmF0b3IuXHJcbiAgICAgKi9cclxuICAgIGdldEl0ZXJhdG9yKHJlc3VsdEdlbmVyYXRvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290XywgbnVsbCwgdGhpcy5jb21wYXJhdG9yXywgZmFsc2UsIHJlc3VsdEdlbmVyYXRvcik7XHJcbiAgICB9XHJcbiAgICBnZXRJdGVyYXRvckZyb20oa2V5LCByZXN1bHRHZW5lcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdF8sIGtleSwgdGhpcy5jb21wYXJhdG9yXywgZmFsc2UsIHJlc3VsdEdlbmVyYXRvcik7XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGtleSwgcmVzdWx0R2VuZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3RfLCBrZXksIHRoaXMuY29tcGFyYXRvcl8sIHRydWUsIHJlc3VsdEdlbmVyYXRvcik7XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3IocmVzdWx0R2VuZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3RfLCBudWxsLCB0aGlzLmNvbXBhcmF0b3JfLCB0cnVlLCByZXN1bHRHZW5lcmF0b3IpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBbHdheXMgdXNlIHRoZSBzYW1lIGVtcHR5IG5vZGUsIHRvIHJlZHVjZSBtZW1vcnkuXHJcbiAqL1xyXG5Tb3J0ZWRNYXAuRU1QVFlfTk9ERSA9IG5ldyBMTFJCRW1wdHlOb2RlKCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIE5BTUVfT05MWV9DT01QQVJBVE9SKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICByZXR1cm4gbmFtZUNvbXBhcmUobGVmdC5uYW1lLCByaWdodC5uYW1lKTtcclxufVxyXG5mdW5jdGlvbiBOQU1FX0NPTVBBUkFUT1IobGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiBuYW1lQ29tcGFyZShsZWZ0LCByaWdodCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IE1BWF9OT0RFJDI7XHJcbmZ1bmN0aW9uIHNldE1heE5vZGUkMSh2YWwpIHtcclxuICAgIE1BWF9OT0RFJDIgPSB2YWw7XHJcbn1cclxuY29uc3QgcHJpb3JpdHlIYXNoVGV4dCA9IGZ1bmN0aW9uIChwcmlvcml0eSkge1xyXG4gICAgaWYgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gJ251bWJlcjonICsgZG91YmxlVG9JRUVFNzU0U3RyaW5nKHByaW9yaXR5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAnc3RyaW5nOicgKyBwcmlvcml0eTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFZhbGlkYXRlcyB0aGF0IGEgcHJpb3JpdHkgc25hcHNob3QgTm9kZSBpcyB2YWxpZC5cclxuICovXHJcbmNvbnN0IHZhbGlkYXRlUHJpb3JpdHlOb2RlID0gZnVuY3Rpb24gKHByaW9yaXR5Tm9kZSkge1xyXG4gICAgaWYgKHByaW9yaXR5Tm9kZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICBjb25zdCB2YWwgPSBwcmlvcml0eU5vZGUudmFsKCk7XHJcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgICAgIHR5cGVvZiB2YWwgPT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgICAgICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiBjb250YWlucyh2YWwsICcuc3YnKSksICdQcmlvcml0eSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlci4nKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFzc2VydChwcmlvcml0eU5vZGUgPT09IE1BWF9OT0RFJDIgfHwgcHJpb3JpdHlOb2RlLmlzRW1wdHkoKSwgJ3ByaW9yaXR5IG9mIHVuZXhwZWN0ZWQgdHlwZS4nKTtcclxuICAgIH1cclxuICAgIC8vIERvbid0IGNhbGwgZ2V0UHJpb3JpdHkoKSBvbiBNQVhfTk9ERSB0byBhdm9pZCBoaXR0aW5nIGFzc2VydGlvbi5cclxuICAgIGFzc2VydChwcmlvcml0eU5vZGUgPT09IE1BWF9OT0RFJDIgfHwgcHJpb3JpdHlOb2RlLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpLCBcIlByaW9yaXR5IG5vZGVzIGNhbid0IGhhdmUgYSBwcmlvcml0eSBvZiB0aGVpciBvd24uXCIpO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvcjtcclxuLyoqXHJcbiAqIExlYWZOb2RlIGlzIGEgY2xhc3MgZm9yIHN0b3JpbmcgbGVhZiBub2RlcyBpbiBhIERhdGFTbmFwc2hvdC4gIEl0XHJcbiAqIGltcGxlbWVudHMgTm9kZSBhbmQgc3RvcmVzIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZSAoYSBzdHJpbmcsXHJcbiAqIG51bWJlciwgb3IgYm9vbGVhbikgYWNjZXNzaWJsZSB2aWEgZ2V0VmFsdWUoKS5cclxuICovXHJcbmNsYXNzIExlYWZOb2RlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHZhbHVlXyAtIFRoZSB2YWx1ZSB0byBzdG9yZSBpbiB0aGlzIGxlYWYgbm9kZS4gVGhlIG9iamVjdCB0eXBlIGlzXHJcbiAgICAgKiBwb3NzaWJsZSBpbiB0aGUgZXZlbnQgb2YgYSBkZWZlcnJlZCB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHByaW9yaXR5Tm9kZV8gLSBUaGUgcHJpb3JpdHkgb2YgdGhpcyBub2RlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZV8sIHByaW9yaXR5Tm9kZV8gPSBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlXyA9IHZhbHVlXztcclxuICAgICAgICB0aGlzLnByaW9yaXR5Tm9kZV8gPSBwcmlvcml0eU5vZGVfO1xyXG4gICAgICAgIHRoaXMubGF6eUhhc2hfID0gbnVsbDtcclxuICAgICAgICBhc3NlcnQodGhpcy52YWx1ZV8gIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZhbHVlXyAhPT0gbnVsbCwgXCJMZWFmTm9kZSBzaG91bGRuJ3QgYmUgY3JlYXRlZCB3aXRoIG51bGwvdW5kZWZpbmVkIHZhbHVlLlwiKTtcclxuICAgICAgICB2YWxpZGF0ZVByaW9yaXR5Tm9kZSh0aGlzLnByaW9yaXR5Tm9kZV8pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHNldCBfX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yKHZhbCkge1xyXG4gICAgICAgIF9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IF9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3I7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGlzTGVhZk5vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldFByaW9yaXR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByaW9yaXR5Tm9kZV87XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHVwZGF0ZVByaW9yaXR5KG5ld1ByaW9yaXR5Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGVhZk5vZGUodGhpcy52YWx1ZV8sIG5ld1ByaW9yaXR5Tm9kZSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIC8vIEhhY2sgdG8gdHJlYXQgcHJpb3JpdHkgYXMgYSByZWd1bGFyIGNoaWxkXHJcbiAgICAgICAgaWYgKGNoaWxkTmFtZSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRDaGlsZChwYXRoKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXRoR2V0RnJvbnQocGF0aCkgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByaW9yaXR5Tm9kZV87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvci5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhc0NoaWxkKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0UHJlZGVjZXNzb3JDaGlsZE5hbWUoY2hpbGROYW1lLCBjaGlsZE5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpIHtcclxuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVQcmlvcml0eShuZXdDaGlsZE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChuZXdDaGlsZE5vZGUuaXNFbXB0eSgpICYmIGNoaWxkTmFtZSAhPT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvci5FTVBUWV9OT0RFLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKS51cGRhdGVQcmlvcml0eSh0aGlzLnByaW9yaXR5Tm9kZV8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdXBkYXRlQ2hpbGQocGF0aCwgbmV3Q2hpbGROb2RlKSB7XHJcbiAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgaWYgKGZyb250ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5ld0NoaWxkTm9kZS5pc0VtcHR5KCkgJiYgZnJvbnQgIT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0KGZyb250ICE9PSAnLnByaW9yaXR5JyB8fCBwYXRoR2V0TGVuZ3RoKHBhdGgpID09PSAxLCAnLnByaW9yaXR5IG11c3QgYmUgdGhlIGxhc3QgdG9rZW4gaW4gYSBwYXRoJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGZyb250LCBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUudXBkYXRlQ2hpbGQocGF0aFBvcEZyb250KHBhdGgpLCBuZXdDaGlsZE5vZGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBudW1DaGlsZHJlbigpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZm9yRWFjaENoaWxkKGluZGV4LCBhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YWwoZXhwb3J0Rm9ybWF0KSB7XHJcbiAgICAgICAgaWYgKGV4cG9ydEZvcm1hdCAmJiAhdGhpcy5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgJy52YWx1ZSc6IHRoaXMuZ2V0VmFsdWUoKSxcclxuICAgICAgICAgICAgICAgICcucHJpb3JpdHknOiB0aGlzLmdldFByaW9yaXR5KCkudmFsKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBoYXNoKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxhenlIYXNoXyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsZXQgdG9IYXNoID0gJyc7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wcmlvcml0eU5vZGVfLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgdG9IYXNoICs9XHJcbiAgICAgICAgICAgICAgICAgICAgJ3ByaW9yaXR5OicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eUhhc2hUZXh0KHRoaXMucHJpb3JpdHlOb2RlXy52YWwoKSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnOic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB0aGlzLnZhbHVlXztcclxuICAgICAgICAgICAgdG9IYXNoICs9IHR5cGUgKyAnOic7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgdG9IYXNoICs9IGRvdWJsZVRvSUVFRTc1NFN0cmluZyh0aGlzLnZhbHVlXyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0b0hhc2ggKz0gdGhpcy52YWx1ZV87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSBzaGExKHRvSGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmxhenlIYXNoXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGxlYWYgbm9kZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgbm9kZS5cclxuICAgICAqL1xyXG4gICAgZ2V0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVfO1xyXG4gICAgfVxyXG4gICAgY29tcGFyZVRvKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyID09PSBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyIGluc3RhbmNlb2YgTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnQob3RoZXIuaXNMZWFmTm9kZSgpLCAnVW5rbm93biBub2RlIHR5cGUnKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvTGVhZk5vZGVfKG90aGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmlzb24gc3BlY2lmaWNhbGx5IGZvciB0d28gbGVhZiBub2Rlc1xyXG4gICAgICovXHJcbiAgICBjb21wYXJlVG9MZWFmTm9kZV8ob3RoZXJMZWFmKSB7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJMZWFmVHlwZSA9IHR5cGVvZiBvdGhlckxlYWYudmFsdWVfO1xyXG4gICAgICAgIGNvbnN0IHRoaXNMZWFmVHlwZSA9IHR5cGVvZiB0aGlzLnZhbHVlXztcclxuICAgICAgICBjb25zdCBvdGhlckluZGV4ID0gTGVhZk5vZGUuVkFMVUVfVFlQRV9PUkRFUi5pbmRleE9mKG90aGVyTGVhZlR5cGUpO1xyXG4gICAgICAgIGNvbnN0IHRoaXNJbmRleCA9IExlYWZOb2RlLlZBTFVFX1RZUEVfT1JERVIuaW5kZXhPZih0aGlzTGVhZlR5cGUpO1xyXG4gICAgICAgIGFzc2VydChvdGhlckluZGV4ID49IDAsICdVbmtub3duIGxlYWYgdHlwZTogJyArIG90aGVyTGVhZlR5cGUpO1xyXG4gICAgICAgIGFzc2VydCh0aGlzSW5kZXggPj0gMCwgJ1Vua25vd24gbGVhZiB0eXBlOiAnICsgdGhpc0xlYWZUeXBlKTtcclxuICAgICAgICBpZiAob3RoZXJJbmRleCA9PT0gdGhpc0luZGV4KSB7XHJcbiAgICAgICAgICAgIC8vIFNhbWUgdHlwZSwgY29tcGFyZSB2YWx1ZXNcclxuICAgICAgICAgICAgaWYgKHRoaXNMZWFmVHlwZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIERlZmVycmVkIHZhbHVlIG5vZGVzIGFyZSBhbGwgZXF1YWwsIGJ1dCB3ZSBzaG91bGQgYWxzbyBuZXZlciBnZXQgdG8gdGhpcyBwb2ludC4uLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyB3b3JrcyBiZWNhdXNlIHRydWUgPiBmYWxzZSwgYWxsIG90aGVycyBhcmUgbnVtYmVyIG9yIHN0cmluZyBjb21wYXJpc29uc1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVfIDwgb3RoZXJMZWFmLnZhbHVlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudmFsdWVfID09PSBvdGhlckxlYWYudmFsdWVfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNJbmRleCAtIG90aGVySW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd2l0aEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgaXNJbmRleGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvdGhlci5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3RoZXJMZWFmID0gb3RoZXI7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZV8gPT09IG90aGVyTGVhZi52YWx1ZV8gJiZcclxuICAgICAgICAgICAgICAgIHRoaXMucHJpb3JpdHlOb2RlXy5lcXVhbHMob3RoZXJMZWFmLnByaW9yaXR5Tm9kZV8pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBzb3J0IG9yZGVyIGZvciBjb21wYXJpbmcgbGVhZiBub2RlcyBvZiBkaWZmZXJlbnQgdHlwZXMuIElmIHR3byBsZWFmIG5vZGVzIGhhdmVcclxuICogdGhlIHNhbWUgdHlwZSwgdGhlIGNvbXBhcmlzb24gZmFsbHMgYmFjayB0byB0aGVpciB2YWx1ZVxyXG4gKi9cclxuTGVhZk5vZGUuVkFMVUVfVFlQRV9PUkRFUiA9IFsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ3N0cmluZyddO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgbm9kZUZyb21KU09OJDE7XHJcbmxldCBNQVhfTk9ERSQxO1xyXG5mdW5jdGlvbiBzZXROb2RlRnJvbUpTT04odmFsKSB7XHJcbiAgICBub2RlRnJvbUpTT04kMSA9IHZhbDtcclxufVxyXG5mdW5jdGlvbiBzZXRNYXhOb2RlKHZhbCkge1xyXG4gICAgTUFYX05PREUkMSA9IHZhbDtcclxufVxyXG5jbGFzcyBQcmlvcml0eUluZGV4IGV4dGVuZHMgSW5kZXgge1xyXG4gICAgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgY29uc3QgYVByaW9yaXR5ID0gYS5ub2RlLmdldFByaW9yaXR5KCk7XHJcbiAgICAgICAgY29uc3QgYlByaW9yaXR5ID0gYi5ub2RlLmdldFByaW9yaXR5KCk7XHJcbiAgICAgICAgY29uc3QgaW5kZXhDbXAgPSBhUHJpb3JpdHkuY29tcGFyZVRvKGJQcmlvcml0eSk7XHJcbiAgICAgICAgaWYgKGluZGV4Q21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lQ29tcGFyZShhLm5hbWUsIGIubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhDbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNEZWZpbmVkT24obm9kZSkge1xyXG4gICAgICAgIHJldHVybiAhbm9kZS5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKTtcclxuICAgIH1cclxuICAgIGluZGV4ZWRWYWx1ZUNoYW5nZWQob2xkTm9kZSwgbmV3Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiAhb2xkTm9kZS5nZXRQcmlvcml0eSgpLmVxdWFscyhuZXdOb2RlLmdldFByaW9yaXR5KCkpO1xyXG4gICAgfVxyXG4gICAgbWluUG9zdCgpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIHJldHVybiBOYW1lZE5vZGUuTUlOO1xyXG4gICAgfVxyXG4gICAgbWF4UG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShNQVhfTkFNRSwgbmV3IExlYWZOb2RlKCdbUFJJT1JJVFktUE9TVF0nLCBNQVhfTk9ERSQxKSk7XHJcbiAgICB9XHJcbiAgICBtYWtlUG9zdChpbmRleFZhbHVlLCBuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgcHJpb3JpdHlOb2RlID0gbm9kZUZyb21KU09OJDEoaW5kZXhWYWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobmFtZSwgbmV3IExlYWZOb2RlKCdbUFJJT1JJVFktUE9TVF0nLCBwcmlvcml0eU5vZGUpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgU3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciBpbmNsdXNpb24gaW4gYSBxdWVyeSBzcGVjXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnLnByaW9yaXR5JztcclxuICAgIH1cclxufVxyXG5jb25zdCBQUklPUklUWV9JTkRFWCA9IG5ldyBQcmlvcml0eUluZGV4KCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR18yID0gTWF0aC5sb2coMik7XHJcbmNsYXNzIEJhc2UxMk51bSB7XHJcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBsb2dCYXNlMiA9IChudW0pID0+IFxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcGFyc2VJbnQoKE1hdGgubG9nKG51bSkgLyBMT0dfMiksIDEwKTtcclxuICAgICAgICBjb25zdCBiaXRNYXNrID0gKGJpdHMpID0+IHBhcnNlSW50KEFycmF5KGJpdHMgKyAxKS5qb2luKCcxJyksIDIpO1xyXG4gICAgICAgIHRoaXMuY291bnQgPSBsb2dCYXNlMihsZW5ndGggKyAxKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRfID0gdGhpcy5jb3VudCAtIDE7XHJcbiAgICAgICAgY29uc3QgbWFzayA9IGJpdE1hc2sodGhpcy5jb3VudCk7XHJcbiAgICAgICAgdGhpcy5iaXRzXyA9IChsZW5ndGggKyAxKSAmIG1hc2s7XHJcbiAgICB9XHJcbiAgICBuZXh0Qml0SXNPbmUoKSB7XHJcbiAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNCaXR3aXNlT3BlcmF0b3JVc2FnZVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICEodGhpcy5iaXRzXyAmICgweDEgPDwgdGhpcy5jdXJyZW50XykpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudF8tLTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUYWtlcyBhIGxpc3Qgb2YgY2hpbGQgbm9kZXMgYW5kIGNvbnN0cnVjdHMgYSBTb3J0ZWRTZXQgdXNpbmcgdGhlIGdpdmVuIGNvbXBhcmlzb25cclxuICogZnVuY3Rpb25cclxuICpcclxuICogVXNlcyB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBpbiB0aGUgcGFwZXIgbGlua2VkIGhlcmU6XHJcbiAqIGh0dHA6Ly9jaXRlc2VlcnguaXN0LnBzdS5lZHUvdmlld2RvYy9zdW1tYXJ5P2RvaT0xMC4xLjEuNDYuMTQ1OFxyXG4gKlxyXG4gKiBAcGFyYW0gY2hpbGRMaXN0IC0gVW5zb3J0ZWQgbGlzdCBvZiBjaGlsZHJlblxyXG4gKiBAcGFyYW0gY21wIC0gVGhlIGNvbXBhcmlzb24gbWV0aG9kIHRvIGJlIHVzZWRcclxuICogQHBhcmFtIGtleUZuIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZXh0cmFjdCBLIGZyb20gYSBub2RlIHdyYXBwZXIsIGlmIEsnc1xyXG4gKiB0eXBlIGlzIG5vdCBOYW1lZE5vZGVcclxuICogQHBhcmFtIG1hcFNvcnRGbiAtIEFuIG9wdGlvbmFsIG92ZXJyaWRlIGZvciBjb21wYXJhdG9yIHVzZWQgYnkgdGhlIGdlbmVyYXRlZCBzb3J0ZWQgbWFwXHJcbiAqL1xyXG5jb25zdCBidWlsZENoaWxkU2V0ID0gZnVuY3Rpb24gKGNoaWxkTGlzdCwgY21wLCBrZXlGbiwgbWFwU29ydEZuKSB7XHJcbiAgICBjaGlsZExpc3Quc29ydChjbXApO1xyXG4gICAgY29uc3QgYnVpbGRCYWxhbmNlZFRyZWUgPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gaGlnaCAtIGxvdztcclxuICAgICAgICBsZXQgbmFtZWROb2RlO1xyXG4gICAgICAgIGxldCBrZXk7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIG5hbWVkTm9kZSA9IGNoaWxkTGlzdFtsb3ddO1xyXG4gICAgICAgICAgICBrZXkgPSBrZXlGbiA/IGtleUZuKG5hbWVkTm9kZSkgOiBuYW1lZE5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5LCBuYW1lZE5vZGUubm9kZSwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgY29uc3QgbWlkZGxlID0gcGFyc2VJbnQoKGxlbmd0aCAvIDIpLCAxMCkgKyBsb3c7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBidWlsZEJhbGFuY2VkVHJlZShsb3csIG1pZGRsZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gYnVpbGRCYWxhbmNlZFRyZWUobWlkZGxlICsgMSwgaGlnaCk7XHJcbiAgICAgICAgICAgIG5hbWVkTm9kZSA9IGNoaWxkTGlzdFttaWRkbGVdO1xyXG4gICAgICAgICAgICBrZXkgPSBrZXlGbiA/IGtleUZuKG5hbWVkTm9kZSkgOiBuYW1lZE5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5LCBuYW1lZE5vZGUubm9kZSwgTExSQk5vZGUuQkxBQ0ssIGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgYnVpbGRGcm9tMTJBcnJheSA9IGZ1bmN0aW9uIChiYXNlMTIpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgbGV0IHJvb3QgPSBudWxsO1xyXG4gICAgICAgIGxldCBpbmRleCA9IGNoaWxkTGlzdC5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgYnVpbGRQZW5uYW50ID0gZnVuY3Rpb24gKGNodW5rU2l6ZSwgY29sb3IpIHtcclxuICAgICAgICAgICAgY29uc3QgbG93ID0gaW5kZXggLSBjaHVua1NpemU7XHJcbiAgICAgICAgICAgIGNvbnN0IGhpZ2ggPSBpbmRleDtcclxuICAgICAgICAgICAgaW5kZXggLT0gY2h1bmtTaXplO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFRyZWUgPSBidWlsZEJhbGFuY2VkVHJlZShsb3cgKyAxLCBoaWdoKTtcclxuICAgICAgICAgICAgY29uc3QgbmFtZWROb2RlID0gY2hpbGRMaXN0W2xvd107XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleUZuID8ga2V5Rm4obmFtZWROb2RlKSA6IG5hbWVkTm9kZTtcclxuICAgICAgICAgICAgYXR0YWNoUGVubmFudChuZXcgTExSQk5vZGUoa2V5LCBuYW1lZE5vZGUubm9kZSwgY29sb3IsIG51bGwsIGNoaWxkVHJlZSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgYXR0YWNoUGVubmFudCA9IGZ1bmN0aW9uIChwZW5uYW50KSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmxlZnQgPSBwZW5uYW50O1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBlbm5hbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByb290ID0gcGVubmFudDtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBwZW5uYW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2UxMi5jb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzT25lID0gYmFzZTEyLm5leHRCaXRJc09uZSgpO1xyXG4gICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIG5vZGVzIHRha2VuIGluIGVhY2ggc2xpY2UgaXMgMl4oYXJyLmxlbmd0aCAtIChpICsgMSkpXHJcbiAgICAgICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgucG93KDIsIGJhc2UxMi5jb3VudCAtIChpICsgMSkpO1xyXG4gICAgICAgICAgICBpZiAoaXNPbmUpIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkUGVubmFudChjaHVua1NpemUsIExMUkJOb2RlLkJMQUNLKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgPT0gMlxyXG4gICAgICAgICAgICAgICAgYnVpbGRQZW5uYW50KGNodW5rU2l6ZSwgTExSQk5vZGUuQkxBQ0spO1xyXG4gICAgICAgICAgICAgICAgYnVpbGRQZW5uYW50KGNodW5rU2l6ZSwgTExSQk5vZGUuUkVEKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgIH07XHJcbiAgICBjb25zdCBiYXNlMTIgPSBuZXcgQmFzZTEyTnVtKGNoaWxkTGlzdC5sZW5ndGgpO1xyXG4gICAgY29uc3Qgcm9vdCA9IGJ1aWxkRnJvbTEyQXJyYXkoYmFzZTEyKTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICByZXR1cm4gbmV3IFNvcnRlZE1hcChtYXBTb3J0Rm4gfHwgY21wLCByb290KTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IF9kZWZhdWx0SW5kZXhNYXA7XHJcbmNvbnN0IGZhbGxiYWNrT2JqZWN0ID0ge307XHJcbmNsYXNzIEluZGV4TWFwIHtcclxuICAgIGNvbnN0cnVjdG9yKGluZGV4ZXNfLCBpbmRleFNldF8pIHtcclxuICAgICAgICB0aGlzLmluZGV4ZXNfID0gaW5kZXhlc187XHJcbiAgICAgICAgdGhpcy5pbmRleFNldF8gPSBpbmRleFNldF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWZhdWx0IEluZGV4TWFwIGZvciBub2RlcyB3aXRob3V0IGEgcHJpb3JpdHlcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICAgIGFzc2VydChmYWxsYmFja09iamVjdCAmJiBQUklPUklUWV9JTkRFWCwgJ0NoaWxkcmVuTm9kZS50cyBoYXMgbm90IGJlZW4gbG9hZGVkJyk7XHJcbiAgICAgICAgX2RlZmF1bHRJbmRleE1hcCA9XHJcbiAgICAgICAgICAgIF9kZWZhdWx0SW5kZXhNYXAgfHxcclxuICAgICAgICAgICAgICAgIG5ldyBJbmRleE1hcCh7ICcucHJpb3JpdHknOiBmYWxsYmFja09iamVjdCB9LCB7ICcucHJpb3JpdHknOiBQUklPUklUWV9JTkRFWCB9KTtcclxuICAgICAgICByZXR1cm4gX2RlZmF1bHRJbmRleE1hcDtcclxuICAgIH1cclxuICAgIGdldChpbmRleEtleSkge1xyXG4gICAgICAgIGNvbnN0IHNvcnRlZE1hcCA9IHNhZmVHZXQodGhpcy5pbmRleGVzXywgaW5kZXhLZXkpO1xyXG4gICAgICAgIGlmICghc29ydGVkTWFwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5kZXggZGVmaW5lZCBmb3IgJyArIGluZGV4S2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNvcnRlZE1hcCBpbnN0YW5jZW9mIFNvcnRlZE1hcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc29ydGVkTWFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlIGluZGV4IGV4aXN0cywgYnV0IGl0IGZhbGxzIGJhY2sgdG8ganVzdCBuYW1lIGNvbXBhcmlzb24uIFJldHVybiBudWxsIHNvIHRoYXQgdGhlIGNhbGxpbmcgY29kZSB1c2VzIHRoZVxyXG4gICAgICAgICAgICAvLyByZWd1bGFyIGNoaWxkIG1hcFxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYXNJbmRleChpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gY29udGFpbnModGhpcy5pbmRleFNldF8sIGluZGV4RGVmaW5pdGlvbi50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIGFkZEluZGV4KGluZGV4RGVmaW5pdGlvbiwgZXhpc3RpbmdDaGlsZHJlbikge1xyXG4gICAgICAgIGFzc2VydChpbmRleERlZmluaXRpb24gIT09IEtFWV9JTkRFWCwgXCJLZXlJbmRleCBhbHdheXMgZXhpc3RzIGFuZCBpc24ndCBtZWFudCB0byBiZSBhZGRlZCB0byB0aGUgSW5kZXhNYXAuXCIpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkTGlzdCA9IFtdO1xyXG4gICAgICAgIGxldCBzYXdJbmRleGVkVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBpdGVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXRJdGVyYXRvcihOYW1lZE5vZGUuV3JhcCk7XHJcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICB3aGlsZSAobmV4dCkge1xyXG4gICAgICAgICAgICBzYXdJbmRleGVkVmFsdWUgPVxyXG4gICAgICAgICAgICAgICAgc2F3SW5kZXhlZFZhbHVlIHx8IGluZGV4RGVmaW5pdGlvbi5pc0RlZmluZWRPbihuZXh0Lm5vZGUpO1xyXG4gICAgICAgICAgICBjaGlsZExpc3QucHVzaChuZXh0KTtcclxuICAgICAgICAgICAgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmV3SW5kZXg7XHJcbiAgICAgICAgaWYgKHNhd0luZGV4ZWRWYWx1ZSkge1xyXG4gICAgICAgICAgICBuZXdJbmRleCA9IGJ1aWxkQ2hpbGRTZXQoY2hpbGRMaXN0LCBpbmRleERlZmluaXRpb24uZ2V0Q29tcGFyZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld0luZGV4ID0gZmFsbGJhY2tPYmplY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluZGV4TmFtZSA9IGluZGV4RGVmaW5pdGlvbi50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IG5ld0luZGV4U2V0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pbmRleFNldF8pO1xyXG4gICAgICAgIG5ld0luZGV4U2V0W2luZGV4TmFtZV0gPSBpbmRleERlZmluaXRpb247XHJcbiAgICAgICAgY29uc3QgbmV3SW5kZXhlcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaW5kZXhlc18pO1xyXG4gICAgICAgIG5ld0luZGV4ZXNbaW5kZXhOYW1lXSA9IG5ld0luZGV4O1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhNYXAobmV3SW5kZXhlcywgbmV3SW5kZXhTZXQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmUgdGhhdCB0aGlzIG5vZGUgaXMgcHJvcGVybHkgdHJhY2tlZCBpbiBhbnkgaW5kZXhlcyB0aGF0IHdlJ3JlIG1haW50YWluaW5nXHJcbiAgICAgKi9cclxuICAgIGFkZFRvSW5kZXhlcyhuYW1lZE5vZGUsIGV4aXN0aW5nQ2hpbGRyZW4pIHtcclxuICAgICAgICBjb25zdCBuZXdJbmRleGVzID0gbWFwKHRoaXMuaW5kZXhlc18sIChpbmRleGVkQ2hpbGRyZW4sIGluZGV4TmFtZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHNhZmVHZXQodGhpcy5pbmRleFNldF8sIGluZGV4TmFtZSk7XHJcbiAgICAgICAgICAgIGFzc2VydChpbmRleCwgJ01pc3NpbmcgaW5kZXggaW1wbGVtZW50YXRpb24gZm9yICcgKyBpbmRleE5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXhlZENoaWxkcmVuID09PSBmYWxsYmFja09iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIG5lZWQgdG8gaW5kZXggZXZlcnl0aGluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4LmlzRGVmaW5lZE9uKG5hbWVkTm9kZS5ub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYnVpbGQgdGhpcyBpbmRleFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldEl0ZXJhdG9yKE5hbWVkTm9kZS5XcmFwKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Lm5hbWUgIT09IG5hbWVkTm9kZS5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZExpc3QucHVzaChuZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdC5wdXNoKG5hbWVkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkQ2hpbGRTZXQoY2hpbGRMaXN0LCBpbmRleC5nZXRDb21wYXJlKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gY2hhbmdlLCB0aGlzIHJlbWFpbnMgYSBmYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxsYmFja09iamVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU25hcCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5hbWVkTm9kZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdDaGlsZHJlbiA9IGluZGV4ZWRDaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1NuYXApIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IG5ld0NoaWxkcmVuLnJlbW92ZShuZXcgTmFtZWROb2RlKG5hbWVkTm9kZS5uYW1lLCBleGlzdGluZ1NuYXApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZHJlbi5pbnNlcnQobmFtZWROb2RlLCBuYW1lZE5vZGUubm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4TWFwKG5ld0luZGV4ZXMsIHRoaXMuaW5kZXhTZXRfKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IEluZGV4TWFwIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIHZhbHVlIHJlbW92ZWRcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlRnJvbUluZGV4ZXMobmFtZWROb2RlLCBleGlzdGluZ0NoaWxkcmVuKSB7XHJcbiAgICAgICAgY29uc3QgbmV3SW5kZXhlcyA9IG1hcCh0aGlzLmluZGV4ZXNfLCAoaW5kZXhlZENoaWxkcmVuKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleGVkQ2hpbGRyZW4gPT09IGZhbGxiYWNrT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmYWxsYmFjay4gSnVzdCByZXR1cm4gaXQsIG5vdGhpbmcgdG8gZG8gaW4gdGhpcyBjYXNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhlZENoaWxkcmVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdTbmFwID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmFtZWROb2RlLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nU25hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleGVkQ2hpbGRyZW4ucmVtb3ZlKG5ldyBOYW1lZE5vZGUobmFtZWROb2RlLm5hbWUsIGV4aXN0aW5nU25hcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gcmVjb3JkIG9mIHRoaXMgY2hpbGRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhlZENoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE1hcChuZXdJbmRleGVzLCB0aGlzLmluZGV4U2V0Xyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gVE9ETzogRm9yIG1lbW9yeSBzYXZpbmdzLCBkb24ndCBzdG9yZSBwcmlvcml0eU5vZGVfIGlmIGl0J3MgZW1wdHkuXHJcbmxldCBFTVBUWV9OT0RFO1xyXG4vKipcclxuICogQ2hpbGRyZW5Ob2RlIGlzIGEgY2xhc3MgZm9yIHN0b3JpbmcgaW50ZXJuYWwgbm9kZXMgaW4gYSBEYXRhU25hcHNob3RcclxuICogKGkuZS4gbm9kZXMgd2l0aCBjaGlsZHJlbikuICBJdCBpbXBsZW1lbnRzIE5vZGUgYW5kIHN0b3JlcyB0aGVcclxuICogbGlzdCBvZiBjaGlsZHJlbiBpbiB0aGUgY2hpbGRyZW4gcHJvcGVydHksIHNvcnRlZCBieSBjaGlsZCBuYW1lLlxyXG4gKi9cclxuY2xhc3MgQ2hpbGRyZW5Ob2RlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNoaWxkcmVuXyAtIExpc3Qgb2YgY2hpbGRyZW4gb2YgdGhpcyBub2RlLi5cclxuICAgICAqIEBwYXJhbSBwcmlvcml0eU5vZGVfIC0gVGhlIHByaW9yaXR5IG9mIHRoaXMgbm9kZSAoYXMgYSBzbmFwc2hvdCBub2RlKS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW5fLCBwcmlvcml0eU5vZGVfLCBpbmRleE1hcF8pIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuXyA9IGNoaWxkcmVuXztcclxuICAgICAgICB0aGlzLnByaW9yaXR5Tm9kZV8gPSBwcmlvcml0eU5vZGVfO1xyXG4gICAgICAgIHRoaXMuaW5kZXhNYXBfID0gaW5kZXhNYXBfO1xyXG4gICAgICAgIHRoaXMubGF6eUhhc2hfID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOb3RlOiBUaGUgb25seSByZWFzb24gd2UgYWxsb3cgbnVsbCBwcmlvcml0eSBpcyBmb3IgRU1QVFlfTk9ERSwgc2luY2Ugd2UgY2FuJ3QgdXNlXHJcbiAgICAgICAgICogRU1QVFlfTk9ERSBhcyB0aGUgcHJpb3JpdHkgb2YgRU1QVFlfTk9ERS4gIFdlIG1pZ2h0IHdhbnQgdG8gY29uc2lkZXIgbWFraW5nIEVNUFRZX05PREUgaXRzIG93blxyXG4gICAgICAgICAqIGNsYXNzIGluc3RlYWQgb2YgYW4gZW1wdHkgQ2hpbGRyZW5Ob2RlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmICh0aGlzLnByaW9yaXR5Tm9kZV8pIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVQcmlvcml0eU5vZGUodGhpcy5wcmlvcml0eU5vZGVfKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5fLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICBhc3NlcnQoIXRoaXMucHJpb3JpdHlOb2RlXyB8fCB0aGlzLnByaW9yaXR5Tm9kZV8uaXNFbXB0eSgpLCAnQW4gZW1wdHkgbm9kZSBjYW5ub3QgaGF2ZSBhIHByaW9yaXR5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBFTVBUWV9OT0RFKCkge1xyXG4gICAgICAgIHJldHVybiAoRU1QVFlfTk9ERSB8fFxyXG4gICAgICAgICAgICAoRU1QVFlfTk9ERSA9IG5ldyBDaGlsZHJlbk5vZGUobmV3IFNvcnRlZE1hcChOQU1FX0NPTVBBUkFUT1IpLCBudWxsLCBJbmRleE1hcC5EZWZhdWx0KSkpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBpc0xlYWZOb2RlKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0UHJpb3JpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXyB8fCBFTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICB1cGRhdGVQcmlvcml0eShuZXdQcmlvcml0eU5vZGUpIHtcclxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbl8uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIC8vIERvbid0IGFsbG93IHByaW9yaXRpZXMgb24gZW1wdHkgbm9kZXNcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZSh0aGlzLmNoaWxkcmVuXywgbmV3UHJpb3JpdHlOb2RlLCB0aGlzLmluZGV4TWFwXyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICAvLyBIYWNrIHRvIHRyZWF0IHByaW9yaXR5IGFzIGEgcmVndWxhciBjaGlsZFxyXG4gICAgICAgIGlmIChjaGlsZE5hbWUgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFByaW9yaXR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5fLmdldChjaGlsZE5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQgPT09IG51bGwgPyBFTVBUWV9OT0RFIDogY2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRDaGlsZChwYXRoKSB7XHJcbiAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgaWYgKGZyb250ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJbW1lZGlhdGVDaGlsZChmcm9udCkuZ2V0Q2hpbGQocGF0aFBvcEZyb250KHBhdGgpKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgaGFzQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmdldChjaGlsZE5hbWUpICE9PSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICB1cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIG5ld0NoaWxkTm9kZSkge1xyXG4gICAgICAgIGFzc2VydChuZXdDaGlsZE5vZGUsICdXZSBzaG91bGQgYWx3YXlzIGJlIHBhc3Npbmcgc25hcHNob3Qgbm9kZXMnKTtcclxuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVQcmlvcml0eShuZXdDaGlsZE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZWROb2RlID0gbmV3IE5hbWVkTm9kZShjaGlsZE5hbWUsIG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgIGxldCBuZXdDaGlsZHJlbiwgbmV3SW5kZXhNYXA7XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZE5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW5fLnJlbW92ZShjaGlsZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgbmV3SW5kZXhNYXAgPSB0aGlzLmluZGV4TWFwXy5yZW1vdmVGcm9tSW5kZXhlcyhuYW1lZE5vZGUsIHRoaXMuY2hpbGRyZW5fKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbl8uaW5zZXJ0KGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgIG5ld0luZGV4TWFwID0gdGhpcy5pbmRleE1hcF8uYWRkVG9JbmRleGVzKG5hbWVkTm9kZSwgdGhpcy5jaGlsZHJlbl8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ByaW9yaXR5ID0gbmV3Q2hpbGRyZW4uaXNFbXB0eSgpXHJcbiAgICAgICAgICAgICAgICA/IEVNUFRZX05PREVcclxuICAgICAgICAgICAgICAgIDogdGhpcy5wcmlvcml0eU5vZGVfO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZShuZXdDaGlsZHJlbiwgbmV3UHJpb3JpdHksIG5ld0luZGV4TWFwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHVwZGF0ZUNoaWxkKHBhdGgsIG5ld0NoaWxkTm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgICAgIGlmIChmcm9udCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3Q2hpbGROb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0KHBhdGhHZXRGcm9udChwYXRoKSAhPT0gJy5wcmlvcml0eScgfHwgcGF0aEdldExlbmd0aChwYXRoKSA9PT0gMSwgJy5wcmlvcml0eSBtdXN0IGJlIHRoZSBsYXN0IHRva2VuIGluIGEgcGF0aCcpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdJbW1lZGlhdGVDaGlsZCA9IHRoaXMuZ2V0SW1tZWRpYXRlQ2hpbGQoZnJvbnQpLnVwZGF0ZUNoaWxkKHBhdGhQb3BGcm9udChwYXRoKSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW1tZWRpYXRlQ2hpbGQoZnJvbnQsIG5ld0ltbWVkaWF0ZUNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmlzRW1wdHkoKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgbnVtQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmNvdW50KCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHZhbChleHBvcnRGb3JtYXQpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xyXG4gICAgICAgIGxldCBudW1LZXlzID0gMCwgbWF4S2V5ID0gMCwgYWxsSW50ZWdlcktleXMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgb2JqW2tleV0gPSBjaGlsZE5vZGUudmFsKGV4cG9ydEZvcm1hdCk7XHJcbiAgICAgICAgICAgIG51bUtleXMrKztcclxuICAgICAgICAgICAgaWYgKGFsbEludGVnZXJLZXlzICYmIENoaWxkcmVuTm9kZS5JTlRFR0VSX1JFR0VYUF8udGVzdChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhLZXkgPSBNYXRoLm1heChtYXhLZXksIE51bWJlcihrZXkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFsbEludGVnZXJLZXlzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIWV4cG9ydEZvcm1hdCAmJiBhbGxJbnRlZ2VyS2V5cyAmJiBtYXhLZXkgPCAyICogbnVtS2V5cykge1xyXG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRvIGFycmF5LlxyXG4gICAgICAgICAgICBjb25zdCBhcnJheSA9IFtdO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgYXJyYXlba2V5XSA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChleHBvcnRGb3JtYXQgJiYgIXRoaXMuZ2V0UHJpb3JpdHkoKS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIG9ialsnLnByaW9yaXR5J10gPSB0aGlzLmdldFByaW9yaXR5KCkudmFsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGhhc2goKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGF6eUhhc2hfID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxldCB0b0hhc2ggPSAnJztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0b0hhc2ggKz1cclxuICAgICAgICAgICAgICAgICAgICAncHJpb3JpdHk6JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5SGFzaFRleHQodGhpcy5nZXRQcmlvcml0eSgpLnZhbCgpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc6JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGtleSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEhhc2ggPSBjaGlsZE5vZGUuaGFzaCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkSGFzaCAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b0hhc2ggKz0gJzonICsga2V5ICsgJzonICsgY2hpbGRIYXNoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSB0b0hhc2ggPT09ICcnID8gJycgOiBzaGExKHRvSGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmxhenlIYXNoXztcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0UHJlZGVjZXNzb3JDaGlsZE5hbWUoY2hpbGROYW1lLCBjaGlsZE5vZGUsIGluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5yZXNvbHZlSW5kZXhfKGluZGV4KTtcclxuICAgICAgICBpZiAoaWR4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZWRlY2Vzc29yID0gaWR4LmdldFByZWRlY2Vzc29yS2V5KG5ldyBOYW1lZE5vZGUoY2hpbGROYW1lLCBjaGlsZE5vZGUpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByZWRlY2Vzc29yID8gcHJlZGVjZXNzb3IubmFtZSA6IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uZ2V0UHJlZGVjZXNzb3JLZXkoY2hpbGROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRGaXJzdENoaWxkTmFtZShpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXhEZWZpbml0aW9uKTtcclxuICAgICAgICBpZiAoaWR4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbktleSA9IGlkeC5taW5LZXkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1pbktleSAmJiBtaW5LZXkubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXy5taW5LZXkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRGaXJzdENoaWxkKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IG1pbktleSA9IHRoaXMuZ2V0Rmlyc3RDaGlsZE5hbWUoaW5kZXhEZWZpbml0aW9uKTtcclxuICAgICAgICBpZiAobWluS2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKG1pbktleSwgdGhpcy5jaGlsZHJlbl8uZ2V0KG1pbktleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhbiBpbmRleCwgcmV0dXJuIHRoZSBrZXkgbmFtZSBvZiB0aGUgbGFyZ2VzdCB2YWx1ZSB3ZSBoYXZlLCBhY2NvcmRpbmcgdG8gdGhhdCBpbmRleFxyXG4gICAgICovXHJcbiAgICBnZXRMYXN0Q2hpbGROYW1lKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgY29uc3QgbWF4S2V5ID0gaWR4Lm1heEtleSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF4S2V5ICYmIG1heEtleS5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLm1heEtleSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldExhc3RDaGlsZChpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICBjb25zdCBtYXhLZXkgPSB0aGlzLmdldExhc3RDaGlsZE5hbWUoaW5kZXhEZWZpbml0aW9uKTtcclxuICAgICAgICBpZiAobWF4S2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKG1heEtleSwgdGhpcy5jaGlsZHJlbl8uZ2V0KG1heEtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yRWFjaENoaWxkKGluZGV4LCBhY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXgpO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkeC5pbm9yZGVyVHJhdmVyc2FsKHdyYXBwZWROb2RlID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24od3JhcHBlZE5vZGUubmFtZSwgd3JhcHBlZE5vZGUubm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRJdGVyYXRvcihpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVyYXRvckZyb20oaW5kZXhEZWZpbml0aW9uLm1pblBvc3QoKSwgaW5kZXhEZWZpbml0aW9uKTtcclxuICAgIH1cclxuICAgIGdldEl0ZXJhdG9yRnJvbShzdGFydFBvc3QsIGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkeC5nZXRJdGVyYXRvckZyb20oc3RhcnRQb3N0LCBrZXkgPT4ga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5jaGlsZHJlbl8uZ2V0SXRlcmF0b3JGcm9tKHN0YXJ0UG9zdC5uYW1lLCBOYW1lZE5vZGUuV3JhcCk7XHJcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xyXG4gICAgICAgICAgICB3aGlsZSAobmV4dCAhPSBudWxsICYmIGluZGV4RGVmaW5pdGlvbi5jb21wYXJlKG5leHQsIHN0YXJ0UG9zdCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3IoaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShpbmRleERlZmluaXRpb24ubWF4UG9zdCgpLCBpbmRleERlZmluaXRpb24pO1xyXG4gICAgfVxyXG4gICAgZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShlbmRQb3N0LCBpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXhEZWZpbml0aW9uKTtcclxuICAgICAgICBpZiAoaWR4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpZHguZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShlbmRQb3N0LCBrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuY2hpbGRyZW5fLmdldFJldmVyc2VJdGVyYXRvckZyb20oZW5kUG9zdC5uYW1lLCBOYW1lZE5vZGUuV3JhcCk7XHJcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xyXG4gICAgICAgICAgICB3aGlsZSAobmV4dCAhPSBudWxsICYmIGluZGV4RGVmaW5pdGlvbi5jb21wYXJlKG5leHQsIGVuZFBvc3QpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLnBlZWsoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29tcGFyZVRvKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGlmIChvdGhlci5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyLmlzTGVhZk5vZGUoKSB8fCBvdGhlci5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyID09PSBNQVhfTk9ERSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNdXN0IGJlIGFub3RoZXIgbm9kZSB3aXRoIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB3aXRoSW5kZXgoaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgaWYgKGluZGV4RGVmaW5pdGlvbiA9PT0gS0VZX0lOREVYIHx8XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBfLmhhc0luZGV4KGluZGV4RGVmaW5pdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleE1hcCA9IHRoaXMuaW5kZXhNYXBfLmFkZEluZGV4KGluZGV4RGVmaW5pdGlvbiwgdGhpcy5jaGlsZHJlbl8pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZSh0aGlzLmNoaWxkcmVuXywgdGhpcy5wcmlvcml0eU5vZGVfLCBuZXdJbmRleE1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNJbmRleGVkKGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSBLRVlfSU5ERVggfHwgdGhpcy5pbmRleE1hcF8uaGFzSW5kZXgoaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvdGhlci5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgb3RoZXJDaGlsZHJlbk5vZGUgPSBvdGhlcjtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldFByaW9yaXR5KCkuZXF1YWxzKG90aGVyQ2hpbGRyZW5Ob2RlLmdldFByaW9yaXR5KCkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jaGlsZHJlbl8uY291bnQoKSA9PT0gb3RoZXJDaGlsZHJlbk5vZGUuY2hpbGRyZW5fLmNvdW50KCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNJdGVyID0gdGhpcy5nZXRJdGVyYXRvcihQUklPUklUWV9JTkRFWCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdGhlckl0ZXIgPSBvdGhlckNoaWxkcmVuTm9kZS5nZXRJdGVyYXRvcihQUklPUklUWV9JTkRFWCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGhpc0N1cnJlbnQgPSB0aGlzSXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXJDdXJyZW50ID0gb3RoZXJJdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzQ3VycmVudCAmJiBvdGhlckN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc0N1cnJlbnQubmFtZSAhPT0gb3RoZXJDdXJyZW50Lm5hbWUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXNDdXJyZW50Lm5vZGUuZXF1YWxzKG90aGVyQ3VycmVudC5ub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNDdXJyZW50ID0gdGhpc0l0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG90aGVyQ3VycmVudCA9IG90aGVySXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0N1cnJlbnQgPT09IG51bGwgJiYgb3RoZXJDdXJyZW50ID09PSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgU29ydGVkTWFwIG9yZGVyZWQgYnkgaW5kZXgsIG9yIG51bGwgaWYgdGhlIGRlZmF1bHQgKGJ5LWtleSkgb3JkZXJpbmcgY2FuIGJlIHVzZWRcclxuICAgICAqIGluc3RlYWQuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICByZXNvbHZlSW5kZXhfKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGlmIChpbmRleERlZmluaXRpb24gPT09IEtFWV9JTkRFWCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4TWFwXy5nZXQoaW5kZXhEZWZpbml0aW9uLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5DaGlsZHJlbk5vZGUuSU5URUdFUl9SRUdFWFBfID0gL14oMHxbMS05XVxcZCopJC87XHJcbmNsYXNzIE1heE5vZGUgZXh0ZW5kcyBDaGlsZHJlbk5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIobmV3IFNvcnRlZE1hcChOQU1FX0NPTVBBUkFUT1IpLCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgSW5kZXhNYXAuRGVmYXVsdCk7XHJcbiAgICB9XHJcbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICAvLyBOb3QgdGhhdCB3ZSBldmVyeSBjb21wYXJlIGl0LCBidXQgTUFYX05PREUgaXMgb25seSBldmVyIGVxdWFsIHRvIGl0c2VsZlxyXG4gICAgICAgIHJldHVybiBvdGhlciA9PT0gdGhpcztcclxuICAgIH1cclxuICAgIGdldFByaW9yaXR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE1hcmtlciB0aGF0IHdpbGwgc29ydCBoaWdoZXIgdGhhbiBhbnkgb3RoZXIgc25hcHNob3QuXHJcbiAqL1xyXG5jb25zdCBNQVhfTk9ERSA9IG5ldyBNYXhOb2RlKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE5hbWVkTm9kZSwge1xyXG4gICAgTUlOOiB7XHJcbiAgICAgICAgdmFsdWU6IG5ldyBOYW1lZE5vZGUoTUlOX05BTUUsIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKVxyXG4gICAgfSxcclxuICAgIE1BWDoge1xyXG4gICAgICAgIHZhbHVlOiBuZXcgTmFtZWROb2RlKE1BWF9OQU1FLCBNQVhfTk9ERSlcclxuICAgIH1cclxufSk7XHJcbi8qKlxyXG4gKiBSZWZlcmVuY2UgRXh0ZW5zaW9uc1xyXG4gKi9cclxuS2V5SW5kZXguX19FTVBUWV9OT0RFID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbkxlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IgPSBDaGlsZHJlbk5vZGU7XHJcbnNldE1heE5vZGUkMShNQVhfTk9ERSk7XHJcbnNldE1heE5vZGUoTUFYX05PREUpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBVU0VfSElOWkUgPSB0cnVlO1xyXG4vKipcclxuICogQ29uc3RydWN0cyBhIHNuYXBzaG90IG5vZGUgcmVwcmVzZW50aW5nIHRoZSBwYXNzZWQgSlNPTiBhbmQgcmV0dXJucyBpdC5cclxuICogQHBhcmFtIGpzb24gLSBKU09OIHRvIGNyZWF0ZSBhIG5vZGUgZm9yLlxyXG4gKiBAcGFyYW0gcHJpb3JpdHkgLSBPcHRpb25hbCBwcmlvcml0eSB0byB1c2UuICBUaGlzIHdpbGwgYmUgaWdub3JlZCBpZiB0aGVcclxuICogcGFzc2VkIEpTT04gY29udGFpbnMgYSAucHJpb3JpdHkgcHJvcGVydHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBub2RlRnJvbUpTT04oanNvbiwgcHJpb3JpdHkgPSBudWxsKSB7XHJcbiAgICBpZiAoanNvbiA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ29iamVjdCcgJiYgJy5wcmlvcml0eScgaW4ganNvbikge1xyXG4gICAgICAgIHByaW9yaXR5ID0ganNvblsnLnByaW9yaXR5J107XHJcbiAgICB9XHJcbiAgICBhc3NlcnQocHJpb3JpdHkgPT09IG51bGwgfHxcclxuICAgICAgICB0eXBlb2YgcHJpb3JpdHkgPT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgdHlwZW9mIHByaW9yaXR5ID09PSAnbnVtYmVyJyB8fFxyXG4gICAgICAgICh0eXBlb2YgcHJpb3JpdHkgPT09ICdvYmplY3QnICYmICcuc3YnIGluIHByaW9yaXR5KSwgJ0ludmFsaWQgcHJpb3JpdHkgdHlwZSBmb3VuZDogJyArIHR5cGVvZiBwcmlvcml0eSk7XHJcbiAgICBpZiAodHlwZW9mIGpzb24gPT09ICdvYmplY3QnICYmICcudmFsdWUnIGluIGpzb24gJiYganNvblsnLnZhbHVlJ10gIT09IG51bGwpIHtcclxuICAgICAgICBqc29uID0ganNvblsnLnZhbHVlJ107XHJcbiAgICB9XHJcbiAgICAvLyBWYWxpZCBsZWFmIG5vZGVzIGluY2x1ZGUgbm9uLW9iamVjdHMgb3Igc2VydmVyLXZhbHVlIHdyYXBwZXIgb2JqZWN0c1xyXG4gICAgaWYgKHR5cGVvZiBqc29uICE9PSAnb2JqZWN0JyB8fCAnLnN2JyBpbiBqc29uKSB7XHJcbiAgICAgICAgY29uc3QganNvbkxlYWYgPSBqc29uO1xyXG4gICAgICAgIHJldHVybiBuZXcgTGVhZk5vZGUoanNvbkxlYWYsIG5vZGVGcm9tSlNPTihwcmlvcml0eSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKCEoanNvbiBpbnN0YW5jZW9mIEFycmF5KSAmJiBVU0VfSElOWkUpIHtcclxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIGxldCBjaGlsZHJlbkhhdmVQcmlvcml0eSA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGhpbnplSnNvbk9iaiA9IGpzb247XHJcbiAgICAgICAgZWFjaChoaW56ZUpzb25PYmosIChrZXksIGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChrZXkuc3Vic3RyaW5nKDAsIDEpICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBtZXRhZGF0YSBub2Rlc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gbm9kZUZyb21KU09OKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIGlmICghY2hpbGROb2RlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuSGF2ZVByaW9yaXR5ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5IYXZlUHJpb3JpdHkgfHwgIWNoaWxkTm9kZS5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBOYW1lZE5vZGUoa2V5LCBjaGlsZE5vZGUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGlsZFNldCA9IGJ1aWxkQ2hpbGRTZXQoY2hpbGRyZW4sIE5BTUVfT05MWV9DT01QQVJBVE9SLCBuYW1lZE5vZGUgPT4gbmFtZWROb2RlLm5hbWUsIE5BTUVfQ09NUEFSQVRPUik7XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuSGF2ZVByaW9yaXR5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZENoaWxkU2V0ID0gYnVpbGRDaGlsZFNldChjaGlsZHJlbiwgUFJJT1JJVFlfSU5ERVguZ2V0Q29tcGFyZSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGlsZHJlbk5vZGUoY2hpbGRTZXQsIG5vZGVGcm9tSlNPTihwcmlvcml0eSksIG5ldyBJbmRleE1hcCh7ICcucHJpb3JpdHknOiBzb3J0ZWRDaGlsZFNldCB9LCB7ICcucHJpb3JpdHknOiBQUklPUklUWV9JTkRFWCB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZShjaGlsZFNldCwgbm9kZUZyb21KU09OKHByaW9yaXR5KSwgSW5kZXhNYXAuRGVmYXVsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICBlYWNoKGpzb24sIChrZXksIGNoaWxkRGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY29udGFpbnMoanNvbiwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdWJzdHJpbmcoMCwgMSkgIT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBtZXRhZGF0YSBub2Rlcy5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBub2RlRnJvbUpTT04oY2hpbGREYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLmlzTGVhZk5vZGUoKSB8fCAhY2hpbGROb2RlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS51cGRhdGVJbW1lZGlhdGVDaGlsZChrZXksIGNoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUudXBkYXRlUHJpb3JpdHkobm9kZUZyb21KU09OKHByaW9yaXR5KSk7XHJcbiAgICB9XHJcbn1cclxuc2V0Tm9kZUZyb21KU09OKG5vZGVGcm9tSlNPTik7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFBhdGhJbmRleCBleHRlbmRzIEluZGV4IHtcclxuICAgIGNvbnN0cnVjdG9yKGluZGV4UGF0aF8pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhQYXRoXyA9IGluZGV4UGF0aF87XHJcbiAgICAgICAgYXNzZXJ0KCFwYXRoSXNFbXB0eShpbmRleFBhdGhfKSAmJiBwYXRoR2V0RnJvbnQoaW5kZXhQYXRoXykgIT09ICcucHJpb3JpdHknLCBcIkNhbid0IGNyZWF0ZSBQYXRoSW5kZXggd2l0aCBlbXB0eSBwYXRoIG9yIC5wcmlvcml0eSBrZXlcIik7XHJcbiAgICB9XHJcbiAgICBleHRyYWN0Q2hpbGQoc25hcCkge1xyXG4gICAgICAgIHJldHVybiBzbmFwLmdldENoaWxkKHRoaXMuaW5kZXhQYXRoXyk7XHJcbiAgICB9XHJcbiAgICBpc0RlZmluZWRPbihub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuICFub2RlLmdldENoaWxkKHRoaXMuaW5kZXhQYXRoXykuaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgY29uc3QgYUNoaWxkID0gdGhpcy5leHRyYWN0Q2hpbGQoYS5ub2RlKTtcclxuICAgICAgICBjb25zdCBiQ2hpbGQgPSB0aGlzLmV4dHJhY3RDaGlsZChiLm5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGluZGV4Q21wID0gYUNoaWxkLmNvbXBhcmVUbyhiQ2hpbGQpO1xyXG4gICAgICAgIGlmIChpbmRleENtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZUNvbXBhcmUoYS5uYW1lLCBiLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4Q21wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1ha2VQb3N0KGluZGV4VmFsdWUsIG5hbWUpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSBub2RlRnJvbUpTT04oaW5kZXhWYWx1ZSk7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLnVwZGF0ZUNoaWxkKHRoaXMuaW5kZXhQYXRoXywgdmFsdWVOb2RlKTtcclxuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShuYW1lLCBub2RlKTtcclxuICAgIH1cclxuICAgIG1heFBvc3QoKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLnVwZGF0ZUNoaWxkKHRoaXMuaW5kZXhQYXRoXywgTUFYX05PREUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKE1BWF9OQU1FLCBub2RlKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBwYXRoU2xpY2UodGhpcy5pbmRleFBhdGhfLCAwKS5qb2luKCcvJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgVmFsdWVJbmRleCBleHRlbmRzIEluZGV4IHtcclxuICAgIGNvbXBhcmUoYSwgYikge1xyXG4gICAgICAgIGNvbnN0IGluZGV4Q21wID0gYS5ub2RlLmNvbXBhcmVUbyhiLm5vZGUpO1xyXG4gICAgICAgIGlmIChpbmRleENtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZUNvbXBhcmUoYS5uYW1lLCBiLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4Q21wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzRGVmaW5lZE9uKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGluZGV4ZWRWYWx1ZUNoYW5nZWQob2xkTm9kZSwgbmV3Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiAhb2xkTm9kZS5lcXVhbHMobmV3Tm9kZSk7XHJcbiAgICB9XHJcbiAgICBtaW5Qb3N0KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NSU47XHJcbiAgICB9XHJcbiAgICBtYXhQb3N0KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NQVg7XHJcbiAgICB9XHJcbiAgICBtYWtlUG9zdChpbmRleFZhbHVlLCBuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gbm9kZUZyb21KU09OKGluZGV4VmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKG5hbWUsIHZhbHVlTm9kZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgaW5jbHVzaW9uIGluIGEgcXVlcnkgc3BlY1xyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gJy52YWx1ZSc7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgVkFMVUVfSU5ERVggPSBuZXcgVmFsdWVJbmRleCgpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGFuZ2VWYWx1ZShzbmFwc2hvdE5vZGUpIHtcclxuICAgIHJldHVybiB7IHR5cGU6IFwidmFsdWVcIiAvKiBDaGFuZ2VUeXBlLlZBTFVFICovLCBzbmFwc2hvdE5vZGUgfTtcclxufVxyXG5mdW5jdGlvbiBjaGFuZ2VDaGlsZEFkZGVkKGNoaWxkTmFtZSwgc25hcHNob3ROb2RlKSB7XHJcbiAgICByZXR1cm4geyB0eXBlOiBcImNoaWxkX2FkZGVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9BRERFRCAqLywgc25hcHNob3ROb2RlLCBjaGlsZE5hbWUgfTtcclxufVxyXG5mdW5jdGlvbiBjaGFuZ2VDaGlsZFJlbW92ZWQoY2hpbGROYW1lLCBzbmFwc2hvdE5vZGUpIHtcclxuICAgIHJldHVybiB7IHR5cGU6IFwiY2hpbGRfcmVtb3ZlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfUkVNT1ZFRCAqLywgc25hcHNob3ROb2RlLCBjaGlsZE5hbWUgfTtcclxufVxyXG5mdW5jdGlvbiBjaGFuZ2VDaGlsZENoYW5nZWQoY2hpbGROYW1lLCBzbmFwc2hvdE5vZGUsIG9sZFNuYXApIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9DSEFOR0VEICovLFxyXG4gICAgICAgIHNuYXBzaG90Tm9kZSxcclxuICAgICAgICBjaGlsZE5hbWUsXHJcbiAgICAgICAgb2xkU25hcFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjaGFuZ2VDaGlsZE1vdmVkKGNoaWxkTmFtZSwgc25hcHNob3ROb2RlKSB7XHJcbiAgICByZXR1cm4geyB0eXBlOiBcImNoaWxkX21vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9NT1ZFRCAqLywgc25hcHNob3ROb2RlLCBjaGlsZE5hbWUgfTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRG9lc24ndCByZWFsbHkgZmlsdGVyIG5vZGVzIGJ1dCBhcHBsaWVzIGFuIGluZGV4IHRvIHRoZSBub2RlIGFuZCBrZWVwcyB0cmFjayBvZiBhbnkgY2hhbmdlc1xyXG4gKi9cclxuY2xhc3MgSW5kZXhlZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihpbmRleF8pIHtcclxuICAgICAgICB0aGlzLmluZGV4XyA9IGluZGV4XztcclxuICAgIH1cclxuICAgIHVwZGF0ZUNoaWxkKHNuYXAsIGtleSwgbmV3Q2hpbGQsIGFmZmVjdGVkUGF0aCwgc291cmNlLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xyXG4gICAgICAgIGFzc2VydChzbmFwLmlzSW5kZXhlZCh0aGlzLmluZGV4XyksICdBIG5vZGUgbXVzdCBiZSBpbmRleGVkIGlmIG9ubHkgYSBjaGlsZCBpcyB1cGRhdGVkJyk7XHJcbiAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBzbmFwLmdldEltbWVkaWF0ZUNoaWxkKGtleSk7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55dGhpbmcgYWN0dWFsbHkgY2hhbmdlZC5cclxuICAgICAgICBpZiAob2xkQ2hpbGQuZ2V0Q2hpbGQoYWZmZWN0ZWRQYXRoKS5lcXVhbHMobmV3Q2hpbGQuZ2V0Q2hpbGQoYWZmZWN0ZWRQYXRoKSkpIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUncyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBjaGlsZCBjYW4gZW50ZXIgb3IgbGVhdmUgdGhlIHZpZXcgYmVjYXVzZSBhZmZlY3RlZFBhdGggd2FzIHNldCB0byBudWxsLlxyXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIGFmZmVjdGVkUGF0aCB3aWxsIGFwcGVhciBudWxsIGluIGJvdGggdGhlIG9sZCBhbmQgbmV3IHNuYXBzaG90cy4gIFNvIHdlIG5lZWRcclxuICAgICAgICAgICAgLy8gdG8gYXZvaWQgdHJlYXRpbmcgdGhlc2UgY2FzZXMgYXMgXCJub3RoaW5nIGNoYW5nZWQuXCJcclxuICAgICAgICAgICAgaWYgKG9sZENoaWxkLmlzRW1wdHkoKSA9PT0gbmV3Q2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIGNoYW5nZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFzc2VydCBzaG91bGQgYmUgdmFsaWQsIGJ1dCBpdCdzIGV4cGVuc2l2ZSAoY2FuIGRvbWluYXRlIHBlcmYgdGVzdGluZykgc28gZG9uJ3QgYWN0dWFsbHkgZG8gaXQuXHJcbiAgICAgICAgICAgICAgICAvL2Fzc2VydChvbGRDaGlsZC5lcXVhbHMobmV3Q2hpbGQpLCAnT2xkIGFuZCBuZXcgc25hcHNob3RzIHNob3VsZCBiZSBlcXVhbC4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRDaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzbmFwLmhhc0NoaWxkKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkUmVtb3ZlZChrZXksIG9sZENoaWxkKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc25hcC5pc0xlYWZOb2RlKCksICdBIGNoaWxkIHJlbW92ZSB3aXRob3V0IGFuIG9sZCBjaGlsZCBvbmx5IG1ha2VzIHNlbnNlIG9uIGEgbGVhZiBub2RlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob2xkQ2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQWRkZWQoa2V5LCBuZXdDaGlsZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZENoYW5nZWQoa2V5LCBuZXdDaGlsZCwgb2xkQ2hpbGQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc25hcC5pc0xlYWZOb2RlKCkgJiYgbmV3Q2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBub2RlIGlzIGluZGV4ZWRcclxuICAgICAgICAgICAgcmV0dXJuIHNuYXAudXBkYXRlSW1tZWRpYXRlQ2hpbGQoa2V5LCBuZXdDaGlsZCkud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBuZXdTbmFwLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xyXG4gICAgICAgIGlmIChvcHRDaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICghb2xkU25hcC5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgIG9sZFNuYXAuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1NuYXAuaGFzQ2hpbGQoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkUmVtb3ZlZChrZXksIGNoaWxkTm9kZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbmV3U25hcC5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgIG5ld1NuYXAuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2xkU25hcC5oYXNDaGlsZChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkID0gb2xkU25hcC5nZXRJbW1lZGlhdGVDaGlsZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZENoaWxkLmVxdWFscyhjaGlsZE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQ2hhbmdlZChrZXksIGNoaWxkTm9kZSwgb2xkQ2hpbGQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZEFkZGVkKGtleSwgY2hpbGROb2RlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld1NuYXAud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVByaW9yaXR5KG9sZFNuYXAsIG5ld1ByaW9yaXR5KSB7XHJcbiAgICAgICAgaWYgKG9sZFNuYXAuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvbGRTbmFwLnVwZGF0ZVByaW9yaXR5KG5ld1ByaW9yaXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmaWx0ZXJzTm9kZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXhlZEZpbHRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGdldEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRmlsdGVycyBub2RlcyBieSByYW5nZSBhbmQgdXNlcyBhbiBJbmRleEZpbHRlciB0byB0cmFjayBhbnkgY2hhbmdlcyBhZnRlciBmaWx0ZXJpbmcgdGhlIG5vZGVcclxuICovXHJcbmNsYXNzIFJhbmdlZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcclxuICAgICAgICB0aGlzLmluZGV4ZWRGaWx0ZXJfID0gbmV3IEluZGV4ZWRGaWx0ZXIocGFyYW1zLmdldEluZGV4KCkpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhfID0gcGFyYW1zLmdldEluZGV4KCk7XHJcbiAgICAgICAgdGhpcy5zdGFydFBvc3RfID0gUmFuZ2VkRmlsdGVyLmdldFN0YXJ0UG9zdF8ocGFyYW1zKTtcclxuICAgICAgICB0aGlzLmVuZFBvc3RfID0gUmFuZ2VkRmlsdGVyLmdldEVuZFBvc3RfKHBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5zdGFydElzSW5jbHVzaXZlXyA9ICFwYXJhbXMuc3RhcnRBZnRlclNldF87XHJcbiAgICAgICAgdGhpcy5lbmRJc0luY2x1c2l2ZV8gPSAhcGFyYW1zLmVuZEJlZm9yZVNldF87XHJcbiAgICB9XHJcbiAgICBnZXRTdGFydFBvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRQb3N0XztcclxuICAgIH1cclxuICAgIGdldEVuZFBvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kUG9zdF87XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKG5vZGUpIHtcclxuICAgICAgICBjb25zdCBpc1dpdGhpblN0YXJ0ID0gdGhpcy5zdGFydElzSW5jbHVzaXZlX1xyXG4gICAgICAgICAgICA/IHRoaXMuaW5kZXhfLmNvbXBhcmUodGhpcy5nZXRTdGFydFBvc3QoKSwgbm9kZSkgPD0gMFxyXG4gICAgICAgICAgICA6IHRoaXMuaW5kZXhfLmNvbXBhcmUodGhpcy5nZXRTdGFydFBvc3QoKSwgbm9kZSkgPCAwO1xyXG4gICAgICAgIGNvbnN0IGlzV2l0aGluRW5kID0gdGhpcy5lbmRJc0luY2x1c2l2ZV9cclxuICAgICAgICAgICAgPyB0aGlzLmluZGV4Xy5jb21wYXJlKG5vZGUsIHRoaXMuZ2V0RW5kUG9zdCgpKSA8PSAwXHJcbiAgICAgICAgICAgIDogdGhpcy5pbmRleF8uY29tcGFyZShub2RlLCB0aGlzLmdldEVuZFBvc3QoKSkgPCAwO1xyXG4gICAgICAgIHJldHVybiBpc1dpdGhpblN0YXJ0ICYmIGlzV2l0aGluRW5kO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ2hpbGQoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm1hdGNoZXMobmV3IE5hbWVkTm9kZShrZXksIG5ld0NoaWxkKSkpIHtcclxuICAgICAgICAgICAgbmV3Q2hpbGQgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhlZEZpbHRlcl8udXBkYXRlQ2hpbGQoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUZ1bGxOb2RlKG9sZFNuYXAsIG5ld1NuYXAsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgaWYgKG5ld1NuYXAuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgY2hpbGRyZW4gbm9kZSB3aXRoIHRoZSBjb3JyZWN0IGluZGV4LCBub3QgYSBsZWFmIG5vZGU7XHJcbiAgICAgICAgICAgIG5ld1NuYXAgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGZpbHRlcmVkID0gbmV3U25hcC53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xyXG4gICAgICAgIC8vIERvbid0IHN1cHBvcnQgcHJpb3JpdGllcyBvbiBxdWVyaWVzXHJcbiAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVQcmlvcml0eShDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgbmV3U25hcC5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChrZXksIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXNlbGYubWF0Y2hlcyhuZXcgTmFtZWROb2RlKGtleSwgY2hpbGROb2RlKSkpIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQudXBkYXRlSW1tZWRpYXRlQ2hpbGQoa2V5LCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleGVkRmlsdGVyXy51cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBmaWx0ZXJlZCwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUHJpb3JpdHkob2xkU25hcCwgbmV3UHJpb3JpdHkpIHtcclxuICAgICAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xyXG4gICAgICAgIHJldHVybiBvbGRTbmFwO1xyXG4gICAgfVxyXG4gICAgZmlsdGVyc05vZGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXhlZEZpbHRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleGVkRmlsdGVyXztcclxuICAgIH1cclxuICAgIGdldEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRTdGFydFBvc3RfKHBhcmFtcykge1xyXG4gICAgICAgIGlmIChwYXJhbXMuaGFzU3RhcnQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydE5hbWUgPSBwYXJhbXMuZ2V0SW5kZXhTdGFydE5hbWUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5nZXRJbmRleCgpLm1ha2VQb3N0KHBhcmFtcy5nZXRJbmRleFN0YXJ0VmFsdWUoKSwgc3RhcnROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuZ2V0SW5kZXgoKS5taW5Qb3N0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldEVuZFBvc3RfKHBhcmFtcykge1xyXG4gICAgICAgIGlmIChwYXJhbXMuaGFzRW5kKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgZW5kTmFtZSA9IHBhcmFtcy5nZXRJbmRleEVuZE5hbWUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5nZXRJbmRleCgpLm1ha2VQb3N0KHBhcmFtcy5nZXRJbmRleEVuZFZhbHVlKCksIGVuZE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5nZXRJbmRleCgpLm1heFBvc3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSBsaW1pdCBhbmQgYSByYW5nZSB0byBhIG5vZGUgYW5kIHVzZXMgUmFuZ2VkRmlsdGVyIHRvIGRvIHRoZSBoZWF2eSBsaWZ0aW5nIHdoZXJlIHBvc3NpYmxlXHJcbiAqL1xyXG5jbGFzcyBMaW1pdGVkRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xyXG4gICAgICAgIHRoaXMud2l0aGluRGlyZWN0aW9uYWxTdGFydCA9IChub2RlKSA9PiB0aGlzLnJldmVyc2VfID8gdGhpcy53aXRoaW5FbmRQb3N0KG5vZGUpIDogdGhpcy53aXRoaW5TdGFydFBvc3Qobm9kZSk7XHJcbiAgICAgICAgdGhpcy53aXRoaW5EaXJlY3Rpb25hbEVuZCA9IChub2RlKSA9PiB0aGlzLnJldmVyc2VfID8gdGhpcy53aXRoaW5TdGFydFBvc3Qobm9kZSkgOiB0aGlzLndpdGhpbkVuZFBvc3Qobm9kZSk7XHJcbiAgICAgICAgdGhpcy53aXRoaW5TdGFydFBvc3QgPSAobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb21wYXJlUmVzID0gdGhpcy5pbmRleF8uY29tcGFyZSh0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0U3RhcnRQb3N0KCksIG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydElzSW5jbHVzaXZlXyA/IGNvbXBhcmVSZXMgPD0gMCA6IGNvbXBhcmVSZXMgPCAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy53aXRoaW5FbmRQb3N0ID0gKG5vZGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29tcGFyZVJlcyA9IHRoaXMuaW5kZXhfLmNvbXBhcmUobm9kZSwgdGhpcy5yYW5nZWRGaWx0ZXJfLmdldEVuZFBvc3QoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZElzSW5jbHVzaXZlXyA/IGNvbXBhcmVSZXMgPD0gMCA6IGNvbXBhcmVSZXMgPCAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5yYW5nZWRGaWx0ZXJfID0gbmV3IFJhbmdlZEZpbHRlcihwYXJhbXMpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhfID0gcGFyYW1zLmdldEluZGV4KCk7XHJcbiAgICAgICAgdGhpcy5saW1pdF8gPSBwYXJhbXMuZ2V0TGltaXQoKTtcclxuICAgICAgICB0aGlzLnJldmVyc2VfID0gIXBhcmFtcy5pc1ZpZXdGcm9tTGVmdCgpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRJc0luY2x1c2l2ZV8gPSAhcGFyYW1zLnN0YXJ0QWZ0ZXJTZXRfO1xyXG4gICAgICAgIHRoaXMuZW5kSXNJbmNsdXNpdmVfID0gIXBhcmFtcy5lbmRCZWZvcmVTZXRfO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ2hpbGQoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJhbmdlZEZpbHRlcl8ubWF0Y2hlcyhuZXcgTmFtZWROb2RlKGtleSwgbmV3Q2hpbGQpKSkge1xyXG4gICAgICAgICAgICBuZXdDaGlsZCA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc25hcC5nZXRJbW1lZGlhdGVDaGlsZChrZXkpLmVxdWFscyhuZXdDaGlsZCkpIHtcclxuICAgICAgICAgICAgLy8gTm8gY2hhbmdlXHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzbmFwLm51bUNoaWxkcmVuKCkgPCB0aGlzLmxpbWl0Xykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYW5nZWRGaWx0ZXJfXHJcbiAgICAgICAgICAgICAgICAuZ2V0SW5kZXhlZEZpbHRlcigpXHJcbiAgICAgICAgICAgICAgICAudXBkYXRlQ2hpbGQoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bGxMaW1pdFVwZGF0ZUNoaWxkXyhzbmFwLCBrZXksIG5ld0NoaWxkLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBuZXdTbmFwLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xyXG4gICAgICAgIGxldCBmaWx0ZXJlZDtcclxuICAgICAgICBpZiAobmV3U25hcC5pc0xlYWZOb2RlKCkgfHwgbmV3U25hcC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBjaGlsZHJlbiBub2RlIHdpdGggdGhlIGNvcnJlY3QgaW5kZXgsIG5vdCBhIGxlYWYgbm9kZTtcclxuICAgICAgICAgICAgZmlsdGVyZWQgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERS53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGltaXRfICogMiA8IG5ld1NuYXAubnVtQ2hpbGRyZW4oKSAmJlxyXG4gICAgICAgICAgICAgICAgbmV3U25hcC5pc0luZGV4ZWQodGhpcy5pbmRleF8pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFYXNpZXIgdG8gYnVpbGQgdXAgYSBzbmFwc2hvdCwgc2luY2Ugd2hhdCB3ZSdyZSBnaXZlbiBoYXMgbW9yZSB0aGFuIHR3aWNlIHRoZSBlbGVtZW50cyB3ZSB3YW50XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgICAgICAgICAvLyBhbmNob3IgdG8gdGhlIHN0YXJ0UG9zdCwgZW5kUG9zdCwgb3IgbGFzdCBlbGVtZW50IGFzIGFwcHJvcHJpYXRlXHJcbiAgICAgICAgICAgICAgICBsZXQgaXRlcmF0b3I7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXZlcnNlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gbmV3U25hcC5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tKHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRFbmRQb3N0KCksIHRoaXMuaW5kZXhfKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gbmV3U25hcC5nZXRJdGVyYXRvckZyb20odGhpcy5yYW5nZWRGaWx0ZXJfLmdldFN0YXJ0UG9zdCgpLCB0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGl0ZXJhdG9yLmhhc05leHQoKSAmJiBjb3VudCA8IHRoaXMubGltaXRfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMud2l0aGluRGlyZWN0aW9uYWxTdGFydChuZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIG5vdCByZWFjaGVkIHRoZSBzdGFydCwgc2tpcCB0byB0aGUgbmV4dCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy53aXRoaW5EaXJlY3Rpb25hbEVuZChuZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCwgc3RvcCBhZGRpbmcgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5leHQubmFtZSwgbmV4dC5ub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgc25hcCBjb250YWlucyBsZXNzIHRoYW4gdHdpY2UgdGhlIGxpbWl0LiBGYXN0ZXIgdG8gZGVsZXRlIGZyb20gdGhlIHNuYXAgdGhhbiBidWlsZCB1cCBhIG5ldyBvbmVcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gbmV3U25hcC53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xyXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3Qgc3VwcG9ydCBwcmlvcml0aWVzIG9uIHF1ZXJpZXNcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQudXBkYXRlUHJpb3JpdHkoQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGl0ZXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmV2ZXJzZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9IGZpbHRlcmVkLmdldFJldmVyc2VJdGVyYXRvcih0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9IGZpbHRlcmVkLmdldEl0ZXJhdG9yKHRoaXMuaW5kZXhfKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXRlcmF0b3IuaGFzTmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpblJhbmdlID0gY291bnQgPCB0aGlzLmxpbWl0XyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndpdGhpbkRpcmVjdGlvbmFsU3RhcnQobmV4dCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53aXRoaW5EaXJlY3Rpb25hbEVuZChuZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5SYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVJbW1lZGlhdGVDaGlsZChuZXh0Lm5hbWUsIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VkRmlsdGVyX1xyXG4gICAgICAgICAgICAuZ2V0SW5kZXhlZEZpbHRlcigpXHJcbiAgICAgICAgICAgIC51cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBmaWx0ZXJlZCwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUHJpb3JpdHkob2xkU25hcCwgbmV3UHJpb3JpdHkpIHtcclxuICAgICAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xyXG4gICAgICAgIHJldHVybiBvbGRTbmFwO1xyXG4gICAgfVxyXG4gICAgZmlsdGVyc05vZGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXhlZEZpbHRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZWRGaWx0ZXJfLmdldEluZGV4ZWRGaWx0ZXIoKTtcclxuICAgIH1cclxuICAgIGdldEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcclxuICAgIH1cclxuICAgIGZ1bGxMaW1pdFVwZGF0ZUNoaWxkXyhzbmFwLCBjaGlsZEtleSwgY2hpbGRTbmFwLCBzb3VyY2UsIGNoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgLy8gVE9ETzogcmVuYW1lIGFsbCBjYWNoZSBzdHVmZiBldGMgdG8gZ2VuZXJhbCBzbmFwIHRlcm1pbm9sb2d5XHJcbiAgICAgICAgbGV0IGNtcDtcclxuICAgICAgICBpZiAodGhpcy5yZXZlcnNlXykge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleENtcCA9IHRoaXMuaW5kZXhfLmdldENvbXBhcmUoKTtcclxuICAgICAgICAgICAgY21wID0gKGEsIGIpID0+IGluZGV4Q21wKGIsIGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY21wID0gdGhpcy5pbmRleF8uZ2V0Q29tcGFyZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvbGRFdmVudENhY2hlID0gc25hcDtcclxuICAgICAgICBhc3NlcnQob2xkRXZlbnRDYWNoZS5udW1DaGlsZHJlbigpID09PSB0aGlzLmxpbWl0XywgJycpO1xyXG4gICAgICAgIGNvbnN0IG5ld0NoaWxkTmFtZWROb2RlID0gbmV3IE5hbWVkTm9kZShjaGlsZEtleSwgY2hpbGRTbmFwKTtcclxuICAgICAgICBjb25zdCB3aW5kb3dCb3VuZGFyeSA9IHRoaXMucmV2ZXJzZV9cclxuICAgICAgICAgICAgPyBvbGRFdmVudENhY2hlLmdldEZpcnN0Q2hpbGQodGhpcy5pbmRleF8pXHJcbiAgICAgICAgICAgIDogb2xkRXZlbnRDYWNoZS5nZXRMYXN0Q2hpbGQodGhpcy5pbmRleF8pO1xyXG4gICAgICAgIGNvbnN0IGluUmFuZ2UgPSB0aGlzLnJhbmdlZEZpbHRlcl8ubWF0Y2hlcyhuZXdDaGlsZE5hbWVkTm9kZSk7XHJcbiAgICAgICAgaWYgKG9sZEV2ZW50Q2FjaGUuaGFzQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkU25hcCA9IG9sZEV2ZW50Q2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICBsZXQgbmV4dENoaWxkID0gc291cmNlLmdldENoaWxkQWZ0ZXJDaGlsZCh0aGlzLmluZGV4Xywgd2luZG93Qm91bmRhcnksIHRoaXMucmV2ZXJzZV8pO1xyXG4gICAgICAgICAgICB3aGlsZSAobmV4dENoaWxkICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIChuZXh0Q2hpbGQubmFtZSA9PT0gY2hpbGRLZXkgfHwgb2xkRXZlbnRDYWNoZS5oYXNDaGlsZChuZXh0Q2hpbGQubmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBhIHdlaXJkIGVkZ2UgY2FzZSB3aGVyZSBhIG5vZGUgaXMgdXBkYXRlZCBhcyBwYXJ0IG9mIGEgbWVyZ2UgaW4gdGhlIHdyaXRlIHRyZWUsIGJ1dCBoYXNuJ3RcclxuICAgICAgICAgICAgICAgIC8vIGJlZW4gYXBwbGllZCB0byB0aGUgbGltaXRlZCBmaWx0ZXIgeWV0LiBJZ25vcmUgdGhpcyBuZXh0IGNoaWxkIHdoaWNoIHdpbGwgYmUgdXBkYXRlZCBsYXRlciBpblxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxpbWl0ZWQgZmlsdGVyLi4uXHJcbiAgICAgICAgICAgICAgICBuZXh0Q2hpbGQgPSBzb3VyY2UuZ2V0Q2hpbGRBZnRlckNoaWxkKHRoaXMuaW5kZXhfLCBuZXh0Q2hpbGQsIHRoaXMucmV2ZXJzZV8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBhcmVOZXh0ID0gbmV4dENoaWxkID09IG51bGwgPyAxIDogY21wKG5leHRDaGlsZCwgbmV3Q2hpbGROYW1lZE5vZGUpO1xyXG4gICAgICAgICAgICBjb25zdCByZW1haW5zSW5XaW5kb3cgPSBpblJhbmdlICYmICFjaGlsZFNuYXAuaXNFbXB0eSgpICYmIGNvbXBhcmVOZXh0ID49IDA7XHJcbiAgICAgICAgICAgIGlmIChyZW1haW5zSW5XaW5kb3cpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZENoYW5nZWQoY2hpbGRLZXksIGNoaWxkU25hcCwgb2xkQ2hpbGRTbmFwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkRXZlbnRDYWNoZS51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZEtleSwgY2hpbGRTbmFwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZFJlbW92ZWQoY2hpbGRLZXksIG9sZENoaWxkU25hcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50Q2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXksIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZEluUmFuZ2UgPSBuZXh0Q2hpbGQgIT0gbnVsbCAmJiB0aGlzLnJhbmdlZEZpbHRlcl8ubWF0Y2hlcyhuZXh0Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZEluUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQWRkZWQobmV4dENoaWxkLm5hbWUsIG5leHRDaGlsZC5ub2RlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdFdmVudENhY2hlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5leHRDaGlsZC5uYW1lLCBuZXh0Q2hpbGQubm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3RXZlbnRDYWNoZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGlsZFNuYXAuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIC8vIHdlJ3JlIGRlbGV0aW5nIGEgbm9kZSwgYnV0IGl0IHdhcyBub3QgaW4gdGhlIHdpbmRvdywgc28gaWdub3JlIGl0XHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpblJhbmdlKSB7XHJcbiAgICAgICAgICAgIGlmIChjbXAod2luZG93Qm91bmRhcnksIG5ld0NoaWxkTmFtZWROb2RlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlQ2hpbGRSZW1vdmVkKHdpbmRvd0JvdW5kYXJ5Lm5hbWUsIHdpbmRvd0JvdW5kYXJ5Lm5vZGUpKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQWRkZWQoY2hpbGRLZXksIGNoaWxkU25hcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZEV2ZW50Q2FjaGVcclxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXksIGNoaWxkU25hcClcclxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlSW1tZWRpYXRlQ2hpbGQod2luZG93Qm91bmRhcnkubmFtZSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyBjbGFzcyBpcyBhbiBpbW11dGFibGUtZnJvbS10aGUtcHVibGljLWFwaSBzdHJ1Y3QgY29udGFpbmluZyBhIHNldCBvZiBxdWVyeSBwYXJhbWV0ZXJzIGRlZmluaW5nIGFcclxuICogcmFuZ2UgdG8gYmUgcmV0dXJuZWQgZm9yIGEgcGFydGljdWxhciBsb2NhdGlvbi4gSXQgaXMgYXNzdW1lZCB0aGF0IHZhbGlkYXRpb24gb2YgcGFyYW1ldGVycyBpcyBkb25lIGF0IHRoZVxyXG4gKiB1c2VyLWZhY2luZyBBUEkgbGV2ZWwsIHNvIGl0IGlzIG5vdCBkb25lIGhlcmUuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgUXVlcnlQYXJhbXMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5saW1pdFNldF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnN0YXJ0U2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RhcnROYW1lU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RhcnRBZnRlclNldF8gPSBmYWxzZTsgLy8gY2FuIG9ubHkgYmUgdHJ1ZSBpZiBzdGFydFNldF8gaXMgdHJ1ZVxyXG4gICAgICAgIHRoaXMuZW5kU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZW5kTmFtZVNldF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVuZEJlZm9yZVNldF8gPSBmYWxzZTsgLy8gY2FuIG9ubHkgYmUgdHJ1ZSBpZiBlbmRTZXRfIGlzIHRydWVcclxuICAgICAgICB0aGlzLmxpbWl0XyA9IDA7XHJcbiAgICAgICAgdGhpcy52aWV3RnJvbV8gPSAnJztcclxuICAgICAgICB0aGlzLmluZGV4U3RhcnRWYWx1ZV8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kZXhTdGFydE5hbWVfID0gJyc7XHJcbiAgICAgICAgdGhpcy5pbmRleEVuZFZhbHVlXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleEVuZE5hbWVfID0gJyc7XHJcbiAgICAgICAgdGhpcy5pbmRleF8gPSBQUklPUklUWV9JTkRFWDtcclxuICAgIH1cclxuICAgIGhhc1N0YXJ0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0U2V0XztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBpdCB3b3VsZCByZXR1cm4gZnJvbSBsZWZ0LlxyXG4gICAgICovXHJcbiAgICBpc1ZpZXdGcm9tTGVmdCgpIHtcclxuICAgICAgICBpZiAodGhpcy52aWV3RnJvbV8gPT09ICcnKSB7XHJcbiAgICAgICAgICAgIC8vIGxpbWl0KCksIHJhdGhlciB0aGFuIGxpbWl0VG9GaXJzdCBvciBsaW1pdFRvTGFzdCB3YXMgY2FsbGVkLlxyXG4gICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgb25seSBvbmUgb2Ygc3RhcnRTZXRfIGFuZCBlbmRTZXRfIGlzIHRydWUuIFVzZSB0aGVtXHJcbiAgICAgICAgICAgIC8vIHRvIGNhbGN1bGF0ZSB3aGljaCBzaWRlIG9mIHRoZSB2aWV3IHRvIGFuY2hvciB0by4gSWYgbmVpdGhlciBpcyBzZXQsXHJcbiAgICAgICAgICAgIC8vIGFuY2hvciB0byB0aGUgZW5kLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydFNldF87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3RnJvbV8gPT09IFwibFwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLlZJRVdfRlJPTV9MRUZUICovO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT25seSB2YWxpZCB0byBjYWxsIGlmIGhhc1N0YXJ0KCkgcmV0dXJucyB0cnVlXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4U3RhcnRWYWx1ZSgpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5zdGFydFNldF8sICdPbmx5IHZhbGlkIGlmIHN0YXJ0IGhhcyBiZWVuIHNldCcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4U3RhcnRWYWx1ZV87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNTdGFydCgpIHJldHVybnMgdHJ1ZS5cclxuICAgICAqIFJldHVybnMgdGhlIHN0YXJ0aW5nIGtleSBuYW1lIGZvciB0aGUgcmFuZ2UgZGVmaW5lZCBieSB0aGVzZSBxdWVyeSBwYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4U3RhcnROYW1lKCkge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLnN0YXJ0U2V0XywgJ09ubHkgdmFsaWQgaWYgc3RhcnQgaGFzIGJlZW4gc2V0Jyk7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhcnROYW1lU2V0Xykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleFN0YXJ0TmFtZV87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTUlOX05BTUU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFzRW5kKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZFNldF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNFbmQoKSByZXR1cm5zIHRydWUuXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4RW5kVmFsdWUoKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuZW5kU2V0XywgJ09ubHkgdmFsaWQgaWYgZW5kIGhhcyBiZWVuIHNldCcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4RW5kVmFsdWVfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPbmx5IHZhbGlkIHRvIGNhbGwgaWYgaGFzRW5kKCkgcmV0dXJucyB0cnVlLlxyXG4gICAgICogUmV0dXJucyB0aGUgZW5kIGtleSBuYW1lIGZvciB0aGUgcmFuZ2UgZGVmaW5lZCBieSB0aGVzZSBxdWVyeSBwYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4RW5kTmFtZSgpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5lbmRTZXRfLCAnT25seSB2YWxpZCBpZiBlbmQgaGFzIGJlZW4gc2V0Jyk7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5kTmFtZVNldF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhFbmROYW1lXztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNQVhfTkFNRTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYXNMaW1pdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saW1pdFNldF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgYSBsaW1pdCBoYXMgYmVlbiBzZXQgYW5kIGl0IGhhcyBiZWVuIGV4cGxpY2l0bHkgYW5jaG9yZWRcclxuICAgICAqL1xyXG4gICAgaGFzQW5jaG9yZWRMaW1pdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saW1pdFNldF8gJiYgdGhpcy52aWV3RnJvbV8gIT09ICcnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPbmx5IHZhbGlkIHRvIGNhbGwgaWYgaGFzTGltaXQoKSByZXR1cm5zIHRydWVcclxuICAgICAqL1xyXG4gICAgZ2V0TGltaXQoKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMubGltaXRTZXRfLCAnT25seSB2YWxpZCBpZiBsaW1pdCBoYXMgYmVlbiBzZXQnKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5saW1pdF87XHJcbiAgICB9XHJcbiAgICBnZXRJbmRleCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleF87XHJcbiAgICB9XHJcbiAgICBsb2Fkc0FsbERhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuICEodGhpcy5zdGFydFNldF8gfHwgdGhpcy5lbmRTZXRfIHx8IHRoaXMubGltaXRTZXRfKTtcclxuICAgIH1cclxuICAgIGlzRGVmYXVsdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2Fkc0FsbERhdGEoKSAmJiB0aGlzLmluZGV4XyA9PT0gUFJJT1JJVFlfSU5ERVg7XHJcbiAgICB9XHJcbiAgICBjb3B5KCkge1xyXG4gICAgICAgIGNvbnN0IGNvcHkgPSBuZXcgUXVlcnlQYXJhbXMoKTtcclxuICAgICAgICBjb3B5LmxpbWl0U2V0XyA9IHRoaXMubGltaXRTZXRfO1xyXG4gICAgICAgIGNvcHkubGltaXRfID0gdGhpcy5saW1pdF87XHJcbiAgICAgICAgY29weS5zdGFydFNldF8gPSB0aGlzLnN0YXJ0U2V0XztcclxuICAgICAgICBjb3B5LnN0YXJ0QWZ0ZXJTZXRfID0gdGhpcy5zdGFydEFmdGVyU2V0XztcclxuICAgICAgICBjb3B5LmluZGV4U3RhcnRWYWx1ZV8gPSB0aGlzLmluZGV4U3RhcnRWYWx1ZV87XHJcbiAgICAgICAgY29weS5zdGFydE5hbWVTZXRfID0gdGhpcy5zdGFydE5hbWVTZXRfO1xyXG4gICAgICAgIGNvcHkuaW5kZXhTdGFydE5hbWVfID0gdGhpcy5pbmRleFN0YXJ0TmFtZV87XHJcbiAgICAgICAgY29weS5lbmRTZXRfID0gdGhpcy5lbmRTZXRfO1xyXG4gICAgICAgIGNvcHkuZW5kQmVmb3JlU2V0XyA9IHRoaXMuZW5kQmVmb3JlU2V0XztcclxuICAgICAgICBjb3B5LmluZGV4RW5kVmFsdWVfID0gdGhpcy5pbmRleEVuZFZhbHVlXztcclxuICAgICAgICBjb3B5LmVuZE5hbWVTZXRfID0gdGhpcy5lbmROYW1lU2V0XztcclxuICAgICAgICBjb3B5LmluZGV4RW5kTmFtZV8gPSB0aGlzLmluZGV4RW5kTmFtZV87XHJcbiAgICAgICAgY29weS5pbmRleF8gPSB0aGlzLmluZGV4XztcclxuICAgICAgICBjb3B5LnZpZXdGcm9tXyA9IHRoaXMudmlld0Zyb21fO1xyXG4gICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5UGFyYW1zR2V0Tm9kZUZpbHRlcihxdWVyeVBhcmFtcykge1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleGVkRmlsdGVyKHF1ZXJ5UGFyYW1zLmdldEluZGV4KCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocXVlcnlQYXJhbXMuaGFzTGltaXQoKSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGltaXRlZEZpbHRlcihxdWVyeVBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlZEZpbHRlcihxdWVyeVBhcmFtcyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNMaW1pdFRvRmlyc3QocXVlcnlQYXJhbXMsIG5ld0xpbWl0KSB7XHJcbiAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtcy5jb3B5KCk7XHJcbiAgICBuZXdQYXJhbXMubGltaXRTZXRfID0gdHJ1ZTtcclxuICAgIG5ld1BhcmFtcy5saW1pdF8gPSBuZXdMaW1pdDtcclxuICAgIG5ld1BhcmFtcy52aWV3RnJvbV8gPSBcImxcIiAvKiBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5WSUVXX0ZST01fTEVGVCAqLztcclxuICAgIHJldHVybiBuZXdQYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNMaW1pdFRvTGFzdChxdWVyeVBhcmFtcywgbmV3TGltaXQpIHtcclxuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zLmNvcHkoKTtcclxuICAgIG5ld1BhcmFtcy5saW1pdFNldF8gPSB0cnVlO1xyXG4gICAgbmV3UGFyYW1zLmxpbWl0XyA9IG5ld0xpbWl0O1xyXG4gICAgbmV3UGFyYW1zLnZpZXdGcm9tXyA9IFwiclwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLlZJRVdfRlJPTV9SSUdIVCAqLztcclxuICAgIHJldHVybiBuZXdQYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNTdGFydEF0KHF1ZXJ5UGFyYW1zLCBpbmRleFZhbHVlLCBrZXkpIHtcclxuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zLmNvcHkoKTtcclxuICAgIG5ld1BhcmFtcy5zdGFydFNldF8gPSB0cnVlO1xyXG4gICAgaWYgKGluZGV4VmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGluZGV4VmFsdWUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgbmV3UGFyYW1zLmluZGV4U3RhcnRWYWx1ZV8gPSBpbmRleFZhbHVlO1xyXG4gICAgaWYgKGtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgbmV3UGFyYW1zLnN0YXJ0TmFtZVNldF8gPSB0cnVlO1xyXG4gICAgICAgIG5ld1BhcmFtcy5pbmRleFN0YXJ0TmFtZV8gPSBrZXk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBuZXdQYXJhbXMuc3RhcnROYW1lU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIG5ld1BhcmFtcy5pbmRleFN0YXJ0TmFtZV8gPSAnJztcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdQYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNTdGFydEFmdGVyKHF1ZXJ5UGFyYW1zLCBpbmRleFZhbHVlLCBrZXkpIHtcclxuICAgIGxldCBwYXJhbXM7XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuaW5kZXhfID09PSBLRVlfSU5ERVggfHwgISFrZXkpIHtcclxuICAgICAgICBwYXJhbXMgPSBxdWVyeVBhcmFtc1N0YXJ0QXQocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIGtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwYXJhbXMgPSBxdWVyeVBhcmFtc1N0YXJ0QXQocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIE1BWF9OQU1FKTtcclxuICAgIH1cclxuICAgIHBhcmFtcy5zdGFydEFmdGVyU2V0XyA9IHRydWU7XHJcbiAgICByZXR1cm4gcGFyYW1zO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5UGFyYW1zRW5kQXQocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIGtleSkge1xyXG4gICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXMuY29weSgpO1xyXG4gICAgbmV3UGFyYW1zLmVuZFNldF8gPSB0cnVlO1xyXG4gICAgaWYgKGluZGV4VmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGluZGV4VmFsdWUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgbmV3UGFyYW1zLmluZGV4RW5kVmFsdWVfID0gaW5kZXhWYWx1ZTtcclxuICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG5ld1BhcmFtcy5lbmROYW1lU2V0XyA9IHRydWU7XHJcbiAgICAgICAgbmV3UGFyYW1zLmluZGV4RW5kTmFtZV8gPSBrZXk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBuZXdQYXJhbXMuZW5kTmFtZVNldF8gPSBmYWxzZTtcclxuICAgICAgICBuZXdQYXJhbXMuaW5kZXhFbmROYW1lXyA9ICcnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1BhcmFtcztcclxufVxyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc0VuZEJlZm9yZShxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwga2V5KSB7XHJcbiAgICBsZXQgcGFyYW1zO1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmluZGV4XyA9PT0gS0VZX0lOREVYIHx8ICEha2V5KSB7XHJcbiAgICAgICAgcGFyYW1zID0gcXVlcnlQYXJhbXNFbmRBdChxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwga2V5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHBhcmFtcyA9IHF1ZXJ5UGFyYW1zRW5kQXQocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIE1JTl9OQU1FKTtcclxuICAgIH1cclxuICAgIHBhcmFtcy5lbmRCZWZvcmVTZXRfID0gdHJ1ZTtcclxuICAgIHJldHVybiBwYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNPcmRlckJ5KHF1ZXJ5UGFyYW1zLCBpbmRleCkge1xyXG4gICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXMuY29weSgpO1xyXG4gICAgbmV3UGFyYW1zLmluZGV4XyA9IGluZGV4O1xyXG4gICAgcmV0dXJuIG5ld1BhcmFtcztcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHNldCBvZiBSRVNUIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzIHJlcHJlc2VudGluZyB0aGlzIHF1ZXJ5LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBxdWVyeSBzdHJpbmcgcGFyYW1ldGVyc1xyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNUb1Jlc3RRdWVyeVN0cmluZ1BhcmFtZXRlcnMocXVlcnlQYXJhbXMpIHtcclxuICAgIGNvbnN0IHFzID0ge307XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuaXNEZWZhdWx0KCkpIHtcclxuICAgICAgICByZXR1cm4gcXM7XHJcbiAgICB9XHJcbiAgICBsZXQgb3JkZXJCeTtcclxuICAgIGlmIChxdWVyeVBhcmFtcy5pbmRleF8gPT09IFBSSU9SSVRZX0lOREVYKSB7XHJcbiAgICAgICAgb3JkZXJCeSA9IFwiJHByaW9yaXR5XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuUFJJT1JJVFlfSU5ERVggKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChxdWVyeVBhcmFtcy5pbmRleF8gPT09IFZBTFVFX0lOREVYKSB7XHJcbiAgICAgICAgb3JkZXJCeSA9IFwiJHZhbHVlXCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuVkFMVUVfSU5ERVggKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChxdWVyeVBhcmFtcy5pbmRleF8gPT09IEtFWV9JTkRFWCkge1xyXG4gICAgICAgIG9yZGVyQnkgPSBcIiRrZXlcIiAvKiBSRVNUX1FVRVJZX0NPTlNUQU5UUy5LRVlfSU5ERVggKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhc3NlcnQocXVlcnlQYXJhbXMuaW5kZXhfIGluc3RhbmNlb2YgUGF0aEluZGV4LCAnVW5yZWNvZ25pemVkIGluZGV4IHR5cGUhJyk7XHJcbiAgICAgICAgb3JkZXJCeSA9IHF1ZXJ5UGFyYW1zLmluZGV4Xy50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgcXNbXCJvcmRlckJ5XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuT1JERVJfQlkgKi9dID0gc3RyaW5naWZ5KG9yZGVyQnkpO1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLnN0YXJ0U2V0Xykge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0UGFyYW0gPSBxdWVyeVBhcmFtcy5zdGFydEFmdGVyU2V0X1xyXG4gICAgICAgICAgICA/IFwic3RhcnRBZnRlclwiIC8qIFJFU1RfUVVFUllfQ09OU1RBTlRTLlNUQVJUX0FGVEVSICovXHJcbiAgICAgICAgICAgIDogXCJzdGFydEF0XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuU1RBUlRfQVQgKi87XHJcbiAgICAgICAgcXNbc3RhcnRQYXJhbV0gPSBzdHJpbmdpZnkocXVlcnlQYXJhbXMuaW5kZXhTdGFydFZhbHVlXyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLnN0YXJ0TmFtZVNldF8pIHtcclxuICAgICAgICAgICAgcXNbc3RhcnRQYXJhbV0gKz0gJywnICsgc3RyaW5naWZ5KHF1ZXJ5UGFyYW1zLmluZGV4U3RhcnROYW1lXyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmVuZFNldF8pIHtcclxuICAgICAgICBjb25zdCBlbmRQYXJhbSA9IHF1ZXJ5UGFyYW1zLmVuZEJlZm9yZVNldF9cclxuICAgICAgICAgICAgPyBcImVuZEJlZm9yZVwiIC8qIFJFU1RfUVVFUllfQ09OU1RBTlRTLkVORF9CRUZPUkUgKi9cclxuICAgICAgICAgICAgOiBcImVuZEF0XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuRU5EX0FUICovO1xyXG4gICAgICAgIHFzW2VuZFBhcmFtXSA9IHN0cmluZ2lmeShxdWVyeVBhcmFtcy5pbmRleEVuZFZhbHVlXyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLmVuZE5hbWVTZXRfKSB7XHJcbiAgICAgICAgICAgIHFzW2VuZFBhcmFtXSArPSAnLCcgKyBzdHJpbmdpZnkocXVlcnlQYXJhbXMuaW5kZXhFbmROYW1lXyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmxpbWl0U2V0Xykge1xyXG4gICAgICAgIGlmIChxdWVyeVBhcmFtcy5pc1ZpZXdGcm9tTGVmdCgpKSB7XHJcbiAgICAgICAgICAgIHFzW1wibGltaXRUb0ZpcnN0XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuTElNSVRfVE9fRklSU1QgKi9dID0gcXVlcnlQYXJhbXMubGltaXRfO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcXNbXCJsaW1pdFRvTGFzdFwiIC8qIFJFU1RfUVVFUllfQ09OU1RBTlRTLkxJTUlUX1RPX0xBU1QgKi9dID0gcXVlcnlQYXJhbXMubGltaXRfO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBxcztcclxufVxyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc0dldFF1ZXJ5T2JqZWN0KHF1ZXJ5UGFyYW1zKSB7XHJcbiAgICBjb25zdCBvYmogPSB7fTtcclxuICAgIGlmIChxdWVyeVBhcmFtcy5zdGFydFNldF8pIHtcclxuICAgICAgICBvYmpbXCJzcFwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX1NUQVJUX1ZBTFVFICovXSA9XHJcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmluZGV4U3RhcnRWYWx1ZV87XHJcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLnN0YXJ0TmFtZVNldF8pIHtcclxuICAgICAgICAgICAgb2JqW1wic25cIiAvKiBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5JTkRFWF9TVEFSVF9OQU1FICovXSA9XHJcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5pbmRleFN0YXJ0TmFtZV87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ialtcInNpblwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX1NUQVJUX0lTX0lOQ0xVU0lWRSAqL10gPVxyXG4gICAgICAgICAgICAhcXVlcnlQYXJhbXMuc3RhcnRBZnRlclNldF87XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuZW5kU2V0Xykge1xyXG4gICAgICAgIG9ialtcImVwXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVhfRU5EX1ZBTFVFICovXSA9IHF1ZXJ5UGFyYW1zLmluZGV4RW5kVmFsdWVfO1xyXG4gICAgICAgIGlmIChxdWVyeVBhcmFtcy5lbmROYW1lU2V0Xykge1xyXG4gICAgICAgICAgICBvYmpbXCJlblwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX0VORF9OQU1FICovXSA9IHF1ZXJ5UGFyYW1zLmluZGV4RW5kTmFtZV87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ialtcImVpblwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX0VORF9JU19JTkNMVVNJVkUgKi9dID1cclxuICAgICAgICAgICAgIXF1ZXJ5UGFyYW1zLmVuZEJlZm9yZVNldF87XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnlQYXJhbXMubGltaXRTZXRfKSB7XHJcbiAgICAgICAgb2JqW1wibFwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLkxJTUlUICovXSA9IHF1ZXJ5UGFyYW1zLmxpbWl0XztcclxuICAgICAgICBsZXQgdmlld0Zyb20gPSBxdWVyeVBhcmFtcy52aWV3RnJvbV87XHJcbiAgICAgICAgaWYgKHZpZXdGcm9tID09PSAnJykge1xyXG4gICAgICAgICAgICBpZiAocXVlcnlQYXJhbXMuaXNWaWV3RnJvbUxlZnQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmlld0Zyb20gPSBcImxcIiAvKiBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5WSUVXX0ZST01fTEVGVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gXCJyXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuVklFV19GUk9NX1JJR0hUICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ialtcInZmXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuVklFV19GUk9NICovXSA9IHZpZXdGcm9tO1xyXG4gICAgfVxyXG4gICAgLy8gRm9yIG5vdywgcHJpb3JpdHkgaW5kZXggaXMgdGhlIGRlZmF1bHQsIHNvIHdlIG9ubHkgc3BlY2lmeSBpZiBpdCdzIHNvbWUgb3RoZXIgaW5kZXhcclxuICAgIGlmIChxdWVyeVBhcmFtcy5pbmRleF8gIT09IFBSSU9SSVRZX0lOREVYKSB7XHJcbiAgICAgICAgb2JqW1wiaVwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYICovXSA9IHF1ZXJ5UGFyYW1zLmluZGV4Xy50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iajtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgU2VydmVyQWN0aW9ucyB0aGF0IGNvbW11bmljYXRlcyB3aXRoIHRoZSBzZXJ2ZXIgdmlhIFJFU1QgcmVxdWVzdHMuXHJcbiAqIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGNyYXdsZXJzLCB3aGVyZSB3ZSBkb24ndCB3YW50IHRvIHNwaW4gdXAgYSBmdWxsXHJcbiAqIHBlcnNpc3RlbnQgY29ubmVjdGlvbiAodXNpbmcgV2ViU29ja2V0cyBvciBsb25nLXBvbGxpbmcpXHJcbiAqL1xyXG5jbGFzcyBSZWFkb25seVJlc3RDbGllbnQgZXh0ZW5kcyBTZXJ2ZXJBY3Rpb25zIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvXyAtIERhdGEgYWJvdXQgdGhlIG5hbWVzcGFjZSB3ZSBhcmUgY29ubmVjdGluZyB0b1xyXG4gICAgICogQHBhcmFtIG9uRGF0YVVwZGF0ZV8gLSBBIGNhbGxiYWNrIGZvciBuZXcgZGF0YSBmcm9tIHRoZSBzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocmVwb0luZm9fLCBvbkRhdGFVcGRhdGVfLCBhdXRoVG9rZW5Qcm92aWRlcl8sIGFwcENoZWNrVG9rZW5Qcm92aWRlcl8pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xyXG4gICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyA9IG9uRGF0YVVwZGF0ZV87XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl8gPSBhdXRoVG9rZW5Qcm92aWRlcl87XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuUHJvdmlkZXJfID0gYXBwQ2hlY2tUb2tlblByb3ZpZGVyXztcclxuICAgICAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKC4uLlsqXSl9ICovXHJcbiAgICAgICAgdGhpcy5sb2dfID0gbG9nV3JhcHBlcigncDpyZXN0OicpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdlIGRvbid0IGFjdHVhbGx5IG5lZWQgdG8gdHJhY2sgbGlzdGVucywgZXhjZXB0IHRvIHByZXZlbnQgdXMgY2FsbGluZyBhbiBvbkNvbXBsZXRlIGZvciBhIGxpc3RlblxyXG4gICAgICAgICAqIHRoYXQncyBiZWVuIHJlbW92ZWQuIDotL1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGlzdGVuc18gPSB7fTtcclxuICAgIH1cclxuICAgIHJlcG9ydFN0YXRzKHN0YXRzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldExpc3RlbklkXyhxdWVyeSwgdGFnKSB7XHJcbiAgICAgICAgaWYgKHRhZyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAndGFnJCcgKyB0YWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnQocXVlcnkuX3F1ZXJ5UGFyYW1zLmlzRGVmYXVsdCgpLCBcInNob3VsZCBoYXZlIGEgdGFnIGlmIGl0J3Mgbm90IGEgZGVmYXVsdCBxdWVyeS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgbGlzdGVuKHF1ZXJ5LCBjdXJyZW50SGFzaEZuLCB0YWcsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICBjb25zdCBwYXRoU3RyaW5nID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmxvZ18oJ0xpc3RlbiBjYWxsZWQgZm9yICcgKyBwYXRoU3RyaW5nICsgJyAnICsgcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcik7XHJcbiAgICAgICAgLy8gTWFyayB0aGlzIGxpc3RlbmVyIHNvIHdlIGNhbiB0ZWxsIGlmIGl0J3MgcmVtb3ZlZC5cclxuICAgICAgICBjb25zdCBsaXN0ZW5JZCA9IFJlYWRvbmx5UmVzdENsaWVudC5nZXRMaXN0ZW5JZF8ocXVlcnksIHRhZyk7XHJcbiAgICAgICAgY29uc3QgdGhpc0xpc3RlbiA9IHt9O1xyXG4gICAgICAgIHRoaXMubGlzdGVuc19bbGlzdGVuSWRdID0gdGhpc0xpc3RlbjtcclxuICAgICAgICBjb25zdCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMgPSBxdWVyeVBhcmFtc1RvUmVzdFF1ZXJ5U3RyaW5nUGFyYW1ldGVycyhxdWVyeS5fcXVlcnlQYXJhbXMpO1xyXG4gICAgICAgIHRoaXMucmVzdFJlcXVlc3RfKHBhdGhTdHJpbmcgKyAnLmpzb24nLCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMsIChlcnJvciwgcmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gcmVzdWx0O1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09IDQwNCkge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBlcnJvciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVycm9yID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8ocGF0aFN0cmluZywgZGF0YSwgLyppc01lcmdlPSovIGZhbHNlLCB0YWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzYWZlR2V0KHRoaXMubGlzdGVuc18sIGxpc3RlbklkKSA9PT0gdGhpc0xpc3Rlbikge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXR1cztcclxuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAnb2snO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgPT09IDQwMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9ICdwZXJtaXNzaW9uX2RlbmllZCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAncmVzdF9lcnJvcjonICsgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKHN0YXR1cywgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdW5saXN0ZW4ocXVlcnksIHRhZykge1xyXG4gICAgICAgIGNvbnN0IGxpc3RlbklkID0gUmVhZG9ubHlSZXN0Q2xpZW50LmdldExpc3RlbklkXyhxdWVyeSwgdGFnKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5saXN0ZW5zX1tsaXN0ZW5JZF07XHJcbiAgICB9XHJcbiAgICBnZXQocXVlcnkpIHtcclxuICAgICAgICBjb25zdCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMgPSBxdWVyeVBhcmFtc1RvUmVzdFF1ZXJ5U3RyaW5nUGFyYW1ldGVycyhxdWVyeS5fcXVlcnlQYXJhbXMpO1xyXG4gICAgICAgIGNvbnN0IHBhdGhTdHJpbmcgPSBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgdGhpcy5yZXN0UmVxdWVzdF8ocGF0aFN0cmluZyArICcuanNvbicsIHF1ZXJ5U3RyaW5nUGFyYW1ldGVycywgKGVycm9yLCByZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIGlmIChlcnJvciA9PT0gNDA0KSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyhwYXRoU3RyaW5nLCBkYXRhLCBcclxuICAgICAgICAgICAgICAgIC8qaXNNZXJnZT0qLyBmYWxzZSwgXHJcbiAgICAgICAgICAgICAgICAvKnRhZz0qLyBudWxsKTtcclxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QobmV3IEVycm9yKGRhdGEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICByZWZyZXNoQXV0aFRva2VuKHRva2VuKSB7XHJcbiAgICAgICAgLy8gbm8tb3Agc2luY2Ugd2UganVzdCBhbHdheXMgY2FsbCBnZXRUb2tlbi5cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgYSBSRVNUIHJlcXVlc3QgdG8gdGhlIGdpdmVuIHBhdGgsIHdpdGggdGhlIHByb3ZpZGVkIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzLFxyXG4gICAgICogYW5kIGFueSBhdXRoIGNyZWRlbnRpYWxzIHdlIGhhdmUuXHJcbiAgICAgKi9cclxuICAgIHJlc3RSZXF1ZXN0XyhwYXRoU3RyaW5nLCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMgPSB7fSwgY2FsbGJhY2spIHtcclxuICAgICAgICBxdWVyeVN0cmluZ1BhcmFtZXRlcnNbJ2Zvcm1hdCddID0gJ2V4cG9ydCc7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl8uZ2V0VG9rZW4oLypmb3JjZVJlZnJlc2g9Ki8gZmFsc2UpLFxyXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5Qcm92aWRlcl8uZ2V0VG9rZW4oLypmb3JjZVJlZnJlc2g9Ki8gZmFsc2UpXHJcbiAgICAgICAgXSkudGhlbigoW2F1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbl0pID0+IHtcclxuICAgICAgICAgICAgaWYgKGF1dGhUb2tlbiAmJiBhdXRoVG9rZW4uYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nUGFyYW1ldGVyc1snYXV0aCddID0gYXV0aFRva2VuLmFjY2Vzc1Rva2VuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhcHBDaGVja1Rva2VuICYmIGFwcENoZWNrVG9rZW4udG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nUGFyYW1ldGVyc1snYWMnXSA9IGFwcENoZWNrVG9rZW4udG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdXJsID0gKHRoaXMucmVwb0luZm9fLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLycpICtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwb0luZm9fLmhvc3QgK1xyXG4gICAgICAgICAgICAgICAgcGF0aFN0cmluZyArXHJcbiAgICAgICAgICAgICAgICAnPycgK1xyXG4gICAgICAgICAgICAgICAgJ25zPScgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvSW5mb18ubmFtZXNwYWNlICtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nKHF1ZXJ5U3RyaW5nUGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnU2VuZGluZyBSRVNUIHJlcXVlc3QgZm9yICcgKyB1cmwpO1xyXG4gICAgICAgICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiB4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nXygnUkVTVCBSZXNwb25zZSBmb3IgJyArIHVybCArICcgcmVjZWl2ZWQuIHN0YXR1czonLCB4aHIuc3RhdHVzLCAncmVzcG9uc2U6JywgeGhyLnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGpzb25FdmFsKHhoci5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuKCdGYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZSBmb3IgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnOiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gNDAxIGFuZCA0MDQgYXJlIGV4cGVjdGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyAhPT0gNDAxICYmIHhoci5zdGF0dXMgIT09IDQwNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybignR290IHVuc3VjY2Vzc2Z1bCBSRVNUIHJlc3BvbnNlIGZvciAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgU3RhdHVzOiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh4aHIuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCAvKmFzeW5jaHJvbm91cz0qLyB0cnVlKTtcclxuICAgICAgICAgICAgeGhyLnNlbmQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogTXV0YWJsZSBvYmplY3Qgd2hpY2ggYmFzaWNhbGx5IGp1c3Qgc3RvcmVzIGEgcmVmZXJlbmNlIHRvIHRoZSBcImxhdGVzdFwiIGltbXV0YWJsZSBzbmFwc2hvdC5cclxuICovXHJcbmNsYXNzIFNuYXBzaG90SG9sZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucm9vdE5vZGVfID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICB9XHJcbiAgICBnZXROb2RlKHBhdGgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Tm9kZV8uZ2V0Q2hpbGQocGF0aCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTbmFwc2hvdChwYXRoLCBuZXdTbmFwc2hvdE5vZGUpIHtcclxuICAgICAgICB0aGlzLnJvb3ROb2RlXyA9IHRoaXMucm9vdE5vZGVfLnVwZGF0ZUNoaWxkKHBhdGgsIG5ld1NuYXBzaG90Tm9kZSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3U3BhcnNlU25hcHNob3RUcmVlKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2YWx1ZTogbnVsbCxcclxuICAgICAgICBjaGlsZHJlbjogbmV3IE1hcCgpXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBTdG9yZXMgdGhlIGdpdmVuIG5vZGUgYXQgdGhlIHNwZWNpZmllZCBwYXRoLiBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgbm9kZVxyXG4gKiBhdCBhIHNoYWxsb3dlciBwYXRoLCBpdCBtZXJnZXMgdGhlIG5ldyBkYXRhIGludG8gdGhhdCBzbmFwc2hvdCBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFBhdGggdG8gbG9vayB1cCBzbmFwc2hvdCBmb3IuXHJcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIG5ldyBkYXRhLCBvciBudWxsLlxyXG4gKi9cclxuZnVuY3Rpb24gc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIoc3BhcnNlU25hcHNob3RUcmVlLCBwYXRoLCBkYXRhKSB7XHJcbiAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgPSBkYXRhO1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlID0gc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlLnVwZGF0ZUNoaWxkKHBhdGgsIGRhdGEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgaWYgKCFzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uaGFzKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uc2V0KGNoaWxkS2V5LCBuZXdTcGFyc2VTbmFwc2hvdFRyZWUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmdldChjaGlsZEtleSk7XHJcbiAgICAgICAgcGF0aCA9IHBhdGhQb3BGcm9udChwYXRoKTtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlcihjaGlsZCwgcGF0aCwgZGF0YSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFB1cmdlIHRoZSBkYXRhIGF0IHBhdGggZnJvbSB0aGUgY2FjaGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gUGF0aCB0byBsb29rIHVwIHNuYXBzaG90IGZvci5cclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGlzIG5vZGUgc2hvdWxkIG5vdyBiZSByZW1vdmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gc3BhcnNlU25hcHNob3RUcmVlRm9yZ2V0KHNwYXJzZVNuYXBzaG90VHJlZSwgcGF0aCkge1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlID0gbnVsbDtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uY2xlYXIoKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIHRyeWluZyB0byBmb3JnZXQgYSBub2RlIHRoYXQgZG9lc24ndCBleGlzdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCB0cmVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIoc3BhcnNlU25hcHNob3RUcmVlLCBuZXcgUGF0aChrZXkpLCB0cmVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwYXJzZVNuYXBzaG90VHJlZUZvcmdldChzcGFyc2VTbmFwc2hvdFRyZWUsIHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5zaXplID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgICAgICAgICAgcGF0aCA9IHBhdGhQb3BGcm9udChwYXRoKTtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5oYXMoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzYWZlVG9SZW1vdmUgPSBzcGFyc2VTbmFwc2hvdFRyZWVGb3JnZXQoc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmdldChjaGlsZEtleSksIHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNhZmVUb1JlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5kZWxldGUoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uc2l6ZSA9PT0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVjdXJzaXZlbHkgaXRlcmF0ZXMgdGhyb3VnaCBhbGwgb2YgdGhlIHN0b3JlZCB0cmVlIGFuZCBjYWxscyB0aGVcclxuICogY2FsbGJhY2sgb24gZWFjaCBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwcmVmaXhQYXRoIC0gUGF0aCB0byBsb29rIHVwIG5vZGUgZm9yLlxyXG4gKiBAcGFyYW0gZnVuYyAtIFRoZSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggdHJlZS5cclxuICovXHJcbmZ1bmN0aW9uIHNwYXJzZVNuYXBzaG90VHJlZUZvckVhY2hUcmVlKHNwYXJzZVNuYXBzaG90VHJlZSwgcHJlZml4UGF0aCwgZnVuYykge1xyXG4gICAgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGZ1bmMocHJlZml4UGF0aCwgc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZUZvckVhY2hDaGlsZChzcGFyc2VTbmFwc2hvdFRyZWUsIChrZXksIHRyZWUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoKHByZWZpeFBhdGgudG9TdHJpbmcoKSArICcvJyArIGtleSk7XHJcbiAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZUZvckVhY2hUcmVlKHRyZWUsIHBhdGgsIGZ1bmMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGVhY2ggaW1tZWRpYXRlIGNoaWxkIGFuZCB0cmlnZ2VycyB0aGUgY2FsbGJhY2suXHJcbiAqIE9ubHkgc2VlbXMgdG8gYmUgdXNlZCBpbiB0ZXN0cy5cclxuICpcclxuICogQHBhcmFtIGZ1bmMgLSBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIGNoaWxkLlxyXG4gKi9cclxuZnVuY3Rpb24gc3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaENoaWxkKHNwYXJzZVNuYXBzaG90VHJlZSwgZnVuYykge1xyXG4gICAgc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmZvckVhY2goKHRyZWUsIGtleSkgPT4ge1xyXG4gICAgICAgIGZ1bmMoa2V5LCB0cmVlKTtcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkZWx0YSBmcm9tIHRoZSBwcmV2aW91cyBjYWxsIHRvIGdldCBzdGF0cy5cclxuICpcclxuICogQHBhcmFtIGNvbGxlY3Rpb25fIC0gVGhlIGNvbGxlY3Rpb24gdG8gXCJsaXN0ZW5cIiB0by5cclxuICovXHJcbmNsYXNzIFN0YXRzTGlzdGVuZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29sbGVjdGlvbl8pIHtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25fID0gY29sbGVjdGlvbl87XHJcbiAgICAgICAgdGhpcy5sYXN0XyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXQoKSB7XHJcbiAgICAgICAgY29uc3QgbmV3U3RhdHMgPSB0aGlzLmNvbGxlY3Rpb25fLmdldCgpO1xyXG4gICAgICAgIGNvbnN0IGRlbHRhID0gT2JqZWN0LmFzc2lnbih7fSwgbmV3U3RhdHMpO1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3RfKSB7XHJcbiAgICAgICAgICAgIGVhY2godGhpcy5sYXN0XywgKHN0YXQsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkZWx0YVtzdGF0XSA9IGRlbHRhW3N0YXRdIC0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxhc3RfID0gbmV3U3RhdHM7XHJcbiAgICAgICAgcmV0dXJuIGRlbHRhO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIEFzc3VtaW5nIHNvbWUgYXBwcyBtYXkgaGF2ZSBhIHNob3J0IGFtb3VudCBvZiB0aW1lIG9uIHBhZ2UsIGFuZCBhIGJ1bGsgb2YgZmlyZWJhc2Ugb3BlcmF0aW9ucyBwcm9iYWJseVxyXG4vLyBoYXBwZW4gb24gcGFnZSBsb2FkLCB3ZSB0cnkgdG8gcmVwb3J0IG91ciBmaXJzdCBzZXQgb2Ygc3RhdHMgcHJldHR5IHF1aWNrbHksIGJ1dCB3ZSB3YWl0IGF0IGxlYXN0IDEwXHJcbi8vIHNlY29uZHMgdG8gdHJ5IHRvIGVuc3VyZSB0aGUgRmlyZWJhc2UgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCAvIHNldHRsZWQuXHJcbmNvbnN0IEZJUlNUX1NUQVRTX01JTl9USU1FID0gMTAgKiAxMDAwO1xyXG5jb25zdCBGSVJTVF9TVEFUU19NQVhfVElNRSA9IDMwICogMTAwMDtcclxuLy8gV2UnbGwgY29udGludWUgdG8gcmVwb3J0IHN0YXRzIG9uIGF2ZXJhZ2UgZXZlcnkgNSBtaW51dGVzLlxyXG5jb25zdCBSRVBPUlRfU1RBVFNfSU5URVJWQUwgPSA1ICogNjAgKiAxMDAwO1xyXG5jbGFzcyBTdGF0c1JlcG9ydGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbGxlY3Rpb24sIHNlcnZlcl8pIHtcclxuICAgICAgICB0aGlzLnNlcnZlcl8gPSBzZXJ2ZXJfO1xyXG4gICAgICAgIHRoaXMuc3RhdHNUb1JlcG9ydF8gPSB7fTtcclxuICAgICAgICB0aGlzLnN0YXRzTGlzdGVuZXJfID0gbmV3IFN0YXRzTGlzdGVuZXIoY29sbGVjdGlvbik7XHJcbiAgICAgICAgY29uc3QgdGltZW91dCA9IEZJUlNUX1NUQVRTX01JTl9USU1FICtcclxuICAgICAgICAgICAgKEZJUlNUX1NUQVRTX01BWF9USU1FIC0gRklSU1RfU1RBVFNfTUlOX1RJTUUpICogTWF0aC5yYW5kb20oKTtcclxuICAgICAgICBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcodGhpcy5yZXBvcnRTdGF0c18uYmluZCh0aGlzKSwgTWF0aC5mbG9vcih0aW1lb3V0KSk7XHJcbiAgICB9XHJcbiAgICByZXBvcnRTdGF0c18oKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdHMgPSB0aGlzLnN0YXRzTGlzdGVuZXJfLmdldCgpO1xyXG4gICAgICAgIGNvbnN0IHJlcG9ydGVkU3RhdHMgPSB7fTtcclxuICAgICAgICBsZXQgaGF2ZVN0YXRzVG9SZXBvcnQgPSBmYWxzZTtcclxuICAgICAgICBlYWNoKHN0YXRzLCAoc3RhdCwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID4gMCAmJiBjb250YWlucyh0aGlzLnN0YXRzVG9SZXBvcnRfLCBzdGF0KSkge1xyXG4gICAgICAgICAgICAgICAgcmVwb3J0ZWRTdGF0c1tzdGF0XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaGF2ZVN0YXRzVG9SZXBvcnQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGhhdmVTdGF0c1RvUmVwb3J0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VydmVyXy5yZXBvcnRTdGF0cyhyZXBvcnRlZFN0YXRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcXVldWUgb3VyIG5leHQgcnVuLlxyXG4gICAgICAgIHNldFRpbWVvdXROb25CbG9ja2luZyh0aGlzLnJlcG9ydFN0YXRzXy5iaW5kKHRoaXMpLCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyICogUkVQT1JUX1NUQVRTX0lOVEVSVkFMKSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqXHJcbiAqIEBlbnVtXHJcbiAqL1xyXG52YXIgT3BlcmF0aW9uVHlwZTtcclxuKGZ1bmN0aW9uIChPcGVyYXRpb25UeXBlKSB7XHJcbiAgICBPcGVyYXRpb25UeXBlW09wZXJhdGlvblR5cGVbXCJPVkVSV1JJVEVcIl0gPSAwXSA9IFwiT1ZFUldSSVRFXCI7XHJcbiAgICBPcGVyYXRpb25UeXBlW09wZXJhdGlvblR5cGVbXCJNRVJHRVwiXSA9IDFdID0gXCJNRVJHRVwiO1xyXG4gICAgT3BlcmF0aW9uVHlwZVtPcGVyYXRpb25UeXBlW1wiQUNLX1VTRVJfV1JJVEVcIl0gPSAyXSA9IFwiQUNLX1VTRVJfV1JJVEVcIjtcclxuICAgIE9wZXJhdGlvblR5cGVbT3BlcmF0aW9uVHlwZVtcIkxJU1RFTl9DT01QTEVURVwiXSA9IDNdID0gXCJMSVNURU5fQ09NUExFVEVcIjtcclxufSkoT3BlcmF0aW9uVHlwZSB8fCAoT3BlcmF0aW9uVHlwZSA9IHt9KSk7XHJcbmZ1bmN0aW9uIG5ld09wZXJhdGlvblNvdXJjZVVzZXIoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZyb21Vc2VyOiB0cnVlLFxyXG4gICAgICAgIGZyb21TZXJ2ZXI6IGZhbHNlLFxyXG4gICAgICAgIHF1ZXJ5SWQ6IG51bGwsXHJcbiAgICAgICAgdGFnZ2VkOiBmYWxzZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXIoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZyb21Vc2VyOiBmYWxzZSxcclxuICAgICAgICBmcm9tU2VydmVyOiB0cnVlLFxyXG4gICAgICAgIHF1ZXJ5SWQ6IG51bGwsXHJcbiAgICAgICAgdGFnZ2VkOiBmYWxzZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXJUYWdnZWRRdWVyeShxdWVyeUlkKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZyb21Vc2VyOiBmYWxzZSxcclxuICAgICAgICBmcm9tU2VydmVyOiB0cnVlLFxyXG4gICAgICAgIHF1ZXJ5SWQsXHJcbiAgICAgICAgdGFnZ2VkOiB0cnVlXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEFja1VzZXJXcml0ZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBhZmZlY3RlZFRyZWUgLSBBIHRyZWUgY29udGFpbmluZyB0cnVlIGZvciBlYWNoIGFmZmVjdGVkIHBhdGguIEFmZmVjdGVkIHBhdGhzIGNhbid0IG92ZXJsYXAuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovIHBhdGgsIFxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovIGFmZmVjdGVkVHJlZSwgXHJcbiAgICAvKiogQGluaGVyaXREb2MgKi8gcmV2ZXJ0KSB7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICB0aGlzLmFmZmVjdGVkVHJlZSA9IGFmZmVjdGVkVHJlZTtcclxuICAgICAgICB0aGlzLnJldmVydCA9IHJldmVydDtcclxuICAgICAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSBPcGVyYXRpb25UeXBlLkFDS19VU0VSX1dSSVRFO1xyXG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gbmV3T3BlcmF0aW9uU291cmNlVXNlcigpO1xyXG4gICAgfVxyXG4gICAgb3BlcmF0aW9uRm9yQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgaWYgKCFwYXRoSXNFbXB0eSh0aGlzLnBhdGgpKSB7XHJcbiAgICAgICAgICAgIGFzc2VydChwYXRoR2V0RnJvbnQodGhpcy5wYXRoKSA9PT0gY2hpbGROYW1lLCAnb3BlcmF0aW9uRm9yQ2hpbGQgY2FsbGVkIGZvciB1bnJlbGF0ZWQgY2hpbGQuJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWNrVXNlcldyaXRlKHBhdGhQb3BGcm9udCh0aGlzLnBhdGgpLCB0aGlzLmFmZmVjdGVkVHJlZSwgdGhpcy5yZXZlcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmFmZmVjdGVkVHJlZS52YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLmFmZmVjdGVkVHJlZS5jaGlsZHJlbi5pc0VtcHR5KCksICdhZmZlY3RlZFRyZWUgc2hvdWxkIG5vdCBoYXZlIG92ZXJsYXBwaW5nIGFmZmVjdGVkIHBhdGhzLicpO1xyXG4gICAgICAgICAgICAvLyBBbGwgY2hpbGQgbG9jYXRpb25zIGFyZSBhZmZlY3RlZCBhcyB3ZWxsOyBqdXN0IHJldHVybiBzYW1lIG9wZXJhdGlvbi5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFRyZWUgPSB0aGlzLmFmZmVjdGVkVHJlZS5zdWJ0cmVlKG5ldyBQYXRoKGNoaWxkTmFtZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFja1VzZXJXcml0ZShuZXdFbXB0eVBhdGgoKSwgY2hpbGRUcmVlLCB0aGlzLnJldmVydCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIExpc3RlbkNvbXBsZXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgcGF0aCkge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gT3BlcmF0aW9uVHlwZS5MSVNURU5fQ09NUExFVEU7XHJcbiAgICB9XHJcbiAgICBvcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkodGhpcy5wYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExpc3RlbkNvbXBsZXRlKHRoaXMuc291cmNlLCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExpc3RlbkNvbXBsZXRlKHRoaXMuc291cmNlLCBwYXRoUG9wRnJvbnQodGhpcy5wYXRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIE92ZXJ3cml0ZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHBhdGgsIHNuYXApIHtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMuc25hcCA9IHNuYXA7XHJcbiAgICAgICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gT3BlcmF0aW9uVHlwZS5PVkVSV1JJVEU7XHJcbiAgICB9XHJcbiAgICBvcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkodGhpcy5wYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE92ZXJ3cml0ZSh0aGlzLnNvdXJjZSwgbmV3RW1wdHlQYXRoKCksIHRoaXMuc25hcC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgT3ZlcndyaXRlKHRoaXMuc291cmNlLCBwYXRoUG9wRnJvbnQodGhpcy5wYXRoKSwgdGhpcy5zbmFwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgTWVyZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogQGluaGVyaXREb2MgKi8gc291cmNlLCBcclxuICAgIC8qKiBAaW5oZXJpdERvYyAqLyBwYXRoLCBcclxuICAgIC8qKiBAaW5oZXJpdERvYyAqLyBjaGlsZHJlbikge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9IE9wZXJhdGlvblR5cGUuTUVSR0U7XHJcbiAgICB9XHJcbiAgICBvcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkodGhpcy5wYXRoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFRyZWUgPSB0aGlzLmNoaWxkcmVuLnN1YnRyZWUobmV3IFBhdGgoY2hpbGROYW1lKSk7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNoaWxkIGlzIHVuYWZmZWN0ZWRcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkVHJlZS52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHNuYXBzaG90IGZvciB0aGUgY2hpbGQgaW4gcXVlc3Rpb24uICBUaGlzIGJlY29tZXMgYW4gb3ZlcndyaXRlIG9mIHRoZSBjaGlsZC5cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgT3ZlcndyaXRlKHRoaXMuc291cmNlLCBuZXdFbXB0eVBhdGgoKSwgY2hpbGRUcmVlLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBtZXJnZSBhdCBhIGRlZXBlciBsZXZlbFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNZXJnZSh0aGlzLnNvdXJjZSwgbmV3RW1wdHlQYXRoKCksIGNoaWxkVHJlZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFzc2VydChwYXRoR2V0RnJvbnQodGhpcy5wYXRoKSA9PT0gY2hpbGROYW1lLCBcIkNhbid0IGdldCBhIG1lcmdlIGZvciBhIGNoaWxkIG5vdCBvbiB0aGUgcGF0aCBvZiB0aGUgb3BlcmF0aW9uXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE1lcmdlKHRoaXMuc291cmNlLCBwYXRoUG9wRnJvbnQodGhpcy5wYXRoKSwgdGhpcy5jaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICgnT3BlcmF0aW9uKCcgK1xyXG4gICAgICAgICAgICB0aGlzLnBhdGggK1xyXG4gICAgICAgICAgICAnOiAnICtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2UudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICcgbWVyZ2U6ICcgK1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAnKScpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNhY2hlIG5vZGUgb25seSBzdG9yZXMgY29tcGxldGUgY2hpbGRyZW4uIEFkZGl0aW9uYWxseSBpdCBob2xkcyBhIGZsYWcgd2hldGhlciB0aGUgbm9kZSBjYW4gYmUgY29uc2lkZXJlZCBmdWxseVxyXG4gKiBpbml0aWFsaXplZCBpbiB0aGUgc2Vuc2UgdGhhdCB3ZSBrbm93IGF0IG9uZSBwb2ludCBpbiB0aW1lIHRoaXMgcmVwcmVzZW50ZWQgYSB2YWxpZCBzdGF0ZSBvZiB0aGUgd29ybGQsIGUuZy5cclxuICogaW5pdGlhbGl6ZWQgd2l0aCBkYXRhIGZyb20gdGhlIHNlcnZlciwgb3IgYSBjb21wbGV0ZSBvdmVyd3JpdGUgYnkgdGhlIGNsaWVudC4gVGhlIGZpbHRlcmVkIGZsYWcgYWxzbyB0cmFja3NcclxuICogd2hldGhlciBhIG5vZGUgcG90ZW50aWFsbHkgaGFkIGNoaWxkcmVuIHJlbW92ZWQgZHVlIHRvIGEgZmlsdGVyLlxyXG4gKi9cclxuY2xhc3MgQ2FjaGVOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKG5vZGVfLCBmdWxseUluaXRpYWxpemVkXywgZmlsdGVyZWRfKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlXyA9IG5vZGVfO1xyXG4gICAgICAgIHRoaXMuZnVsbHlJbml0aWFsaXplZF8gPSBmdWxseUluaXRpYWxpemVkXztcclxuICAgICAgICB0aGlzLmZpbHRlcmVkXyA9IGZpbHRlcmVkXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgbm9kZSB3YXMgZnVsbHkgaW5pdGlhbGl6ZWQgd2l0aCBlaXRoZXIgc2VydmVyIGRhdGEgb3IgYSBjb21wbGV0ZSBvdmVyd3JpdGUgYnkgdGhlIGNsaWVudFxyXG4gICAgICovXHJcbiAgICBpc0Z1bGx5SW5pdGlhbGl6ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVsbHlJbml0aWFsaXplZF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIG5vZGUgaXMgcG90ZW50aWFsbHkgbWlzc2luZyBjaGlsZHJlbiBkdWUgdG8gYSBmaWx0ZXIgYXBwbGllZCB0byB0aGUgbm9kZVxyXG4gICAgICovXHJcbiAgICBpc0ZpbHRlcmVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcmVkXztcclxuICAgIH1cclxuICAgIGlzQ29tcGxldGVGb3JQYXRoKHBhdGgpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNGdWxseUluaXRpYWxpemVkKCkgJiYgIXRoaXMuZmlsdGVyZWRfO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZUZvckNoaWxkKGtleSkge1xyXG4gICAgICAgIHJldHVybiAoKHRoaXMuaXNGdWxseUluaXRpYWxpemVkKCkgJiYgIXRoaXMuZmlsdGVyZWRfKSB8fCB0aGlzLm5vZGVfLmhhc0NoaWxkKGtleSkpO1xyXG4gICAgfVxyXG4gICAgZ2V0Tm9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlXztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gRXZlbnRHZW5lcmF0b3IgaXMgdXNlZCB0byBjb252ZXJ0IFwicmF3XCIgY2hhbmdlcyAoQ2hhbmdlKSBhcyBjb21wdXRlZCBieSB0aGVcclxuICogQ2FjaGVEaWZmZXIgaW50byBhY3R1YWwgZXZlbnRzIChFdmVudCkgdGhhdCBjYW4gYmUgcmFpc2VkLiAgU2VlIGdlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlcygpXHJcbiAqIGZvciBkZXRhaWxzLlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgRXZlbnRHZW5lcmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IocXVlcnlfKSB7XHJcbiAgICAgICAgdGhpcy5xdWVyeV8gPSBxdWVyeV87XHJcbiAgICAgICAgdGhpcy5pbmRleF8gPSB0aGlzLnF1ZXJ5Xy5fcXVlcnlQYXJhbXMuZ2V0SW5kZXgoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2l2ZW4gYSBzZXQgb2YgcmF3IGNoYW5nZXMgKG5vIG1vdmVkIGV2ZW50cyBhbmQgcHJldk5hbWUgbm90IHNwZWNpZmllZCB5ZXQpLCBhbmQgYSBzZXQgb2ZcclxuICogRXZlbnRSZWdpc3RyYXRpb25zIHRoYXQgc2hvdWxkIGJlIG5vdGlmaWVkIG9mIHRoZXNlIGNoYW5nZXMsIGdlbmVyYXRlIHRoZSBhY3R1YWwgZXZlbnRzIHRvIGJlIHJhaXNlZC5cclxuICpcclxuICogTm90ZXM6XHJcbiAqICAtIGNoaWxkX21vdmVkIGV2ZW50cyB3aWxsIGJlIHN5bnRoZXNpemVkIGF0IHRoaXMgdGltZSBmb3IgYW55IGNoaWxkX2NoYW5nZWQgZXZlbnRzIHRoYXQgYWZmZWN0XHJcbiAqICAgIG91ciBpbmRleC5cclxuICogIC0gcHJldk5hbWUgd2lsbCBiZSBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBpbmRleCBvcmRlcmluZy5cclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzKGV2ZW50R2VuZXJhdG9yLCBjaGFuZ2VzLCBldmVudENhY2hlLCBldmVudFJlZ2lzdHJhdGlvbnMpIHtcclxuICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xyXG4gICAgY29uc3QgbW92ZXMgPSBbXTtcclxuICAgIGNoYW5nZXMuZm9yRWFjaChjaGFuZ2UgPT4ge1xyXG4gICAgICAgIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9DSEFOR0VEICovICYmXHJcbiAgICAgICAgICAgIGV2ZW50R2VuZXJhdG9yLmluZGV4Xy5pbmRleGVkVmFsdWVDaGFuZ2VkKGNoYW5nZS5vbGRTbmFwLCBjaGFuZ2Uuc25hcHNob3ROb2RlKSkge1xyXG4gICAgICAgICAgICBtb3Zlcy5wdXNoKGNoYW5nZUNoaWxkTW92ZWQoY2hhbmdlLmNoaWxkTmFtZSwgY2hhbmdlLnNuYXBzaG90Tm9kZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgZXZlbnRHZW5lcmF0b3JHZW5lcmF0ZUV2ZW50c0ZvclR5cGUoZXZlbnRHZW5lcmF0b3IsIGV2ZW50cywgXCJjaGlsZF9yZW1vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9SRU1PVkVEICovLCBjaGFuZ2VzLCBldmVudFJlZ2lzdHJhdGlvbnMsIGV2ZW50Q2FjaGUpO1xyXG4gICAgZXZlbnRHZW5lcmF0b3JHZW5lcmF0ZUV2ZW50c0ZvclR5cGUoZXZlbnRHZW5lcmF0b3IsIGV2ZW50cywgXCJjaGlsZF9hZGRlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQURERUQgKi8sIGNoYW5nZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XHJcbiAgICBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBcImNoaWxkX21vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9NT1ZFRCAqLywgbW92ZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XHJcbiAgICBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBcImNoaWxkX2NoYW5nZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0NIQU5HRUQgKi8sIGNoYW5nZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XHJcbiAgICBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBcInZhbHVlXCIgLyogQ2hhbmdlVHlwZS5WQUxVRSAqLywgY2hhbmdlcywgZXZlbnRSZWdpc3RyYXRpb25zLCBldmVudENhY2hlKTtcclxuICAgIHJldHVybiBldmVudHM7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGNoYW5nZXMgb2YgYSBzaW5nbGUgY2hhbmdlIHR5cGUsIGdlbmVyYXRlIHRoZSBjb3JyZXNwb25kaW5nIGV2ZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JUeXBlKGV2ZW50R2VuZXJhdG9yLCBldmVudHMsIGV2ZW50VHlwZSwgY2hhbmdlcywgcmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSkge1xyXG4gICAgY29uc3QgZmlsdGVyZWRDaGFuZ2VzID0gY2hhbmdlcy5maWx0ZXIoY2hhbmdlID0+IGNoYW5nZS50eXBlID09PSBldmVudFR5cGUpO1xyXG4gICAgZmlsdGVyZWRDaGFuZ2VzLnNvcnQoKGEsIGIpID0+IGV2ZW50R2VuZXJhdG9yQ29tcGFyZUNoYW5nZXMoZXZlbnRHZW5lcmF0b3IsIGEsIGIpKTtcclxuICAgIGZpbHRlcmVkQ2hhbmdlcy5mb3JFYWNoKGNoYW5nZSA9PiB7XHJcbiAgICAgICAgY29uc3QgbWF0ZXJpYWxpemVkQ2hhbmdlID0gZXZlbnRHZW5lcmF0b3JNYXRlcmlhbGl6ZVNpbmdsZUNoYW5nZShldmVudEdlbmVyYXRvciwgY2hhbmdlLCBldmVudENhY2hlKTtcclxuICAgICAgICByZWdpc3RyYXRpb25zLmZvckVhY2gocmVnaXN0cmF0aW9uID0+IHtcclxuICAgICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5yZXNwb25kc1RvKGNoYW5nZS50eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzLnB1c2gocmVnaXN0cmF0aW9uLmNyZWF0ZUV2ZW50KG1hdGVyaWFsaXplZENoYW5nZSwgZXZlbnRHZW5lcmF0b3IucXVlcnlfKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGV2ZW50R2VuZXJhdG9yTWF0ZXJpYWxpemVTaW5nbGVDaGFuZ2UoZXZlbnRHZW5lcmF0b3IsIGNoYW5nZSwgZXZlbnRDYWNoZSkge1xyXG4gICAgaWYgKGNoYW5nZS50eXBlID09PSAndmFsdWUnIHx8IGNoYW5nZS50eXBlID09PSAnY2hpbGRfcmVtb3ZlZCcpIHtcclxuICAgICAgICByZXR1cm4gY2hhbmdlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY2hhbmdlLnByZXZOYW1lID0gZXZlbnRDYWNoZS5nZXRQcmVkZWNlc3NvckNoaWxkTmFtZShjaGFuZ2UuY2hpbGROYW1lLCBjaGFuZ2Uuc25hcHNob3ROb2RlLCBldmVudEdlbmVyYXRvci5pbmRleF8pO1xyXG4gICAgICAgIHJldHVybiBjaGFuZ2U7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZXZlbnRHZW5lcmF0b3JDb21wYXJlQ2hhbmdlcyhldmVudEdlbmVyYXRvciwgYSwgYikge1xyXG4gICAgaWYgKGEuY2hpbGROYW1lID09IG51bGwgfHwgYi5jaGlsZE5hbWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKCdTaG91bGQgb25seSBjb21wYXJlIGNoaWxkXyBldmVudHMuJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhV3JhcHBlZCA9IG5ldyBOYW1lZE5vZGUoYS5jaGlsZE5hbWUsIGEuc25hcHNob3ROb2RlKTtcclxuICAgIGNvbnN0IGJXcmFwcGVkID0gbmV3IE5hbWVkTm9kZShiLmNoaWxkTmFtZSwgYi5zbmFwc2hvdE5vZGUpO1xyXG4gICAgcmV0dXJuIGV2ZW50R2VuZXJhdG9yLmluZGV4Xy5jb21wYXJlKGFXcmFwcGVkLCBiV3JhcHBlZCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3Vmlld0NhY2hlKGV2ZW50Q2FjaGUsIHNlcnZlckNhY2hlKSB7XHJcbiAgICByZXR1cm4geyBldmVudENhY2hlLCBzZXJ2ZXJDYWNoZSB9O1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdDYWNoZVVwZGF0ZUV2ZW50U25hcCh2aWV3Q2FjaGUsIGV2ZW50U25hcCwgY29tcGxldGUsIGZpbHRlcmVkKSB7XHJcbiAgICByZXR1cm4gbmV3Vmlld0NhY2hlKG5ldyBDYWNoZU5vZGUoZXZlbnRTbmFwLCBjb21wbGV0ZSwgZmlsdGVyZWQpLCB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdDYWNoZVVwZGF0ZVNlcnZlclNuYXAodmlld0NhY2hlLCBzZXJ2ZXJTbmFwLCBjb21wbGV0ZSwgZmlsdGVyZWQpIHtcclxuICAgIHJldHVybiBuZXdWaWV3Q2FjaGUodmlld0NhY2hlLmV2ZW50Q2FjaGUsIG5ldyBDYWNoZU5vZGUoc2VydmVyU25hcCwgY29tcGxldGUsIGZpbHRlcmVkKSk7XHJcbn1cclxuZnVuY3Rpb24gdmlld0NhY2hlR2V0Q29tcGxldGVFdmVudFNuYXAodmlld0NhY2hlKSB7XHJcbiAgICByZXR1cm4gdmlld0NhY2hlLmV2ZW50Q2FjaGUuaXNGdWxseUluaXRpYWxpemVkKClcclxuICAgICAgICA/IHZpZXdDYWNoZS5ldmVudENhY2hlLmdldE5vZGUoKVxyXG4gICAgICAgIDogbnVsbDtcclxufVxyXG5mdW5jdGlvbiB2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAodmlld0NhY2hlKSB7XHJcbiAgICByZXR1cm4gdmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpXHJcbiAgICAgICAgPyB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpXHJcbiAgICAgICAgOiBudWxsO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmxldCBlbXB0eUNoaWxkcmVuU2luZ2xldG9uO1xyXG4vKipcclxuICogU2luZ2xldG9uIGVtcHR5IGNoaWxkcmVuIGNvbGxlY3Rpb24uXHJcbiAqXHJcbiAqL1xyXG5jb25zdCBFbXB0eUNoaWxkcmVuID0gKCkgPT4ge1xyXG4gICAgaWYgKCFlbXB0eUNoaWxkcmVuU2luZ2xldG9uKSB7XHJcbiAgICAgICAgZW1wdHlDaGlsZHJlblNpbmdsZXRvbiA9IG5ldyBTb3J0ZWRNYXAoc3RyaW5nQ29tcGFyZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW1wdHlDaGlsZHJlblNpbmdsZXRvbjtcclxufTtcclxuLyoqXHJcbiAqIEEgdHJlZSB3aXRoIGltbXV0YWJsZSBlbGVtZW50cy5cclxuICovXHJcbmNsYXNzIEltbXV0YWJsZVRyZWUge1xyXG4gICAgY29uc3RydWN0b3IodmFsdWUsIGNoaWxkcmVuID0gRW1wdHlDaGlsZHJlbigpKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tT2JqZWN0KG9iaikge1xyXG4gICAgICAgIGxldCB0cmVlID0gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgZWFjaChvYmosIChjaGlsZFBhdGgsIGNoaWxkU25hcCkgPT4ge1xyXG4gICAgICAgICAgICB0cmVlID0gdHJlZS5zZXQobmV3IFBhdGgoY2hpbGRQYXRoKSwgY2hpbGRTbmFwKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdHJlZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgZW1wdHkgYW5kIHRoZXJlIGFyZSBubyBjaGlsZHJlblxyXG4gICAgICovXHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBudWxsICYmIHRoaXMuY2hpbGRyZW4uaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIHBhdGggYW5kIHByZWRpY2F0ZSwgcmV0dXJuIHRoZSBmaXJzdCBub2RlIGFuZCB0aGUgcGF0aCB0byB0aGF0IG5vZGVcclxuICAgICAqIHdoZXJlIHRoZSBwcmVkaWNhdGUgcmV0dXJucyB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIFRPRE8gRG8gYSBwZXJmIHRlc3QgLS0gSWYgd2UncmUgY3JlYXRpbmcgYSBidW5jaCBvZiBge3BhdGg6IHZhbHVlOn1gXHJcbiAgICAgKiBvYmplY3RzIG9uIHRoZSB3YXkgYmFjayBvdXQsIGl0IG1heSBiZSBiZXR0ZXIgdG8gcGFzcyBkb3duIGEgcGF0aFNvRmFyIG9iai5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQYXRoIC0gVGhlIHJlbWFpbmRlciBvZiB0aGUgcGF0aFxyXG4gICAgICogQHBhcmFtIHByZWRpY2F0ZSAtIFRoZSBwcmVkaWNhdGUgdG8gc2F0aXNmeSB0byByZXR1cm4gYSBub2RlXHJcbiAgICAgKi9cclxuICAgIGZpbmRSb290TW9zdE1hdGNoaW5nUGF0aEFuZFZhbHVlKHJlbGF0aXZlUGF0aCwgcHJlZGljYXRlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT0gbnVsbCAmJiBwcmVkaWNhdGUodGhpcy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgcGF0aDogbmV3RW1wdHlQYXRoKCksIHZhbHVlOiB0aGlzLnZhbHVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEV4aXN0aW5nUGF0aEFuZFZhbHVlID0gY2hpbGQuZmluZFJvb3RNb3N0TWF0Y2hpbmdQYXRoQW5kVmFsdWUocGF0aFBvcEZyb250KHJlbGF0aXZlUGF0aCksIHByZWRpY2F0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkRXhpc3RpbmdQYXRoQW5kVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGhDaGlsZChuZXcgUGF0aChmcm9udCksIGNoaWxkRXhpc3RpbmdQYXRoQW5kVmFsdWUucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHBhdGg6IGZ1bGxQYXRoLCB2YWx1ZTogY2hpbGRFeGlzdGluZ1BhdGhBbmRWYWx1ZS52YWx1ZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQsIGlmIGl0IGV4aXN0cywgdGhlIHNob3J0ZXN0IHN1YnBhdGggb2YgdGhlIGdpdmVuIHBhdGggdGhhdCBwb2ludHMgYSBkZWZpbmVkXHJcbiAgICAgKiB2YWx1ZSBpbiB0aGUgdHJlZVxyXG4gICAgICovXHJcbiAgICBmaW5kUm9vdE1vc3RWYWx1ZUFuZFBhdGgocmVsYXRpdmVQYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFJvb3RNb3N0TWF0Y2hpbmdQYXRoQW5kVmFsdWUocmVsYXRpdmVQYXRoLCAoKSA9PiB0cnVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIHN1YnRyZWUgYXQgdGhlIGdpdmVuIHBhdGhcclxuICAgICAqL1xyXG4gICAgc3VidHJlZShyZWxhdGl2ZVBhdGgpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkVHJlZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkVHJlZS5zdWJ0cmVlKHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQYXRoIC0gUGF0aCB0byBzZXQgdmFsdWUgYXQuXHJcbiAgICAgKiBAcGFyYW0gdG9TZXQgLSBWYWx1ZSB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRpbmcgdHJlZS5cclxuICAgICAqL1xyXG4gICAgc2V0KHJlbGF0aXZlUGF0aCwgdG9TZXQpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUodG9TZXQsIHRoaXMuY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocmVsYXRpdmVQYXRoKTtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCkgfHwgbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gY2hpbGQuc2V0KHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpLCB0b1NldCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5pbnNlcnQoZnJvbnQsIG5ld0NoaWxkKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKHRoaXMudmFsdWUsIG5ld0NoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQYXRoIC0gUGF0aCB0byB2YWx1ZSB0byByZW1vdmUuXHJcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRpbmcgdHJlZS5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKHJlbGF0aXZlUGF0aCkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKG51bGwsIHRoaXMuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDaGlsZCA9IGNoaWxkLnJlbW92ZShwYXRoUG9wRnJvbnQocmVsYXRpdmVQYXRoKSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3Q2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnJlbW92ZShmcm9udCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uaW5zZXJ0KGZyb250LCBuZXdDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbCAmJiBuZXdDaGlsZHJlbi5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUodGhpcy52YWx1ZSwgbmV3Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSB2YWx1ZSBmcm9tIHRoZSB0cmVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZWxhdGl2ZVBhdGggLSBQYXRoIHRvIGdldCB2YWx1ZSBmb3IuXHJcbiAgICAgKiBAcmV0dXJucyBWYWx1ZSBhdCBwYXRoLCBvciBudWxsLlxyXG4gICAgICovXHJcbiAgICBnZXQocmVsYXRpdmVQYXRoKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHJlbGF0aXZlUGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuZ2V0KHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBsYWNlIHRoZSBzdWJ0cmVlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIHRoZSBnaXZlbiBuZXcgdHJlZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQYXRoIC0gUGF0aCB0byByZXBsYWNlIHN1YnRyZWUgZm9yLlxyXG4gICAgICogQHBhcmFtIG5ld1RyZWUgLSBOZXcgdHJlZS5cclxuICAgICAqIEByZXR1cm5zIFJlc3VsdGluZyB0cmVlLlxyXG4gICAgICovXHJcbiAgICBzZXRUcmVlKHJlbGF0aXZlUGF0aCwgbmV3VHJlZSkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdUcmVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocmVsYXRpdmVQYXRoKTtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCkgfHwgbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gY2hpbGQuc2V0VHJlZShwYXRoUG9wRnJvbnQocmVsYXRpdmVQYXRoKSwgbmV3VHJlZSk7XHJcbiAgICAgICAgICAgIGxldCBuZXdDaGlsZHJlbjtcclxuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnJlbW92ZShmcm9udCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uaW5zZXJ0KGZyb250LCBuZXdDaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKHRoaXMudmFsdWUsIG5ld0NoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIGEgZGVwdGggZmlyc3QgZm9sZCBvbiB0aGlzIHRyZWUuIFRyYW5zZm9ybXMgYSB0cmVlIGludG8gYSBzaW5nbGVcclxuICAgICAqIHZhbHVlLCBnaXZlbiBhIGZ1bmN0aW9uIHRoYXQgb3BlcmF0ZXMgb24gdGhlIHBhdGggdG8gYSBub2RlLCBhbiBvcHRpb25hbFxyXG4gICAgICogY3VycmVudCB2YWx1ZSwgYW5kIGEgbWFwIG9mIGNoaWxkIG5hbWVzIHRvIGZvbGRlZCBzdWJ0cmVlc1xyXG4gICAgICovXHJcbiAgICBmb2xkKGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9sZF8obmV3RW1wdHlQYXRoKCksIGZuKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVjdXJzaXZlIGhlbHBlciBmb3IgcHVibGljLWZhY2luZyBmb2xkKCkgbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIGZvbGRfKHBhdGhTb0ZhciwgZm4pIHtcclxuICAgICAgICBjb25zdCBhY2N1bSA9IHt9O1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGRLZXksIGNoaWxkVHJlZSkgPT4ge1xyXG4gICAgICAgICAgICBhY2N1bVtjaGlsZEtleV0gPSBjaGlsZFRyZWUuZm9sZF8ocGF0aENoaWxkKHBhdGhTb0ZhciwgY2hpbGRLZXkpLCBmbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZuKHBhdGhTb0ZhciwgdGhpcy52YWx1ZSwgYWNjdW0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBmaXJzdCBtYXRjaGluZyB2YWx1ZSBvbiB0aGUgZ2l2ZW4gcGF0aC4gUmV0dXJuIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgZiB0byBpdC5cclxuICAgICAqL1xyXG4gICAgZmluZE9uUGF0aChwYXRoLCBmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZE9uUGF0aF8ocGF0aCwgbmV3RW1wdHlQYXRoKCksIGYpO1xyXG4gICAgfVxyXG4gICAgZmluZE9uUGF0aF8ocGF0aFRvRm9sbG93LCBwYXRoU29GYXIsIGYpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnZhbHVlID8gZihwYXRoU29GYXIsIHRoaXMudmFsdWUpIDogZmFsc2U7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHBhdGhUb0ZvbGxvdykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aFRvRm9sbG93KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dENoaWxkLmZpbmRPblBhdGhfKHBhdGhQb3BGcm9udChwYXRoVG9Gb2xsb3cpLCBwYXRoQ2hpbGQocGF0aFNvRmFyLCBmcm9udCksIGYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3JlYWNoT25QYXRoKHBhdGgsIGYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb3JlYWNoT25QYXRoXyhwYXRoLCBuZXdFbXB0eVBhdGgoKSwgZik7XHJcbiAgICB9XHJcbiAgICBmb3JlYWNoT25QYXRoXyhwYXRoVG9Gb2xsb3csIGN1cnJlbnRSZWxhdGl2ZVBhdGgsIGYpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocGF0aFRvRm9sbG93KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBmKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIHRoaXMudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHBhdGhUb0ZvbGxvdyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgaWYgKG5leHRDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRDaGlsZC5mb3JlYWNoT25QYXRoXyhwYXRoUG9wRnJvbnQocGF0aFRvRm9sbG93KSwgcGF0aENoaWxkKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIGZyb250KSwgZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxzIHRoZSBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBub2RlIGluIHRoZSB0cmVlIHRoYXQgaGFzIGEgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGYgLSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBwYXRoIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHRyZWUgdG9cclxuICAgICAqIGEgbm9kZSwgYW5kIHRoZSB2YWx1ZSBhdCB0aGF0IG5vZGUuIENhbGxlZCBpbiBkZXB0aC1maXJzdCBvcmRlci5cclxuICAgICAqL1xyXG4gICAgZm9yZWFjaChmKSB7XHJcbiAgICAgICAgdGhpcy5mb3JlYWNoXyhuZXdFbXB0eVBhdGgoKSwgZik7XHJcbiAgICB9XHJcbiAgICBmb3JlYWNoXyhjdXJyZW50UmVsYXRpdmVQYXRoLCBmKSB7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKChjaGlsZE5hbWUsIGNoaWxkVHJlZSkgPT4ge1xyXG4gICAgICAgICAgICBjaGlsZFRyZWUuZm9yZWFjaF8ocGF0aENoaWxkKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIGNoaWxkTmFtZSksIGYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIGYoY3VycmVudFJlbGF0aXZlUGF0aCwgdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yZWFjaENoaWxkKGYpIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkTmFtZSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGYoY2hpbGROYW1lLCBjaGlsZFRyZWUudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgaG9sZHMgYSBjb2xsZWN0aW9uIG9mIHdyaXRlcyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIG5vZGVzIGluIHVuaXNvbi4gSXQgYWJzdHJhY3RzIGF3YXkgdGhlIGxvZ2ljIHdpdGhcclxuICogZGVhbGluZyB3aXRoIHByaW9yaXR5IHdyaXRlcyBhbmQgbXVsdGlwbGUgbmVzdGVkIHdyaXRlcy4gQXQgYW55IGdpdmVuIHBhdGggdGhlcmUgaXMgb25seSBhbGxvd2VkIHRvIGJlIG9uZSB3cml0ZVxyXG4gKiBtb2RpZnlpbmcgdGhhdCBwYXRoLiBBbnkgd3JpdGUgdG8gYW4gZXhpc3RpbmcgcGF0aCBvciBzaGFkb3dpbmcgYW4gZXhpc3RpbmcgcGF0aCB3aWxsIG1vZGlmeSB0aGF0IGV4aXN0aW5nIHdyaXRlXHJcbiAqIHRvIHJlZmxlY3QgdGhlIHdyaXRlIGFkZGVkLlxyXG4gKi9cclxuY2xhc3MgQ29tcG91bmRXcml0ZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3cml0ZVRyZWVfKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZVRyZWVfID0gd3JpdGVUcmVlXztcclxuICAgIH1cclxuICAgIHN0YXRpYyBlbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3IEltbXV0YWJsZVRyZWUobnVsbCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVBZGRXcml0ZShjb21wb3VuZFdyaXRlLCBwYXRoLCBub2RlKSB7XHJcbiAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3IEltbXV0YWJsZVRyZWUobm9kZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgcm9vdG1vc3QgPSBjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8uZmluZFJvb3RNb3N0VmFsdWVBbmRQYXRoKHBhdGgpO1xyXG4gICAgICAgIGlmIChyb290bW9zdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvb3RNb3N0UGF0aCA9IHJvb3Rtb3N0LnBhdGg7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHJvb3Rtb3N0LnZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocm9vdE1vc3RQYXRoLCBwYXRoKTtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGgsIG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUoY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLnNldChyb290TW9zdFBhdGgsIHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzdWJ0cmVlID0gbmV3IEltbXV0YWJsZVRyZWUobm9kZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1dyaXRlVHJlZSA9IGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5zZXRUcmVlKHBhdGgsIHN1YnRyZWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3V3JpdGVUcmVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZUFkZFdyaXRlcyhjb21wb3VuZFdyaXRlLCBwYXRoLCB1cGRhdGVzKSB7XHJcbiAgICBsZXQgbmV3V3JpdGUgPSBjb21wb3VuZFdyaXRlO1xyXG4gICAgZWFjaCh1cGRhdGVzLCAoY2hpbGRLZXksIG5vZGUpID0+IHtcclxuICAgICAgICBuZXdXcml0ZSA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZShuZXdXcml0ZSwgcGF0aENoaWxkKHBhdGgsIGNoaWxkS2V5KSwgbm9kZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXdXcml0ZTtcclxufVxyXG4vKipcclxuICogV2lsbCByZW1vdmUgYSB3cml0ZSBhdCB0aGUgZ2l2ZW4gcGF0aCBhbmQgZGVlcGVyIHBhdGhzLiBUaGlzIHdpbGwgPGVtPm5vdDwvZW0+IG1vZGlmeSBhIHdyaXRlIGF0IGEgaGlnaGVyXHJcbiAqIGxvY2F0aW9uLCB3aGljaCBtdXN0IGJlIHJlbW92ZWQgYnkgY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIHRoYXQgcGF0aC5cclxuICpcclxuICogQHBhcmFtIGNvbXBvdW5kV3JpdGUgLSBUaGUgQ29tcG91bmRXcml0ZSB0byByZW1vdmUuXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggYXQgd2hpY2ggYSB3cml0ZSBhbmQgYWxsIGRlZXBlciB3cml0ZXMgc2hvdWxkIGJlIHJlbW92ZWRcclxuICogQHJldHVybnMgVGhlIG5ldyBDb21wb3VuZFdyaXRlIHdpdGggdGhlIHJlbW92ZWQgcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZVJlbW92ZVdyaXRlKGNvbXBvdW5kV3JpdGUsIHBhdGgpIHtcclxuICAgIGlmIChwYXRoSXNFbXB0eShwYXRoKSkge1xyXG4gICAgICAgIHJldHVybiBDb21wb3VuZFdyaXRlLmVtcHR5KCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBuZXdXcml0ZVRyZWUgPSBjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8uc2V0VHJlZShwYXRoLCBuZXcgSW1tdXRhYmxlVHJlZShudWxsKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKG5ld1dyaXRlVHJlZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGlzIENvbXBvdW5kV3JpdGUgd2lsbCBmdWxseSBvdmVyd3JpdGUgYSBub2RlIGF0IGEgZ2l2ZW4gbG9jYXRpb24gYW5kIGNhbiB0aGVyZWZvcmUgYmVcclxuICogY29uc2lkZXJlZCBcImNvbXBsZXRlXCIuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb21wb3VuZFdyaXRlIC0gVGhlIENvbXBvdW5kV3JpdGUgdG8gY2hlY2suXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gY2hlY2sgZm9yXHJcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlcmUgaXMgYSBjb21wbGV0ZSB3cml0ZSBhdCB0aGF0IHBhdGhcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVIYXNDb21wbGV0ZVdyaXRlKGNvbXBvdW5kV3JpdGUsIHBhdGgpIHtcclxuICAgIHJldHVybiBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVOb2RlKGNvbXBvdW5kV3JpdGUsIHBhdGgpICE9IG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBub2RlIGZvciBhIHBhdGggaWYgYW5kIG9ubHkgaWYgdGhlIG5vZGUgaXMgYSBcImNvbXBsZXRlXCIgb3ZlcndyaXRlIGF0IHRoYXQgcGF0aC4gVGhpcyB3aWxsIG5vdCBhZ2dyZWdhdGVcclxuICogd3JpdGVzIGZyb20gZGVlcGVyIHBhdGhzLCBidXQgd2lsbCByZXR1cm4gY2hpbGQgbm9kZXMgZnJvbSBhIG1vcmUgc2hhbGxvdyBwYXRoLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29tcG91bmRXcml0ZSAtIFRoZSBDb21wb3VuZFdyaXRlIHRvIGdldCB0aGUgbm9kZSBmcm9tLlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIGdldCBhIGNvbXBsZXRlIHdyaXRlXHJcbiAqIEByZXR1cm5zIFRoZSBub2RlIGlmIGNvbXBsZXRlIGF0IHRoYXQgcGF0aCwgb3IgbnVsbCBvdGhlcndpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVOb2RlKGNvbXBvdW5kV3JpdGUsIHBhdGgpIHtcclxuICAgIGNvbnN0IHJvb3Rtb3N0ID0gY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLmZpbmRSb290TW9zdFZhbHVlQW5kUGF0aChwYXRoKTtcclxuICAgIGlmIChyb290bW9zdCAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlX1xyXG4gICAgICAgICAgICAuZ2V0KHJvb3Rtb3N0LnBhdGgpXHJcbiAgICAgICAgICAgIC5nZXRDaGlsZChuZXdSZWxhdGl2ZVBhdGgocm9vdG1vc3QucGF0aCwgcGF0aCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYWxsIGNoaWxkcmVuIHRoYXQgYXJlIGd1YXJhbnRlZWQgdG8gYmUgYSBjb21wbGV0ZSBvdmVyd3JpdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb21wb3VuZFdyaXRlIC0gVGhlIENvbXBvdW5kV3JpdGUgdG8gZ2V0IGNoaWxkcmVuIGZyb20uXHJcbiAqIEByZXR1cm5zIEEgbGlzdCBvZiBhbGwgY29tcGxldGUgY2hpbGRyZW4uXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVDaGlsZHJlbihjb21wb3VuZFdyaXRlKSB7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xyXG4gICAgY29uc3Qgbm9kZSA9IGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy52YWx1ZTtcclxuICAgIGlmIChub2RlICE9IG51bGwpIHtcclxuICAgICAgICAvLyBJZiBpdCdzIGEgbGVhZiBub2RlLCBpdCBoYXMgbm8gY2hpbGRyZW47IHNvIG5vdGhpbmcgdG8gZG8uXHJcbiAgICAgICAgaWYgKCFub2RlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICBub2RlLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGNoaWxkTmFtZSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBOYW1lZE5vZGUoY2hpbGROYW1lLCBjaGlsZE5vZGUpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkTmFtZSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUudmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChuZXcgTmFtZWROb2RlKGNoaWxkTmFtZSwgY2hpbGRUcmVlLnZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBjaGlsZHJlbjtcclxufVxyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKGNvbXBvdW5kV3JpdGUsIHBhdGgpIHtcclxuICAgIGlmIChwYXRoSXNFbXB0eShwYXRoKSkge1xyXG4gICAgICAgIHJldHVybiBjb21wb3VuZFdyaXRlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgc2hhZG93aW5nTm9kZSA9IGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUoY29tcG91bmRXcml0ZSwgcGF0aCk7XHJcbiAgICAgICAgaWYgKHNoYWRvd2luZ05vZGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3IEltbXV0YWJsZVRyZWUoc2hhZG93aW5nTm9kZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5zdWJ0cmVlKHBhdGgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIENvbXBvdW5kV3JpdGUgaXMgZW1wdHkgYW5kIHRoZXJlZm9yZSBkb2VzIG5vdCBtb2RpZnkgYW55IG5vZGVzLlxyXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoaXMgQ29tcG91bmRXcml0ZSBpcyBlbXB0eVxyXG4gKi9cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZUlzRW1wdHkoY29tcG91bmRXcml0ZSkge1xyXG4gICAgcmV0dXJuIGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5pc0VtcHR5KCk7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhpcyBDb21wb3VuZFdyaXRlIHRvIGEgbm9kZS4gVGhlIG5vZGUgaXMgcmV0dXJuZWQgd2l0aCBhbGwgd3JpdGVzIGZyb20gdGhpcyBDb21wb3VuZFdyaXRlIGFwcGxpZWQgdG8gdGhlXHJcbiAqIG5vZGVcclxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBhcHBseSB0aGlzIENvbXBvdW5kV3JpdGUgdG9cclxuICogQHJldHVybnMgVGhlIG5vZGUgd2l0aCBhbGwgd3JpdGVzIGFwcGxpZWRcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVBcHBseShjb21wb3VuZFdyaXRlLCBub2RlKSB7XHJcbiAgICByZXR1cm4gYXBwbHlTdWJ0cmVlV3JpdGUobmV3RW1wdHlQYXRoKCksIGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXywgbm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlTdWJ0cmVlV3JpdGUocmVsYXRpdmVQYXRoLCB3cml0ZVRyZWUsIG5vZGUpIHtcclxuICAgIGlmICh3cml0ZVRyZWUudmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIFNpbmNlIHRoZXJlIGEgd3JpdGUgaXMgYWx3YXlzIGEgbGVhZiwgd2UncmUgZG9uZSBoZXJlXHJcbiAgICAgICAgcmV0dXJuIG5vZGUudXBkYXRlQ2hpbGQocmVsYXRpdmVQYXRoLCB3cml0ZVRyZWUudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IHByaW9yaXR5V3JpdGUgPSBudWxsO1xyXG4gICAgICAgIHdyaXRlVHJlZS5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKChjaGlsZEtleSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZEtleSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHByaW9yaXRpZXMgYXQgdGhlIGVuZCBzbyB3ZSBkb24ndCB1cGRhdGUgcHJpb3JpdGllcyBmb3IgZWl0aGVyIGVtcHR5IG5vZGVzIG9yIGZvcmdldFxyXG4gICAgICAgICAgICAgICAgLy8gdG8gYXBwbHkgcHJpb3JpdGllcyB0byBlbXB0eSBub2RlcyB0aGF0IGFyZSBsYXRlciBmaWxsZWRcclxuICAgICAgICAgICAgICAgIGFzc2VydChjaGlsZFRyZWUudmFsdWUgIT09IG51bGwsICdQcmlvcml0eSB3cml0ZXMgbXVzdCBhbHdheXMgYmUgbGVhZiBub2RlcycpO1xyXG4gICAgICAgICAgICAgICAgcHJpb3JpdHlXcml0ZSA9IGNoaWxkVHJlZS52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBhcHBseVN1YnRyZWVXcml0ZShwYXRoQ2hpbGQocmVsYXRpdmVQYXRoLCBjaGlsZEtleSksIGNoaWxkVHJlZSwgbm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwcmlvcml0eSB3cml0ZSwgd2Ugb25seSBhcHBseSBpdCBpZiB0aGUgbm9kZSBpcyBub3QgZW1wdHlcclxuICAgICAgICBpZiAoIW5vZGUuZ2V0Q2hpbGQocmVsYXRpdmVQYXRoKS5pc0VtcHR5KCkgJiYgcHJpb3JpdHlXcml0ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS51cGRhdGVDaGlsZChwYXRoQ2hpbGQocmVsYXRpdmVQYXRoLCAnLnByaW9yaXR5JyksIHByaW9yaXR5V3JpdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ3JlYXRlIGEgbmV3IFdyaXRlVHJlZVJlZiBmb3IgdGhlIGdpdmVuIHBhdGguIEZvciB1c2Ugd2l0aCBhIG5ldyBzeW5jIHBvaW50IGF0IHRoZSBnaXZlbiBwYXRoLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQ2hpbGRXcml0ZXMod3JpdGVUcmVlLCBwYXRoKSB7XHJcbiAgICByZXR1cm4gbmV3V3JpdGVUcmVlUmVmKHBhdGgsIHdyaXRlVHJlZSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlY29yZCBhIG5ldyBvdmVyd3JpdGUgZnJvbSB1c2VyIGNvZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB2aXNpYmxlIC0gVGhpcyBpcyBzZXQgdG8gZmFsc2UgYnkgc29tZSB0cmFuc2FjdGlvbnMuIEl0IHNob3VsZCBiZSBleGNsdWRlZCBmcm9tIGV2ZW50IGNhY2hlc1xyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQWRkT3ZlcndyaXRlKHdyaXRlVHJlZSwgcGF0aCwgc25hcCwgd3JpdGVJZCwgdmlzaWJsZSkge1xyXG4gICAgYXNzZXJ0KHdyaXRlSWQgPiB3cml0ZVRyZWUubGFzdFdyaXRlSWQsICdTdGFja2luZyBhbiBvbGRlciB3cml0ZSBvbiB0b3Agb2YgbmV3ZXIgb25lcycpO1xyXG4gICAgaWYgKHZpc2libGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHZpc2libGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgd3JpdGVUcmVlLmFsbFdyaXRlcy5wdXNoKHtcclxuICAgICAgICBwYXRoLFxyXG4gICAgICAgIHNuYXAsXHJcbiAgICAgICAgd3JpdGVJZCxcclxuICAgICAgICB2aXNpYmxlXHJcbiAgICB9KTtcclxuICAgIGlmICh2aXNpYmxlKSB7XHJcbiAgICAgICAgd3JpdGVUcmVlLnZpc2libGVXcml0ZXMgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgsIHNuYXApO1xyXG4gICAgfVxyXG4gICAgd3JpdGVUcmVlLmxhc3RXcml0ZUlkID0gd3JpdGVJZDtcclxufVxyXG4vKipcclxuICogUmVjb3JkIGEgbmV3IG1lcmdlIGZyb20gdXNlciBjb2RlLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQWRkTWVyZ2Uod3JpdGVUcmVlLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpIHtcclxuICAgIGFzc2VydCh3cml0ZUlkID4gd3JpdGVUcmVlLmxhc3RXcml0ZUlkLCAnU3RhY2tpbmcgYW4gb2xkZXIgbWVyZ2Ugb24gdG9wIG9mIG5ld2VyIG9uZXMnKTtcclxuICAgIHdyaXRlVHJlZS5hbGxXcml0ZXMucHVzaCh7XHJcbiAgICAgICAgcGF0aCxcclxuICAgICAgICBjaGlsZHJlbjogY2hhbmdlZENoaWxkcmVuLFxyXG4gICAgICAgIHdyaXRlSWQsXHJcbiAgICAgICAgdmlzaWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICB3cml0ZVRyZWUudmlzaWJsZVdyaXRlcyA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZXMod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbik7XHJcbiAgICB3cml0ZVRyZWUubGFzdFdyaXRlSWQgPSB3cml0ZUlkO1xyXG59XHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUdldFdyaXRlKHdyaXRlVHJlZSwgd3JpdGVJZCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cml0ZVRyZWUuYWxsV3JpdGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcmVjb3JkID0gd3JpdGVUcmVlLmFsbFdyaXRlc1tpXTtcclxuICAgICAgICBpZiAocmVjb3JkLndyaXRlSWQgPT09IHdyaXRlSWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vKipcclxuICogUmVtb3ZlIGEgd3JpdGUgKGVpdGhlciBhbiBvdmVyd3JpdGUgb3IgbWVyZ2UpIHRoYXQgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGFja25vd2xlZGdlIGJ5IHRoZSBzZXJ2ZXIuIFJlY2FsY3VsYXRlc1xyXG4gKiB0aGUgdHJlZSBpZiBuZWNlc3NhcnkuICBXZSByZXR1cm4gdHJ1ZSBpZiBpdCBtYXkgaGF2ZSBiZWVuIHZpc2libGUsIG1lYW5pbmcgdmlld3MgbmVlZCB0byByZWV2YWx1YXRlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB3cml0ZSBtYXkgaGF2ZSBiZWVuIHZpc2libGUgKG1lYW5pbmcgd2UnbGwgbmVlZCB0byByZWV2YWx1YXRlIC8gcmFpc2VcclxuICogZXZlbnRzIGFzIGEgcmVzdWx0KS5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlbW92ZVdyaXRlKHdyaXRlVHJlZSwgd3JpdGVJZCkge1xyXG4gICAgLy8gTm90ZTogZGlzYWJsaW5nIHRoaXMgY2hlY2suIEl0IGNvdWxkIGJlIGEgdHJhbnNhY3Rpb24gdGhhdCBwcmVlbXB0ZWQgYW5vdGhlciB0cmFuc2FjdGlvbiwgYW5kIHRodXMgd2FzIGFwcGxpZWRcclxuICAgIC8vIG91dCBvZiBvcmRlci5cclxuICAgIC8vY29uc3QgdmFsaWRDbGVhciA9IHJldmVydCB8fCB0aGlzLmFsbFdyaXRlc18ubGVuZ3RoID09PSAwIHx8IHdyaXRlSWQgPD0gdGhpcy5hbGxXcml0ZXNfWzBdLndyaXRlSWQ7XHJcbiAgICAvL2Fzc2VydCh2YWxpZENsZWFyLCBcIkVpdGhlciB3ZSBkb24ndCBoYXZlIHRoaXMgd3JpdGUsIG9yIGl0J3MgdGhlIGZpcnN0IG9uZSBpbiB0aGUgcXVldWVcIik7XHJcbiAgICBjb25zdCBpZHggPSB3cml0ZVRyZWUuYWxsV3JpdGVzLmZpbmRJbmRleChzID0+IHtcclxuICAgICAgICByZXR1cm4gcy53cml0ZUlkID09PSB3cml0ZUlkO1xyXG4gICAgfSk7XHJcbiAgICBhc3NlcnQoaWR4ID49IDAsICdyZW1vdmVXcml0ZSBjYWxsZWQgd2l0aCBub25leGlzdGVudCB3cml0ZUlkLicpO1xyXG4gICAgY29uc3Qgd3JpdGVUb1JlbW92ZSA9IHdyaXRlVHJlZS5hbGxXcml0ZXNbaWR4XTtcclxuICAgIHdyaXRlVHJlZS5hbGxXcml0ZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICBsZXQgcmVtb3ZlZFdyaXRlV2FzVmlzaWJsZSA9IHdyaXRlVG9SZW1vdmUudmlzaWJsZTtcclxuICAgIGxldCByZW1vdmVkV3JpdGVPdmVybGFwc1dpdGhPdGhlcldyaXRlcyA9IGZhbHNlO1xyXG4gICAgbGV0IGkgPSB3cml0ZVRyZWUuYWxsV3JpdGVzLmxlbmd0aCAtIDE7XHJcbiAgICB3aGlsZSAocmVtb3ZlZFdyaXRlV2FzVmlzaWJsZSAmJiBpID49IDApIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50V3JpdGUgPSB3cml0ZVRyZWUuYWxsV3JpdGVzW2ldO1xyXG4gICAgICAgIGlmIChjdXJyZW50V3JpdGUudmlzaWJsZSkge1xyXG4gICAgICAgICAgICBpZiAoaSA+PSBpZHggJiZcclxuICAgICAgICAgICAgICAgIHdyaXRlVHJlZVJlY29yZENvbnRhaW5zUGF0aF8oY3VycmVudFdyaXRlLCB3cml0ZVRvUmVtb3ZlLnBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVtb3ZlZCB3cml0ZSB3YXMgY29tcGxldGVseSBzaGFkb3dlZCBieSBhIHN1YnNlcXVlbnQgd3JpdGUuXHJcbiAgICAgICAgICAgICAgICByZW1vdmVkV3JpdGVXYXNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGF0aENvbnRhaW5zKHdyaXRlVG9SZW1vdmUucGF0aCwgY3VycmVudFdyaXRlLnBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgd2UncmUgY292ZXJpbmcgc29tZSB3cml0ZXMgb3IgdGhleSdyZSBjb3ZlcmluZyBwYXJ0IG9mIHVzIChkZXBlbmRpbmcgb24gd2hpY2ggY2FtZSBmaXJzdCkuXHJcbiAgICAgICAgICAgICAgICByZW1vdmVkV3JpdGVPdmVybGFwc1dpdGhPdGhlcldyaXRlcyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaS0tO1xyXG4gICAgfVxyXG4gICAgaWYgKCFyZW1vdmVkV3JpdGVXYXNWaXNpYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmVtb3ZlZFdyaXRlT3ZlcmxhcHNXaXRoT3RoZXJXcml0ZXMpIHtcclxuICAgICAgICAvLyBUaGVyZSdzIHNvbWUgc2hhZG93aW5nIGdvaW5nIG9uLiBKdXN0IHJlYnVpbGQgdGhlIHZpc2libGUgd3JpdGVzIGZyb20gc2NyYXRjaC5cclxuICAgICAgICB3cml0ZVRyZWVSZXNldFRyZWVfKHdyaXRlVHJlZSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBUaGVyZSdzIG5vIHNoYWRvd2luZy4gIFdlIGNhbiBzYWZlbHkganVzdCByZW1vdmUgdGhlIHdyaXRlKHMpIGZyb20gdmlzaWJsZVdyaXRlcy5cclxuICAgICAgICBpZiAod3JpdGVUb1JlbW92ZS5zbmFwKSB7XHJcbiAgICAgICAgICAgIHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzID0gY29tcG91bmRXcml0ZVJlbW92ZVdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB3cml0ZVRvUmVtb3ZlLnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB3cml0ZVRvUmVtb3ZlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICBlYWNoKGNoaWxkcmVuLCAoY2hpbGROYW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVRyZWUudmlzaWJsZVdyaXRlcyA9IGNvbXBvdW5kV3JpdGVSZW1vdmVXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aENoaWxkKHdyaXRlVG9SZW1vdmUucGF0aCwgY2hpbGROYW1lKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWNvcmRDb250YWluc1BhdGhfKHdyaXRlUmVjb3JkLCBwYXRoKSB7XHJcbiAgICBpZiAod3JpdGVSZWNvcmQuc25hcCkge1xyXG4gICAgICAgIHJldHVybiBwYXRoQ29udGFpbnMod3JpdGVSZWNvcmQucGF0aCwgcGF0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkTmFtZSBpbiB3cml0ZVJlY29yZC5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAod3JpdGVSZWNvcmQuY2hpbGRyZW4uaGFzT3duUHJvcGVydHkoY2hpbGROYW1lKSAmJlxyXG4gICAgICAgICAgICAgICAgcGF0aENvbnRhaW5zKHBhdGhDaGlsZCh3cml0ZVJlY29yZC5wYXRoLCBjaGlsZE5hbWUpLCBwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZS1sYXllciB0aGUgd3JpdGVzIGFuZCBtZXJnZXMgaW50byBhIHRyZWUgc28gd2UgY2FuIGVmZmljaWVudGx5IGNhbGN1bGF0ZSBldmVudCBzbmFwc2hvdHNcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlc2V0VHJlZV8od3JpdGVUcmVlKSB7XHJcbiAgICB3cml0ZVRyZWUudmlzaWJsZVdyaXRlcyA9IHdyaXRlVHJlZUxheWVyVHJlZV8od3JpdGVUcmVlLmFsbFdyaXRlcywgd3JpdGVUcmVlRGVmYXVsdEZpbHRlcl8sIG5ld0VtcHR5UGF0aCgpKTtcclxuICAgIGlmICh3cml0ZVRyZWUuYWxsV3JpdGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB3cml0ZVRyZWUubGFzdFdyaXRlSWQgPVxyXG4gICAgICAgICAgICB3cml0ZVRyZWUuYWxsV3JpdGVzW3dyaXRlVHJlZS5hbGxXcml0ZXMubGVuZ3RoIC0gMV0ud3JpdGVJZDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHdyaXRlVHJlZS5sYXN0V3JpdGVJZCA9IC0xO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBmaWx0ZXIgdXNlZCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgdHJlZS4gS2VlcCBldmVyeXRoaW5nIHRoYXQncyB2aXNpYmxlLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlRGVmYXVsdEZpbHRlcl8od3JpdGUpIHtcclxuICAgIHJldHVybiB3cml0ZS52aXNpYmxlO1xyXG59XHJcbi8qKlxyXG4gKiBTdGF0aWMgbWV0aG9kLiBHaXZlbiBhbiBhcnJheSBvZiBXcml0ZVJlY29yZHMsIGEgZmlsdGVyIGZvciB3aGljaCBvbmVzIHRvIGluY2x1ZGUsIGFuZCBhIHBhdGgsIGNvbnN0cnVjdCB0aGUgdHJlZSBvZlxyXG4gKiBldmVudCBkYXRhIGF0IHRoYXQgcGF0aC5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUxheWVyVHJlZV8od3JpdGVzLCBmaWx0ZXIsIHRyZWVSb290KSB7XHJcbiAgICBsZXQgY29tcG91bmRXcml0ZSA9IENvbXBvdW5kV3JpdGUuZW1wdHkoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JpdGVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY29uc3Qgd3JpdGUgPSB3cml0ZXNbaV07XHJcbiAgICAgICAgLy8gVGhlb3J5LCBhIGxhdGVyIHNldCB3aWxsIGVpdGhlcjpcclxuICAgICAgICAvLyBhKSBhYm9ydCBhIHJlbGV2YW50IHRyYW5zYWN0aW9uLCBzbyBubyBuZWVkIHRvIHdvcnJ5IGFib3V0IGV4Y2x1ZGluZyBpdCBmcm9tIGNhbGN1bGF0aW5nIHRoYXQgdHJhbnNhY3Rpb25cclxuICAgICAgICAvLyBiKSBub3QgYmUgcmVsZXZhbnQgdG8gYSB0cmFuc2FjdGlvbiAoc2VwYXJhdGUgYnJhbmNoKSwgc28gYWdhaW4gd2lsbCBub3QgYWZmZWN0IHRoZSBkYXRhIGZvciB0aGF0IHRyYW5zYWN0aW9uXHJcbiAgICAgICAgaWYgKGZpbHRlcih3cml0ZSkpIHtcclxuICAgICAgICAgICAgY29uc3Qgd3JpdGVQYXRoID0gd3JpdGUucGF0aDtcclxuICAgICAgICAgICAgbGV0IHJlbGF0aXZlUGF0aDtcclxuICAgICAgICAgICAgaWYgKHdyaXRlLnNuYXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXRoQ29udGFpbnModHJlZVJvb3QsIHdyaXRlUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgodHJlZVJvb3QsIHdyaXRlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG91bmRXcml0ZSA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZShjb21wb3VuZFdyaXRlLCByZWxhdGl2ZVBhdGgsIHdyaXRlLnNuYXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGF0aENvbnRhaW5zKHdyaXRlUGF0aCwgdHJlZVJvb3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHdyaXRlUGF0aCwgdHJlZVJvb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kV3JpdGUgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGUoY29tcG91bmRXcml0ZSwgbmV3RW1wdHlQYXRoKCksIHdyaXRlLnNuYXAuZ2V0Q2hpbGQocmVsYXRpdmVQYXRoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh3cml0ZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGhDb250YWlucyh0cmVlUm9vdCwgd3JpdGVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aCh0cmVlUm9vdCwgd3JpdGVQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZUFkZFdyaXRlcyhjb21wb3VuZFdyaXRlLCByZWxhdGl2ZVBhdGgsIHdyaXRlLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhdGhDb250YWlucyh3cml0ZVBhdGgsIHRyZWVSb290KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aCh3cml0ZVBhdGgsIHRyZWVSb290KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZUFkZFdyaXRlcyhjb21wb3VuZFdyaXRlLCBuZXdFbXB0eVBhdGgoKSwgd3JpdGUuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBzYWZlR2V0KHdyaXRlLmNoaWxkcmVuLCBwYXRoR2V0RnJvbnQocmVsYXRpdmVQYXRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgZXhpc3RzIGEgY2hpbGQgaW4gdGhpcyBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgcm9vdCBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWVwTm9kZSA9IGNoaWxkLmdldENoaWxkKHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kV3JpdGUgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGUoY29tcG91bmRXcml0ZSwgbmV3RW1wdHlQYXRoKCksIGRlZXBOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IoJ1dyaXRlUmVjb3JkIHNob3VsZCBoYXZlIC5zbmFwIG9yIC5jaGlsZHJlbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbXBvdW5kV3JpdGU7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIG9wdGlvbmFsLCB1bmRlcmx5aW5nIHNlcnZlciBkYXRhLCBhbmQgYW4gb3B0aW9uYWwgc2V0IG9mIGNvbnN0cmFpbnRzIChleGNsdWRlIHNvbWUgc2V0cywgaW5jbHVkZSBoaWRkZW5cclxuICogd3JpdGVzKSwgYXR0ZW1wdCB0byBjYWxjdWxhdGUgYSBjb21wbGV0ZSBzbmFwc2hvdCBmb3IgdGhlIGdpdmVuIHBhdGhcclxuICpcclxuICogQHBhcmFtIHdyaXRlSWRzVG9FeGNsdWRlIC0gQW4gb3B0aW9uYWwgc2V0IHRvIGJlIGV4Y2x1ZGVkXHJcbiAqIEBwYXJhbSBpbmNsdWRlSGlkZGVuV3JpdGVzIC0gRGVmYXVsdHMgdG8gZmFsc2UsIHdoZXRoZXIgb3Igbm90IHRvIGxheWVyIG9uIHdyaXRlcyB3aXRoIHZpc2libGUgc2V0IHRvIGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlVHJlZSwgdHJlZVBhdGgsIGNvbXBsZXRlU2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuV3JpdGVzKSB7XHJcbiAgICBpZiAoIXdyaXRlSWRzVG9FeGNsdWRlICYmICFpbmNsdWRlSGlkZGVuV3JpdGVzKSB7XHJcbiAgICAgICAgY29uc3Qgc2hhZG93aW5nTm9kZSA9IGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHRyZWVQYXRoKTtcclxuICAgICAgICBpZiAoc2hhZG93aW5nTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaGFkb3dpbmdOb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc3ViTWVyZ2UgPSBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB0cmVlUGF0aCk7XHJcbiAgICAgICAgICAgIGlmIChjb21wb3VuZFdyaXRlSXNFbXB0eShzdWJNZXJnZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZVNlcnZlckNhY2hlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBsZXRlU2VydmVyQ2FjaGUgPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgIWNvbXBvdW5kV3JpdGVIYXNDb21wbGV0ZVdyaXRlKHN1Yk1lcmdlLCBuZXdFbXB0eVBhdGgoKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHdvdWxkbid0IGhhdmUgYSBjb21wbGV0ZSBzbmFwc2hvdCwgc2luY2UgdGhlcmUncyBubyB1bmRlcmx5aW5nIGRhdGEgYW5kIG5vIGNvbXBsZXRlIHNoYWRvd1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXllcmVkQ2FjaGUgPSBjb21wbGV0ZVNlcnZlckNhY2hlIHx8IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvdW5kV3JpdGVBcHBseShzdWJNZXJnZSwgbGF5ZXJlZENhY2hlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG1lcmdlID0gY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgdHJlZVBhdGgpO1xyXG4gICAgICAgIGlmICghaW5jbHVkZUhpZGRlbldyaXRlcyAmJiBjb21wb3VuZFdyaXRlSXNFbXB0eShtZXJnZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlU2VydmVyQ2FjaGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgc2VydmVyIGNhY2hlIGlzIG51bGwsIGFuZCB3ZSBkb24ndCBoYXZlIGEgY29tcGxldGUgY2FjaGUsIHdlIG5lZWQgdG8gcmV0dXJuIG51bGxcclxuICAgICAgICAgICAgaWYgKCFpbmNsdWRlSGlkZGVuV3JpdGVzICYmXHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZVNlcnZlckNhY2hlID09IG51bGwgJiZcclxuICAgICAgICAgICAgICAgICFjb21wb3VuZFdyaXRlSGFzQ29tcGxldGVXcml0ZShtZXJnZSwgbmV3RW1wdHlQYXRoKCkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGZ1bmN0aW9uICh3cml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHdyaXRlLnZpc2libGUgfHwgaW5jbHVkZUhpZGRlbldyaXRlcykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCF3cml0ZUlkc1RvRXhjbHVkZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIX53cml0ZUlkc1RvRXhjbHVkZS5pbmRleE9mKHdyaXRlLndyaXRlSWQpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocGF0aENvbnRhaW5zKHdyaXRlLnBhdGgsIHRyZWVQYXRoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aENvbnRhaW5zKHRyZWVQYXRoLCB3cml0ZS5wYXRoKSkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlQXRQYXRoID0gd3JpdGVUcmVlTGF5ZXJUcmVlXyh3cml0ZVRyZWUuYWxsV3JpdGVzLCBmaWx0ZXIsIHRyZWVQYXRoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyZWRDYWNoZSA9IGNvbXBsZXRlU2VydmVyQ2FjaGUgfHwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG91bmRXcml0ZUFwcGx5KG1lcmdlQXRQYXRoLCBsYXllcmVkQ2FjaGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBXaXRoIG9wdGlvbmFsLCB1bmRlcmx5aW5nIHNlcnZlciBkYXRhLCBhdHRlbXB0IHRvIHJldHVybiBhIGNoaWxkcmVuIG5vZGUgb2YgY2hpbGRyZW4gdGhhdCB3ZSBoYXZlIGNvbXBsZXRlIGRhdGEgZm9yLlxyXG4gKiBVc2VkIHdoZW4gY3JlYXRpbmcgbmV3IHZpZXdzLCB0byBwcmUtZmlsbCB0aGVpciBjb21wbGV0ZSBldmVudCBjaGlsZHJlbiBzbmFwc2hvdC5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4od3JpdGVUcmVlLCB0cmVlUGF0aCwgY29tcGxldGVTZXJ2ZXJDaGlsZHJlbikge1xyXG4gICAgbGV0IGNvbXBsZXRlQ2hpbGRyZW4gPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgIGNvbnN0IHRvcExldmVsU2V0ID0gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgdHJlZVBhdGgpO1xyXG4gICAgaWYgKHRvcExldmVsU2V0KSB7XHJcbiAgICAgICAgaWYgKCF0b3BMZXZlbFNldC5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgLy8gd2UncmUgc2hhZG93aW5nIGV2ZXJ5dGhpbmcuIFJldHVybiB0aGUgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgIHRvcExldmVsU2V0LmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGNoaWxkTmFtZSwgY2hpbGRTbmFwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIGNoaWxkU25hcCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29tcGxldGVDaGlsZHJlbjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4pIHtcclxuICAgICAgICAvLyBMYXllciBhbnkgY2hpbGRyZW4gd2UgaGF2ZSBvbiB0b3Agb2YgdGhpc1xyXG4gICAgICAgIC8vIFdlIGtub3cgd2UgZG9uJ3QgaGF2ZSBhIHRvcC1sZXZlbCBzZXQsIHNvIGp1c3QgZW51bWVyYXRlIGV4aXN0aW5nIGNoaWxkcmVuXHJcbiAgICAgICAgY29uc3QgbWVyZ2UgPSBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB0cmVlUGF0aCk7XHJcbiAgICAgICAgY29tcGxldGVTZXJ2ZXJDaGlsZHJlbi5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChjaGlsZE5hbWUsIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlID0gY29tcG91bmRXcml0ZUFwcGx5KGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUobWVyZ2UsIG5ldyBQYXRoKGNoaWxkTmFtZSkpLCBjaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIG5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEFkZCBhbnkgY29tcGxldGUgY2hpbGRyZW4gd2UgaGF2ZSBmcm9tIHRoZSBzZXRcclxuICAgICAgICBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVDaGlsZHJlbihtZXJnZSkuZm9yRWFjaChuYW1lZE5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChuYW1lZE5vZGUubmFtZSwgbmFtZWROb2RlLm5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb21wbGV0ZUNoaWxkcmVuO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBsYXllciBvbiB0b3Agb2YuIExheWVyIG9uIGFueSBjaGlsZHJlbiB3ZSBoYXZlXHJcbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGNhbiByZXR1cm4gYW4gZW1wdHkgc25hcCBpZiB3ZSBoYXZlIGEgZGVmaW5lZCBkZWxldGVcclxuICAgICAgICBjb25zdCBtZXJnZSA9IGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHRyZWVQYXRoKTtcclxuICAgICAgICBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVDaGlsZHJlbihtZXJnZSkuZm9yRWFjaChuYW1lZE5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChuYW1lZE5vZGUubmFtZSwgbmFtZWROb2RlLm5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb21wbGV0ZUNoaWxkcmVuO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiB0aGF0IHRoZSB1bmRlcmx5aW5nIHNlcnZlciBkYXRhIGhhcyB1cGRhdGVkLCBkZXRlcm1pbmUgd2hhdCwgaWYgYW55dGhpbmcsIG5lZWRzIHRvIGJlXHJcbiAqIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGNhY2hlLlxyXG4gKlxyXG4gKiBQb3NzaWJpbGl0aWVzOlxyXG4gKlxyXG4gKiAxLiBObyB3cml0ZXMgYXJlIHNoYWRvd2luZy4gRXZlbnRzIHNob3VsZCBiZSByYWlzZWQsIHRoZSBzbmFwIHRvIGJlIGFwcGxpZWQgY29tZXMgZnJvbSB0aGUgc2VydmVyIGRhdGFcclxuICpcclxuICogMi4gU29tZSB3cml0ZSBpcyBjb21wbGV0ZWx5IHNoYWRvd2luZy4gTm8gZXZlbnRzIHRvIGJlIHJhaXNlZFxyXG4gKlxyXG4gKiAzLiBJcyBwYXJ0aWFsbHkgc2hhZG93ZWQuIEV2ZW50c1xyXG4gKlxyXG4gKiBFaXRoZXIgZXhpc3RpbmdFdmVudFNuYXAgb3IgZXhpc3RpbmdTZXJ2ZXJTbmFwIG11c3QgZXhpc3RcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUod3JpdGVUcmVlLCB0cmVlUGF0aCwgY2hpbGRQYXRoLCBleGlzdGluZ0V2ZW50U25hcCwgZXhpc3RpbmdTZXJ2ZXJTbmFwKSB7XHJcbiAgICBhc3NlcnQoZXhpc3RpbmdFdmVudFNuYXAgfHwgZXhpc3RpbmdTZXJ2ZXJTbmFwLCAnRWl0aGVyIGV4aXN0aW5nRXZlbnRTbmFwIG9yIGV4aXN0aW5nU2VydmVyU25hcCBtdXN0IGV4aXN0Jyk7XHJcbiAgICBjb25zdCBwYXRoID0gcGF0aENoaWxkKHRyZWVQYXRoLCBjaGlsZFBhdGgpO1xyXG4gICAgaWYgKGNvbXBvdW5kV3JpdGVIYXNDb21wbGV0ZVdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCBwYXRoKSkge1xyXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgY2FuIHByb2JhYmx5IGd1YXJhbnRlZSB0aGF0IHdlJ3JlIGluIGNhc2UgMiwgbWVhbmluZyBubyBldmVudHNcclxuICAgICAgICAvLyBNYXkgbmVlZCB0byBjaGVjayB2aXNpYmlsaXR5IHdoaWxlIGRvaW5nIHRoZSBmaW5kUm9vdE1vc3RWYWx1ZUFuZFBhdGggY2FsbFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gTm8gY29tcGxldGUgc2hhZG93aW5nLiBXZSdyZSBlaXRoZXIgcGFydGlhbGx5IHNoYWRvd2luZyBvciBub3Qgc2hhZG93aW5nIGF0IGFsbC5cclxuICAgICAgICBjb25zdCBjaGlsZE1lcmdlID0gY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aCk7XHJcbiAgICAgICAgaWYgKGNvbXBvdW5kV3JpdGVJc0VtcHR5KGNoaWxkTWVyZ2UpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBzaGFkb3dpbmcgYXQgYWxsLiBDYXNlIDFcclxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nU2VydmVyU25hcC5nZXRDaGlsZChjaGlsZFBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBtb3JlIGVmZmljaWVudCBpZiB0aGUgc2VydmVyTm9kZSArIHVwZGF0ZXMgZG9lc24ndCBjaGFuZ2UgdGhlIGV2ZW50U25hcFxyXG4gICAgICAgICAgICAvLyBIb3dldmVyIHRoaXMgaXMgdHJpY2t5IHRvIGZpbmQgb3V0LCBzaW5jZSB1c2VyIHVwZGF0ZXMgZG9uJ3QgbmVjZXNzYXJ5IGNoYW5nZSB0aGUgc2VydmVyXHJcbiAgICAgICAgICAgIC8vIHNuYXAsIGUuZy4gcHJpb3JpdHkgdXBkYXRlcyBvbiBlbXB0eSBub2Rlcywgb3IgZGVlcCBkZWxldGVzLiBBbm90aGVyIHNwZWNpYWwgY2FzZSBpcyBpZiB0aGUgc2VydmVyXHJcbiAgICAgICAgICAgIC8vIGFkZHMgbm9kZXMsIGJ1dCBkb2Vzbid0IGNoYW5nZSBhbnkgZXhpc3Rpbmcgd3JpdGVzLiBJdCBpcyB0aGVyZWZvcmUgbm90IGVub3VnaCB0b1xyXG4gICAgICAgICAgICAvLyBvbmx5IGNoZWNrIGlmIHRoZSB1cGRhdGVzIGNoYW5nZSB0aGUgc2VydmVyTm9kZS5cclxuICAgICAgICAgICAgLy8gTWF5YmUgY2hlY2sgaWYgdGhlIG1lcmdlIHRyZWUgY29udGFpbnMgdGhlc2Ugc3BlY2lhbCBjYXNlcyBhbmQgb25seSBkbyBhIGZ1bGwgb3ZlcndyaXRlIGluIHRoYXQgY2FzZT9cclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBvdW5kV3JpdGVBcHBseShjaGlsZE1lcmdlLCBleGlzdGluZ1NlcnZlclNuYXAuZ2V0Q2hpbGQoY2hpbGRQYXRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY29tcGxldGUgY2hpbGQgZm9yIGEgZ2l2ZW4gc2VydmVyIHNuYXAgYWZ0ZXIgYXBwbHlpbmcgYWxsIHVzZXIgd3JpdGVzIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9cclxuICogY29tcGxldGUgY2hpbGQgZm9yIHRoaXMgQ2hpbGRLZXkuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVDYWxjQ29tcGxldGVDaGlsZCh3cml0ZVRyZWUsIHRyZWVQYXRoLCBjaGlsZEtleSwgZXhpc3RpbmdTZXJ2ZXJTbmFwKSB7XHJcbiAgICBjb25zdCBwYXRoID0gcGF0aENoaWxkKHRyZWVQYXRoLCBjaGlsZEtleSk7XHJcbiAgICBjb25zdCBzaGFkb3dpbmdOb2RlID0gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aCk7XHJcbiAgICBpZiAoc2hhZG93aW5nTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHNoYWRvd2luZ05vZGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoZXhpc3RpbmdTZXJ2ZXJTbmFwLmlzQ29tcGxldGVGb3JDaGlsZChjaGlsZEtleSkpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRNZXJnZSA9IGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcG91bmRXcml0ZUFwcGx5KGNoaWxkTWVyZ2UsIGV4aXN0aW5nU2VydmVyU25hcC5nZXROb2RlKCkuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIG5vZGUgaWYgdGhlcmUgaXMgYSBjb21wbGV0ZSBvdmVyd3JpdGUgZm9yIHRoaXMgcGF0aC4gTW9yZSBzcGVjaWZpY2FsbHksIGlmIHRoZXJlIGlzIGEgd3JpdGUgYXRcclxuICogYSBoaWdoZXIgcGF0aCwgdGhpcyB3aWxsIHJldHVybiB0aGUgY2hpbGQgb2YgdGhhdCB3cml0ZSByZWxhdGl2ZSB0byB0aGUgd3JpdGUgYW5kIHRoaXMgcGF0aC5cclxuICogUmV0dXJucyBudWxsIGlmIHRoZXJlIGlzIG5vIHdyaXRlIGF0IHRoaXMgcGF0aC5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVNoYWRvd2luZ1dyaXRlKHdyaXRlVHJlZSwgcGF0aCkge1xyXG4gICAgcmV0dXJuIGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgpO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHdoZW4gcHJvY2Vzc2luZyBjaGlsZCByZW1vdmUgZXZlbnRzIG9uIGEgcXVlcnkuIElmIHdlIGNhbiwgd2UgcHVsbCBpbiBjaGlsZHJlbiB0aGF0IHdlcmUgb3V0c2lkZVxyXG4gKiB0aGUgd2luZG93LCBidXQgbWF5IG5vdyBiZSBpbiB0aGUgd2luZG93LlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQ2FsY0luZGV4ZWRTbGljZSh3cml0ZVRyZWUsIHRyZWVQYXRoLCBjb21wbGV0ZVNlcnZlckRhdGEsIHN0YXJ0UG9zdCwgY291bnQsIHJldmVyc2UsIGluZGV4KSB7XHJcbiAgICBsZXQgdG9JdGVyYXRlO1xyXG4gICAgY29uc3QgbWVyZ2UgPSBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB0cmVlUGF0aCk7XHJcbiAgICBjb25zdCBzaGFkb3dpbmdOb2RlID0gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZShtZXJnZSwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgaWYgKHNoYWRvd2luZ05vZGUgIT0gbnVsbCkge1xyXG4gICAgICAgIHRvSXRlcmF0ZSA9IHNoYWRvd2luZ05vZGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb21wbGV0ZVNlcnZlckRhdGEgIT0gbnVsbCkge1xyXG4gICAgICAgIHRvSXRlcmF0ZSA9IGNvbXBvdW5kV3JpdGVBcHBseShtZXJnZSwgY29tcGxldGVTZXJ2ZXJEYXRhKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIG5vIGNoaWxkcmVuIHRvIGl0ZXJhdGUgb25cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICB0b0l0ZXJhdGUgPSB0b0l0ZXJhdGUud2l0aEluZGV4KGluZGV4KTtcclxuICAgIGlmICghdG9JdGVyYXRlLmlzRW1wdHkoKSAmJiAhdG9JdGVyYXRlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gW107XHJcbiAgICAgICAgY29uc3QgY21wID0gaW5kZXguZ2V0Q29tcGFyZSgpO1xyXG4gICAgICAgIGNvbnN0IGl0ZXIgPSByZXZlcnNlXHJcbiAgICAgICAgICAgID8gdG9JdGVyYXRlLmdldFJldmVyc2VJdGVyYXRvckZyb20oc3RhcnRQb3N0LCBpbmRleClcclxuICAgICAgICAgICAgOiB0b0l0ZXJhdGUuZ2V0SXRlcmF0b3JGcm9tKHN0YXJ0UG9zdCwgaW5kZXgpO1xyXG4gICAgICAgIGxldCBuZXh0ID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgd2hpbGUgKG5leHQgJiYgbm9kZXMubGVuZ3RoIDwgY291bnQpIHtcclxuICAgICAgICAgICAgaWYgKGNtcChuZXh0LCBzdGFydFBvc3QpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5leHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5leHQgPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5ld1dyaXRlVHJlZSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmlzaWJsZVdyaXRlczogQ29tcG91bmRXcml0ZS5lbXB0eSgpLFxyXG4gICAgICAgIGFsbFdyaXRlczogW10sXHJcbiAgICAgICAgbGFzdFdyaXRlSWQ6IC0xXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBJZiBwb3NzaWJsZSwgcmV0dXJucyBhIGNvbXBsZXRlIGV2ZW50IGNhY2hlLCB1c2luZyB0aGUgdW5kZXJseWluZyBzZXJ2ZXIgZGF0YSBpZiBwb3NzaWJsZS4gSW4gYWRkaXRpb24sIGNhbiBiZSB1c2VkXHJcbiAqIHRvIGdldCBhIGNhY2hlIHRoYXQgaW5jbHVkZXMgaGlkZGVuIHdyaXRlcywgYW5kIGV4Y2x1ZGVzIGFyYml0cmFyeSB3cml0ZXMuIE5vdGUgdGhhdCBjdXN0b21pemluZyB0aGUgcmV0dXJuZWQgbm9kZVxyXG4gKiBjYW4gbGVhZCB0byBhIG1vcmUgZXhwZW5zaXZlIGNhbGN1bGF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gd3JpdGVJZHNUb0V4Y2x1ZGUgLSBPcHRpb25hbCB3cml0ZXMgdG8gZXhjbHVkZS5cclxuICogQHBhcmFtIGluY2x1ZGVIaWRkZW5Xcml0ZXMgLSBEZWZhdWx0cyB0byBmYWxzZSwgd2hldGhlciBvciBub3QgdG8gbGF5ZXIgb24gd3JpdGVzIHdpdGggdmlzaWJsZSBzZXQgdG8gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVUcmVlUmVmLCBjb21wbGV0ZVNlcnZlckNhY2hlLCB3cml0ZUlkc1RvRXhjbHVkZSwgaW5jbHVkZUhpZGRlbldyaXRlcykge1xyXG4gICAgcmV0dXJuIHdyaXRlVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVUcmVlUmVmLndyaXRlVHJlZSwgd3JpdGVUcmVlUmVmLnRyZWVQYXRoLCBjb21wbGV0ZVNlcnZlckNhY2hlLCB3cml0ZUlkc1RvRXhjbHVkZSwgaW5jbHVkZUhpZGRlbldyaXRlcyk7XHJcbn1cclxuLyoqXHJcbiAqIElmIHBvc3NpYmxlLCByZXR1cm5zIGEgY2hpbGRyZW4gbm9kZSBjb250YWluaW5nIGFsbCBvZiB0aGUgY29tcGxldGUgY2hpbGRyZW4gd2UgaGF2ZSBkYXRhIGZvci4gVGhlIHJldHVybmVkIGRhdGEgaXMgYVxyXG4gKiBtaXggb2YgdGhlIGdpdmVuIHNlcnZlciBkYXRhIGFuZCB3cml0ZSBkYXRhLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbih3cml0ZVRyZWVSZWYsIGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4pIHtcclxuICAgIHJldHVybiB3cml0ZVRyZWVDYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKHdyaXRlVHJlZVJlZi53cml0ZVRyZWUsIHdyaXRlVHJlZVJlZi50cmVlUGF0aCwgY29tcGxldGVTZXJ2ZXJDaGlsZHJlbik7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIHRoYXQgZWl0aGVyIHRoZSB1bmRlcmx5aW5nIHNlcnZlciBkYXRhIGhhcyB1cGRhdGVkIG9yIHRoZSBvdXRzdGFuZGluZyB3cml0ZXMgaGF2ZSB1cGRhdGVkLCBkZXRlcm1pbmUgd2hhdCxcclxuICogaWYgYW55dGhpbmcsIG5lZWRzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGNhY2hlLlxyXG4gKlxyXG4gKiBQb3NzaWJpbGl0aWVzOlxyXG4gKlxyXG4gKiAxLiBObyB3cml0ZXMgYXJlIHNoYWRvd2luZy4gRXZlbnRzIHNob3VsZCBiZSByYWlzZWQsIHRoZSBzbmFwIHRvIGJlIGFwcGxpZWQgY29tZXMgZnJvbSB0aGUgc2VydmVyIGRhdGFcclxuICpcclxuICogMi4gU29tZSB3cml0ZSBpcyBjb21wbGV0ZWx5IHNoYWRvd2luZy4gTm8gZXZlbnRzIHRvIGJlIHJhaXNlZFxyXG4gKlxyXG4gKiAzLiBJcyBwYXJ0aWFsbHkgc2hhZG93ZWQuIEV2ZW50cyBzaG91bGQgYmUgcmFpc2VkXHJcbiAqXHJcbiAqIEVpdGhlciBleGlzdGluZ0V2ZW50U25hcCBvciBleGlzdGluZ1NlcnZlclNuYXAgbXVzdCBleGlzdCwgdGhpcyBpcyB2YWxpZGF0ZWQgdmlhIGFuIGFzc2VydFxyXG4gKlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVmQ2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZSh3cml0ZVRyZWVSZWYsIHBhdGgsIGV4aXN0aW5nRXZlbnRTbmFwLCBleGlzdGluZ1NlcnZlclNuYXApIHtcclxuICAgIHJldHVybiB3cml0ZVRyZWVDYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlKHdyaXRlVHJlZVJlZi53cml0ZVRyZWUsIHdyaXRlVHJlZVJlZi50cmVlUGF0aCwgcGF0aCwgZXhpc3RpbmdFdmVudFNuYXAsIGV4aXN0aW5nU2VydmVyU25hcCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBub2RlIGlmIHRoZXJlIGlzIGEgY29tcGxldGUgb3ZlcndyaXRlIGZvciB0aGlzIHBhdGguIE1vcmUgc3BlY2lmaWNhbGx5LCBpZiB0aGVyZSBpcyBhIHdyaXRlIGF0XHJcbiAqIGEgaGlnaGVyIHBhdGgsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGNoaWxkIG9mIHRoYXQgd3JpdGUgcmVsYXRpdmUgdG8gdGhlIHdyaXRlIGFuZCB0aGlzIHBhdGguXHJcbiAqIFJldHVybnMgbnVsbCBpZiB0aGVyZSBpcyBubyB3cml0ZSBhdCB0aGlzIHBhdGguXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWZTaGFkb3dpbmdXcml0ZSh3cml0ZVRyZWVSZWYsIHBhdGgpIHtcclxuICAgIHJldHVybiB3cml0ZVRyZWVTaGFkb3dpbmdXcml0ZSh3cml0ZVRyZWVSZWYud3JpdGVUcmVlLCBwYXRoQ2hpbGQod3JpdGVUcmVlUmVmLnRyZWVQYXRoLCBwYXRoKSk7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgd2hlbiBwcm9jZXNzaW5nIGNoaWxkIHJlbW92ZSBldmVudHMgb24gYSBxdWVyeS4gSWYgd2UgY2FuLCB3ZSBwdWxsIGluIGNoaWxkcmVuIHRoYXQgd2VyZSBvdXRzaWRlXHJcbiAqIHRoZSB3aW5kb3csIGJ1dCBtYXkgbm93IGJlIGluIHRoZSB3aW5kb3dcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlZkNhbGNJbmRleGVkU2xpY2Uod3JpdGVUcmVlUmVmLCBjb21wbGV0ZVNlcnZlckRhdGEsIHN0YXJ0UG9zdCwgY291bnQsIHJldmVyc2UsIGluZGV4KSB7XHJcbiAgICByZXR1cm4gd3JpdGVUcmVlQ2FsY0luZGV4ZWRTbGljZSh3cml0ZVRyZWVSZWYud3JpdGVUcmVlLCB3cml0ZVRyZWVSZWYudHJlZVBhdGgsIGNvbXBsZXRlU2VydmVyRGF0YSwgc3RhcnRQb3N0LCBjb3VudCwgcmV2ZXJzZSwgaW5kZXgpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY29tcGxldGUgY2hpbGQgZm9yIGEgZ2l2ZW4gc2VydmVyIHNuYXAgYWZ0ZXIgYXBwbHlpbmcgYWxsIHVzZXIgd3JpdGVzIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9cclxuICogY29tcGxldGUgY2hpbGQgZm9yIHRoaXMgQ2hpbGRLZXkuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVDaGlsZCh3cml0ZVRyZWVSZWYsIGNoaWxkS2V5LCBleGlzdGluZ1NlcnZlckNhY2hlKSB7XHJcbiAgICByZXR1cm4gd3JpdGVUcmVlQ2FsY0NvbXBsZXRlQ2hpbGQod3JpdGVUcmVlUmVmLndyaXRlVHJlZSwgd3JpdGVUcmVlUmVmLnRyZWVQYXRoLCBjaGlsZEtleSwgZXhpc3RpbmdTZXJ2ZXJDYWNoZSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiBhIFdyaXRlVHJlZVJlZiBmb3IgYSBjaGlsZC5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlZkNoaWxkKHdyaXRlVHJlZVJlZiwgY2hpbGROYW1lKSB7XHJcbiAgICByZXR1cm4gbmV3V3JpdGVUcmVlUmVmKHBhdGhDaGlsZCh3cml0ZVRyZWVSZWYudHJlZVBhdGgsIGNoaWxkTmFtZSksIHdyaXRlVHJlZVJlZi53cml0ZVRyZWUpO1xyXG59XHJcbmZ1bmN0aW9uIG5ld1dyaXRlVHJlZVJlZihwYXRoLCB3cml0ZVRyZWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHJlZVBhdGg6IHBhdGgsXHJcbiAgICAgICAgd3JpdGVUcmVlXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIENoaWxkQ2hhbmdlQWNjdW11bGF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICB0cmFja0NoaWxkQ2hhbmdlKGNoYW5nZSkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBjaGFuZ2UudHlwZTtcclxuICAgICAgICBjb25zdCBjaGlsZEtleSA9IGNoYW5nZS5jaGlsZE5hbWU7XHJcbiAgICAgICAgYXNzZXJ0KHR5cGUgPT09IFwiY2hpbGRfYWRkZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0FEREVEICovIHx8XHJcbiAgICAgICAgICAgIHR5cGUgPT09IFwiY2hpbGRfY2hhbmdlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQ0hBTkdFRCAqLyB8fFxyXG4gICAgICAgICAgICB0eXBlID09PSBcImNoaWxkX3JlbW92ZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX1JFTU9WRUQgKi8sICdPbmx5IGNoaWxkIGNoYW5nZXMgc3VwcG9ydGVkIGZvciB0cmFja2luZycpO1xyXG4gICAgICAgIGFzc2VydChjaGlsZEtleSAhPT0gJy5wcmlvcml0eScsICdPbmx5IG5vbi1wcmlvcml0eSBjaGlsZCBjaGFuZ2VzIGNhbiBiZSB0cmFja2VkLicpO1xyXG4gICAgICAgIGNvbnN0IG9sZENoYW5nZSA9IHRoaXMuY2hhbmdlTWFwLmdldChjaGlsZEtleSk7XHJcbiAgICAgICAgaWYgKG9sZENoYW5nZSkge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRUeXBlID0gb2xkQ2hhbmdlLnR5cGU7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImNoaWxkX2FkZGVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9BRERFRCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PT0gXCJjaGlsZF9yZW1vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9SRU1PVkVEICovKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZU1hcC5zZXQoY2hpbGRLZXksIGNoYW5nZUNoaWxkQ2hhbmdlZChjaGlsZEtleSwgY2hhbmdlLnNuYXBzaG90Tm9kZSwgb2xkQ2hhbmdlLnNuYXBzaG90Tm9kZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiY2hpbGRfcmVtb3ZlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfUkVNT1ZFRCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PT0gXCJjaGlsZF9hZGRlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQURERUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLmRlbGV0ZShjaGlsZEtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJjaGlsZF9yZW1vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9SRU1PVkVEICovICYmXHJcbiAgICAgICAgICAgICAgICBvbGRUeXBlID09PSBcImNoaWxkX2NoYW5nZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0NIQU5HRUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLnNldChjaGlsZEtleSwgY2hhbmdlQ2hpbGRSZW1vdmVkKGNoaWxkS2V5LCBvbGRDaGFuZ2Uub2xkU25hcCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiY2hpbGRfY2hhbmdlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQ0hBTkdFRCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PT0gXCJjaGlsZF9hZGRlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQURERUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLnNldChjaGlsZEtleSwgY2hhbmdlQ2hpbGRBZGRlZChjaGlsZEtleSwgY2hhbmdlLnNuYXBzaG90Tm9kZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiY2hpbGRfY2hhbmdlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQ0hBTkdFRCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PT0gXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9DSEFOR0VEICovKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZU1hcC5zZXQoY2hpbGRLZXksIGNoYW5nZUNoaWxkQ2hhbmdlZChjaGlsZEtleSwgY2hhbmdlLnNuYXBzaG90Tm9kZSwgb2xkQ2hhbmdlLm9sZFNuYXApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKCdJbGxlZ2FsIGNvbWJpbmF0aW9uIG9mIGNoYW5nZXM6ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBvY2N1cnJlZCBhZnRlciAnICtcclxuICAgICAgICAgICAgICAgICAgICBvbGRDaGFuZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcC5zZXQoY2hpbGRLZXksIGNoYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0Q2hhbmdlcygpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNoYW5nZU1hcC52YWx1ZXMoKSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIENvbXBsZXRlQ2hpbGRTb3VyY2UgdGhhdCBuZXZlciByZXR1cm5zIGFueSBhZGRpdGlvbmFsIGNoaWxkcmVuXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmNsYXNzIE5vQ29tcGxldGVDaGlsZFNvdXJjZV8ge1xyXG4gICAgZ2V0Q29tcGxldGVDaGlsZChjaGlsZEtleSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2hpbGRBZnRlckNoaWxkKGluZGV4LCBjaGlsZCwgcmV2ZXJzZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTaW5nbGV0b24gaW5zdGFuY2UuXHJcbiAqL1xyXG5jb25zdCBOT19DT01QTEVURV9DSElMRF9TT1VSQ0UgPSBuZXcgTm9Db21wbGV0ZUNoaWxkU291cmNlXygpO1xyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgQ29tcGxldGVDaGlsZFNvdXJjZSB0aGF0IHVzZXMgYSBXcml0ZVRyZWUgaW4gYWRkaXRpb24gdG8gYW55IG90aGVyIHNlcnZlciBkYXRhIG9yXHJcbiAqIG9sZCBldmVudCBjYWNoZXMgYXZhaWxhYmxlIHRvIGNhbGN1bGF0ZSBjb21wbGV0ZSBjaGlsZHJlbi5cclxuICovXHJcbmNsYXNzIFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2Uge1xyXG4gICAgY29uc3RydWN0b3Iod3JpdGVzXywgdmlld0NhY2hlXywgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZXNfID0gd3JpdGVzXztcclxuICAgICAgICB0aGlzLnZpZXdDYWNoZV8gPSB2aWV3Q2FjaGVfO1xyXG4gICAgICAgIHRoaXMub3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gPSBvcHRDb21wbGV0ZVNlcnZlckNhY2hlXztcclxuICAgIH1cclxuICAgIGdldENvbXBsZXRlQ2hpbGQoY2hpbGRLZXkpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy52aWV3Q2FjaGVfLmV2ZW50Q2FjaGU7XHJcbiAgICAgICAgaWYgKG5vZGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXROb2RlKCkuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VydmVyTm9kZSA9IHRoaXMub3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gIT0gbnVsbFxyXG4gICAgICAgICAgICAgICAgPyBuZXcgQ2FjaGVOb2RlKHRoaXMub3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8sIHRydWUsIGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgOiB0aGlzLnZpZXdDYWNoZV8uc2VydmVyQ2FjaGU7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVDaGlsZCh0aGlzLndyaXRlc18sIGNoaWxkS2V5LCBzZXJ2ZXJOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDaGlsZEFmdGVyQ2hpbGQoaW5kZXgsIGNoaWxkLCByZXZlcnNlKSB7XHJcbiAgICAgICAgY29uc3QgY29tcGxldGVTZXJ2ZXJEYXRhID0gdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlXyAhPSBudWxsXHJcbiAgICAgICAgICAgID8gdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlX1xyXG4gICAgICAgICAgICA6IHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh0aGlzLnZpZXdDYWNoZV8pO1xyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gd3JpdGVUcmVlUmVmQ2FsY0luZGV4ZWRTbGljZSh0aGlzLndyaXRlc18sIGNvbXBsZXRlU2VydmVyRGF0YSwgY2hpbGQsIDEsIHJldmVyc2UsIGluZGV4KTtcclxuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzWzBdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdWaWV3UHJvY2Vzc29yKGZpbHRlcikge1xyXG4gICAgcmV0dXJuIHsgZmlsdGVyIH07XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFzc2VydEluZGV4ZWQodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlKSB7XHJcbiAgICBhc3NlcnQodmlld0NhY2hlLmV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLmlzSW5kZXhlZCh2aWV3UHJvY2Vzc29yLmZpbHRlci5nZXRJbmRleCgpKSwgJ0V2ZW50IHNuYXAgbm90IGluZGV4ZWQnKTtcclxuICAgIGFzc2VydCh2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLmlzSW5kZXhlZCh2aWV3UHJvY2Vzc29yLmZpbHRlci5nZXRJbmRleCgpKSwgJ1NlcnZlciBzbmFwIG5vdCBpbmRleGVkJyk7XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFwcGx5T3BlcmF0aW9uKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSkge1xyXG4gICAgY29uc3QgYWNjdW11bGF0b3IgPSBuZXcgQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcigpO1xyXG4gICAgbGV0IG5ld1ZpZXdDYWNoZSwgZmlsdGVyU2VydmVyTm9kZTtcclxuICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gT3BlcmF0aW9uVHlwZS5PVkVSV1JJVEUpIHtcclxuICAgICAgICBjb25zdCBvdmVyd3JpdGUgPSBvcGVyYXRpb247XHJcbiAgICAgICAgaWYgKG92ZXJ3cml0ZS5zb3VyY2UuZnJvbVVzZXIpIHtcclxuICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5VXNlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIG92ZXJ3cml0ZS5wYXRoLCBvdmVyd3JpdGUuc25hcCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFzc2VydChvdmVyd3JpdGUuc291cmNlLmZyb21TZXJ2ZXIsICdVbmtub3duIHNvdXJjZS4nKTtcclxuICAgICAgICAgICAgLy8gV2UgZmlsdGVyIHRoZSBub2RlIGlmIGl0J3MgYSB0YWdnZWQgdXBkYXRlIG9yIHRoZSBub2RlIGhhcyBiZWVuIHByZXZpb3VzbHkgZmlsdGVyZWQgIGFuZCB0aGVcclxuICAgICAgICAgICAgLy8gdXBkYXRlIGlzIG5vdCBhdCB0aGUgcm9vdCBpbiB3aGljaCBjYXNlIGl0IGlzIG9rIChhbmQgbmVjZXNzYXJ5KSB0byBtYXJrIHRoZSBub2RlIHVuZmlsdGVyZWRcclxuICAgICAgICAgICAgLy8gYWdhaW5cclxuICAgICAgICAgICAgZmlsdGVyU2VydmVyTm9kZSA9XHJcbiAgICAgICAgICAgICAgICBvdmVyd3JpdGUuc291cmNlLnRhZ2dlZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChvbGRWaWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGaWx0ZXJlZCgpICYmICFwYXRoSXNFbXB0eShvdmVyd3JpdGUucGF0aCkpO1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJPdmVyd3JpdGUodmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBvdmVyd3JpdGUucGF0aCwgb3ZlcndyaXRlLnNuYXAsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvblR5cGUuTUVSR0UpIHtcclxuICAgICAgICBjb25zdCBtZXJnZSA9IG9wZXJhdGlvbjtcclxuICAgICAgICBpZiAobWVyZ2Uuc291cmNlLmZyb21Vc2VyKSB7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdQcm9jZXNzb3JBcHBseVVzZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIG1lcmdlLnBhdGgsIG1lcmdlLmNoaWxkcmVuLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0KG1lcmdlLnNvdXJjZS5mcm9tU2VydmVyLCAnVW5rbm93biBzb3VyY2UuJyk7XHJcbiAgICAgICAgICAgIC8vIFdlIGZpbHRlciB0aGUgbm9kZSBpZiBpdCdzIGEgdGFnZ2VkIHVwZGF0ZSBvciB0aGUgbm9kZSBoYXMgYmVlbiBwcmV2aW91c2x5IGZpbHRlcmVkXHJcbiAgICAgICAgICAgIGZpbHRlclNlcnZlck5vZGUgPVxyXG4gICAgICAgICAgICAgICAgbWVyZ2Uuc291cmNlLnRhZ2dlZCB8fCBvbGRWaWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGaWx0ZXJlZCgpO1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIG1lcmdlLnBhdGgsIG1lcmdlLmNoaWxkcmVuLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25UeXBlLkFDS19VU0VSX1dSSVRFKSB7XHJcbiAgICAgICAgY29uc3QgYWNrVXNlcldyaXRlID0gb3BlcmF0aW9uO1xyXG4gICAgICAgIGlmICghYWNrVXNlcldyaXRlLnJldmVydCkge1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQWNrVXNlcldyaXRlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgYWNrVXNlcldyaXRlLnBhdGgsIGFja1VzZXJXcml0ZS5hZmZlY3RlZFRyZWUsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yUmV2ZXJ0VXNlcldyaXRlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgYWNrVXNlcldyaXRlLnBhdGgsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvblR5cGUuTElTVEVOX0NPTVBMRVRFKSB7XHJcbiAgICAgICAgbmV3Vmlld0NhY2hlID0gdmlld1Byb2Nlc3Nvckxpc3RlbkNvbXBsZXRlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgb3BlcmF0aW9uLnBhdGgsIHdyaXRlc0NhY2hlLCBhY2N1bXVsYXRvcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBhc3NlcnRpb25FcnJvcignVW5rbm93biBvcGVyYXRpb24gdHlwZTogJyArIG9wZXJhdGlvbi50eXBlKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNoYW5nZXMgPSBhY2N1bXVsYXRvci5nZXRDaGFuZ2VzKCk7XHJcbiAgICB2aWV3UHJvY2Vzc29yTWF5YmVBZGRWYWx1ZUV2ZW50KG9sZFZpZXdDYWNoZSwgbmV3Vmlld0NhY2hlLCBjaGFuZ2VzKTtcclxuICAgIHJldHVybiB7IHZpZXdDYWNoZTogbmV3Vmlld0NhY2hlLCBjaGFuZ2VzIH07XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3Nvck1heWJlQWRkVmFsdWVFdmVudChvbGRWaWV3Q2FjaGUsIG5ld1ZpZXdDYWNoZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGNvbnN0IGV2ZW50U25hcCA9IG5ld1ZpZXdDYWNoZS5ldmVudENhY2hlO1xyXG4gICAgaWYgKGV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgIGNvbnN0IGlzTGVhZk9yRW1wdHkgPSBldmVudFNuYXAuZ2V0Tm9kZSgpLmlzTGVhZk5vZGUoKSB8fCBldmVudFNuYXAuZ2V0Tm9kZSgpLmlzRW1wdHkoKTtcclxuICAgICAgICBjb25zdCBvbGRDb21wbGV0ZVNuYXAgPSB2aWV3Q2FjaGVHZXRDb21wbGV0ZUV2ZW50U25hcChvbGRWaWV3Q2FjaGUpO1xyXG4gICAgICAgIGlmIChhY2N1bXVsYXRvci5sZW5ndGggPiAwIHx8XHJcbiAgICAgICAgICAgICFvbGRWaWV3Q2FjaGUuZXZlbnRDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fFxyXG4gICAgICAgICAgICAoaXNMZWFmT3JFbXB0eSAmJiAhZXZlbnRTbmFwLmdldE5vZGUoKS5lcXVhbHMob2xkQ29tcGxldGVTbmFwKSkgfHxcclxuICAgICAgICAgICAgIWV2ZW50U25hcC5nZXROb2RlKCkuZ2V0UHJpb3JpdHkoKS5lcXVhbHMob2xkQ29tcGxldGVTbmFwLmdldFByaW9yaXR5KCkpKSB7XHJcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yLnB1c2goY2hhbmdlVmFsdWUodmlld0NhY2hlR2V0Q29tcGxldGVFdmVudFNuYXAobmV3Vmlld0NhY2hlKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yR2VuZXJhdGVFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJFdmVudCh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIGNoYW5nZVBhdGgsIHdyaXRlc0NhY2hlLCBzb3VyY2UsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICBjb25zdCBvbGRFdmVudFNuYXAgPSB2aWV3Q2FjaGUuZXZlbnRDYWNoZTtcclxuICAgIGlmICh3cml0ZVRyZWVSZWZTaGFkb3dpbmdXcml0ZSh3cml0ZXNDYWNoZSwgY2hhbmdlUGF0aCkgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIHdlIGhhdmUgYSBzaGFkb3dpbmcgd3JpdGUsIGlnbm9yZSBjaGFuZ2VzXHJcbiAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBuZXdFdmVudENhY2hlLCBzZXJ2ZXJOb2RlO1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShjaGFuZ2VQYXRoKSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IGhvdyB0aGlzIHBsYXlzIHdpdGggXCJzbGlkaW5nIGFjayB3aW5kb3dzXCJcclxuICAgICAgICAgICAgYXNzZXJ0KHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgJ0lmIGNoYW5nZSBwYXRoIGlzIGVtcHR5LCB3ZSBtdXN0IGhhdmUgY29tcGxldGUgc2VydmVyIGRhdGEnKTtcclxuICAgICAgICAgICAgaWYgKHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0ZpbHRlcmVkKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gc3BlY2lhbCBjYXNlIHRoaXMsIGJlY2F1c2Ugd2UgbmVlZCB0byBvbmx5IGFwcGx5IHdyaXRlcyB0byBjb21wbGV0ZSBjaGlsZHJlbiwgb3JcclxuICAgICAgICAgICAgICAgIC8vIHdlIG1pZ2h0IGVuZCB1cCByYWlzaW5nIGV2ZW50cyBmb3IgaW5jb21wbGV0ZSBjaGlsZHJlbi4gSWYgdGhlIHNlcnZlciBkYXRhIGlzIGZpbHRlcmVkIGRlZXBcclxuICAgICAgICAgICAgICAgIC8vIHdyaXRlcyBjYW5ub3QgYmUgZ3VhcmFudGVlZCB0byBiZSBjb21wbGV0ZVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyQ2FjaGUgPSB2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAodmlld0NhY2hlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlQ2hpbGRyZW4gPSBzZXJ2ZXJDYWNoZSBpbnN0YW5jZW9mIENoaWxkcmVuTm9kZVxyXG4gICAgICAgICAgICAgICAgICAgID8gc2VydmVyQ2FjaGVcclxuICAgICAgICAgICAgICAgICAgICA6IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGVFdmVudENoaWxkcmVuID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbih3cml0ZXNDYWNoZSwgY29tcGxldGVDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlRnVsbE5vZGUodmlld0NhY2hlLmV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLCBjb21wbGV0ZUV2ZW50Q2hpbGRyZW4sIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlTm9kZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVzQ2FjaGUsIHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3Q2FjaGUpKTtcclxuICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVGdWxsTm9kZSh2aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCksIGNvbXBsZXRlTm9kZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChjaGFuZ2VQYXRoKTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkS2V5ID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KHBhdGhHZXRMZW5ndGgoY2hhbmdlUGF0aCkgPT09IDEsIFwiQ2FuJ3QgaGF2ZSBhIHByaW9yaXR5IHdpdGggYWRkaXRpb25hbCBwYXRoIGNvbXBvbmVudHNcIik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRFdmVudE5vZGUgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgc2VydmVyTm9kZSA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5nZXROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBtaWdodCBoYXZlIG92ZXJ3cml0ZXMgZm9yIHRoaXMgcHJpb3JpdHlcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcmlvcml0eSA9IHdyaXRlVHJlZVJlZkNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUod3JpdGVzQ2FjaGUsIGNoYW5nZVBhdGgsIG9sZEV2ZW50Tm9kZSwgc2VydmVyTm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlZFByaW9yaXR5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlUHJpb3JpdHkob2xkRXZlbnROb2RlLCB1cGRhdGVkUHJpb3JpdHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJpb3JpdHkgZGlkbid0IGNoYW5nZSwga2VlcCBvbGQgbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDaGFuZ2VQYXRoID0gcGF0aFBvcEZyb250KGNoYW5nZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGNoaWxkXHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3RXZlbnRDaGlsZDtcclxuICAgICAgICAgICAgICAgIGlmIChvbGRFdmVudFNuYXAuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50Q2hpbGRVcGRhdGUgPSB3cml0ZVRyZWVSZWZDYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlKHdyaXRlc0NhY2hlLCBjaGFuZ2VQYXRoLCBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLCBzZXJ2ZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRDaGlsZFVwZGF0ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2hpbGQgPSBvbGRFdmVudFNuYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXROb2RlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51cGRhdGVDaGlsZChjaGlsZENoYW5nZVBhdGgsIGV2ZW50Q2hpbGRVcGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBjaGFuZ2VkLCBqdXN0IGtlZXAgdGhlIG9sZCBjaGlsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENoaWxkID0gb2xkRXZlbnRTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDaGlsZCA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUNoaWxkKHdyaXRlc0NhY2hlLCBjaGlsZEtleSwgdmlld0NhY2hlLnNlcnZlckNhY2hlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChuZXdFdmVudENoaWxkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlQ2hpbGQob2xkRXZlbnRTbmFwLmdldE5vZGUoKSwgY2hpbGRLZXksIG5ld0V2ZW50Q2hpbGQsIGNoaWxkQ2hhbmdlUGF0aCwgc291cmNlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBubyBjb21wbGV0ZSBjaGlsZCBhdmFpbGFibGUgb3Igbm8gY2hhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50U25hcC5nZXROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZpZXdDYWNoZVVwZGF0ZUV2ZW50U25hcCh2aWV3Q2FjaGUsIG5ld0V2ZW50Q2FjaGUsIG9sZEV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fCBwYXRoSXNFbXB0eShjaGFuZ2VQYXRoKSwgdmlld1Byb2Nlc3Nvci5maWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIGNoYW5nZVBhdGgsIGNoYW5nZWRTbmFwLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGNvbnN0IG9sZFNlcnZlclNuYXAgPSBvbGRWaWV3Q2FjaGUuc2VydmVyQ2FjaGU7XHJcbiAgICBsZXQgbmV3U2VydmVyQ2FjaGU7XHJcbiAgICBjb25zdCBzZXJ2ZXJGaWx0ZXIgPSBmaWx0ZXJTZXJ2ZXJOb2RlXHJcbiAgICAgICAgPyB2aWV3UHJvY2Vzc29yLmZpbHRlclxyXG4gICAgICAgIDogdmlld1Byb2Nlc3Nvci5maWx0ZXIuZ2V0SW5kZXhlZEZpbHRlcigpO1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KGNoYW5nZVBhdGgpKSB7XHJcbiAgICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlRnVsbE5vZGUob2xkU2VydmVyU25hcC5nZXROb2RlKCksIGNoYW5nZWRTbmFwLCBudWxsKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNlcnZlckZpbHRlci5maWx0ZXJzTm9kZXMoKSAmJiAhb2xkU2VydmVyU25hcC5pc0ZpbHRlcmVkKCkpIHtcclxuICAgICAgICAvLyB3ZSB3YW50IHRvIGZpbHRlciB0aGUgc2VydmVyIG5vZGUsIGJ1dCB3ZSBkaWRuJ3QgZmlsdGVyIHRoZSBzZXJ2ZXIgbm9kZSB5ZXQsIHNvIHNpbXVsYXRlIGEgZnVsbCB1cGRhdGVcclxuICAgICAgICBjb25zdCBuZXdTZXJ2ZXJOb2RlID0gb2xkU2VydmVyU25hcFxyXG4gICAgICAgICAgICAuZ2V0Tm9kZSgpXHJcbiAgICAgICAgICAgIC51cGRhdGVDaGlsZChjaGFuZ2VQYXRoLCBjaGFuZ2VkU25hcCk7XHJcbiAgICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlRnVsbE5vZGUob2xkU2VydmVyU25hcC5nZXROb2RlKCksIG5ld1NlcnZlck5vZGUsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBwYXRoR2V0RnJvbnQoY2hhbmdlUGF0aCk7XHJcbiAgICAgICAgaWYgKCFvbGRTZXJ2ZXJTbmFwLmlzQ29tcGxldGVGb3JQYXRoKGNoYW5nZVBhdGgpICYmXHJcbiAgICAgICAgICAgIHBhdGhHZXRMZW5ndGgoY2hhbmdlUGF0aCkgPiAxKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHVwZGF0ZSBpbmNvbXBsZXRlIG5vZGVzIHdpdGggdXBkYXRlcyBpbnRlbmRlZCBmb3Igb3RoZXIgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgIHJldHVybiBvbGRWaWV3Q2FjaGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoaWxkQ2hhbmdlUGF0aCA9IHBhdGhQb3BGcm9udChjaGFuZ2VQYXRoKTtcclxuICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgY29uc3QgbmV3Q2hpbGROb2RlID0gY2hpbGROb2RlLnVwZGF0ZUNoaWxkKGNoaWxkQ2hhbmdlUGF0aCwgY2hhbmdlZFNuYXApO1xyXG4gICAgICAgIGlmIChjaGlsZEtleSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlUHJpb3JpdHkob2xkU2VydmVyU25hcC5nZXROb2RlKCksIG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXdTZXJ2ZXJDYWNoZSA9IHNlcnZlckZpbHRlci51cGRhdGVDaGlsZChvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKSwgY2hpbGRLZXksIG5ld0NoaWxkTm9kZSwgY2hpbGRDaGFuZ2VQYXRoLCBOT19DT01QTEVURV9DSElMRF9TT1VSQ0UsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IG5ld1ZpZXdDYWNoZSA9IHZpZXdDYWNoZVVwZGF0ZVNlcnZlclNuYXAob2xkVmlld0NhY2hlLCBuZXdTZXJ2ZXJDYWNoZSwgb2xkU2VydmVyU25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fCBwYXRoSXNFbXB0eShjaGFuZ2VQYXRoKSwgc2VydmVyRmlsdGVyLmZpbHRlcnNOb2RlcygpKTtcclxuICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlKHdyaXRlc0NhY2hlLCBuZXdWaWV3Q2FjaGUsIGNvbXBsZXRlQ2FjaGUpO1xyXG4gICAgcmV0dXJuIHZpZXdQcm9jZXNzb3JHZW5lcmF0ZUV2ZW50Q2FjaGVBZnRlclNlcnZlckV2ZW50KHZpZXdQcm9jZXNzb3IsIG5ld1ZpZXdDYWNoZSwgY2hhbmdlUGF0aCwgd3JpdGVzQ2FjaGUsIHNvdXJjZSwgYWNjdW11bGF0b3IpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JBcHBseVVzZXJPdmVyd3JpdGUodmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBjaGFuZ2VQYXRoLCBjaGFuZ2VkU25hcCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICBjb25zdCBvbGRFdmVudFNuYXAgPSBvbGRWaWV3Q2FjaGUuZXZlbnRDYWNoZTtcclxuICAgIGxldCBuZXdWaWV3Q2FjaGUsIG5ld0V2ZW50Q2FjaGU7XHJcbiAgICBjb25zdCBzb3VyY2UgPSBuZXcgV3JpdGVUcmVlQ29tcGxldGVDaGlsZFNvdXJjZSh3cml0ZXNDYWNoZSwgb2xkVmlld0NhY2hlLCBjb21wbGV0ZUNhY2hlKTtcclxuICAgIGlmIChwYXRoSXNFbXB0eShjaGFuZ2VQYXRoKSkge1xyXG4gICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVGdWxsTm9kZShvbGRWaWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCksIGNoYW5nZWRTbmFwLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgbmV3Vmlld0NhY2hlID0gdmlld0NhY2hlVXBkYXRlRXZlbnRTbmFwKG9sZFZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZSwgdHJ1ZSwgdmlld1Byb2Nlc3Nvci5maWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBwYXRoR2V0RnJvbnQoY2hhbmdlUGF0aCk7XHJcbiAgICAgICAgaWYgKGNoaWxkS2V5ID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlUHJpb3JpdHkob2xkVmlld0NhY2hlLmV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLCBjaGFuZ2VkU25hcCk7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdDYWNoZVVwZGF0ZUV2ZW50U25hcChvbGRWaWV3Q2FjaGUsIG5ld0V2ZW50Q2FjaGUsIG9sZEV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgb2xkRXZlbnRTbmFwLmlzRmlsdGVyZWQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZENoYW5nZVBhdGggPSBwYXRoUG9wRnJvbnQoY2hhbmdlUGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkID0gb2xkRXZlbnRTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgICAgIGxldCBuZXdDaGlsZDtcclxuICAgICAgICAgICAgaWYgKHBhdGhJc0VtcHR5KGNoaWxkQ2hhbmdlUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIENoaWxkIG92ZXJ3cml0ZSwgd2UgY2FuIHJlcGxhY2UgdGhlIGNoaWxkXHJcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNoYW5nZWRTbmFwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gc291cmNlLmdldENvbXBsZXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhHZXRCYWNrKGNoaWxkQ2hhbmdlUGF0aCkgPT09ICcucHJpb3JpdHknICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5nZXRDaGlsZChwYXRoUGFyZW50KGNoaWxkQ2hhbmdlUGF0aCkpLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgcHJpb3JpdHkgdXBkYXRlIG9uIGFuIGVtcHR5IG5vZGUuIElmIHRoaXMgbm9kZSBleGlzdHMgb24gdGhlIHNlcnZlciwgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlcnZlciB3aWxsIHNlbmQgZG93biB0aGUgcHJpb3JpdHkgaW4gdGhlIHVwZGF0ZSwgc28gaWdub3JlIGZvciBub3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBjaGlsZE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNoaWxkTm9kZS51cGRhdGVDaGlsZChjaGlsZENoYW5nZVBhdGgsIGNoYW5nZWRTbmFwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBjb21wbGV0ZSBjaGlsZCBub2RlIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFvbGRDaGlsZC5lcXVhbHMobmV3Q2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFdmVudFNuYXAgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVDaGlsZChvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLCBjaGlsZEtleSwgbmV3Q2hpbGQsIGNoaWxkQ2hhbmdlUGF0aCwgc291cmNlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3Q2FjaGVVcGRhdGVFdmVudFNuYXAob2xkVmlld0NhY2hlLCBuZXdFdmVudFNuYXAsIG9sZEV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgdmlld1Byb2Nlc3Nvci5maWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gb2xkVmlld0NhY2hlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1ZpZXdDYWNoZTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQ2FjaGVIYXNDaGlsZCh2aWV3Q2FjaGUsIGNoaWxkS2V5KSB7XHJcbiAgICByZXR1cm4gdmlld0NhY2hlLmV2ZW50Q2FjaGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQXBwbHlVc2VyTWVyZ2Uodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIC8vIEhBQ0s6IEluIHRoZSBjYXNlIG9mIGEgbGltaXQgcXVlcnksIHRoZXJlIG1heSBiZSBzb21lIGNoYW5nZXMgdGhhdCBidW1wIHRoaW5ncyBvdXQgb2YgdGhlXHJcbiAgICAvLyB3aW5kb3cgbGVhdmluZyByb29tIGZvciBuZXcgaXRlbXMuICBJdCdzIGltcG9ydGFudCB3ZSBwcm9jZXNzIHRoZXNlIGNoYW5nZXMgZmlyc3QsIHNvIHdlXHJcbiAgICAvLyBpdGVyYXRlIHRoZSBjaGFuZ2VzIHR3aWNlLCBmaXJzdCBwcm9jZXNzaW5nIGFueSB0aGF0IGFmZmVjdCBpdGVtcyBjdXJyZW50bHkgaW4gdmlldy5cclxuICAgIC8vIFRPRE86IEkgY29uc2lkZXIgYW4gaXRlbSBcImluIHZpZXdcIiBpZiBjYWNoZUhhc0NoaWxkIGlzIHRydWUsIHdoaWNoIGNoZWNrcyBib3RoIHRoZSBzZXJ2ZXJcclxuICAgIC8vIGFuZCBldmVudCBzbmFwLiAgSSdtIG5vdCBzdXJlIGlmIHRoaXMgd2lsbCByZXN1bHQgaW4gZWRnZSBjYXNlcyB3aGVuIGEgY2hpbGQgaXMgaW4gb25lIGJ1dFxyXG4gICAgLy8gbm90IHRoZSBvdGhlci5cclxuICAgIGxldCBjdXJWaWV3Q2FjaGUgPSB2aWV3Q2FjaGU7XHJcbiAgICBjaGFuZ2VkQ2hpbGRyZW4uZm9yZWFjaCgocmVsYXRpdmVQYXRoLCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICBjb25zdCB3cml0ZVBhdGggPSBwYXRoQ2hpbGQocGF0aCwgcmVsYXRpdmVQYXRoKTtcclxuICAgICAgICBpZiAodmlld1Byb2Nlc3NvckNhY2hlSGFzQ2hpbGQodmlld0NhY2hlLCBwYXRoR2V0RnJvbnQod3JpdGVQYXRoKSkpIHtcclxuICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5VXNlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBjdXJWaWV3Q2FjaGUsIHdyaXRlUGF0aCwgY2hpbGROb2RlLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNoYW5nZWRDaGlsZHJlbi5mb3JlYWNoKChyZWxhdGl2ZVBhdGgsIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHdyaXRlUGF0aCA9IHBhdGhDaGlsZChwYXRoLCByZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgIGlmICghdmlld1Byb2Nlc3NvckNhY2hlSGFzQ2hpbGQodmlld0NhY2hlLCBwYXRoR2V0RnJvbnQod3JpdGVQYXRoKSkpIHtcclxuICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5VXNlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBjdXJWaWV3Q2FjaGUsIHdyaXRlUGF0aCwgY2hpbGROb2RlLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjdXJWaWV3Q2FjaGU7XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFwcGx5TWVyZ2Uodmlld1Byb2Nlc3Nvciwgbm9kZSwgbWVyZ2UpIHtcclxuICAgIG1lcmdlLmZvcmVhY2goKHJlbGF0aXZlUGF0aCwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgbm9kZSA9IG5vZGUudXBkYXRlQ2hpbGQocmVsYXRpdmVQYXRoLCBjaGlsZE5vZGUpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbm9kZTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNhY2hlIHlldCwgdGhpcyBtZXJnZSB3YXMgaW50ZW5kZWQgZm9yIGEgcHJldmlvdXNseSBsaXN0ZW4gaW4gdGhlIHNhbWUgbG9jYXRpb24uIElnbm9yZSBpdCBhbmRcclxuICAgIC8vIHdhaXQgZm9yIHRoZSBjb21wbGV0ZSBkYXRhIHVwZGF0ZSBjb21pbmcgc29vbi5cclxuICAgIGlmICh2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLmlzRW1wdHkoKSAmJlxyXG4gICAgICAgICF2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkpIHtcclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xyXG4gICAgfVxyXG4gICAgLy8gSEFDSzogSW4gdGhlIGNhc2Ugb2YgYSBsaW1pdCBxdWVyeSwgdGhlcmUgbWF5IGJlIHNvbWUgY2hhbmdlcyB0aGF0IGJ1bXAgdGhpbmdzIG91dCBvZiB0aGVcclxuICAgIC8vIHdpbmRvdyBsZWF2aW5nIHJvb20gZm9yIG5ldyBpdGVtcy4gIEl0J3MgaW1wb3J0YW50IHdlIHByb2Nlc3MgdGhlc2UgY2hhbmdlcyBmaXJzdCwgc28gd2VcclxuICAgIC8vIGl0ZXJhdGUgdGhlIGNoYW5nZXMgdHdpY2UsIGZpcnN0IHByb2Nlc3NpbmcgYW55IHRoYXQgYWZmZWN0IGl0ZW1zIGN1cnJlbnRseSBpbiB2aWV3LlxyXG4gICAgLy8gVE9ETzogSSBjb25zaWRlciBhbiBpdGVtIFwiaW4gdmlld1wiIGlmIGNhY2hlSGFzQ2hpbGQgaXMgdHJ1ZSwgd2hpY2ggY2hlY2tzIGJvdGggdGhlIHNlcnZlclxyXG4gICAgLy8gYW5kIGV2ZW50IHNuYXAuICBJJ20gbm90IHN1cmUgaWYgdGhpcyB3aWxsIHJlc3VsdCBpbiBlZGdlIGNhc2VzIHdoZW4gYSBjaGlsZCBpcyBpbiBvbmUgYnV0XHJcbiAgICAvLyBub3QgdGhlIG90aGVyLlxyXG4gICAgbGV0IGN1clZpZXdDYWNoZSA9IHZpZXdDYWNoZTtcclxuICAgIGxldCB2aWV3TWVyZ2VUcmVlO1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgdmlld01lcmdlVHJlZSA9IGNoYW5nZWRDaGlsZHJlbjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZpZXdNZXJnZVRyZWUgPSBuZXcgSW1tdXRhYmxlVHJlZShudWxsKS5zZXRUcmVlKHBhdGgsIGNoYW5nZWRDaGlsZHJlbik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXJ2ZXJOb2RlID0gdmlld0NhY2hlLnNlcnZlckNhY2hlLmdldE5vZGUoKTtcclxuICAgIHZpZXdNZXJnZVRyZWUuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGRLZXksIGNoaWxkVHJlZSkgPT4ge1xyXG4gICAgICAgIGlmIChzZXJ2ZXJOb2RlLmhhc0NoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJDaGlsZCA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZVxyXG4gICAgICAgICAgICAgICAgLmdldE5vZGUoKVxyXG4gICAgICAgICAgICAgICAgLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSB2aWV3UHJvY2Vzc29yQXBwbHlNZXJnZSh2aWV3UHJvY2Vzc29yLCBzZXJ2ZXJDaGlsZCwgY2hpbGRUcmVlKTtcclxuICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5U2VydmVyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIGN1clZpZXdDYWNoZSwgbmV3IFBhdGgoY2hpbGRLZXkpLCBuZXdDaGlsZCwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2aWV3TWVyZ2VUcmVlLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkS2V5LCBjaGlsZE1lcmdlVHJlZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlzVW5rbm93bkRlZXBNZXJnZSA9ICF2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSAmJlxyXG4gICAgICAgICAgICBjaGlsZE1lcmdlVHJlZS52YWx1ZSA9PT0gbnVsbDtcclxuICAgICAgICBpZiAoIXNlcnZlck5vZGUuaGFzQ2hpbGQoY2hpbGRLZXkpICYmICFpc1Vua25vd25EZWVwTWVyZ2UpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VydmVyQ2hpbGQgPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGVcclxuICAgICAgICAgICAgICAgIC5nZXROb2RlKClcclxuICAgICAgICAgICAgICAgIC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gdmlld1Byb2Nlc3NvckFwcGx5TWVyZ2Uodmlld1Byb2Nlc3Nvciwgc2VydmVyQ2hpbGQsIGNoaWxkTWVyZ2VUcmVlKTtcclxuICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5U2VydmVyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIGN1clZpZXdDYWNoZSwgbmV3IFBhdGgoY2hpbGRLZXkpLCBuZXdDaGlsZCwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY3VyVmlld0NhY2hlO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JBY2tVc2VyV3JpdGUodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBhY2tQYXRoLCBhZmZlY3RlZFRyZWUsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgaWYgKHdyaXRlVHJlZVJlZlNoYWRvd2luZ1dyaXRlKHdyaXRlc0NhY2hlLCBhY2tQYXRoKSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcclxuICAgIH1cclxuICAgIC8vIE9ubHkgZmlsdGVyIHNlcnZlciBub2RlIGlmIGl0IGlzIGN1cnJlbnRseSBmaWx0ZXJlZFxyXG4gICAgY29uc3QgZmlsdGVyU2VydmVyTm9kZSA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0ZpbHRlcmVkKCk7XHJcbiAgICAvLyBFc3NlbnRpYWxseSB3ZSdsbCBqdXN0IGdldCBvdXIgZXhpc3Rpbmcgc2VydmVyIGNhY2hlIGZvciB0aGUgYWZmZWN0ZWQgcGF0aHMgYW5kIHJlLWFwcGx5IGl0IGFzIGEgc2VydmVyIHVwZGF0ZVxyXG4gICAgLy8gbm93IHRoYXQgaXQgd29uJ3QgYmUgc2hhZG93ZWQuXHJcbiAgICBjb25zdCBzZXJ2ZXJDYWNoZSA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZTtcclxuICAgIGlmIChhZmZlY3RlZFRyZWUudmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgYW4gb3ZlcndyaXRlLlxyXG4gICAgICAgIGlmICgocGF0aElzRW1wdHkoYWNrUGF0aCkgJiYgc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkpIHx8XHJcbiAgICAgICAgICAgIHNlcnZlckNhY2hlLmlzQ29tcGxldGVGb3JQYXRoKGFja1BhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJPdmVyd3JpdGUodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBhY2tQYXRoLCBzZXJ2ZXJDYWNoZS5nZXROb2RlKCkuZ2V0Q2hpbGQoYWNrUGF0aCksIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhdGhJc0VtcHR5KGFja1BhdGgpKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBnb29meSBlZGdlIGNhc2Ugd2hlcmUgd2UgYXJlIGFja2luZyBkYXRhIGF0IHRoaXMgbG9jYXRpb24gYnV0IGRvbid0IGhhdmUgZnVsbCBkYXRhLiAgV2VcclxuICAgICAgICAgICAgLy8gc2hvdWxkIGp1c3QgcmUtYXBwbHkgd2hhdGV2ZXIgd2UgaGF2ZSBpbiBvdXIgY2FjaGUgYXMgYSBtZXJnZS5cclxuICAgICAgICAgICAgbGV0IGNoYW5nZWRDaGlsZHJlbiA9IG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZS5nZXROb2RlKCkuZm9yRWFjaENoaWxkKEtFWV9JTkRFWCwgKG5hbWUsIG5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWRDaGlsZHJlbiA9IGNoYW5nZWRDaGlsZHJlbi5zZXQobmV3IFBhdGgobmFtZSksIG5vZGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck1lcmdlKHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgYWNrUGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBUaGlzIGlzIGEgbWVyZ2UuXHJcbiAgICAgICAgbGV0IGNoYW5nZWRDaGlsZHJlbiA9IG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgIGFmZmVjdGVkVHJlZS5mb3JlYWNoKChtZXJnZVBhdGgsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlckNhY2hlUGF0aCA9IHBhdGhDaGlsZChhY2tQYXRoLCBtZXJnZVBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoc2VydmVyQ2FjaGUuaXNDb21wbGV0ZUZvclBhdGgoc2VydmVyQ2FjaGVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZENoaWxkcmVuID0gY2hhbmdlZENoaWxkcmVuLnNldChtZXJnZVBhdGgsIHNlcnZlckNhY2hlLmdldE5vZGUoKS5nZXRDaGlsZChzZXJ2ZXJDYWNoZVBhdGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIGFja1BhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yTGlzdGVuQ29tcGxldGUodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBwYXRoLCB3cml0ZXNDYWNoZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGNvbnN0IG9sZFNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGU7XHJcbiAgICBjb25zdCBuZXdWaWV3Q2FjaGUgPSB2aWV3Q2FjaGVVcGRhdGVTZXJ2ZXJTbmFwKHZpZXdDYWNoZSwgb2xkU2VydmVyTm9kZS5nZXROb2RlKCksIG9sZFNlcnZlck5vZGUuaXNGdWxseUluaXRpYWxpemVkKCkgfHwgcGF0aElzRW1wdHkocGF0aCksIG9sZFNlcnZlck5vZGUuaXNGaWx0ZXJlZCgpKTtcclxuICAgIHJldHVybiB2aWV3UHJvY2Vzc29yR2VuZXJhdGVFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJFdmVudCh2aWV3UHJvY2Vzc29yLCBuZXdWaWV3Q2FjaGUsIHBhdGgsIHdyaXRlc0NhY2hlLCBOT19DT01QTEVURV9DSElMRF9TT1VSQ0UsIGFjY3VtdWxhdG9yKTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yUmV2ZXJ0VXNlcldyaXRlKHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgcGF0aCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlU2VydmVyQ2FjaGUsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICBsZXQgY29tcGxldGU7XHJcbiAgICBpZiAod3JpdGVUcmVlUmVmU2hhZG93aW5nV3JpdGUod3JpdGVzQ2FjaGUsIHBhdGgpICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlID0gbmV3IFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2Uod3JpdGVzQ2FjaGUsIHZpZXdDYWNoZSwgY29tcGxldGVTZXJ2ZXJDYWNoZSk7XHJcbiAgICAgICAgY29uc3Qgb2xkRXZlbnRDYWNoZSA9IHZpZXdDYWNoZS5ldmVudENhY2hlLmdldE5vZGUoKTtcclxuICAgICAgICBsZXQgbmV3RXZlbnRDYWNoZTtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocGF0aCkgfHwgcGF0aEdldEZyb250KHBhdGgpID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICBsZXQgbmV3Tm9kZTtcclxuICAgICAgICAgICAgaWYgKHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVzQ2FjaGUsIHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3Q2FjaGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlckNoaWxkcmVuID0gdmlld0NhY2hlLnNlcnZlckNhY2hlLmdldE5vZGUoKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydChzZXJ2ZXJDaGlsZHJlbiBpbnN0YW5jZW9mIENoaWxkcmVuTm9kZSwgJ3NlcnZlckNoaWxkcmVuIHdvdWxkIGJlIGNvbXBsZXRlIGlmIGxlYWYgbm9kZScpO1xyXG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4od3JpdGVzQ2FjaGUsIHNlcnZlckNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdOb2RlID0gbmV3Tm9kZTtcclxuICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKG9sZEV2ZW50Q2FjaGUsIG5ld05vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgICAgICAgICBsZXQgbmV3Q2hpbGQgPSB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVDaGlsZCh3cml0ZXNDYWNoZSwgY2hpbGRLZXksIHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZSk7XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZCA9PSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBvbGRFdmVudENhY2hlLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUNoaWxkKG9sZEV2ZW50Q2FjaGUsIGNoaWxkS2V5LCBuZXdDaGlsZCwgcGF0aFBvcEZyb250KHBhdGgpLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCkuaGFzQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBObyBjb21wbGV0ZSBjaGlsZCBhdmFpbGFibGUsIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lLCBpZiBhbnlcclxuICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVDaGlsZChvbGRFdmVudENhY2hlLCBjaGlsZEtleSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUsIHBhdGhQb3BGcm9udChwYXRoKSwgc291cmNlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gb2xkRXZlbnRDYWNoZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV3RXZlbnRDYWNoZS5pc0VtcHR5KCkgJiZcclxuICAgICAgICAgICAgICAgIHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgbWlnaHQgaGF2ZSByZXZlcnRlZCBhbGwgY2hpbGQgd3JpdGVzLiBNYXliZSB0aGUgb2xkIGV2ZW50IHdhcyBhIGxlYWYgbm9kZVxyXG4gICAgICAgICAgICAgICAgY29tcGxldGUgPSB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlc0NhY2hlLCB2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAodmlld0NhY2hlKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGUuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKG5ld0V2ZW50Q2FjaGUsIGNvbXBsZXRlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcGxldGUgPVxyXG4gICAgICAgICAgICB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkgfHxcclxuICAgICAgICAgICAgICAgIHdyaXRlVHJlZVJlZlNoYWRvd2luZ1dyaXRlKHdyaXRlc0NhY2hlLCBuZXdFbXB0eVBhdGgoKSkgIT0gbnVsbDtcclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlVXBkYXRlRXZlbnRTbmFwKHZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZSwgY29tcGxldGUsIHZpZXdQcm9jZXNzb3IuZmlsdGVyLmZpbHRlcnNOb2RlcygpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSB2aWV3IHJlcHJlc2VudHMgYSBzcGVjaWZpYyBsb2NhdGlvbiBhbmQgcXVlcnkgdGhhdCBoYXMgMSBvciBtb3JlIGV2ZW50IHJlZ2lzdHJhdGlvbnMuXHJcbiAqXHJcbiAqIEl0IGRvZXMgc2V2ZXJhbCB0aGluZ3M6XHJcbiAqICAtIE1haW50YWlucyB0aGUgbGlzdCBvZiBldmVudCByZWdpc3RyYXRpb25zIGZvciB0aGlzIGxvY2F0aW9uL3F1ZXJ5LlxyXG4gKiAgLSBNYWludGFpbnMgYSBjYWNoZSBvZiB0aGUgZGF0YSB2aXNpYmxlIGZvciB0aGlzIGxvY2F0aW9uL3F1ZXJ5LlxyXG4gKiAgLSBBcHBsaWVzIG5ldyBvcGVyYXRpb25zICh2aWEgYXBwbHlPcGVyYXRpb24pLCB1cGRhdGVzIHRoZSBjYWNoZSwgYW5kIGJhc2VkIG9uIHRoZSBldmVudFxyXG4gKiAgICByZWdpc3RyYXRpb25zIHJldHVybnMgdGhlIHNldCBvZiBldmVudHMgdG8gYmUgcmFpc2VkLlxyXG4gKi9cclxuY2xhc3MgVmlldyB7XHJcbiAgICBjb25zdHJ1Y3RvcihxdWVyeV8sIGluaXRpYWxWaWV3Q2FjaGUpIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5XyA9IHF1ZXJ5XztcclxuICAgICAgICB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uc18gPSBbXTtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnF1ZXJ5Xy5fcXVlcnlQYXJhbXM7XHJcbiAgICAgICAgY29uc3QgaW5kZXhGaWx0ZXIgPSBuZXcgSW5kZXhlZEZpbHRlcihwYXJhbXMuZ2V0SW5kZXgoKSk7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyID0gcXVlcnlQYXJhbXNHZXROb2RlRmlsdGVyKHBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzb3JfID0gbmV3Vmlld1Byb2Nlc3NvcihmaWx0ZXIpO1xyXG4gICAgICAgIGNvbnN0IGluaXRpYWxTZXJ2ZXJDYWNoZSA9IGluaXRpYWxWaWV3Q2FjaGUuc2VydmVyQ2FjaGU7XHJcbiAgICAgICAgY29uc3QgaW5pdGlhbEV2ZW50Q2FjaGUgPSBpbml0aWFsVmlld0NhY2hlLmV2ZW50Q2FjaGU7XHJcbiAgICAgICAgLy8gRG9uJ3QgZmlsdGVyIHNlcnZlciBub2RlIHdpdGggb3RoZXIgZmlsdGVyIHRoYW4gaW5kZXgsIHdhaXQgZm9yIHRhZ2dlZCBsaXN0ZW5cclxuICAgICAgICBjb25zdCBzZXJ2ZXJTbmFwID0gaW5kZXhGaWx0ZXIudXBkYXRlRnVsbE5vZGUoQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUsIGluaXRpYWxTZXJ2ZXJDYWNoZS5nZXROb2RlKCksIG51bGwpO1xyXG4gICAgICAgIGNvbnN0IGV2ZW50U25hcCA9IGZpbHRlci51cGRhdGVGdWxsTm9kZShDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgaW5pdGlhbEV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLCBudWxsKTtcclxuICAgICAgICBjb25zdCBuZXdTZXJ2ZXJDYWNoZSA9IG5ldyBDYWNoZU5vZGUoc2VydmVyU25hcCwgaW5pdGlhbFNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpLCBpbmRleEZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XHJcbiAgICAgICAgY29uc3QgbmV3RXZlbnRDYWNoZSA9IG5ldyBDYWNoZU5vZGUoZXZlbnRTbmFwLCBpbml0aWFsRXZlbnRDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgZmlsdGVyLmZpbHRlcnNOb2RlcygpKTtcclxuICAgICAgICB0aGlzLnZpZXdDYWNoZV8gPSBuZXdWaWV3Q2FjaGUobmV3RXZlbnRDYWNoZSwgbmV3U2VydmVyQ2FjaGUpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRHZW5lcmF0b3JfID0gbmV3IEV2ZW50R2VuZXJhdG9yKHRoaXMucXVlcnlfKTtcclxuICAgIH1cclxuICAgIGdldCBxdWVyeSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeV87XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmlld0dldFNlcnZlckNhY2hlKHZpZXcpIHtcclxuICAgIHJldHVybiB2aWV3LnZpZXdDYWNoZV8uc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdHZXRDb21wbGV0ZU5vZGUodmlldykge1xyXG4gICAgcmV0dXJuIHZpZXdDYWNoZUdldENvbXBsZXRlRXZlbnRTbmFwKHZpZXcudmlld0NhY2hlXyk7XHJcbn1cclxuZnVuY3Rpb24gdmlld0dldENvbXBsZXRlU2VydmVyQ2FjaGUodmlldywgcGF0aCkge1xyXG4gICAgY29uc3QgY2FjaGUgPSB2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAodmlldy52aWV3Q2FjaGVfKTtcclxuICAgIGlmIChjYWNoZSkge1xyXG4gICAgICAgIC8vIElmIHRoaXMgaXNuJ3QgYSBcImxvYWRzQWxsRGF0YVwiIHZpZXcsIHRoZW4gY2FjaGUgaXNuJ3QgYWN0dWFsbHkgYSBjb21wbGV0ZSBjYWNoZSBhbmRcclxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHNlZSBpZiBpdCBjb250YWlucyB0aGUgY2hpbGQgd2UncmUgaW50ZXJlc3RlZCBpbi5cclxuICAgICAgICBpZiAodmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkgfHxcclxuICAgICAgICAgICAgKCFwYXRoSXNFbXB0eShwYXRoKSAmJlxyXG4gICAgICAgICAgICAgICAgIWNhY2hlLmdldEltbWVkaWF0ZUNoaWxkKHBhdGhHZXRGcm9udChwYXRoKSkuaXNFbXB0eSgpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0Q2hpbGQocGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gdmlld0lzRW1wdHkodmlldykge1xyXG4gICAgcmV0dXJuIHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXy5sZW5ndGggPT09IDA7XHJcbn1cclxuZnVuY3Rpb24gdmlld0FkZEV2ZW50UmVnaXN0cmF0aW9uKHZpZXcsIGV2ZW50UmVnaXN0cmF0aW9uKSB7XHJcbiAgICB2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc18ucHVzaChldmVudFJlZ2lzdHJhdGlvbik7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBldmVudFJlZ2lzdHJhdGlvbiAtIElmIG51bGwsIHJlbW92ZSBhbGwgY2FsbGJhY2tzLlxyXG4gKiBAcGFyYW0gY2FuY2VsRXJyb3IgLSBJZiBhIGNhbmNlbEVycm9yIGlzIHByb3ZpZGVkLCBhcHByb3ByaWF0ZSBjYW5jZWwgZXZlbnRzIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAqIEByZXR1cm5zIENhbmNlbCBldmVudHMsIGlmIGNhbmNlbEVycm9yIHdhcyBwcm92aWRlZC5cclxuICovXHJcbmZ1bmN0aW9uIHZpZXdSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbih2aWV3LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpIHtcclxuICAgIGNvbnN0IGNhbmNlbEV2ZW50cyA9IFtdO1xyXG4gICAgaWYgKGNhbmNlbEVycm9yKSB7XHJcbiAgICAgICAgYXNzZXJ0KGV2ZW50UmVnaXN0cmF0aW9uID09IG51bGwsICdBIGNhbmNlbCBzaG91bGQgY2FuY2VsIGFsbCBldmVudCByZWdpc3RyYXRpb25zLicpO1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSB2aWV3LnF1ZXJ5Ll9wYXRoO1xyXG4gICAgICAgIHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXy5mb3JFYWNoKHJlZ2lzdHJhdGlvbiA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heWJlRXZlbnQgPSByZWdpc3RyYXRpb24uY3JlYXRlQ2FuY2VsRXZlbnQoY2FuY2VsRXJyb3IsIHBhdGgpO1xyXG4gICAgICAgICAgICBpZiAobWF5YmVFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgY2FuY2VsRXZlbnRzLnB1c2gobWF5YmVFdmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChldmVudFJlZ2lzdHJhdGlvbikge1xyXG4gICAgICAgIGxldCByZW1haW5pbmcgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zX1tpXTtcclxuICAgICAgICAgICAgaWYgKCFleGlzdGluZy5tYXRjaGVzKGV2ZW50UmVnaXN0cmF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nLnB1c2goZXhpc3RpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50UmVnaXN0cmF0aW9uLmhhc0FueUNhbGxiYWNrKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIHJlbW92aW5nIGp1c3QgdGhpcyBvbmVcclxuICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5jb25jYXQodmlldy5ldmVudFJlZ2lzdHJhdGlvbnNfLnNsaWNlKGkgKyAxKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc18gPSByZW1haW5pbmc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc18gPSBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiBjYW5jZWxFdmVudHM7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhlIGdpdmVuIE9wZXJhdGlvbiwgdXBkYXRlcyBvdXIgY2FjaGUsIGFuZCByZXR1cm5zIHRoZSBhcHByb3ByaWF0ZSBldmVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiB2aWV3QXBwbHlPcGVyYXRpb24odmlldywgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgY29tcGxldGVTZXJ2ZXJDYWNoZSkge1xyXG4gICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25UeXBlLk1FUkdFICYmXHJcbiAgICAgICAgb3BlcmF0aW9uLnNvdXJjZS5xdWVyeUlkICE9PSBudWxsKSB7XHJcbiAgICAgICAgYXNzZXJ0KHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3LnZpZXdDYWNoZV8pLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgZnVsbCBjYWNoZSBiZWZvcmUgaGFuZGxpbmcgbWVyZ2VzJyk7XHJcbiAgICAgICAgYXNzZXJ0KHZpZXdDYWNoZUdldENvbXBsZXRlRXZlbnRTbmFwKHZpZXcudmlld0NhY2hlXyksICdNaXNzaW5nIGV2ZW50IGNhY2hlLCBldmVuIHRob3VnaCB3ZSBoYXZlIGEgc2VydmVyIGNhY2hlJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbGRWaWV3Q2FjaGUgPSB2aWV3LnZpZXdDYWNoZV87XHJcbiAgICBjb25zdCByZXN1bHQgPSB2aWV3UHJvY2Vzc29yQXBwbHlPcGVyYXRpb24odmlldy5wcm9jZXNzb3JfLCBvbGRWaWV3Q2FjaGUsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlU2VydmVyQ2FjaGUpO1xyXG4gICAgdmlld1Byb2Nlc3NvckFzc2VydEluZGV4ZWQodmlldy5wcm9jZXNzb3JfLCByZXN1bHQudmlld0NhY2hlKTtcclxuICAgIGFzc2VydChyZXN1bHQudmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8XHJcbiAgICAgICAgIW9sZFZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgJ09uY2UgYSBzZXJ2ZXIgc25hcCBpcyBjb21wbGV0ZSwgaXQgc2hvdWxkIG5ldmVyIGdvIGJhY2snKTtcclxuICAgIHZpZXcudmlld0NhY2hlXyA9IHJlc3VsdC52aWV3Q2FjaGU7XHJcbiAgICByZXR1cm4gdmlld0dlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlc18odmlldywgcmVzdWx0LmNoYW5nZXMsIHJlc3VsdC52aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCksIG51bGwpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdHZXRJbml0aWFsRXZlbnRzKHZpZXcsIHJlZ2lzdHJhdGlvbikge1xyXG4gICAgY29uc3QgZXZlbnRTbmFwID0gdmlldy52aWV3Q2FjaGVfLmV2ZW50Q2FjaGU7XHJcbiAgICBjb25zdCBpbml0aWFsQ2hhbmdlcyA9IFtdO1xyXG4gICAgaWYgKCFldmVudFNuYXAuZ2V0Tm9kZSgpLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50Tm9kZSA9IGV2ZW50U25hcC5nZXROb2RlKCk7XHJcbiAgICAgICAgZXZlbnROb2RlLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGtleSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGluaXRpYWxDaGFuZ2VzLnB1c2goY2hhbmdlQ2hpbGRBZGRlZChrZXksIGNoaWxkTm9kZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgIGluaXRpYWxDaGFuZ2VzLnB1c2goY2hhbmdlVmFsdWUoZXZlbnRTbmFwLmdldE5vZGUoKSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZpZXdHZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXNfKHZpZXcsIGluaXRpYWxDaGFuZ2VzLCBldmVudFNuYXAuZ2V0Tm9kZSgpLCByZWdpc3RyYXRpb24pO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdHZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXNfKHZpZXcsIGNoYW5nZXMsIGV2ZW50Q2FjaGUsIGV2ZW50UmVnaXN0cmF0aW9uKSB7XHJcbiAgICBjb25zdCByZWdpc3RyYXRpb25zID0gZXZlbnRSZWdpc3RyYXRpb25cclxuICAgICAgICA/IFtldmVudFJlZ2lzdHJhdGlvbl1cclxuICAgICAgICA6IHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXztcclxuICAgIHJldHVybiBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlcyh2aWV3LmV2ZW50R2VuZXJhdG9yXywgY2hhbmdlcywgZXZlbnRDYWNoZSwgcmVnaXN0cmF0aW9ucyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IHJlZmVyZW5jZUNvbnN0cnVjdG9yJDE7XHJcbi8qKlxyXG4gKiBTeW5jUG9pbnQgcmVwcmVzZW50cyBhIHNpbmdsZSBsb2NhdGlvbiBpbiBhIFN5bmNUcmVlIHdpdGggMSBvciBtb3JlIGV2ZW50IHJlZ2lzdHJhdGlvbnMsIG1lYW5pbmcgd2UgbmVlZCB0b1xyXG4gKiBtYWludGFpbiAxIG9yIG1vcmUgVmlld3MgYXQgdGhpcyBsb2NhdGlvbiB0byBjYWNoZSBzZXJ2ZXIgZGF0YSBhbmQgcmFpc2UgYXBwcm9wcmlhdGUgZXZlbnRzIGZvciBzZXJ2ZXIgY2hhbmdlc1xyXG4gKiBhbmQgdXNlciB3cml0ZXMgKHNldCwgdHJhbnNhY3Rpb24sIHVwZGF0ZSkuXHJcbiAqXHJcbiAqIEl0J3MgcmVzcG9uc2libGUgZm9yOlxyXG4gKiAgLSBNYWludGFpbmluZyB0aGUgc2V0IG9mIDEgb3IgbW9yZSB2aWV3cyBuZWNlc3NhcnkgYXQgdGhpcyBsb2NhdGlvbiAoYSBTeW5jUG9pbnQgd2l0aCAwIHZpZXdzIHNob3VsZCBiZSByZW1vdmVkKS5cclxuICogIC0gUHJveHlpbmcgdXNlciAvIHNlcnZlciBvcGVyYXRpb25zIHRvIHRoZSB2aWV3cyBhcyBhcHByb3ByaWF0ZSAoaS5lLiBhcHBseVNlcnZlck92ZXJ3cml0ZSxcclxuICogICAgYXBwbHlVc2VyT3ZlcndyaXRlLCBldGMuKVxyXG4gKi9cclxuY2xhc3MgU3luY1BvaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBWaWV3cyBiZWluZyB0cmFja2VkIGF0IHRoaXMgbG9jYXRpb24gaW4gdGhlIHRyZWUsIHN0b3JlZCBhcyBhIG1hcCB3aGVyZSB0aGUga2V5IGlzIGFcclxuICAgICAgICAgKiBxdWVyeUlkIGFuZCB0aGUgdmFsdWUgaXMgdGhlIFZpZXcgZm9yIHRoYXQgcXVlcnkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBOT1RFOiBUaGlzIGxpc3Qgd2lsbCBiZSBxdWl0ZSBzbWFsbCAodXN1YWxseSAxLCBidXQgcGVyaGFwcyAyIG9yIDM7IGFueSBtb3JlIGlzIGFuIG9kZCB1c2UgY2FzZSkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52aWV3cyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRTZXRSZWZlcmVuY2VDb25zdHJ1Y3Rvcih2YWwpIHtcclxuICAgIGFzc2VydCghcmVmZXJlbmNlQ29uc3RydWN0b3IkMSwgJ19fcmVmZXJlbmNlQ29uc3RydWN0b3IgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkJyk7XHJcbiAgICByZWZlcmVuY2VDb25zdHJ1Y3RvciQxID0gdmFsO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludEdldFJlZmVyZW5jZUNvbnN0cnVjdG9yKCkge1xyXG4gICAgYXNzZXJ0KHJlZmVyZW5jZUNvbnN0cnVjdG9yJDEsICdSZWZlcmVuY2UudHMgaGFzIG5vdCBiZWVuIGxvYWRlZCcpO1xyXG4gICAgcmV0dXJuIHJlZmVyZW5jZUNvbnN0cnVjdG9yJDE7XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50SXNFbXB0eShzeW5jUG9pbnQpIHtcclxuICAgIHJldHVybiBzeW5jUG9pbnQudmlld3Muc2l6ZSA9PT0gMDtcclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRBcHBseU9wZXJhdGlvbihzeW5jUG9pbnQsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIG9wdENvbXBsZXRlU2VydmVyQ2FjaGUpIHtcclxuICAgIGNvbnN0IHF1ZXJ5SWQgPSBvcGVyYXRpb24uc291cmNlLnF1ZXJ5SWQ7XHJcbiAgICBpZiAocXVlcnlJZCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnQudmlld3MuZ2V0KHF1ZXJ5SWQpO1xyXG4gICAgICAgIGFzc2VydCh2aWV3ICE9IG51bGwsICdTeW5jVHJlZSBnYXZlIHVzIGFuIG9wIGZvciBhbiBpbnZhbGlkIHF1ZXJ5LicpO1xyXG4gICAgICAgIHJldHVybiB2aWV3QXBwbHlPcGVyYXRpb24odmlldywgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCB2aWV3IG9mIHN5bmNQb2ludC52aWV3cy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHZpZXdBcHBseU9wZXJhdGlvbih2aWV3LCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBvcHRDb21wbGV0ZVNlcnZlckNhY2hlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudHM7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdldCBhIHZpZXcgZm9yIHRoZSBzcGVjaWZpZWQgcXVlcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0byByZXR1cm4gYSB2aWV3IGZvclxyXG4gKiBAcGFyYW0gd3JpdGVzQ2FjaGVcclxuICogQHBhcmFtIHNlcnZlckNhY2hlXHJcbiAqIEBwYXJhbSBzZXJ2ZXJDYWNoZUNvbXBsZXRlXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNQb2ludEdldFZpZXcoc3luY1BvaW50LCBxdWVyeSwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlKSB7XHJcbiAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnQudmlld3MuZ2V0KHF1ZXJ5SWQpO1xyXG4gICAgaWYgKCF2aWV3KSB7XHJcbiAgICAgICAgLy8gVE9ETzogbWFrZSB3cml0ZXNDYWNoZSB0YWtlIGZsYWcgZm9yIGNvbXBsZXRlIHNlcnZlciBub2RlXHJcbiAgICAgICAgbGV0IGV2ZW50Q2FjaGUgPSB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlID8gc2VydmVyQ2FjaGUgOiBudWxsKTtcclxuICAgICAgICBsZXQgZXZlbnRDYWNoZUNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGV2ZW50Q2FjaGUpIHtcclxuICAgICAgICAgICAgZXZlbnRDYWNoZUNvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2VydmVyQ2FjaGUgaW5zdGFuY2VvZiBDaGlsZHJlbk5vZGUpIHtcclxuICAgICAgICAgICAgZXZlbnRDYWNoZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4od3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlKTtcclxuICAgICAgICAgICAgZXZlbnRDYWNoZUNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBldmVudENhY2hlID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgIGV2ZW50Q2FjaGVDb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2aWV3Q2FjaGUgPSBuZXdWaWV3Q2FjaGUobmV3IENhY2hlTm9kZShldmVudENhY2hlLCBldmVudENhY2hlQ29tcGxldGUsIGZhbHNlKSwgbmV3IENhY2hlTm9kZShzZXJ2ZXJDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSwgZmFsc2UpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFZpZXcocXVlcnksIHZpZXdDYWNoZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmlldztcclxufVxyXG4vKipcclxuICogQWRkIGFuIGV2ZW50IGNhbGxiYWNrIGZvciB0aGUgc3BlY2lmaWVkIHF1ZXJ5LlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnlcclxuICogQHBhcmFtIGV2ZW50UmVnaXN0cmF0aW9uXHJcbiAqIEBwYXJhbSB3cml0ZXNDYWNoZVxyXG4gKiBAcGFyYW0gc2VydmVyQ2FjaGUgLSBDb21wbGV0ZSBzZXJ2ZXIgY2FjaGUsIGlmIHdlIGhhdmUgaXQuXHJcbiAqIEBwYXJhbSBzZXJ2ZXJDYWNoZUNvbXBsZXRlXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNQb2ludEFkZEV2ZW50UmVnaXN0cmF0aW9uKHN5bmNQb2ludCwgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIHNlcnZlckNhY2hlQ29tcGxldGUpIHtcclxuICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnRHZXRWaWV3KHN5bmNQb2ludCwgcXVlcnksIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSk7XHJcbiAgICBpZiAoIXN5bmNQb2ludC52aWV3cy5oYXMocXVlcnkuX3F1ZXJ5SWRlbnRpZmllcikpIHtcclxuICAgICAgICBzeW5jUG9pbnQudmlld3Muc2V0KHF1ZXJ5Ll9xdWVyeUlkZW50aWZpZXIsIHZpZXcpO1xyXG4gICAgfVxyXG4gICAgLy8gVGhpcyBpcyBndWFyYW50ZWVkIHRvIGV4aXN0IG5vdywgd2UganVzdCBjcmVhdGVkIGFueXRoaW5nIHRoYXQgd2FzIG1pc3NpbmdcclxuICAgIHZpZXdBZGRFdmVudFJlZ2lzdHJhdGlvbih2aWV3LCBldmVudFJlZ2lzdHJhdGlvbik7XHJcbiAgICByZXR1cm4gdmlld0dldEluaXRpYWxFdmVudHModmlldywgZXZlbnRSZWdpc3RyYXRpb24pO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmUgZXZlbnQgY2FsbGJhY2socykuICBSZXR1cm4gY2FuY2VsRXZlbnRzIGlmIGEgY2FuY2VsRXJyb3IgaXMgc3BlY2lmaWVkLlxyXG4gKlxyXG4gKiBJZiBxdWVyeSBpcyB0aGUgZGVmYXVsdCBxdWVyeSwgd2UnbGwgY2hlY2sgYWxsIHZpZXdzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50UmVnaXN0cmF0aW9uLlxyXG4gKiBJZiBldmVudFJlZ2lzdHJhdGlvbiBpcyBudWxsLCB3ZSdsbCByZW1vdmUgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIHNwZWNpZmllZCB2aWV3KHMpLlxyXG4gKlxyXG4gKiBAcGFyYW0gZXZlbnRSZWdpc3RyYXRpb24gLSBJZiBudWxsLCByZW1vdmUgYWxsIGNhbGxiYWNrcy5cclxuICogQHBhcmFtIGNhbmNlbEVycm9yIC0gSWYgYSBjYW5jZWxFcnJvciBpcyBwcm92aWRlZCwgYXBwcm9wcmlhdGUgY2FuY2VsIGV2ZW50cyB3aWxsIGJlIHJldHVybmVkLlxyXG4gKiBAcmV0dXJucyByZW1vdmVkIHF1ZXJpZXMgYW5kIGFueSBjYW5jZWwgZXZlbnRzXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jUG9pbnRSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihzeW5jUG9pbnQsIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpIHtcclxuICAgIGNvbnN0IHF1ZXJ5SWQgPSBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgY29uc3QgcmVtb3ZlZCA9IFtdO1xyXG4gICAgbGV0IGNhbmNlbEV2ZW50cyA9IFtdO1xyXG4gICAgY29uc3QgaGFkQ29tcGxldGVWaWV3ID0gc3luY1BvaW50SGFzQ29tcGxldGVWaWV3KHN5bmNQb2ludCk7XHJcbiAgICBpZiAocXVlcnlJZCA9PT0gJ2RlZmF1bHQnKSB7XHJcbiAgICAgICAgLy8gV2hlbiB5b3UgZG8gcmVmLm9mZiguLi4pLCB3ZSBzZWFyY2ggYWxsIHZpZXdzIGZvciB0aGUgcmVnaXN0cmF0aW9uIHRvIHJlbW92ZS5cclxuICAgICAgICBmb3IgKGNvbnN0IFt2aWV3UXVlcnlJZCwgdmlld10gb2Ygc3luY1BvaW50LnZpZXdzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBjYW5jZWxFdmVudHMgPSBjYW5jZWxFdmVudHMuY29uY2F0KHZpZXdSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbih2aWV3LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpKTtcclxuICAgICAgICAgICAgaWYgKHZpZXdJc0VtcHR5KHZpZXcpKSB7XHJcbiAgICAgICAgICAgICAgICBzeW5jUG9pbnQudmlld3MuZGVsZXRlKHZpZXdRdWVyeUlkKTtcclxuICAgICAgICAgICAgICAgIC8vIFdlJ2xsIGRlYWwgd2l0aCBjb21wbGV0ZSB2aWV3cyBsYXRlci5cclxuICAgICAgICAgICAgICAgIGlmICghdmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkLnB1c2godmlldy5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gdGhlIHNwZWNpZmljIHZpZXcuXHJcbiAgICAgICAgY29uc3QgdmlldyA9IHN5bmNQb2ludC52aWV3cy5nZXQocXVlcnlJZCk7XHJcbiAgICAgICAgaWYgKHZpZXcpIHtcclxuICAgICAgICAgICAgY2FuY2VsRXZlbnRzID0gY2FuY2VsRXZlbnRzLmNvbmNhdCh2aWV3UmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24odmlldywgZXZlbnRSZWdpc3RyYXRpb24sIGNhbmNlbEVycm9yKSk7XHJcbiAgICAgICAgICAgIGlmICh2aWV3SXNFbXB0eSh2aWV3KSkge1xyXG4gICAgICAgICAgICAgICAgc3luY1BvaW50LnZpZXdzLmRlbGV0ZShxdWVyeUlkKTtcclxuICAgICAgICAgICAgICAgIC8vIFdlJ2xsIGRlYWwgd2l0aCBjb21wbGV0ZSB2aWV3cyBsYXRlci5cclxuICAgICAgICAgICAgICAgIGlmICghdmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkLnB1c2godmlldy5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaGFkQ29tcGxldGVWaWV3ICYmICFzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcoc3luY1BvaW50KSkge1xyXG4gICAgICAgIC8vIFdlIHJlbW92ZWQgb3VyIGxhc3QgY29tcGxldGUgdmlldy5cclxuICAgICAgICByZW1vdmVkLnB1c2gobmV3IChzeW5jUG9pbnRHZXRSZWZlcmVuY2VDb25zdHJ1Y3RvcigpKShxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IHJlbW92ZWQsIGV2ZW50czogY2FuY2VsRXZlbnRzIH07XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50R2V0UXVlcnlWaWV3cyhzeW5jUG9pbnQpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgZm9yIChjb25zdCB2aWV3IG9mIHN5bmNQb2ludC52aWV3cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIGlmICghdmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godmlldyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byB0aGUgZGVzaXJlZCBjb21wbGV0ZSBzbmFwc2hvdFxyXG4gKiBAcmV0dXJucyBBIGNvbXBsZXRlIGNhY2hlLCBpZiBpdCBleGlzdHNcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3luY1BvaW50LCBwYXRoKSB7XHJcbiAgICBsZXQgc2VydmVyQ2FjaGUgPSBudWxsO1xyXG4gICAgZm9yIChjb25zdCB2aWV3IG9mIHN5bmNQb2ludC52aWV3cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIHNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGUgfHwgdmlld0dldENvbXBsZXRlU2VydmVyQ2FjaGUodmlldywgcGF0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2VydmVyQ2FjaGU7XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50Vmlld0ZvclF1ZXJ5KHN5bmNQb2ludCwgcXVlcnkpIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IHF1ZXJ5Ll9xdWVyeVBhcmFtcztcclxuICAgIGlmIChwYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICByZXR1cm4gc3luY1BvaW50R2V0Q29tcGxldGVWaWV3KHN5bmNQb2ludCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICByZXR1cm4gc3luY1BvaW50LnZpZXdzLmdldChxdWVyeUlkKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRWaWV3RXhpc3RzRm9yUXVlcnkoc3luY1BvaW50LCBxdWVyeSkge1xyXG4gICAgcmV0dXJuIHN5bmNQb2ludFZpZXdGb3JRdWVyeShzeW5jUG9pbnQsIHF1ZXJ5KSAhPSBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhzeW5jUG9pbnQpIHtcclxuICAgIHJldHVybiBzeW5jUG9pbnRHZXRDb21wbGV0ZVZpZXcoc3luY1BvaW50KSAhPSBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludEdldENvbXBsZXRlVmlldyhzeW5jUG9pbnQpIHtcclxuICAgIGZvciAoY29uc3QgdmlldyBvZiBzeW5jUG9pbnQudmlld3MudmFsdWVzKCkpIHtcclxuICAgICAgICBpZiAodmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IHJlZmVyZW5jZUNvbnN0cnVjdG9yO1xyXG5mdW5jdGlvbiBzeW5jVHJlZVNldFJlZmVyZW5jZUNvbnN0cnVjdG9yKHZhbCkge1xyXG4gICAgYXNzZXJ0KCFyZWZlcmVuY2VDb25zdHJ1Y3RvciwgJ19fcmVmZXJlbmNlQ29uc3RydWN0b3IgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkJyk7XHJcbiAgICByZWZlcmVuY2VDb25zdHJ1Y3RvciA9IHZhbDtcclxufVxyXG5mdW5jdGlvbiBzeW5jVHJlZUdldFJlZmVyZW5jZUNvbnN0cnVjdG9yKCkge1xyXG4gICAgYXNzZXJ0KHJlZmVyZW5jZUNvbnN0cnVjdG9yLCAnUmVmZXJlbmNlLnRzIGhhcyBub3QgYmVlbiBsb2FkZWQnKTtcclxuICAgIHJldHVybiByZWZlcmVuY2VDb25zdHJ1Y3RvcjtcclxufVxyXG4vKipcclxuICogU3RhdGljIHRyYWNrZXIgZm9yIG5leHQgcXVlcnkgdGFnLlxyXG4gKi9cclxubGV0IHN5bmNUcmVlTmV4dFF1ZXJ5VGFnXyA9IDE7XHJcbi8qKlxyXG4gKiBTeW5jVHJlZSBpcyB0aGUgY2VudHJhbCBjbGFzcyBmb3IgbWFuYWdpbmcgZXZlbnQgY2FsbGJhY2sgcmVnaXN0cmF0aW9uLCBkYXRhIGNhY2hpbmcsIHZpZXdzXHJcbiAqIChxdWVyeSBwcm9jZXNzaW5nKSwgYW5kIGV2ZW50IGdlbmVyYXRpb24uICBUaGVyZSBhcmUgdHlwaWNhbGx5IHR3byBTeW5jVHJlZSBpbnN0YW5jZXMgZm9yXHJcbiAqIGVhY2ggUmVwbywgb25lIGZvciB0aGUgbm9ybWFsIEZpcmViYXNlIGRhdGEsIGFuZCBvbmUgZm9yIHRoZSAuaW5mbyBkYXRhLlxyXG4gKlxyXG4gKiBJdCBoYXMgYSBudW1iZXIgb2YgcmVzcG9uc2liaWxpdGllcywgaW5jbHVkaW5nOlxyXG4gKiAgLSBUcmFja2luZyBhbGwgdXNlciBldmVudCBjYWxsYmFja3MgKHJlZ2lzdGVyZWQgdmlhIGFkZEV2ZW50UmVnaXN0cmF0aW9uKCkgYW5kIHJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKCkpLlxyXG4gKiAgLSBBcHBseWluZyBhbmQgY2FjaGluZyBkYXRhIGNoYW5nZXMgZm9yIHVzZXIgc2V0KCksIHRyYW5zYWN0aW9uKCksIGFuZCB1cGRhdGUoKSBjYWxsc1xyXG4gKiAgICAoYXBwbHlVc2VyT3ZlcndyaXRlKCksIGFwcGx5VXNlck1lcmdlKCkpLlxyXG4gKiAgLSBBcHBseWluZyBhbmQgY2FjaGluZyBkYXRhIGNoYW5nZXMgZm9yIHNlcnZlciBkYXRhIGNoYW5nZXMgKGFwcGx5U2VydmVyT3ZlcndyaXRlKCksXHJcbiAqICAgIGFwcGx5U2VydmVyTWVyZ2UoKSkuXHJcbiAqICAtIEdlbmVyYXRpbmcgdXNlci1mYWNpbmcgZXZlbnRzIGZvciBzZXJ2ZXIgYW5kIHVzZXIgY2hhbmdlcyAoYWxsIG9mIHRoZSBhcHBseSogbWV0aG9kc1xyXG4gKiAgICByZXR1cm4gdGhlIHNldCBvZiBldmVudHMgdGhhdCBuZWVkIHRvIGJlIHJhaXNlZCBhcyBhIHJlc3VsdCkuXHJcbiAqICAtIE1haW50YWluaW5nIHRoZSBhcHByb3ByaWF0ZSBzZXQgb2Ygc2VydmVyIGxpc3RlbnMgdG8gZW5zdXJlIHdlIGFyZSBhbHdheXMgc3Vic2NyaWJlZFxyXG4gKiAgICB0byB0aGUgY29ycmVjdCBzZXQgb2YgcGF0aHMgYW5kIHF1ZXJpZXMgdG8gc2F0aXNmeSB0aGUgY3VycmVudCBzZXQgb2YgdXNlciBldmVudFxyXG4gKiAgICBjYWxsYmFja3MgKGxpc3RlbnMgYXJlIHN0YXJ0ZWQvc3RvcHBlZCB1c2luZyB0aGUgcHJvdmlkZWQgbGlzdGVuUHJvdmlkZXIpLlxyXG4gKlxyXG4gKiBOT1RFOiBBbHRob3VnaCBTeW5jVHJlZSB0cmFja3MgZXZlbnQgY2FsbGJhY2tzIGFuZCBjYWxjdWxhdGVzIGV2ZW50cyB0byByYWlzZSwgdGhlIGFjdHVhbFxyXG4gKiBldmVudHMgYXJlIHJldHVybmVkIHRvIHRoZSBjYWxsZXIgcmF0aGVyIHRoYW4gcmFpc2VkIHN5bmNocm9ub3VzbHkuXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBTeW5jVHJlZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBsaXN0ZW5Qcm92aWRlcl8gLSBVc2VkIGJ5IFN5bmNUcmVlIHRvIHN0YXJ0IC8gc3RvcCBsaXN0ZW5pbmdcclxuICAgICAqICAgdG8gc2VydmVyIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxpc3RlblByb3ZpZGVyXykge1xyXG4gICAgICAgIHRoaXMubGlzdGVuUHJvdmlkZXJfID0gbGlzdGVuUHJvdmlkZXJfO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyZWUgb2YgU3luY1BvaW50cy4gIFRoZXJlJ3MgYSBTeW5jUG9pbnQgYXQgYW55IGxvY2F0aW9uIHRoYXQgaGFzIDEgb3IgbW9yZSB2aWV3cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN5bmNQb2ludFRyZWVfID0gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSB0cmVlIG9mIGFsbCBwZW5kaW5nIHVzZXIgd3JpdGVzICh1c2VyLWluaXRpYXRlZCBzZXQoKSdzLCB0cmFuc2FjdGlvbigpJ3MsIHVwZGF0ZSgpJ3MsIGV0Yy4pLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1dyaXRlVHJlZV8gPSBuZXdXcml0ZVRyZWUoKTtcclxuICAgICAgICB0aGlzLnRhZ1RvUXVlcnlNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5xdWVyeVRvVGFnTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBcHBseSB0aGUgZGF0YSBjaGFuZ2VzIGZvciBhIHVzZXItZ2VuZXJhdGVkIHNldCgpIG9yIHRyYW5zYWN0aW9uKCkgY2FsbC5cclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVVzZXJPdmVyd3JpdGUoc3luY1RyZWUsIHBhdGgsIG5ld0RhdGEsIHdyaXRlSWQsIHZpc2libGUpIHtcclxuICAgIC8vIFJlY29yZCBwZW5kaW5nIHdyaXRlLlxyXG4gICAgd3JpdGVUcmVlQWRkT3ZlcndyaXRlKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCBwYXRoLCBuZXdEYXRhLCB3cml0ZUlkLCB2aXNpYmxlKTtcclxuICAgIGlmICghdmlzaWJsZSkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhzeW5jVHJlZSwgbmV3IE92ZXJ3cml0ZShuZXdPcGVyYXRpb25Tb3VyY2VVc2VyKCksIHBhdGgsIG5ld0RhdGEpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXBwbHkgdGhlIGRhdGEgZnJvbSBhIHVzZXItZ2VuZXJhdGVkIHVwZGF0ZSgpIGNhbGxcclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVVzZXJNZXJnZShzeW5jVHJlZSwgcGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZUlkKSB7XHJcbiAgICAvLyBSZWNvcmQgcGVuZGluZyBtZXJnZS5cclxuICAgIHdyaXRlVHJlZUFkZE1lcmdlKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpO1xyXG4gICAgY29uc3QgY2hhbmdlVHJlZSA9IEltbXV0YWJsZVRyZWUuZnJvbU9iamVjdChjaGFuZ2VkQ2hpbGRyZW4pO1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgTWVyZ2UobmV3T3BlcmF0aW9uU291cmNlVXNlcigpLCBwYXRoLCBjaGFuZ2VUcmVlKSk7XHJcbn1cclxuLyoqXHJcbiAqIEFja25vd2xlZGdlIGEgcGVuZGluZyB1c2VyIHdyaXRlIHRoYXQgd2FzIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIGFwcGx5VXNlck92ZXJ3cml0ZSgpIG9yIGFwcGx5VXNlck1lcmdlKCkuXHJcbiAqXHJcbiAqIEBwYXJhbSByZXZlcnQgLSBUcnVlIGlmIHRoZSBnaXZlbiB3cml0ZSBmYWlsZWQgYW5kIG5lZWRzIHRvIGJlIHJldmVydGVkXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQWNrVXNlcldyaXRlKHN5bmNUcmVlLCB3cml0ZUlkLCByZXZlcnQgPSBmYWxzZSkge1xyXG4gICAgY29uc3Qgd3JpdGUgPSB3cml0ZVRyZWVHZXRXcml0ZShzeW5jVHJlZS5wZW5kaW5nV3JpdGVUcmVlXywgd3JpdGVJZCk7XHJcbiAgICBjb25zdCBuZWVkVG9SZWV2YWx1YXRlID0gd3JpdGVUcmVlUmVtb3ZlV3JpdGUoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIHdyaXRlSWQpO1xyXG4gICAgaWYgKCFuZWVkVG9SZWV2YWx1YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IGFmZmVjdGVkVHJlZSA9IG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgIGlmICh3cml0ZS5zbmFwICE9IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gb3ZlcndyaXRlXHJcbiAgICAgICAgICAgIGFmZmVjdGVkVHJlZSA9IGFmZmVjdGVkVHJlZS5zZXQobmV3RW1wdHlQYXRoKCksIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWFjaCh3cml0ZS5jaGlsZHJlbiwgKHBhdGhTdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGFmZmVjdGVkVHJlZSA9IGFmZmVjdGVkVHJlZS5zZXQobmV3IFBhdGgocGF0aFN0cmluZyksIHRydWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgQWNrVXNlcldyaXRlKHdyaXRlLnBhdGgsIGFmZmVjdGVkVHJlZSwgcmV2ZXJ0KSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IG5ldyBzZXJ2ZXIgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCBwYXRoLi5cclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVNlcnZlck92ZXJ3cml0ZShzeW5jVHJlZSwgcGF0aCwgbmV3RGF0YSkge1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgT3ZlcndyaXRlKG5ld09wZXJhdGlvblNvdXJjZVNlcnZlcigpLCBwYXRoLCBuZXdEYXRhKSk7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IG5ldyBzZXJ2ZXIgZGF0YSB0byBiZSBtZXJnZWQgaW4gYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5U2VydmVyTWVyZ2Uoc3luY1RyZWUsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbikge1xyXG4gICAgY29uc3QgY2hhbmdlVHJlZSA9IEltbXV0YWJsZVRyZWUuZnJvbU9iamVjdChjaGFuZ2VkQ2hpbGRyZW4pO1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgTWVyZ2UobmV3T3BlcmF0aW9uU291cmNlU2VydmVyKCksIHBhdGgsIGNoYW5nZVRyZWUpKTtcclxufVxyXG4vKipcclxuICogQXBwbHkgYSBsaXN0ZW4gY29tcGxldGUgZm9yIGEgcXVlcnlcclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseUxpc3RlbkNvbXBsZXRlKHN5bmNUcmVlLCBwYXRoKSB7XHJcbiAgICByZXR1cm4gc3luY1RyZWVBcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18oc3luY1RyZWUsIG5ldyBMaXN0ZW5Db21wbGV0ZShuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXIoKSwgcGF0aCkpO1xyXG59XHJcbi8qKlxyXG4gKiBBcHBseSBhIGxpc3RlbiBjb21wbGV0ZSBmb3IgYSB0YWdnZWQgcXVlcnlcclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVRhZ2dlZExpc3RlbkNvbXBsZXRlKHN5bmNUcmVlLCBwYXRoLCB0YWcpIHtcclxuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gc3luY1RyZWVRdWVyeUtleUZvclRhZ18oc3luY1RyZWUsIHRhZyk7XHJcbiAgICBpZiAocXVlcnlLZXkpIHtcclxuICAgICAgICBjb25zdCByID0gc3luY1RyZWVQYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSk7XHJcbiAgICAgICAgY29uc3QgcXVlcnlQYXRoID0gci5wYXRoLCBxdWVyeUlkID0gci5xdWVyeUlkO1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChxdWVyeVBhdGgsIHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IG9wID0gbmV3IExpc3RlbkNvbXBsZXRlKG5ld09wZXJhdGlvblNvdXJjZVNlcnZlclRhZ2dlZFF1ZXJ5KHF1ZXJ5SWQpLCByZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5VGFnZ2VkT3BlcmF0aW9uXyhzeW5jVHJlZSwgcXVlcnlQYXRoLCBvcCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IHJlbW92ZWQgdGhlIHF1ZXJ5LiBObyBiaWcgZGVhbCwgaWdub3JlIHRoZSB1cGRhdGVcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSBldmVudCBjYWxsYmFjayhzKS5cclxuICpcclxuICogSWYgcXVlcnkgaXMgdGhlIGRlZmF1bHQgcXVlcnksIHdlJ2xsIGNoZWNrIGFsbCBxdWVyaWVzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50UmVnaXN0cmF0aW9uLlxyXG4gKiBJZiBldmVudFJlZ2lzdHJhdGlvbiBpcyBudWxsLCB3ZSdsbCByZW1vdmUgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIHNwZWNpZmllZCBxdWVyeS9xdWVyaWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gZXZlbnRSZWdpc3RyYXRpb24gLSBJZiBudWxsLCBhbGwgY2FsbGJhY2tzIGFyZSByZW1vdmVkLlxyXG4gKiBAcGFyYW0gY2FuY2VsRXJyb3IgLSBJZiBhIGNhbmNlbEVycm9yIGlzIHByb3ZpZGVkLCBhcHByb3ByaWF0ZSBjYW5jZWwgZXZlbnRzIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAqIEBwYXJhbSBza2lwTGlzdGVuZXJEZWR1cCAtIFdoZW4gcGVyZm9ybWluZyBhIGBnZXQoKWAsIHdlIGRvbid0IGFkZCBhbnkgbmV3IGxpc3RlbmVycywgc28gbm9cclxuICogIGRlZHVwaW5nIG5lZWRzIHRvIHRha2UgcGxhY2UuIFRoaXMgZmxhZyBhbGxvd3MgdG9nZ2xpbmcgb2YgdGhhdCBiZWhhdmlvclxyXG4gKiBAcmV0dXJucyBDYW5jZWwgZXZlbnRzLCBpZiBjYW5jZWxFcnJvciB3YXMgcHJvdmlkZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZVJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHN5bmNUcmVlLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIGNhbmNlbEVycm9yLCBza2lwTGlzdGVuZXJEZWR1cCA9IGZhbHNlKSB7XHJcbiAgICAvLyBGaW5kIHRoZSBzeW5jUG9pbnQgZmlyc3QuIFRoZW4gZGVhbCB3aXRoIHdoZXRoZXIgb3Igbm90IGl0IGhhcyBtYXRjaGluZyBsaXN0ZW5lcnNcclxuICAgIGNvbnN0IHBhdGggPSBxdWVyeS5fcGF0aDtcclxuICAgIGNvbnN0IG1heWJlU3luY1BvaW50ID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZ2V0KHBhdGgpO1xyXG4gICAgbGV0IGNhbmNlbEV2ZW50cyA9IFtdO1xyXG4gICAgLy8gQSByZW1vdmFsIG9uIGEgZGVmYXVsdCBxdWVyeSBhZmZlY3RzIGFsbCBxdWVyaWVzIGF0IHRoYXQgbG9jYXRpb24uIEEgcmVtb3ZhbCBvbiBhbiBpbmRleGVkIHF1ZXJ5LCBldmVuIG9uZSB3aXRob3V0XHJcbiAgICAvLyBvdGhlciBxdWVyeSBjb25zdHJhaW50cywgZG9lcyAqbm90KiBhZmZlY3QgYWxsIHF1ZXJpZXMgYXQgdGhhdCBsb2NhdGlvbi4gU28gdGhpcyBjaGVjayBtdXN0IGJlIGZvciAnZGVmYXVsdCcsIGFuZFxyXG4gICAgLy8gbm90IGxvYWRzQWxsRGF0YSgpLlxyXG4gICAgaWYgKG1heWJlU3luY1BvaW50ICYmXHJcbiAgICAgICAgKHF1ZXJ5Ll9xdWVyeUlkZW50aWZpZXIgPT09ICdkZWZhdWx0JyB8fFxyXG4gICAgICAgICAgICBzeW5jUG9pbnRWaWV3RXhpc3RzRm9yUXVlcnkobWF5YmVTeW5jUG9pbnQsIHF1ZXJ5KSkpIHtcclxuICAgICAgICBjb25zdCByZW1vdmVkQW5kRXZlbnRzID0gc3luY1BvaW50UmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24obWF5YmVTeW5jUG9pbnQsIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpO1xyXG4gICAgICAgIGlmIChzeW5jUG9pbnRJc0VtcHR5KG1heWJlU3luY1BvaW50KSkge1xyXG4gICAgICAgICAgICBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXyA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnJlbW92ZShwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IHJlbW92ZWRBbmRFdmVudHMucmVtb3ZlZDtcclxuICAgICAgICBjYW5jZWxFdmVudHMgPSByZW1vdmVkQW5kRXZlbnRzLmV2ZW50cztcclxuICAgICAgICBpZiAoIXNraXBMaXN0ZW5lckRlZHVwKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXZSBtYXkgaGF2ZSBqdXN0IHJlbW92ZWQgb25lIG9mIG1hbnkgbGlzdGVuZXJzIGFuZCBjYW4gc2hvcnQtY2lyY3VpdCB0aGlzIHdob2xlIHByb2Nlc3NcclxuICAgICAgICAgICAgICogV2UgbWF5IGFsc28gbm90IGhhdmUgcmVtb3ZlZCBhIGRlZmF1bHQgbGlzdGVuZXIsIGluIHdoaWNoIGNhc2UgYWxsIG9mIHRoZSBkZXNjZW5kYW50IGxpc3RlbmVycyBzaG91bGQgYWxyZWFkeSBiZVxyXG4gICAgICAgICAgICAgKiBwcm9wZXJseSBzZXQgdXAuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAvLyBTaW5jZSBpbmRleGVkIHF1ZXJpZXMgY2FuIHNoYWRvdyBpZiB0aGV5IGRvbid0IGhhdmUgb3RoZXIgcXVlcnkgY29uc3RyYWludHMsIGNoZWNrIGZvciBsb2Fkc0FsbERhdGEoKSwgaW5zdGVhZCBvZlxyXG4gICAgICAgICAgICAvLyBxdWVyeUlkID09PSAnZGVmYXVsdCdcclxuICAgICAgICAgICAgY29uc3QgcmVtb3ZpbmdEZWZhdWx0ID0gLTEgIT09XHJcbiAgICAgICAgICAgICAgICByZW1vdmVkLmZpbmRJbmRleChxdWVyeSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBjb3ZlcmVkID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZmluZE9uUGF0aChwYXRoLCAocmVsYXRpdmVQYXRoLCBwYXJlbnRTeW5jUG9pbnQpID0+IHN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhwYXJlbnRTeW5jUG9pbnQpKTtcclxuICAgICAgICAgICAgaWYgKHJlbW92aW5nRGVmYXVsdCAmJiAhY292ZXJlZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3VidHJlZSA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnN1YnRyZWUocGF0aCk7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBhcmUgcG90ZW50aWFsbHkgY2hpbGQgbGlzdGVuZXJzLiBEZXRlcm1pbmUgd2hhdCBpZiBhbnkgbGlzdGVucyB3ZSBuZWVkIHRvIHNlbmQgYmVmb3JlIGV4ZWN1dGluZyB0aGVcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92YWxcclxuICAgICAgICAgICAgICAgIGlmICghc3VidHJlZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGZvbGQgb3ZlciBvdXIgc3VidHJlZSBhbmQgY29sbGVjdCB0aGUgbGlzdGVuZXJzIHRvIHNlbmRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdWaWV3cyA9IHN5bmNUcmVlQ29sbGVjdERpc3RpbmN0Vmlld3NGb3JTdWJUcmVlXyhzdWJ0cmVlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBPaywgd2UndmUgY29sbGVjdGVkIGFsbCB0aGUgbGlzdGVucyB3ZSBuZWVkLiBTZXQgdGhlbSB1cC5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1ZpZXdzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXdWaWV3c1tpXSwgbmV3UXVlcnkgPSB2aWV3LnF1ZXJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IHN5bmNUcmVlQ3JlYXRlTGlzdGVuZXJGb3JWaWV3XyhzeW5jVHJlZSwgdmlldyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNUcmVlLmxpc3RlblByb3ZpZGVyXy5zdGFydExpc3RlbmluZyhzeW5jVHJlZVF1ZXJ5Rm9yTGlzdGVuaW5nXyhuZXdRdWVyeSksIHN5bmNUcmVlVGFnRm9yUXVlcnkoc3luY1RyZWUsIG5ld1F1ZXJ5KSwgbGlzdGVuZXIuaGFzaEZuLCBsaXN0ZW5lci5vbkNvbXBsZXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgdGhlcmUncyBub3RoaW5nIGJlbG93IHVzLCBzbyBub3RoaW5nIHdlIG5lZWQgdG8gc3RhcnQgbGlzdGVuaW5nIG9uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgd2UgcmVtb3ZlZCBhbnl0aGluZyBhbmQgd2UncmUgbm90IGNvdmVyZWQgYnkgYSBoaWdoZXIgdXAgbGlzdGVuLCB3ZSBuZWVkIHRvIHN0b3AgbGlzdGVuaW5nIG9uIHRoaXMgcXVlcnlcclxuICAgICAgICAgICAgLy8gVGhlIGFib3ZlIGJsb2NrIGhhcyB1cyBjb3ZlcmVkIGluIHRlcm1zIG9mIG1ha2luZyBzdXJlIHdlJ3JlIHNldCB1cCBvbiBsaXN0ZW5zIGxvd2VyIGluIHRoZSB0cmVlLlxyXG4gICAgICAgICAgICAvLyBBbHNvLCBub3RlIHRoYXQgaWYgd2UgaGF2ZSBhIGNhbmNlbEVycm9yLCBpdCdzIGFscmVhZHkgYmVlbiByZW1vdmVkIGF0IHRoZSBwcm92aWRlciBsZXZlbC5cclxuICAgICAgICAgICAgaWYgKCFjb3ZlcmVkICYmIHJlbW92ZWQubGVuZ3RoID4gMCAmJiAhY2FuY2VsRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlbW92ZWQgYSBkZWZhdWx0LCB0aGVuIHdlIHdlcmVuJ3QgbGlzdGVuaW5nIG9uIGFueSBvZiB0aGUgb3RoZXIgcXVlcmllcyBoZXJlLiBKdXN0IGNhbmNlbCB0aGUgb25lXHJcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0LiBPdGhlcndpc2UsIHdlIG5lZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIGFuZCBjYW5jZWwgZWFjaCBpbmRpdmlkdWFsIHF1ZXJ5XHJcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZpbmdEZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdGFnIGRlZmF1bHQgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdFRhZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgc3luY1RyZWUubGlzdGVuUHJvdmlkZXJfLnN0b3BMaXN0ZW5pbmcoc3luY1RyZWVRdWVyeUZvckxpc3RlbmluZ18ocXVlcnkpLCBkZWZhdWx0VGFnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQuZm9yRWFjaCgocXVlcnlUb1JlbW92ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWdUb1JlbW92ZSA9IHN5bmNUcmVlLnF1ZXJ5VG9UYWdNYXAuZ2V0KHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhxdWVyeVRvUmVtb3ZlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNUcmVlLmxpc3RlblByb3ZpZGVyXy5zdG9wTGlzdGVuaW5nKHN5bmNUcmVlUXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5VG9SZW1vdmUpLCB0YWdUb1JlbW92ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm93LCBjbGVhciBhbGwgb2YgdGhlIHRhZ3Mgd2UncmUgdHJhY2tpbmcgZm9yIHRoZSByZW1vdmVkIGxpc3RlbnNcclxuICAgICAgICBzeW5jVHJlZVJlbW92ZVRhZ3NfKHN5bmNUcmVlLCByZW1vdmVkKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjYW5jZWxFdmVudHM7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IG5ldyBzZXJ2ZXIgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCB0YWdnZWQgcXVlcnkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlUYWdnZWRRdWVyeU92ZXJ3cml0ZShzeW5jVHJlZSwgcGF0aCwgc25hcCwgdGFnKSB7XHJcbiAgICBjb25zdCBxdWVyeUtleSA9IHN5bmNUcmVlUXVlcnlLZXlGb3JUYWdfKHN5bmNUcmVlLCB0YWcpO1xyXG4gICAgaWYgKHF1ZXJ5S2V5ICE9IG51bGwpIHtcclxuICAgICAgICBjb25zdCByID0gc3luY1RyZWVQYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSk7XHJcbiAgICAgICAgY29uc3QgcXVlcnlQYXRoID0gci5wYXRoLCBxdWVyeUlkID0gci5xdWVyeUlkO1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChxdWVyeVBhdGgsIHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IG9wID0gbmV3IE92ZXJ3cml0ZShuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXJUYWdnZWRRdWVyeShxdWVyeUlkKSwgcmVsYXRpdmVQYXRoLCBzbmFwKTtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseVRhZ2dlZE9wZXJhdGlvbl8oc3luY1RyZWUsIHF1ZXJ5UGF0aCwgb3ApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gUXVlcnkgbXVzdCBoYXZlIGJlZW4gcmVtb3ZlZCBhbHJlYWR5XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBcHBseSBzZXJ2ZXIgZGF0YSB0byBiZSBtZXJnZWQgaW4gZm9yIHRoZSBzcGVjaWZpZWQgdGFnZ2VkIHF1ZXJ5LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5VGFnZ2VkUXVlcnlNZXJnZShzeW5jVHJlZSwgcGF0aCwgY2hhbmdlZENoaWxkcmVuLCB0YWcpIHtcclxuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gc3luY1RyZWVRdWVyeUtleUZvclRhZ18oc3luY1RyZWUsIHRhZyk7XHJcbiAgICBpZiAocXVlcnlLZXkpIHtcclxuICAgICAgICBjb25zdCByID0gc3luY1RyZWVQYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSk7XHJcbiAgICAgICAgY29uc3QgcXVlcnlQYXRoID0gci5wYXRoLCBxdWVyeUlkID0gci5xdWVyeUlkO1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChxdWVyeVBhdGgsIHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZVRyZWUgPSBJbW11dGFibGVUcmVlLmZyb21PYmplY3QoY2hhbmdlZENoaWxkcmVuKTtcclxuICAgICAgICBjb25zdCBvcCA9IG5ldyBNZXJnZShuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXJUYWdnZWRRdWVyeShxdWVyeUlkKSwgcmVsYXRpdmVQYXRoLCBjaGFuZ2VUcmVlKTtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseVRhZ2dlZE9wZXJhdGlvbl8oc3luY1RyZWUsIHF1ZXJ5UGF0aCwgb3ApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gV2UndmUgYWxyZWFkeSByZW1vdmVkIHRoZSBxdWVyeS4gTm8gYmlnIGRlYWwsIGlnbm9yZSB0aGUgdXBkYXRlXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBZGQgYW4gZXZlbnQgY2FsbGJhY2sgZm9yIHRoZSBzcGVjaWZpZWQgcXVlcnkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQWRkRXZlbnRSZWdpc3RyYXRpb24oc3luY1RyZWUsIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgc2tpcFNldHVwTGlzdGVuZXIgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgcGF0aCA9IHF1ZXJ5Ll9wYXRoO1xyXG4gICAgbGV0IHNlcnZlckNhY2hlID0gbnVsbDtcclxuICAgIGxldCBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgPSBmYWxzZTtcclxuICAgIC8vIEFueSBjb3ZlcmluZyB3cml0ZXMgd2lsbCBuZWNlc3NhcmlseSBiZSBhdCB0aGUgcm9vdCwgc28gcmVhbGx5IGFsbCB3ZSBuZWVkIHRvIGZpbmQgaXMgdGhlIHNlcnZlciBjYWNoZS5cclxuICAgIC8vIENvbnNpZGVyIG9wdGltaXppbmcgdGhpcyBvbmNlIHRoZXJlJ3MgYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiB3aGF0IGFjdHVhbCBiZWhhdmlvciB3aWxsIGJlLlxyXG4gICAgc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZm9yZWFjaE9uUGF0aChwYXRoLCAocGF0aFRvU3luY1BvaW50LCBzcCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChwYXRoVG9TeW5jUG9pbnQsIHBhdGgpO1xyXG4gICAgICAgIHNlcnZlckNhY2hlID1cclxuICAgICAgICAgICAgc2VydmVyQ2FjaGUgfHwgc3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShzcCwgcmVsYXRpdmVQYXRoKTtcclxuICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgPVxyXG4gICAgICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgfHwgc3luY1BvaW50SGFzQ29tcGxldGVWaWV3KHNwKTtcclxuICAgIH0pO1xyXG4gICAgbGV0IHN5bmNQb2ludCA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmdldChwYXRoKTtcclxuICAgIGlmICghc3luY1BvaW50KSB7XHJcbiAgICAgICAgc3luY1BvaW50ID0gbmV3IFN5bmNQb2ludCgpO1xyXG4gICAgICAgIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uc2V0KHBhdGgsIHN5bmNQb2ludCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgPVxyXG4gICAgICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgfHwgc3luY1BvaW50SGFzQ29tcGxldGVWaWV3KHN5bmNQb2ludCk7XHJcbiAgICAgICAgc2VydmVyQ2FjaGUgPVxyXG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSB8fCBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHN5bmNQb2ludCwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgfVxyXG4gICAgbGV0IHNlcnZlckNhY2hlQ29tcGxldGU7XHJcbiAgICBpZiAoc2VydmVyQ2FjaGUgIT0gbnVsbCkge1xyXG4gICAgICAgIHNlcnZlckNhY2hlQ29tcGxldGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2VydmVyQ2FjaGVDb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgIHNlcnZlckNhY2hlID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgY29uc3Qgc3VidHJlZSA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnN1YnRyZWUocGF0aCk7XHJcbiAgICAgICAgc3VidHJlZS5mb3JlYWNoQ2hpbGQoKGNoaWxkTmFtZSwgY2hpbGRTeW5jUG9pbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29tcGxldGVDYWNoZSA9IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoY2hpbGRTeW5jUG9pbnQsIG5ld0VtcHR5UGF0aCgpKTtcclxuICAgICAgICAgICAgaWYgKGNvbXBsZXRlQ2FjaGUpIHtcclxuICAgICAgICAgICAgICAgIHNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBjb21wbGV0ZUNhY2hlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgdmlld0FscmVhZHlFeGlzdHMgPSBzeW5jUG9pbnRWaWV3RXhpc3RzRm9yUXVlcnkoc3luY1BvaW50LCBxdWVyeSk7XHJcbiAgICBpZiAoIXZpZXdBbHJlYWR5RXhpc3RzICYmICFxdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAvLyBXZSBuZWVkIHRvIHRyYWNrIGEgdGFnIGZvciB0aGlzIHF1ZXJ5XHJcbiAgICAgICAgY29uc3QgcXVlcnlLZXkgPSBzeW5jVHJlZU1ha2VRdWVyeUtleV8ocXVlcnkpO1xyXG4gICAgICAgIGFzc2VydCghc3luY1RyZWUucXVlcnlUb1RhZ01hcC5oYXMocXVlcnlLZXkpLCAnVmlldyBkb2VzIG5vdCBleGlzdCwgYnV0IHdlIGhhdmUgYSB0YWcnKTtcclxuICAgICAgICBjb25zdCB0YWcgPSBzeW5jVHJlZUdldE5leHRRdWVyeVRhZ18oKTtcclxuICAgICAgICBzeW5jVHJlZS5xdWVyeVRvVGFnTWFwLnNldChxdWVyeUtleSwgdGFnKTtcclxuICAgICAgICBzeW5jVHJlZS50YWdUb1F1ZXJ5TWFwLnNldCh0YWcsIHF1ZXJ5S2V5KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHdyaXRlc0NhY2hlID0gd3JpdGVUcmVlQ2hpbGRXcml0ZXMoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIHBhdGgpO1xyXG4gICAgbGV0IGV2ZW50cyA9IHN5bmNQb2ludEFkZEV2ZW50UmVnaXN0cmF0aW9uKHN5bmNQb2ludCwgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIHNlcnZlckNhY2hlQ29tcGxldGUpO1xyXG4gICAgaWYgKCF2aWV3QWxyZWFkeUV4aXN0cyAmJiAhZm91bmRBbmNlc3RvckRlZmF1bHRWaWV3ICYmICFza2lwU2V0dXBMaXN0ZW5lcikge1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnRWaWV3Rm9yUXVlcnkoc3luY1BvaW50LCBxdWVyeSk7XHJcbiAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZVNldHVwTGlzdGVuZXJfKHN5bmNUcmVlLCBxdWVyeSwgdmlldykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2ZW50cztcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIGNvbXBsZXRlIGNhY2hlLCBpZiB3ZSBoYXZlIG9uZSwgb2YgdGhlIGRhdGEgYXQgYSBwYXJ0aWN1bGFyIHBhdGguIElmIHRoZSBsb2NhdGlvbiBkb2VzIG5vdCBoYXZlIGFcclxuICogbGlzdGVuZXIgYWJvdmUgaXQsIHdlIHdpbGwgZ2V0IGEgZmFsc2UgXCJudWxsXCIuIFRoaXMgc2hvdWxkbid0IGJlIGEgcHJvYmxlbSBiZWNhdXNlIHRyYW5zYWN0aW9ucyB3aWxsIGFsd2F5c1xyXG4gKiBoYXZlIGEgbGlzdGVuZXIgYWJvdmUsIGFuZCBhdG9taWMgb3BlcmF0aW9ucyB3b3VsZCBjb3JyZWN0bHkgc2hvdyBhIGppdHRlciBvZiA8aW5jcmVtZW50IHZhbHVlPiAtPlxyXG4gKiAgICAgPGluY3JlbWVudGVkIHRvdGFsPiBhcyB0aGUgd3JpdGUgaXMgYXBwbGllZCBsb2NhbGx5IGFuZCB0aGVuIGFja25vd2xlZGdlZCBhdCB0aGUgc2VydmVyLlxyXG4gKlxyXG4gKiBOb3RlOiB0aGlzIG1ldGhvZCB3aWxsICppbmNsdWRlKiBoaWRkZW4gd3JpdGVzIGZyb20gdHJhbnNhY3Rpb24gd2l0aCBhcHBseUxvY2FsbHkgc2V0IHRvIGZhbHNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHRoZSBkYXRhIHdlIHdhbnRcclxuICogQHBhcmFtIHdyaXRlSWRzVG9FeGNsdWRlIC0gQSBzcGVjaWZpYyBzZXQgdG8gYmUgZXhjbHVkZWRcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZShzeW5jVHJlZSwgcGF0aCwgd3JpdGVJZHNUb0V4Y2x1ZGUpIHtcclxuICAgIGNvbnN0IGluY2x1ZGVIaWRkZW5TZXRzID0gdHJ1ZTtcclxuICAgIGNvbnN0IHdyaXRlVHJlZSA9IHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfO1xyXG4gICAgY29uc3Qgc2VydmVyQ2FjaGUgPSBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5maW5kT25QYXRoKHBhdGgsIChwYXRoU29GYXIsIHN5bmNQb2ludCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChwYXRoU29GYXIsIHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IHNlcnZlckNhY2hlID0gc3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShzeW5jUG9pbnQsIHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgaWYgKHNlcnZlckNhY2hlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJDYWNoZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB3cml0ZVRyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlVHJlZSwgcGF0aCwgc2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuU2V0cyk7XHJcbn1cclxuZnVuY3Rpb24gc3luY1RyZWVHZXRTZXJ2ZXJWYWx1ZShzeW5jVHJlZSwgcXVlcnkpIHtcclxuICAgIGNvbnN0IHBhdGggPSBxdWVyeS5fcGF0aDtcclxuICAgIGxldCBzZXJ2ZXJDYWNoZSA9IG51bGw7XHJcbiAgICAvLyBBbnkgY292ZXJpbmcgd3JpdGVzIHdpbGwgbmVjZXNzYXJpbHkgYmUgYXQgdGhlIHJvb3QsIHNvIHJlYWxseSBhbGwgd2UgbmVlZCB0byBmaW5kIGlzIHRoZSBzZXJ2ZXIgY2FjaGUuXHJcbiAgICAvLyBDb25zaWRlciBvcHRpbWl6aW5nIHRoaXMgb25jZSB0aGVyZSdzIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2Ygd2hhdCBhY3R1YWwgYmVoYXZpb3Igd2lsbCBiZS5cclxuICAgIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmZvcmVhY2hPblBhdGgocGF0aCwgKHBhdGhUb1N5bmNQb2ludCwgc3ApID0+IHtcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocGF0aFRvU3luY1BvaW50LCBwYXRoKTtcclxuICAgICAgICBzZXJ2ZXJDYWNoZSA9XHJcbiAgICAgICAgICAgIHNlcnZlckNhY2hlIHx8IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3AsIHJlbGF0aXZlUGF0aCk7XHJcbiAgICB9KTtcclxuICAgIGxldCBzeW5jUG9pbnQgPSBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5nZXQocGF0aCk7XHJcbiAgICBpZiAoIXN5bmNQb2ludCkge1xyXG4gICAgICAgIHN5bmNQb2ludCA9IG5ldyBTeW5jUG9pbnQoKTtcclxuICAgICAgICBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXyA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnNldChwYXRoLCBzeW5jUG9pbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2VydmVyQ2FjaGUgPVxyXG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSB8fCBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHN5bmNQb2ludCwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2VydmVyQ2FjaGVDb21wbGV0ZSA9IHNlcnZlckNhY2hlICE9IG51bGw7XHJcbiAgICBjb25zdCBzZXJ2ZXJDYWNoZU5vZGUgPSBzZXJ2ZXJDYWNoZUNvbXBsZXRlXHJcbiAgICAgICAgPyBuZXcgQ2FjaGVOb2RlKHNlcnZlckNhY2hlLCB0cnVlLCBmYWxzZSlcclxuICAgICAgICA6IG51bGw7XHJcbiAgICBjb25zdCB3cml0ZXNDYWNoZSA9IHdyaXRlVHJlZUNoaWxkV3JpdGVzKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCBxdWVyeS5fcGF0aCk7XHJcbiAgICBjb25zdCB2aWV3ID0gc3luY1BvaW50R2V0VmlldyhzeW5jUG9pbnQsIHF1ZXJ5LCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSA/IHNlcnZlckNhY2hlTm9kZS5nZXROb2RlKCkgOiBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgc2VydmVyQ2FjaGVDb21wbGV0ZSk7XHJcbiAgICByZXR1cm4gdmlld0dldENvbXBsZXRlTm9kZSh2aWV3KTtcclxufVxyXG4vKipcclxuICogQSBoZWxwZXIgbWV0aG9kIHRoYXQgdmlzaXRzIGFsbCBkZXNjZW5kYW50IGFuZCBhbmNlc3RvciBTeW5jUG9pbnRzLCBhcHBseWluZyB0aGUgb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBOT1RFUzpcclxuICogLSBEZXNjZW5kYW50IFN5bmNQb2ludHMgd2lsbCBiZSB2aXNpdGVkIGZpcnN0IChzaW5jZSB3ZSByYWlzZSBldmVudHMgZGVwdGgtZmlyc3QpLlxyXG4gKlxyXG4gKiAtIFdlIGNhbGwgYXBwbHlPcGVyYXRpb24oKSBvbiBlYWNoIFN5bmNQb2ludCBwYXNzaW5nIHRocmVlIHRoaW5nczpcclxuICogICAxLiBBIHZlcnNpb24gb2YgdGhlIE9wZXJhdGlvbiB0aGF0IGhhcyBiZWVuIG1hZGUgcmVsYXRpdmUgdG8gdGhlIFN5bmNQb2ludCBsb2NhdGlvbi5cclxuICogICAyLiBBIFdyaXRlVHJlZVJlZiBvZiBhbnkgd3JpdGVzIHdlIGhhdmUgY2FjaGVkIGF0IHRoZSBTeW5jUG9pbnQgbG9jYXRpb24uXHJcbiAqICAgMy4gQSBzbmFwc2hvdCBOb2RlIHdpdGggY2FjaGVkIHNlcnZlciBkYXRhLCBpZiB3ZSBoYXZlIGl0LlxyXG4gKlxyXG4gKiAtIFdlIGNvbmNhdGVuYXRlIGFsbCBvZiB0aGUgZXZlbnRzIHJldHVybmVkIGJ5IGVhY2ggU3luY1BvaW50IGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBvcGVyYXRpb24pIHtcclxuICAgIHJldHVybiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uSGVscGVyXyhvcGVyYXRpb24sIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLCBcclxuICAgIC8qc2VydmVyQ2FjaGU9Ki8gbnVsbCwgd3JpdGVUcmVlQ2hpbGRXcml0ZXMoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIG5ld0VtcHR5UGF0aCgpKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZSBoZWxwZXIgZm9yIGFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzX1xyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseU9wZXJhdGlvbkhlbHBlcl8ob3BlcmF0aW9uLCBzeW5jUG9pbnRUcmVlLCBzZXJ2ZXJDYWNoZSwgd3JpdGVzQ2FjaGUpIHtcclxuICAgIGlmIChwYXRoSXNFbXB0eShvcGVyYXRpb24ucGF0aCkpIHtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyhvcGVyYXRpb24sIHN5bmNQb2ludFRyZWUsIHNlcnZlckNhY2hlLCB3cml0ZXNDYWNoZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBzeW5jUG9pbnQgPSBzeW5jUG9pbnRUcmVlLmdldChuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBjYWNoZWQgc2VydmVyIGRhdGEsIHNlZSBpZiB3ZSBjYW4gZ2V0IGl0IGZyb20gdGhpcyBTeW5jUG9pbnQuXHJcbiAgICAgICAgaWYgKHNlcnZlckNhY2hlID09IG51bGwgJiYgc3luY1BvaW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2VydmVyQ2FjaGUgPSBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHN5bmNQb2ludCwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAgICAgY29uc3QgY2hpbGROYW1lID0gcGF0aEdldEZyb250KG9wZXJhdGlvbi5wYXRoKTtcclxuICAgICAgICBjb25zdCBjaGlsZE9wZXJhdGlvbiA9IG9wZXJhdGlvbi5vcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IHN5bmNQb2ludFRyZWUuY2hpbGRyZW4uZ2V0KGNoaWxkTmFtZSk7XHJcbiAgICAgICAgaWYgKGNoaWxkVHJlZSAmJiBjaGlsZE9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGVcclxuICAgICAgICAgICAgICAgID8gc2VydmVyQ2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKVxyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFdyaXRlc0NhY2hlID0gd3JpdGVUcmVlUmVmQ2hpbGQod3JpdGVzQ2FjaGUsIGNoaWxkTmFtZSk7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBcHBseU9wZXJhdGlvbkhlbHBlcl8oY2hpbGRPcGVyYXRpb24sIGNoaWxkVHJlZSwgY2hpbGRTZXJ2ZXJDYWNoZSwgY2hpbGRXcml0ZXNDYWNoZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3luY1BvaW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1BvaW50QXBwbHlPcGVyYXRpb24oc3luY1BvaW50LCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnRzO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZWN1cnNpdmUgaGVscGVyIGZvciBhcHBseU9wZXJhdGlvblRvU3luY1BvaW50c19cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25EZXNjZW5kYW50c0hlbHBlcl8ob3BlcmF0aW9uLCBzeW5jUG9pbnRUcmVlLCBzZXJ2ZXJDYWNoZSwgd3JpdGVzQ2FjaGUpIHtcclxuICAgIGNvbnN0IHN5bmNQb2ludCA9IHN5bmNQb2ludFRyZWUuZ2V0KG5ld0VtcHR5UGF0aCgpKTtcclxuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgY2FjaGVkIHNlcnZlciBkYXRhLCBzZWUgaWYgd2UgY2FuIGdldCBpdCBmcm9tIHRoaXMgU3luY1BvaW50LlxyXG4gICAgaWYgKHNlcnZlckNhY2hlID09IG51bGwgJiYgc3luY1BvaW50ICE9IG51bGwpIHtcclxuICAgICAgICBzZXJ2ZXJDYWNoZSA9IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3luY1BvaW50LCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICBzeW5jUG9pbnRUcmVlLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkTmFtZSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRTZXJ2ZXJDYWNoZSA9IHNlcnZlckNhY2hlXHJcbiAgICAgICAgICAgID8gc2VydmVyQ2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKVxyXG4gICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgY2hpbGRXcml0ZXNDYWNoZSA9IHdyaXRlVHJlZVJlZkNoaWxkKHdyaXRlc0NhY2hlLCBjaGlsZE5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkT3BlcmF0aW9uID0gb3BlcmF0aW9uLm9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZSk7XHJcbiAgICAgICAgaWYgKGNoaWxkT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyhjaGlsZE9wZXJhdGlvbiwgY2hpbGRUcmVlLCBjaGlsZFNlcnZlckNhY2hlLCBjaGlsZFdyaXRlc0NhY2hlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAoc3luY1BvaW50KSB7XHJcbiAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jUG9pbnRBcHBseU9wZXJhdGlvbihzeW5jUG9pbnQsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZlbnRzO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNUcmVlQ3JlYXRlTGlzdGVuZXJGb3JWaWV3XyhzeW5jVHJlZSwgdmlldykge1xyXG4gICAgY29uc3QgcXVlcnkgPSB2aWV3LnF1ZXJ5O1xyXG4gICAgY29uc3QgdGFnID0gc3luY1RyZWVUYWdGb3JRdWVyeShzeW5jVHJlZSwgcXVlcnkpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoYXNoRm46ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSB2aWV3R2V0U2VydmVyQ2FjaGUodmlldykgfHwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5oYXNoKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkNvbXBsZXRlOiAoc3RhdHVzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseVRhZ2dlZExpc3RlbkNvbXBsZXRlKHN5bmNUcmVlLCBxdWVyeS5fcGF0aCwgdGFnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5TGlzdGVuQ29tcGxldGUoc3luY1RyZWUsIHF1ZXJ5Ll9wYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIGEgbGlzdGVuIGZhaWxlZCwga2lsbCBhbGwgb2YgdGhlIGxpc3RlbmVycyBoZXJlLCBub3QganVzdCB0aGUgb25lIHRoYXQgdHJpZ2dlcmVkIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBuZWVkIHRvIGJlIHNjb3BlZCB0byBqdXN0IHRoaXMgbGlzdGVuZXIgaWYgd2UgY2hhbmdlIHBlcm1pc3Npb25zIG9uIGZpbHRlcmVkIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGVycm9yRm9yU2VydmVyQ29kZShzdGF0dXMsIHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW5jVHJlZVJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHN5bmNUcmVlLCBxdWVyeSwgXHJcbiAgICAgICAgICAgICAgICAvKmV2ZW50UmVnaXN0cmF0aW9uKi8gbnVsbCwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJuIHRoZSB0YWcgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBxdWVyeS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlVGFnRm9yUXVlcnkoc3luY1RyZWUsIHF1ZXJ5KSB7XHJcbiAgICBjb25zdCBxdWVyeUtleSA9IHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhxdWVyeSk7XHJcbiAgICByZXR1cm4gc3luY1RyZWUucXVlcnlUb1RhZ01hcC5nZXQocXVlcnlLZXkpO1xyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiBhIHF1ZXJ5LCBjb21wdXRlcyBhIFwicXVlcnlLZXlcIiBzdWl0YWJsZSBmb3IgdXNlIGluIG91ciBxdWVyeVRvVGFnTWFwXy5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhxdWVyeSkge1xyXG4gICAgcmV0dXJuIHF1ZXJ5Ll9wYXRoLnRvU3RyaW5nKCkgKyAnJCcgKyBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIHF1ZXJ5IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gdGFnLCBpZiB3ZSBoYXZlIG9uZVxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVRdWVyeUtleUZvclRhZ18oc3luY1RyZWUsIHRhZykge1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlLnRhZ1RvUXVlcnlNYXAuZ2V0KHRhZyk7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGEgcXVlcnlLZXkgKGNyZWF0ZWQgYnkgbWFrZVF1ZXJ5S2V5KSwgcGFyc2UgaXQgYmFjayBpbnRvIGEgcGF0aCBhbmQgcXVlcnlJZC5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlUGFyc2VRdWVyeUtleV8ocXVlcnlLZXkpIHtcclxuICAgIGNvbnN0IHNwbGl0SW5kZXggPSBxdWVyeUtleS5pbmRleE9mKCckJyk7XHJcbiAgICBhc3NlcnQoc3BsaXRJbmRleCAhPT0gLTEgJiYgc3BsaXRJbmRleCA8IHF1ZXJ5S2V5Lmxlbmd0aCAtIDEsICdCYWQgcXVlcnlLZXkuJyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHF1ZXJ5SWQ6IHF1ZXJ5S2V5LnN1YnN0cihzcGxpdEluZGV4ICsgMSksXHJcbiAgICAgICAgcGF0aDogbmV3IFBhdGgocXVlcnlLZXkuc3Vic3RyKDAsIHNwbGl0SW5kZXgpKVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQSBoZWxwZXIgbWV0aG9kIHRvIGFwcGx5IHRhZ2dlZCBvcGVyYXRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5VGFnZ2VkT3BlcmF0aW9uXyhzeW5jVHJlZSwgcXVlcnlQYXRoLCBvcGVyYXRpb24pIHtcclxuICAgIGNvbnN0IHN5bmNQb2ludCA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmdldChxdWVyeVBhdGgpO1xyXG4gICAgYXNzZXJ0KHN5bmNQb2ludCwgXCJNaXNzaW5nIHN5bmMgcG9pbnQgZm9yIHF1ZXJ5IHRhZyB0aGF0IHdlJ3JlIHRyYWNraW5nXCIpO1xyXG4gICAgY29uc3Qgd3JpdGVzQ2FjaGUgPSB3cml0ZVRyZWVDaGlsZFdyaXRlcyhzeW5jVHJlZS5wZW5kaW5nV3JpdGVUcmVlXywgcXVlcnlQYXRoKTtcclxuICAgIHJldHVybiBzeW5jUG9pbnRBcHBseU9wZXJhdGlvbihzeW5jUG9pbnQsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIG51bGwpO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGNvbGxhcHNlcyBtdWx0aXBsZSB1bmZpbHRlcmVkIHZpZXdzIGludG8gYSBzaW5nbGUgdmlldywgc2luY2Ugd2Ugb25seSBuZWVkIGEgc2luZ2xlXHJcbiAqIGxpc3RlbmVyIGZvciB0aGVtLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVDb2xsZWN0RGlzdGluY3RWaWV3c0ZvclN1YlRyZWVfKHN1YnRyZWUpIHtcclxuICAgIHJldHVybiBzdWJ0cmVlLmZvbGQoKHJlbGF0aXZlUGF0aCwgbWF5YmVDaGlsZFN5bmNQb2ludCwgY2hpbGRNYXApID0+IHtcclxuICAgICAgICBpZiAobWF5YmVDaGlsZFN5bmNQb2ludCAmJiBzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcobWF5YmVDaGlsZFN5bmNQb2ludCkpIHtcclxuICAgICAgICAgICAgY29uc3QgY29tcGxldGVWaWV3ID0gc3luY1BvaW50R2V0Q29tcGxldGVWaWV3KG1heWJlQ2hpbGRTeW5jUG9pbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gW2NvbXBsZXRlVmlld107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBObyBjb21wbGV0ZSB2aWV3IGhlcmUsIGZsYXR0ZW4gYW55IGRlZXBlciBsaXN0ZW5zIGludG8gYW4gYXJyYXlcclxuICAgICAgICAgICAgbGV0IHZpZXdzID0gW107XHJcbiAgICAgICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50KSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3cyA9IHN5bmNQb2ludEdldFF1ZXJ5Vmlld3MobWF5YmVDaGlsZFN5bmNQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWFjaChjaGlsZE1hcCwgKF9rZXksIGNoaWxkVmlld3MpID0+IHtcclxuICAgICAgICAgICAgICAgIHZpZXdzID0gdmlld3MuY29uY2F0KGNoaWxkVmlld3MpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXdzO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBOb3JtYWxpemVzIGEgcXVlcnkgdG8gYSBxdWVyeSB3ZSBzZW5kIHRoZSBzZXJ2ZXIgZm9yIGxpc3RlbmluZ1xyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCBxdWVyeVxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVRdWVyeUZvckxpc3RlbmluZ18ocXVlcnkpIHtcclxuICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkgJiYgIXF1ZXJ5Ll9xdWVyeVBhcmFtcy5pc0RlZmF1bHQoKSkge1xyXG4gICAgICAgIC8vIFdlIHRyZWF0IHF1ZXJpZXMgdGhhdCBsb2FkIGFsbCBkYXRhIGFzIGRlZmF1bHQgcXVlcmllc1xyXG4gICAgICAgIC8vIENhc3QgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgcmVmKCkgdGVjaG5pY2FsbHkgcmV0dXJucyBGaXJlYmFzZSB3aGljaCBpcyBhY3R1YWxseSBmYi5hcGkuRmlyZWJhc2Ugd2hpY2ggaW5oZXJpdHNcclxuICAgICAgICAvLyBmcm9tIFF1ZXJ5XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoc3luY1RyZWVHZXRSZWZlcmVuY2VDb25zdHJ1Y3RvcigpKShxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHN5bmNUcmVlUmVtb3ZlVGFnc18oc3luY1RyZWUsIHF1ZXJpZXMpIHtcclxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcXVlcmllcy5sZW5ndGg7ICsraikge1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZWRRdWVyeSA9IHF1ZXJpZXNbal07XHJcbiAgICAgICAgaWYgKCFyZW1vdmVkUXVlcnkuX3F1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBoYXZlIGEgdGFnIGZvciB0aGlzXHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRRdWVyeUtleSA9IHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhyZW1vdmVkUXVlcnkpO1xyXG4gICAgICAgICAgICBjb25zdCByZW1vdmVkUXVlcnlUYWcgPSBzeW5jVHJlZS5xdWVyeVRvVGFnTWFwLmdldChyZW1vdmVkUXVlcnlLZXkpO1xyXG4gICAgICAgICAgICBzeW5jVHJlZS5xdWVyeVRvVGFnTWFwLmRlbGV0ZShyZW1vdmVkUXVlcnlLZXkpO1xyXG4gICAgICAgICAgICBzeW5jVHJlZS50YWdUb1F1ZXJ5TWFwLmRlbGV0ZShyZW1vdmVkUXVlcnlUYWcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogU3RhdGljIGFjY2Vzc29yIGZvciBxdWVyeSB0YWdzLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVHZXROZXh0UXVlcnlUYWdfKCkge1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlTmV4dFF1ZXJ5VGFnXysrO1xyXG59XHJcbi8qKlxyXG4gKiBGb3IgYSBnaXZlbiBuZXcgbGlzdGVuLCBtYW5hZ2UgdGhlIGRlLWR1cGxpY2F0aW9uIG9mIG91dHN0YW5kaW5nIHN1YnNjcmlwdGlvbnMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoaXMgbWV0aG9kIGNhbiByZXR1cm4gZXZlbnRzIHRvIHN1cHBvcnQgc3luY2hyb25vdXMgZGF0YSBzb3VyY2VzXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZVNldHVwTGlzdGVuZXJfKHN5bmNUcmVlLCBxdWVyeSwgdmlldykge1xyXG4gICAgY29uc3QgcGF0aCA9IHF1ZXJ5Ll9wYXRoO1xyXG4gICAgY29uc3QgdGFnID0gc3luY1RyZWVUYWdGb3JRdWVyeShzeW5jVHJlZSwgcXVlcnkpO1xyXG4gICAgY29uc3QgbGlzdGVuZXIgPSBzeW5jVHJlZUNyZWF0ZUxpc3RlbmVyRm9yVmlld18oc3luY1RyZWUsIHZpZXcpO1xyXG4gICAgY29uc3QgZXZlbnRzID0gc3luY1RyZWUubGlzdGVuUHJvdmlkZXJfLnN0YXJ0TGlzdGVuaW5nKHN5bmNUcmVlUXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5KSwgdGFnLCBsaXN0ZW5lci5oYXNoRm4sIGxpc3RlbmVyLm9uQ29tcGxldGUpO1xyXG4gICAgY29uc3Qgc3VidHJlZSA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnN1YnRyZWUocGF0aCk7XHJcbiAgICAvLyBUaGUgcm9vdCBvZiB0aGlzIHN1YnRyZWUgaGFzIG91ciBxdWVyeS4gV2UncmUgaGVyZSBiZWNhdXNlIHdlIGRlZmluaXRlbHkgbmVlZCB0byBzZW5kIGEgbGlzdGVuIGZvciB0aGF0LCBidXQgd2VcclxuICAgIC8vIG1heSBuZWVkIHRvIHNoYWRvdyBvdGhlciBsaXN0ZW5zIGFzIHdlbGwuXHJcbiAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgYXNzZXJ0KCFzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcoc3VidHJlZS52YWx1ZSksIFwiSWYgd2UncmUgYWRkaW5nIGEgcXVlcnksIGl0IHNob3VsZG4ndCBiZSBzaGFkb3dlZFwiKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFNoYWRvdyBldmVyeXRoaW5nIGF0IG9yIGJlbG93IHRoaXMgbG9jYXRpb24sIHRoaXMgaXMgYSBkZWZhdWx0IGxpc3RlbmVyLlxyXG4gICAgICAgIGNvbnN0IHF1ZXJpZXNUb1N0b3AgPSBzdWJ0cmVlLmZvbGQoKHJlbGF0aXZlUGF0aCwgbWF5YmVDaGlsZFN5bmNQb2ludCwgY2hpbGRNYXApID0+IHtcclxuICAgICAgICAgICAgaWYgKCFwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpICYmXHJcbiAgICAgICAgICAgICAgICBtYXliZUNoaWxkU3luY1BvaW50ICYmXHJcbiAgICAgICAgICAgICAgICBzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcobWF5YmVDaGlsZFN5bmNQb2ludCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbc3luY1BvaW50R2V0Q29tcGxldGVWaWV3KG1heWJlQ2hpbGRTeW5jUG9pbnQpLnF1ZXJ5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIGRlZmF1bHQgbGlzdGVuZXIgaGVyZSwgZmxhdHRlbiBhbnkgZGVlcGVyIHF1ZXJpZXMgaW50byBhbiBhcnJheVxyXG4gICAgICAgICAgICAgICAgbGV0IHF1ZXJpZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcmllcyA9IHF1ZXJpZXMuY29uY2F0KHN5bmNQb2ludEdldFF1ZXJ5Vmlld3MobWF5YmVDaGlsZFN5bmNQb2ludCkubWFwKHZpZXcgPT4gdmlldy5xdWVyeSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWFjaChjaGlsZE1hcCwgKF9rZXksIGNoaWxkUXVlcmllcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJpZXMgPSBxdWVyaWVzLmNvbmNhdChjaGlsZFF1ZXJpZXMpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVlcmllcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVlcmllc1RvU3RvcC5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBxdWVyeVRvU3RvcCA9IHF1ZXJpZXNUb1N0b3BbaV07XHJcbiAgICAgICAgICAgIHN5bmNUcmVlLmxpc3RlblByb3ZpZGVyXy5zdG9wTGlzdGVuaW5nKHN5bmNUcmVlUXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5VG9TdG9wKSwgc3luY1RyZWVUYWdGb3JRdWVyeShzeW5jVHJlZSwgcXVlcnlUb1N0b3ApKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZlbnRzO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEV4aXN0aW5nVmFsdWVQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlXykge1xyXG4gICAgICAgIHRoaXMubm9kZV8gPSBub2RlXztcclxuICAgIH1cclxuICAgIGdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5ub2RlXy5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRXhpc3RpbmdWYWx1ZVByb3ZpZGVyKGNoaWxkKTtcclxuICAgIH1cclxuICAgIG5vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZV87XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRGVmZXJyZWRWYWx1ZVByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHN5bmNUcmVlLCBwYXRoKSB7XHJcbiAgICAgICAgdGhpcy5zeW5jVHJlZV8gPSBzeW5jVHJlZTtcclxuICAgICAgICB0aGlzLnBhdGhfID0gcGF0aDtcclxuICAgIH1cclxuICAgIGdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGhDaGlsZCh0aGlzLnBhdGhfLCBjaGlsZE5hbWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGVmZXJyZWRWYWx1ZVByb3ZpZGVyKHRoaXMuc3luY1RyZWVfLCBjaGlsZFBhdGgpO1xyXG4gICAgfVxyXG4gICAgbm9kZSgpIHtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHRoaXMuc3luY1RyZWVfLCB0aGlzLnBhdGhfKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2VuZXJhdGUgcGxhY2Vob2xkZXJzIGZvciBkZWZlcnJlZCB2YWx1ZXMuXHJcbiAqL1xyXG5jb25zdCBnZW5lcmF0ZVdpdGhWYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7XHJcbiAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwge307XHJcbiAgICB2YWx1ZXNbJ3RpbWVzdGFtcCddID0gdmFsdWVzWyd0aW1lc3RhbXAnXSB8fCBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIHJldHVybiB2YWx1ZXM7XHJcbn07XHJcbi8qKlxyXG4gKiBWYWx1ZSB0byB1c2Ugd2hlbiBmaXJpbmcgbG9jYWwgZXZlbnRzLiBXaGVuIHdyaXRpbmcgc2VydmVyIHZhbHVlcywgZmlyZVxyXG4gKiBsb2NhbCBldmVudHMgd2l0aCBhbiBhcHByb3hpbWF0ZSB2YWx1ZSwgb3RoZXJ3aXNlIHJldHVybiB2YWx1ZSBhcy1pcy5cclxuICovXHJcbmNvbnN0IHJlc29sdmVEZWZlcnJlZExlYWZWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZXhpc3RpbmdWYWwsIHNlcnZlclZhbHVlcykge1xyXG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0KCcuc3YnIGluIHZhbHVlLCAnVW5leHBlY3RlZCBsZWFmIG5vZGUgb3IgcHJpb3JpdHkgY29udGVudHMnKTtcclxuICAgIGlmICh0eXBlb2YgdmFsdWVbJy5zdiddID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlU2NhbGFyRGVmZXJyZWRWYWx1ZSh2YWx1ZVsnLnN2J10sIGV4aXN0aW5nVmFsLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlWycuc3YnXSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZUNvbXBsZXhEZWZlcnJlZFZhbHVlKHZhbHVlWycuc3YnXSwgZXhpc3RpbmdWYWwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAnVW5leHBlY3RlZCBzZXJ2ZXIgdmFsdWU6ICcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgMikpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCByZXNvbHZlU2NhbGFyRGVmZXJyZWRWYWx1ZSA9IGZ1bmN0aW9uIChvcCwgZXhpc3RpbmcsIHNlcnZlclZhbHVlcykge1xyXG4gICAgc3dpdGNoIChvcCkge1xyXG4gICAgICAgIGNhc2UgJ3RpbWVzdGFtcCc6XHJcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJWYWx1ZXNbJ3RpbWVzdGFtcCddO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgJ1VuZXhwZWN0ZWQgc2VydmVyIHZhbHVlOiAnICsgb3ApO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCByZXNvbHZlQ29tcGxleERlZmVycmVkVmFsdWUgPSBmdW5jdGlvbiAob3AsIGV4aXN0aW5nLCB1bnVzZWQpIHtcclxuICAgIGlmICghb3AuaGFzT3duUHJvcGVydHkoJ2luY3JlbWVudCcpKSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAnVW5leHBlY3RlZCBzZXJ2ZXIgdmFsdWU6ICcgKyBKU09OLnN0cmluZ2lmeShvcCwgbnVsbCwgMikpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVsdGEgPSBvcFsnaW5jcmVtZW50J107XHJcbiAgICBpZiAodHlwZW9mIGRlbHRhICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgJ1VuZXhwZWN0ZWQgaW5jcmVtZW50IHZhbHVlOiAnICsgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZXhpc3RpbmdOb2RlID0gZXhpc3Rpbmcubm9kZSgpO1xyXG4gICAgYXNzZXJ0KGV4aXN0aW5nTm9kZSAhPT0gbnVsbCAmJiB0eXBlb2YgZXhpc3RpbmdOb2RlICE9PSAndW5kZWZpbmVkJywgJ0V4cGVjdGVkIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFIGZvciBudWxscycpO1xyXG4gICAgLy8gSW5jcmVtZW50aW5nIGEgbm9uLW51bWJlciBzZXRzIHRoZSB2YWx1ZSB0byB0aGUgaW5jcmVtZW50ZWQgYW1vdW50XHJcbiAgICBpZiAoIWV4aXN0aW5nTm9kZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICByZXR1cm4gZGVsdGE7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsZWFmID0gZXhpc3RpbmdOb2RlO1xyXG4gICAgY29uc3QgZXhpc3RpbmdWYWwgPSBsZWFmLmdldFZhbHVlKCk7XHJcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nVmFsICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiBkZWx0YTtcclxuICAgIH1cclxuICAgIC8vIE5vIG5lZWQgdG8gZG8gb3Zlci91bmRlcmZsb3cgYXJpdGhtZXRpYyBoZXJlIGJlY2F1c2UgSlMgb25seSBoYW5kbGVzIGZsb2F0cyB1bmRlciB0aGUgY292ZXJzXHJcbiAgICByZXR1cm4gZXhpc3RpbmdWYWwgKyBkZWx0YTtcclxufTtcclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZWx5IHJlcGxhY2UgYWxsIGRlZmVycmVkIHZhbHVlcyBhbmQgcHJpb3JpdGllcyBpbiB0aGUgdHJlZSB3aXRoIHRoZVxyXG4gKiBzcGVjaWZpZWQgZ2VuZXJhdGVkIHJlcGxhY2VtZW50IHZhbHVlcy5cclxuICogQHBhcmFtIHBhdGggLSBwYXRoIHRvIHdoaWNoIHdyaXRlIGlzIHJlbGF0aXZlXHJcbiAqIEBwYXJhbSBub2RlIC0gbmV3IGRhdGEgd3JpdHRlbiBhdCBwYXRoXHJcbiAqIEBwYXJhbSBzeW5jVHJlZSAtIGN1cnJlbnQgZGF0YVxyXG4gKi9cclxuY29uc3QgcmVzb2x2ZURlZmVycmVkVmFsdWVUcmVlID0gZnVuY3Rpb24gKHBhdGgsIG5vZGUsIHN5bmNUcmVlLCBzZXJ2ZXJWYWx1ZXMpIHtcclxuICAgIHJldHVybiByZXNvbHZlRGVmZXJyZWRWYWx1ZShub2RlLCBuZXcgRGVmZXJyZWRWYWx1ZVByb3ZpZGVyKHN5bmNUcmVlLCBwYXRoKSwgc2VydmVyVmFsdWVzKTtcclxufTtcclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZWx5IHJlcGxhY2UgYWxsIGRlZmVycmVkIHZhbHVlcyBhbmQgcHJpb3JpdGllcyBpbiB0aGUgbm9kZSB3aXRoIHRoZVxyXG4gKiBzcGVjaWZpZWQgZ2VuZXJhdGVkIHJlcGxhY2VtZW50IHZhbHVlcy4gIElmIHRoZXJlIGFyZSBubyBzZXJ2ZXIgdmFsdWVzIGluIHRoZSBub2RlLFxyXG4gKiBpdCdsbCBiZSByZXR1cm5lZCBhcy1pcy5cclxuICovXHJcbmNvbnN0IHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QgPSBmdW5jdGlvbiAobm9kZSwgZXhpc3RpbmcsIHNlcnZlclZhbHVlcykge1xyXG4gICAgcmV0dXJuIHJlc29sdmVEZWZlcnJlZFZhbHVlKG5vZGUsIG5ldyBFeGlzdGluZ1ZhbHVlUHJvdmlkZXIoZXhpc3RpbmcpLCBzZXJ2ZXJWYWx1ZXMpO1xyXG59O1xyXG5mdW5jdGlvbiByZXNvbHZlRGVmZXJyZWRWYWx1ZShub2RlLCBleGlzdGluZ1ZhbCwgc2VydmVyVmFsdWVzKSB7XHJcbiAgICBjb25zdCByYXdQcmkgPSBub2RlLmdldFByaW9yaXR5KCkudmFsKCk7XHJcbiAgICBjb25zdCBwcmlvcml0eSA9IHJlc29sdmVEZWZlcnJlZExlYWZWYWx1ZShyYXdQcmksIGV4aXN0aW5nVmFsLmdldEltbWVkaWF0ZUNoaWxkKCcucHJpb3JpdHknKSwgc2VydmVyVmFsdWVzKTtcclxuICAgIGxldCBuZXdOb2RlO1xyXG4gICAgaWYgKG5vZGUuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgY29uc3QgbGVhZk5vZGUgPSBub2RlO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmVzb2x2ZURlZmVycmVkTGVhZlZhbHVlKGxlYWZOb2RlLmdldFZhbHVlKCksIGV4aXN0aW5nVmFsLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbGVhZk5vZGUuZ2V0VmFsdWUoKSB8fFxyXG4gICAgICAgICAgICBwcmlvcml0eSAhPT0gbGVhZk5vZGUuZ2V0UHJpb3JpdHkoKS52YWwoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExlYWZOb2RlKHZhbHVlLCBub2RlRnJvbUpTT04ocHJpb3JpdHkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgbmV3Tm9kZSA9IGNoaWxkcmVuTm9kZTtcclxuICAgICAgICBpZiAocHJpb3JpdHkgIT09IGNoaWxkcmVuTm9kZS5nZXRQcmlvcml0eSgpLnZhbCgpKSB7XHJcbiAgICAgICAgICAgIG5ld05vZGUgPSBuZXdOb2RlLnVwZGF0ZVByaW9yaXR5KG5ldyBMZWFmTm9kZShwcmlvcml0eSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGlsZHJlbk5vZGUuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoY2hpbGROYW1lLCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGROb2RlID0gcmVzb2x2ZURlZmVycmVkVmFsdWUoY2hpbGROb2RlLCBleGlzdGluZ1ZhbC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgICAgICAgICBpZiAobmV3Q2hpbGROb2RlICE9PSBjaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIG5ld05vZGUgPSBuZXdOb2RlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGxpZ2h0LXdlaWdodCB0cmVlLCB0cmF2ZXJzYWJsZSBieSBwYXRoLiAgTm9kZXMgY2FuIGhhdmUgYm90aCB2YWx1ZXMgYW5kIGNoaWxkcmVuLlxyXG4gKiBOb2RlcyBhcmUgbm90IGVudW1lcmF0ZWQgKGJ5IGZvckVhY2hDaGlsZCkgdW5sZXNzIHRoZXkgaGF2ZSBhIHZhbHVlIG9yIG5vbi1lbXB0eVxyXG4gKiBjaGlsZHJlbi5cclxuICovXHJcbmNsYXNzIFRyZWUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSAtIE9wdGlvbmFsIG5hbWUgb2YgdGhlIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0gcGFyZW50IC0gT3B0aW9uYWwgcGFyZW50IG5vZGUuXHJcbiAgICAgKiBAcGFyYW0gbm9kZSAtIE9wdGlvbmFsIG5vZGUgdG8gd3JhcC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmFtZSA9ICcnLCBwYXJlbnQgPSBudWxsLCBub2RlID0geyBjaGlsZHJlbjoge30sIGNoaWxkQ291bnQ6IDAgfSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHN1Yi1UcmVlIGZvciB0aGUgZ2l2ZW4gcGF0aC5cclxuICpcclxuICogQHBhcmFtIHBhdGhPYmogLSBQYXRoIHRvIGxvb2sgdXAuXHJcbiAqIEByZXR1cm5zIFRyZWUgZm9yIHBhdGguXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlU3ViVHJlZSh0cmVlLCBwYXRoT2JqKSB7XHJcbiAgICAvLyBUT0RPOiBSZXF1aXJlIHBhdGhPYmogdG8gYmUgUGF0aD9cclxuICAgIGxldCBwYXRoID0gcGF0aE9iaiBpbnN0YW5jZW9mIFBhdGggPyBwYXRoT2JqIDogbmV3IFBhdGgocGF0aE9iaik7XHJcbiAgICBsZXQgY2hpbGQgPSB0cmVlLCBuZXh0ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgd2hpbGUgKG5leHQgIT09IG51bGwpIHtcclxuICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBzYWZlR2V0KGNoaWxkLm5vZGUuY2hpbGRyZW4sIG5leHQpIHx8IHtcclxuICAgICAgICAgICAgY2hpbGRyZW46IHt9LFxyXG4gICAgICAgICAgICBjaGlsZENvdW50OiAwXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjaGlsZCA9IG5ldyBUcmVlKG5leHQsIGNoaWxkLCBjaGlsZE5vZGUpO1xyXG4gICAgICAgIHBhdGggPSBwYXRoUG9wRnJvbnQocGF0aCk7XHJcbiAgICAgICAgbmV4dCA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjaGlsZDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0cmVlIG5vZGUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSBkYXRhIG9yIG51bGwgaWYgbm8gZGF0YSBleGlzdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlR2V0VmFsdWUodHJlZSkge1xyXG4gICAgcmV0dXJuIHRyZWUubm9kZS52YWx1ZTtcclxufVxyXG4vKipcclxuICogU2V0cyBkYXRhIHRvIHRoaXMgdHJlZSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBzZXQuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlU2V0VmFsdWUodHJlZSwgdmFsdWUpIHtcclxuICAgIHRyZWUubm9kZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgdHJlZVVwZGF0ZVBhcmVudHModHJlZSk7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHRyZWUgaGFzIGFueSBjaGlsZHJlbi5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVIYXNDaGlsZHJlbih0cmVlKSB7XHJcbiAgICByZXR1cm4gdHJlZS5ub2RlLmNoaWxkQ291bnQgPiAwO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBXaGV0aGUgcnRoZSB0cmVlIGlzIGVtcHR5IChubyB2YWx1ZSBvciBjaGlsZHJlbikuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlSXNFbXB0eSh0cmVlKSB7XHJcbiAgICByZXR1cm4gdHJlZUdldFZhbHVlKHRyZWUpID09PSB1bmRlZmluZWQgJiYgIXRyZWVIYXNDaGlsZHJlbih0cmVlKTtcclxufVxyXG4vKipcclxuICogQ2FsbHMgYWN0aW9uIGZvciBlYWNoIGNoaWxkIG9mIHRoaXMgdHJlZSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gYWN0aW9uIC0gQWN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBjaGlsZC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVGb3JFYWNoQ2hpbGQodHJlZSwgYWN0aW9uKSB7XHJcbiAgICBlYWNoKHRyZWUubm9kZS5jaGlsZHJlbiwgKGNoaWxkLCBjaGlsZFRyZWUpID0+IHtcclxuICAgICAgICBhY3Rpb24obmV3IFRyZWUoY2hpbGQsIHRyZWUsIGNoaWxkVHJlZSkpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIERvZXMgYSBkZXB0aC1maXJzdCB0cmF2ZXJzYWwgb2YgdGhpcyBub2RlJ3MgZGVzY2VuZGFudHMsIGNhbGxpbmcgYWN0aW9uIGZvciBlYWNoIG9uZS5cclxuICpcclxuICogQHBhcmFtIGFjdGlvbiAtIEFjdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2ggY2hpbGQuXHJcbiAqIEBwYXJhbSBpbmNsdWRlU2VsZiAtIFdoZXRoZXIgdG8gY2FsbCBhY3Rpb24gb24gdGhpcyBub2RlIGFzIHdlbGwuIERlZmF1bHRzIHRvXHJcbiAqICAgZmFsc2UuXHJcbiAqIEBwYXJhbSBjaGlsZHJlbkZpcnN0IC0gV2hldGhlciB0byBjYWxsIGFjdGlvbiBvbiBjaGlsZHJlbiBiZWZvcmUgY2FsbGluZyBpdCBvblxyXG4gKiAgIHBhcmVudC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVGb3JFYWNoRGVzY2VuZGFudCh0cmVlLCBhY3Rpb24sIGluY2x1ZGVTZWxmLCBjaGlsZHJlbkZpcnN0KSB7XHJcbiAgICBpZiAoaW5jbHVkZVNlbGYgJiYgIWNoaWxkcmVuRmlyc3QpIHtcclxuICAgICAgICBhY3Rpb24odHJlZSk7XHJcbiAgICB9XHJcbiAgICB0cmVlRm9yRWFjaENoaWxkKHRyZWUsIGNoaWxkID0+IHtcclxuICAgICAgICB0cmVlRm9yRWFjaERlc2NlbmRhbnQoY2hpbGQsIGFjdGlvbiwgdHJ1ZSwgY2hpbGRyZW5GaXJzdCk7XHJcbiAgICB9KTtcclxuICAgIGlmIChpbmNsdWRlU2VsZiAmJiBjaGlsZHJlbkZpcnN0KSB7XHJcbiAgICAgICAgYWN0aW9uKHRyZWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYWxscyBhY3Rpb24gb24gZWFjaCBhbmNlc3RvciBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gYWN0aW9uIC0gQWN0aW9uIHRvIGJlIGNhbGxlZCBvbiBlYWNoIHBhcmVudDsgcmV0dXJuXHJcbiAqICAgdHJ1ZSB0byBhYm9ydC5cclxuICogQHBhcmFtIGluY2x1ZGVTZWxmIC0gV2hldGhlciB0byBjYWxsIGFjdGlvbiBvbiB0aGlzIG5vZGUgYXMgd2VsbC5cclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgYWN0aW9uIGNhbGxiYWNrIHJldHVybmVkIHRydWUuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlRm9yRWFjaEFuY2VzdG9yKHRyZWUsIGFjdGlvbiwgaW5jbHVkZVNlbGYpIHtcclxuICAgIGxldCBub2RlID0gaW5jbHVkZVNlbGYgPyB0cmVlIDogdHJlZS5wYXJlbnQ7XHJcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChhY3Rpb24obm9kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgVGhlIHBhdGggb2YgdGhpcyB0cmVlIG5vZGUsIGFzIGEgUGF0aC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVHZXRQYXRoKHRyZWUpIHtcclxuICAgIHJldHVybiBuZXcgUGF0aCh0cmVlLnBhcmVudCA9PT0gbnVsbFxyXG4gICAgICAgID8gdHJlZS5uYW1lXHJcbiAgICAgICAgOiB0cmVlR2V0UGF0aCh0cmVlLnBhcmVudCkgKyAnLycgKyB0cmVlLm5hbWUpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGRzIG9yIHJlbW92ZXMgdGhpcyBjaGlsZCBmcm9tIGl0cyBwYXJlbnQgYmFzZWQgb24gd2hldGhlciBpdCdzIGVtcHR5IG9yIG5vdC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVVcGRhdGVQYXJlbnRzKHRyZWUpIHtcclxuICAgIGlmICh0cmVlLnBhcmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHRyZWVVcGRhdGVDaGlsZCh0cmVlLnBhcmVudCwgdHJlZS5uYW1lLCB0cmVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWRkcyBvciByZW1vdmVzIHRoZSBwYXNzZWQgY2hpbGQgdG8gdGhpcyB0cmVlIG5vZGUsIGRlcGVuZGluZyBvbiB3aGV0aGVyIGl0J3MgZW1wdHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBjaGlsZE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY2hpbGQgdG8gdXBkYXRlLlxyXG4gKiBAcGFyYW0gY2hpbGQgLSBUaGUgY2hpbGQgdG8gdXBkYXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZVVwZGF0ZUNoaWxkKHRyZWUsIGNoaWxkTmFtZSwgY2hpbGQpIHtcclxuICAgIGNvbnN0IGNoaWxkRW1wdHkgPSB0cmVlSXNFbXB0eShjaGlsZCk7XHJcbiAgICBjb25zdCBjaGlsZEV4aXN0cyA9IGNvbnRhaW5zKHRyZWUubm9kZS5jaGlsZHJlbiwgY2hpbGROYW1lKTtcclxuICAgIGlmIChjaGlsZEVtcHR5ICYmIGNoaWxkRXhpc3RzKSB7XHJcbiAgICAgICAgZGVsZXRlIHRyZWUubm9kZS5jaGlsZHJlbltjaGlsZE5hbWVdO1xyXG4gICAgICAgIHRyZWUubm9kZS5jaGlsZENvdW50LS07XHJcbiAgICAgICAgdHJlZVVwZGF0ZVBhcmVudHModHJlZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghY2hpbGRFbXB0eSAmJiAhY2hpbGRFeGlzdHMpIHtcclxuICAgICAgICB0cmVlLm5vZGUuY2hpbGRyZW5bY2hpbGROYW1lXSA9IGNoaWxkLm5vZGU7XHJcbiAgICAgICAgdHJlZS5ub2RlLmNoaWxkQ291bnQrKztcclxuICAgICAgICB0cmVlVXBkYXRlUGFyZW50cyh0cmVlKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVHJ1ZSBmb3IgaW52YWxpZCBGaXJlYmFzZSBrZXlzXHJcbiAqL1xyXG5jb25zdCBJTlZBTElEX0tFWV9SRUdFWF8gPSAvW1xcW1xcXS4jJFxcL1xcdTAwMDAtXFx1MDAxRlxcdTAwN0ZdLztcclxuLyoqXHJcbiAqIFRydWUgZm9yIGludmFsaWQgRmlyZWJhc2UgcGF0aHMuXHJcbiAqIEFsbG93cyAnLycgaW4gcGF0aHMuXHJcbiAqL1xyXG5jb25zdCBJTlZBTElEX1BBVEhfUkVHRVhfID0gL1tcXFtcXF0uIyRcXHUwMDAwLVxcdTAwMUZcXHUwMDdGXS87XHJcbi8qKlxyXG4gKiBNYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIGFsbG93IGluIGxlYWYgdmFsdWVcclxuICovXHJcbmNvbnN0IE1BWF9MRUFGX1NJWkVfID0gMTAgKiAxMDI0ICogMTAyNDtcclxuY29uc3QgaXNWYWxpZEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHJldHVybiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5Lmxlbmd0aCAhPT0gMCAmJiAhSU5WQUxJRF9LRVlfUkVHRVhfLnRlc3Qoa2V5KSk7XHJcbn07XHJcbmNvbnN0IGlzVmFsaWRQYXRoU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcclxuICAgIHJldHVybiAodHlwZW9mIHBhdGhTdHJpbmcgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgcGF0aFN0cmluZy5sZW5ndGggIT09IDAgJiZcclxuICAgICAgICAhSU5WQUxJRF9QQVRIX1JFR0VYXy50ZXN0KHBhdGhTdHJpbmcpKTtcclxufTtcclxuY29uc3QgaXNWYWxpZFJvb3RQYXRoU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcclxuICAgIGlmIChwYXRoU3RyaW5nKSB7XHJcbiAgICAgICAgLy8gQWxsb3cgJy8uaW5mby8nIGF0IHRoZSBiZWdpbm5pbmcuXHJcbiAgICAgICAgcGF0aFN0cmluZyA9IHBhdGhTdHJpbmcucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sICcvJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNWYWxpZFBhdGhTdHJpbmcocGF0aFN0cmluZyk7XHJcbn07XHJcbmNvbnN0IGlzVmFsaWRQcmlvcml0eSA9IGZ1bmN0aW9uIChwcmlvcml0eSkge1xyXG4gICAgcmV0dXJuIChwcmlvcml0eSA9PT0gbnVsbCB8fFxyXG4gICAgICAgIHR5cGVvZiBwcmlvcml0eSA9PT0gJ3N0cmluZycgfHxcclxuICAgICAgICAodHlwZW9mIHByaW9yaXR5ID09PSAnbnVtYmVyJyAmJiAhaXNJbnZhbGlkSlNPTk51bWJlcihwcmlvcml0eSkpIHx8XHJcbiAgICAgICAgKHByaW9yaXR5ICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBwcmlvcml0eSA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgY29udGFpbnMocHJpb3JpdHksICcuc3YnKSkpO1xyXG59O1xyXG4vKipcclxuICogUHJlLXZhbGlkYXRlIGEgZGF0dW0gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIEZpcmViYXNlIGZ1bmN0aW9uLlxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcgPSBmdW5jdGlvbiAoZm5OYW1lLCB2YWx1ZSwgcGF0aCwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVGaXJlYmFzZURhdGEoZXJyb3JQcmVmaXgoZm5OYW1lLCAndmFsdWUnKSwgdmFsdWUsIHBhdGgpO1xyXG59O1xyXG4vKipcclxuICogVmFsaWRhdGUgYSBkYXRhIG9iamVjdCBjbGllbnQtc2lkZSBiZWZvcmUgc2VuZGluZyB0byBzZXJ2ZXIuXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZUZpcmViYXNlRGF0YSA9IGZ1bmN0aW9uIChlcnJvclByZWZpeCwgZGF0YSwgcGF0aF8pIHtcclxuICAgIGNvbnN0IHBhdGggPSBwYXRoXyBpbnN0YW5jZW9mIFBhdGggPyBuZXcgVmFsaWRhdGlvblBhdGgocGF0aF8sIGVycm9yUHJlZml4KSA6IHBhdGhfO1xyXG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArICdjb250YWlucyB1bmRlZmluZWQgJyArIHZhbGlkYXRpb25QYXRoVG9FcnJvclN0cmluZyhwYXRoKSk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAnY29udGFpbnMgYSBmdW5jdGlvbiAnICtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHBhdGgpICtcclxuICAgICAgICAgICAgJyB3aXRoIGNvbnRlbnRzID0gJyArXHJcbiAgICAgICAgICAgIGRhdGEudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNJbnZhbGlkSlNPTk51bWJlcihkYXRhKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXHJcbiAgICAgICAgICAgICdjb250YWlucyAnICtcclxuICAgICAgICAgICAgZGF0YS50b1N0cmluZygpICtcclxuICAgICAgICAgICAgJyAnICtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHBhdGgpKTtcclxuICAgIH1cclxuICAgIC8vIENoZWNrIG1heCBsZWFmIHNpemUsIGJ1dCB0cnkgdG8gYXZvaWQgdGhlIHV0ZjggY29udmVyc2lvbiBpZiB3ZSBjYW4uXHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgZGF0YS5sZW5ndGggPiBNQVhfTEVBRl9TSVpFXyAvIDMgJiZcclxuICAgICAgICBzdHJpbmdMZW5ndGgoZGF0YSkgPiBNQVhfTEVBRl9TSVpFXykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXHJcbiAgICAgICAgICAgICdjb250YWlucyBhIHN0cmluZyBncmVhdGVyIHRoYW4gJyArXHJcbiAgICAgICAgICAgIE1BWF9MRUFGX1NJWkVfICtcclxuICAgICAgICAgICAgJyB1dGY4IGJ5dGVzICcgK1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmcocGF0aCkgK1xyXG4gICAgICAgICAgICBcIiAoJ1wiICtcclxuICAgICAgICAgICAgZGF0YS5zdWJzdHJpbmcoMCwgNTApICtcclxuICAgICAgICAgICAgXCIuLi4nKVwiKTtcclxuICAgIH1cclxuICAgIC8vIFRPRE8gPSBQZXJmID0gQ29uc2lkZXIgY29tYmluaW5nIHRoZSByZWN1cnNpdmUgdmFsaWRhdGlvbiBvZiBrZXlzIGludG8gTm9kZUZyb21KU09OXHJcbiAgICAvLyB0byBzYXZlIGV4dHJhIHdhbGtpbmcgb2YgbGFyZ2Ugb2JqZWN0cy5cclxuICAgIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGxldCBoYXNEb3RWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBoYXNBY3R1YWxDaGlsZCA9IGZhbHNlO1xyXG4gICAgICAgIGVhY2goZGF0YSwgKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJy52YWx1ZScpIHtcclxuICAgICAgICAgICAgICAgIGhhc0RvdFZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICcucHJpb3JpdHknICYmIGtleSAhPT0gJy5zdicpIHtcclxuICAgICAgICAgICAgICAgIGhhc0FjdHVhbENoaWxkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEtleShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyBjb250YWlucyBhbiBpbnZhbGlkIGtleSAoJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcpICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmcocGF0aCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnLiAgS2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhQdXNoKHBhdGgsIGtleSk7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKGVycm9yUHJlZml4LCB2YWx1ZSwgcGF0aCk7XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25QYXRoUG9wKHBhdGgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChoYXNEb3RWYWx1ZSAmJiBoYXNBY3R1YWxDaGlsZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAgICAgJyBjb250YWlucyBcIi52YWx1ZVwiIGNoaWxkICcgK1xyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHBhdGgpICtcclxuICAgICAgICAgICAgICAgICcgaW4gYWRkaXRpb24gdG8gYWN0dWFsIGNoaWxkcmVuLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFByZS12YWxpZGF0ZSBwYXRocyBwYXNzZWQgaW4gdGhlIGZpcmViYXNlIGZ1bmN0aW9uLlxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVGaXJlYmFzZU1lcmdlUGF0aHMgPSBmdW5jdGlvbiAoZXJyb3JQcmVmaXgsIG1lcmdlUGF0aHMpIHtcclxuICAgIGxldCBpLCBjdXJQYXRoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG1lcmdlUGF0aHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjdXJQYXRoID0gbWVyZ2VQYXRoc1tpXTtcclxuICAgICAgICBjb25zdCBrZXlzID0gcGF0aFNsaWNlKGN1clBhdGgpO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoa2V5c1tqXSA9PT0gJy5wcmlvcml0eScgJiYgaiA9PT0ga2V5cy5sZW5ndGggLSAxKSA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1ZhbGlkS2V5KGtleXNbal0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAgICAgICAgICdjb250YWlucyBhbiBpbnZhbGlkIGtleSAoJyArXHJcbiAgICAgICAgICAgICAgICAgICAga2V5c1tqXSArXHJcbiAgICAgICAgICAgICAgICAgICAgJykgaW4gcGF0aCAnICtcclxuICAgICAgICAgICAgICAgICAgICBjdXJQYXRoLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICcuIEtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyAnICtcclxuICAgICAgICAgICAgICAgICAgICAnYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDaGVjayB0aGF0IHVwZGF0ZSBrZXlzIGFyZSBub3QgZGVzY2VuZGFudHMgb2YgZWFjaCBvdGhlci5cclxuICAgIC8vIFdlIHJlbHkgb24gdGhlIHByb3BlcnR5IHRoYXQgc29ydGluZyBndWFyYW50ZWVzIHRoYXQgYW5jZXN0b3JzIGNvbWVcclxuICAgIC8vIHJpZ2h0IGJlZm9yZSBkZXNjZW5kYW50cy5cclxuICAgIG1lcmdlUGF0aHMuc29ydChwYXRoQ29tcGFyZSk7XHJcbiAgICBsZXQgcHJldlBhdGggPSBudWxsO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG1lcmdlUGF0aHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjdXJQYXRoID0gbWVyZ2VQYXRoc1tpXTtcclxuICAgICAgICBpZiAocHJldlBhdGggIT09IG51bGwgJiYgcGF0aENvbnRhaW5zKHByZXZQYXRoLCBjdXJQYXRoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAgICAgJ2NvbnRhaW5zIGEgcGF0aCAnICtcclxuICAgICAgICAgICAgICAgIHByZXZQYXRoLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAgICAgJyB0aGF0IGlzIGFuY2VzdG9yIG9mIGFub3RoZXIgcGF0aCAnICtcclxuICAgICAgICAgICAgICAgIGN1clBhdGgudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXZQYXRoID0gY3VyUGF0aDtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIHByZS12YWxpZGF0ZSBhbiBvYmplY3QgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIGZpcmViYXNlIGZ1bmN0aW9uIChcclxuICogbXVzdCBiZSBhbiBvYmplY3QgLSBlLmcuIGZvciBmaXJlYmFzZS51cGRhdGUoKSkuXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZUZpcmViYXNlTWVyZ2VEYXRhQXJnID0gZnVuY3Rpb24gKGZuTmFtZSwgZGF0YSwgcGF0aCwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiBkYXRhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBlcnJvclByZWZpeCQxID0gZXJyb3JQcmVmaXgoZm5OYW1lLCAndmFsdWVzJyk7XHJcbiAgICBpZiAoIShkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JykgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCQxICsgJyBtdXN0IGJlIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjaGlsZHJlbiB0byByZXBsYWNlLicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWVyZ2VQYXRocyA9IFtdO1xyXG4gICAgZWFjaChkYXRhLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGN1clBhdGggPSBuZXcgUGF0aChrZXkpO1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKGVycm9yUHJlZml4JDEsIHZhbHVlLCBwYXRoQ2hpbGQocGF0aCwgY3VyUGF0aCkpO1xyXG4gICAgICAgIGlmIChwYXRoR2V0QmFjayhjdXJQYXRoKSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkUHJpb3JpdHkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgkMSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJjb250YWlucyBhbiBpbnZhbGlkIHZhbHVlIGZvciAnXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIGN1clBhdGgudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCInLCB3aGljaCBtdXN0IGJlIGEgdmFsaWQgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICdGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbCkuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbWVyZ2VQYXRocy5wdXNoKGN1clBhdGgpO1xyXG4gICAgfSk7XHJcbiAgICB2YWxpZGF0ZUZpcmViYXNlTWVyZ2VQYXRocyhlcnJvclByZWZpeCQxLCBtZXJnZVBhdGhzKTtcclxufTtcclxuY29uc3QgdmFsaWRhdGVQcmlvcml0eSA9IGZ1bmN0aW9uIChmbk5hbWUsIHByaW9yaXR5LCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmIHByaW9yaXR5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoaXNJbnZhbGlkSlNPTk51bWJlcihwcmlvcml0eSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCAncHJpb3JpdHknKSArXHJcbiAgICAgICAgICAgICdpcyAnICtcclxuICAgICAgICAgICAgcHJpb3JpdHkudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICcsIGJ1dCBtdXN0IGJlIGEgdmFsaWQgRmlyZWJhc2UgcHJpb3JpdHkgKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCAnICtcclxuICAgICAgICAgICAgJ3NlcnZlciB2YWx1ZSwgb3IgbnVsbCkuJyk7XHJcbiAgICB9XHJcbiAgICAvLyBTcGVjaWFsIGNhc2UgdG8gYWxsb3cgaW1wb3J0aW5nIGRhdGEgd2l0aCBhIC5zdi5cclxuICAgIGlmICghaXNWYWxpZFByaW9yaXR5KHByaW9yaXR5KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsICdwcmlvcml0eScpICtcclxuICAgICAgICAgICAgJ211c3QgYmUgYSB2YWxpZCBGaXJlYmFzZSBwcmlvcml0eSAnICtcclxuICAgICAgICAgICAgJyhhIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsKS4nKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgdmFsaWRhdGVLZXkgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE5hbWUsIGtleSwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiBrZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghaXNWYWxpZEtleShrZXkpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArXHJcbiAgICAgICAgICAgICd3YXMgYW4gaW52YWxpZCBrZXkgPSBcIicgK1xyXG4gICAgICAgICAgICBrZXkgK1xyXG4gICAgICAgICAgICAnXCIuICBGaXJlYmFzZSBrZXlzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgYW5kICcgK1xyXG4gICAgICAgICAgICAnY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCIpLicpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZVBhdGhTdHJpbmcgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE5hbWUsIHBhdGhTdHJpbmcsIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgcGF0aFN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1ZhbGlkUGF0aFN0cmluZyhwYXRoU3RyaW5nKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TmFtZSkgK1xyXG4gICAgICAgICAgICAnd2FzIGFuIGludmFsaWQgcGF0aCA9IFwiJyArXHJcbiAgICAgICAgICAgIHBhdGhTdHJpbmcgK1xyXG4gICAgICAgICAgICAnXCIuIFBhdGhzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgYW5kICcgK1xyXG4gICAgICAgICAgICAnY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiW1wiLCBvciBcIl1cIicpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCB2YWxpZGF0ZVJvb3RQYXRoU3RyaW5nID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROYW1lLCBwYXRoU3RyaW5nLCBvcHRpb25hbCkge1xyXG4gICAgaWYgKHBhdGhTdHJpbmcpIHtcclxuICAgICAgICAvLyBBbGxvdyAnLy5pbmZvLycgYXQgdGhlIGJlZ2lubmluZy5cclxuICAgICAgICBwYXRoU3RyaW5nID0gcGF0aFN0cmluZy5yZXBsYWNlKC9eXFwvKlxcLmluZm8oXFwvfCQpLywgJy8nKTtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlUGF0aFN0cmluZyhmbk5hbWUsIGFyZ3VtZW50TmFtZSwgcGF0aFN0cmluZywgb3B0aW9uYWwpO1xyXG59O1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZVdyaXRhYmxlUGF0aCA9IGZ1bmN0aW9uIChmbk5hbWUsIHBhdGgpIHtcclxuICAgIGlmIChwYXRoR2V0RnJvbnQocGF0aCkgPT09ICcuaW5mbycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm5OYW1lICsgXCIgZmFpbGVkID0gQ2FuJ3QgbW9kaWZ5IGRhdGEgdW5kZXIgLy5pbmZvL1wiKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgdmFsaWRhdGVVcmwgPSBmdW5jdGlvbiAoZm5OYW1lLCBwYXJzZWRVcmwpIHtcclxuICAgIC8vIFRPRE8gPSBWYWxpZGF0ZSBzZXJ2ZXIgYmV0dGVyLlxyXG4gICAgY29uc3QgcGF0aFN0cmluZyA9IHBhcnNlZFVybC5wYXRoLnRvU3RyaW5nKCk7XHJcbiAgICBpZiAoISh0eXBlb2YgcGFyc2VkVXJsLnJlcG9JbmZvLmhvc3QgPT09ICdzdHJpbmcnKSB8fFxyXG4gICAgICAgIHBhcnNlZFVybC5yZXBvSW5mby5ob3N0Lmxlbmd0aCA9PT0gMCB8fFxyXG4gICAgICAgICghaXNWYWxpZEtleShwYXJzZWRVcmwucmVwb0luZm8ubmFtZXNwYWNlKSAmJlxyXG4gICAgICAgICAgICBwYXJzZWRVcmwucmVwb0luZm8uaG9zdC5zcGxpdCgnOicpWzBdICE9PSAnbG9jYWxob3N0JykgfHxcclxuICAgICAgICAocGF0aFN0cmluZy5sZW5ndGggIT09IDAgJiYgIWlzVmFsaWRSb290UGF0aFN0cmluZyhwYXRoU3RyaW5nKSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCAndXJsJykgK1xyXG4gICAgICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIGZpcmViYXNlIFVSTCBhbmQgJyArXHJcbiAgICAgICAgICAgICd0aGUgcGF0aCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiLicpO1xyXG4gICAgfVxyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGV2ZW50IHF1ZXVlIHNlcnZlcyBhIGZldyBwdXJwb3NlczpcclxuICogMS4gSXQgZW5zdXJlcyB3ZSBtYWludGFpbiBldmVudCBvcmRlciBpbiB0aGUgZmFjZSBvZiBldmVudCBjYWxsYmFja3MgZG9pbmcgb3BlcmF0aW9ucyB0aGF0IHJlc3VsdCBpbiBtb3JlXHJcbiAqICAgIGV2ZW50cyBiZWluZyBxdWV1ZWQuXHJcbiAqIDIuIHJhaXNlUXVldWVkRXZlbnRzKCkgaGFuZGxlcyBiZWluZyBjYWxsZWQgcmVlbnRyYW50bHkgbmljZWx5LiAgVGhhdCBpcywgaWYgaW4gdGhlIGNvdXJzZSBvZiByYWlzaW5nIGV2ZW50cyxcclxuICogICAgcmFpc2VRdWV1ZWRFdmVudHMoKSBpcyBjYWxsZWQgYWdhaW4sIHRoZSBcImlubmVyXCIgY2FsbCB3aWxsIHBpY2sgdXAgcmFpc2luZyBldmVudHMgd2hlcmUgdGhlIFwib3V0ZXJcIiBjYWxsXHJcbiAqICAgIGxlZnQgb2ZmLCBlbnN1cmluZyB0aGF0IHRoZSBldmVudHMgYXJlIHN0aWxsIHJhaXNlZCBzeW5jaHJvbm91c2x5IGFuZCBpbiBvcmRlci5cclxuICogMy4gWW91IGNhbiB1c2UgcmFpc2VFdmVudHNBdFBhdGggYW5kIHJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGggdG8gZW5zdXJlIG9ubHkgcmVsZXZhbnQgcHJldmlvdXNseS1xdWV1ZWRcclxuICogICAgZXZlbnRzIGFyZSByYWlzZWQgc3luY2hyb25vdXNseS5cclxuICpcclxuICogTk9URTogVGhpcyBjYW4gYWxsIGdvIGF3YXkgaWYvd2hlbiB3ZSBtb3ZlIHRvIGFzeW5jIGV2ZW50cy5cclxuICpcclxuICovXHJcbmNsYXNzIEV2ZW50UXVldWUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudExpc3RzXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyYWNrcyByZWN1cnNpb24gZGVwdGggb2YgcmFpc2VRdWV1ZWRFdmVudHNfLCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVjdXJzaW9uRGVwdGhfID0gMDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQHBhcmFtIGV2ZW50RGF0YUxpc3QgLSBUaGUgbmV3IGV2ZW50cyB0byBxdWV1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50UXVldWVRdWV1ZUV2ZW50cyhldmVudFF1ZXVlLCBldmVudERhdGFMaXN0KSB7XHJcbiAgICAvLyBXZSBncm91cCBldmVudHMgYnkgcGF0aCwgc3RvcmluZyB0aGVtIGluIGEgc2luZ2xlIEV2ZW50TGlzdCwgdG8gbWFrZSBpdCBlYXNpZXIgdG8gc2tpcCBvdmVyIHRoZW0gcXVpY2tseS5cclxuICAgIGxldCBjdXJyTGlzdCA9IG51bGw7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50RGF0YUxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gZXZlbnREYXRhTGlzdFtpXTtcclxuICAgICAgICBjb25zdCBwYXRoID0gZGF0YS5nZXRQYXRoKCk7XHJcbiAgICAgICAgaWYgKGN1cnJMaXN0ICE9PSBudWxsICYmICFwYXRoRXF1YWxzKHBhdGgsIGN1cnJMaXN0LnBhdGgpKSB7XHJcbiAgICAgICAgICAgIGV2ZW50UXVldWUuZXZlbnRMaXN0c18ucHVzaChjdXJyTGlzdCk7XHJcbiAgICAgICAgICAgIGN1cnJMaXN0ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJMaXN0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGN1cnJMaXN0ID0geyBldmVudHM6IFtdLCBwYXRoIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJMaXN0LmV2ZW50cy5wdXNoKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgaWYgKGN1cnJMaXN0KSB7XHJcbiAgICAgICAgZXZlbnRRdWV1ZS5ldmVudExpc3RzXy5wdXNoKGN1cnJMaXN0KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUXVldWVzIHRoZSBzcGVjaWZpZWQgZXZlbnRzIGFuZCBzeW5jaHJvbm91c2x5IHJhaXNlcyBhbGwgZXZlbnRzIChpbmNsdWRpbmcgcHJldmlvdXNseSBxdWV1ZWQgb25lcylcclxuICogZm9yIHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICpcclxuICogSXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBuZXcgZXZlbnRzIGFyZSBhbGwgZm9yIHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byByYWlzZSBldmVudHMgZm9yLlxyXG4gKiBAcGFyYW0gZXZlbnREYXRhTGlzdCAtIFRoZSBuZXcgZXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZXZlbnRRdWV1ZVJhaXNlRXZlbnRzQXRQYXRoKGV2ZW50UXVldWUsIHBhdGgsIGV2ZW50RGF0YUxpc3QpIHtcclxuICAgIGV2ZW50UXVldWVRdWV1ZUV2ZW50cyhldmVudFF1ZXVlLCBldmVudERhdGFMaXN0KTtcclxuICAgIGV2ZW50UXVldWVSYWlzZVF1ZXVlZEV2ZW50c01hdGNoaW5nUHJlZGljYXRlKGV2ZW50UXVldWUsIGV2ZW50UGF0aCA9PiBwYXRoRXF1YWxzKGV2ZW50UGF0aCwgcGF0aCkpO1xyXG59XHJcbi8qKlxyXG4gKiBRdWV1ZXMgdGhlIHNwZWNpZmllZCBldmVudHMgYW5kIHN5bmNocm9ub3VzbHkgcmFpc2VzIGFsbCBldmVudHMgKGluY2x1ZGluZyBwcmV2aW91c2x5IHF1ZXVlZCBvbmVzKSBmb3JcclxuICogbG9jYXRpb25zIHJlbGF0ZWQgdG8gdGhlIHNwZWNpZmllZCBjaGFuZ2UgcGF0aCAoaS5lLiBhbGwgYW5jZXN0b3JzIGFuZCBkZXNjZW5kYW50cykuXHJcbiAqXHJcbiAqIEl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgbmV3IGV2ZW50cyBhcmUgYWxsIHJlbGF0ZWQgKGFuY2VzdG9yIG9yIGRlc2NlbmRhbnQpIHRvIHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICpcclxuICogQHBhcmFtIGNoYW5nZWRQYXRoIC0gVGhlIHBhdGggdG8gcmFpc2UgZXZlbnRzIGZvci5cclxuICogQHBhcmFtIGV2ZW50RGF0YUxpc3QgLSBUaGUgZXZlbnRzIHRvIHJhaXNlXHJcbiAqL1xyXG5mdW5jdGlvbiBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChldmVudFF1ZXVlLCBjaGFuZ2VkUGF0aCwgZXZlbnREYXRhTGlzdCkge1xyXG4gICAgZXZlbnRRdWV1ZVF1ZXVlRXZlbnRzKGV2ZW50UXVldWUsIGV2ZW50RGF0YUxpc3QpO1xyXG4gICAgZXZlbnRRdWV1ZVJhaXNlUXVldWVkRXZlbnRzTWF0Y2hpbmdQcmVkaWNhdGUoZXZlbnRRdWV1ZSwgZXZlbnRQYXRoID0+IHBhdGhDb250YWlucyhldmVudFBhdGgsIGNoYW5nZWRQYXRoKSB8fFxyXG4gICAgICAgIHBhdGhDb250YWlucyhjaGFuZ2VkUGF0aCwgZXZlbnRQYXRoKSk7XHJcbn1cclxuZnVuY3Rpb24gZXZlbnRRdWV1ZVJhaXNlUXVldWVkRXZlbnRzTWF0Y2hpbmdQcmVkaWNhdGUoZXZlbnRRdWV1ZSwgcHJlZGljYXRlKSB7XHJcbiAgICBldmVudFF1ZXVlLnJlY3Vyc2lvbkRlcHRoXysrO1xyXG4gICAgbGV0IHNlbnRBbGwgPSB0cnVlO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudFF1ZXVlLmV2ZW50TGlzdHNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnRMaXN0ID0gZXZlbnRRdWV1ZS5ldmVudExpc3RzX1tpXTtcclxuICAgICAgICBpZiAoZXZlbnRMaXN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50UGF0aCA9IGV2ZW50TGlzdC5wYXRoO1xyXG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKGV2ZW50UGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50TGlzdFJhaXNlKGV2ZW50UXVldWUuZXZlbnRMaXN0c19baV0pO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRRdWV1ZS5ldmVudExpc3RzX1tpXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZW50QWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc2VudEFsbCkge1xyXG4gICAgICAgIGV2ZW50UXVldWUuZXZlbnRMaXN0c18gPSBbXTtcclxuICAgIH1cclxuICAgIGV2ZW50UXVldWUucmVjdXJzaW9uRGVwdGhfLS07XHJcbn1cclxuLyoqXHJcbiAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIGxpc3QgYW5kIHJhaXNlcyBlYWNoIGV2ZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBldmVudExpc3RSYWlzZShldmVudExpc3QpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRMaXN0LmV2ZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IGV2ZW50TGlzdC5ldmVudHNbaV07XHJcbiAgICAgICAgaWYgKGV2ZW50RGF0YSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBldmVudExpc3QuZXZlbnRzW2ldID0gbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnRGbiA9IGV2ZW50RGF0YS5nZXRFdmVudFJ1bm5lcigpO1xyXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICBsb2coJ2V2ZW50OiAnICsgZXZlbnREYXRhLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV4Y2VwdGlvbkd1YXJkKGV2ZW50Rm4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBJTlRFUlJVUFRfUkVBU09OID0gJ3JlcG9faW50ZXJydXB0JztcclxuLyoqXHJcbiAqIElmIGEgdHJhbnNhY3Rpb24gZG9lcyBub3Qgc3VjY2VlZCBhZnRlciAyNSByZXRyaWVzLCB3ZSBhYm9ydCBpdC4gQW1vbmcgb3RoZXJcclxuICogdGhpbmdzIHRoaXMgZW5zdXJlIHRoYXQgaWYgdGhlcmUncyBldmVyIGEgYnVnIGNhdXNpbmcgYSBtaXNtYXRjaCBiZXR3ZWVuXHJcbiAqIGNsaWVudCAvIHNlcnZlciBoYXNoZXMgZm9yIHNvbWUgZGF0YSwgd2Ugd29uJ3QgcmV0cnkgaW5kZWZpbml0ZWx5LlxyXG4gKi9cclxuY29uc3QgTUFYX1RSQU5TQUNUSU9OX1JFVFJJRVMgPSAyNTtcclxuLyoqXHJcbiAqIEEgY29ubmVjdGlvbiB0byBhIHNpbmdsZSBkYXRhIHJlcG9zaXRvcnkuXHJcbiAqL1xyXG5jbGFzcyBSZXBvIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlcG9JbmZvXywgZm9yY2VSZXN0Q2xpZW50XywgYXV0aFRva2VuUHJvdmlkZXJfLCBhcHBDaGVja1Byb3ZpZGVyXykge1xyXG4gICAgICAgIHRoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xyXG4gICAgICAgIHRoaXMuZm9yY2VSZXN0Q2xpZW50XyA9IGZvcmNlUmVzdENsaWVudF87XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl8gPSBhdXRoVG9rZW5Qcm92aWRlcl87XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Byb3ZpZGVyXyA9IGFwcENoZWNrUHJvdmlkZXJfO1xyXG4gICAgICAgIHRoaXMuZGF0YVVwZGF0ZUNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnN0YXRzTGlzdGVuZXJfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmV2ZW50UXVldWVfID0gbmV3IEV2ZW50UXVldWUoKTtcclxuICAgICAgICB0aGlzLm5leHRXcml0ZUlkXyA9IDE7XHJcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRTZXJ2ZXJEYXRhQ2FsbGJhY2tfID0gbnVsbDtcclxuICAgICAgICAvKiogQSBsaXN0IG9mIGRhdGEgcGllY2VzIGFuZCBwYXRocyB0byBiZSBzZXQgd2hlbiB0aGlzIGNsaWVudCBkaXNjb25uZWN0cy4gKi9cclxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBuZXdTcGFyc2VTbmFwc2hvdFRyZWUoKTtcclxuICAgICAgICAvKiogU3RvcmVzIHF1ZXVlcyBvZiBvdXRzdGFuZGluZyB0cmFuc2FjdGlvbnMgZm9yIEZpcmViYXNlIGxvY2F0aW9ucy4gKi9cclxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uUXVldWVUcmVlXyA9IG5ldyBUcmVlKCk7XHJcbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgQHByaXZhdGUgYnV0IGl0J3MgdXNlZCBieSB0ZXN0X2FjY2Vzcy5qcyBhbmQgaW50ZXJuYWwuanNcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbnRDb25uZWN0aW9uXyA9IG51bGw7XHJcbiAgICAgICAgLy8gVGhpcyBrZXkgaXMgaW50ZW50aW9uYWxseSBub3QgdXBkYXRlZCBpZiBSZXBvSW5mbyBpcyBsYXRlciBjaGFuZ2VkIG9yIHJlcGxhY2VkXHJcbiAgICAgICAgdGhpcy5rZXkgPSB0aGlzLnJlcG9JbmZvXy50b1VSTFN0cmluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgVVJMIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJvb3Qgb2YgdGhpcyBGaXJlYmFzZS5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICgodGhpcy5yZXBvSW5mb18uc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJykgKyB0aGlzLnJlcG9JbmZvXy5ob3N0KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXBvU3RhcnQocmVwbywgYXBwSWQsIGF1dGhPdmVycmlkZSkge1xyXG4gICAgcmVwby5zdGF0c18gPSBzdGF0c01hbmFnZXJHZXRDb2xsZWN0aW9uKHJlcG8ucmVwb0luZm9fKTtcclxuICAgIGlmIChyZXBvLmZvcmNlUmVzdENsaWVudF8gfHwgYmVpbmdDcmF3bGVkKCkpIHtcclxuICAgICAgICByZXBvLnNlcnZlcl8gPSBuZXcgUmVhZG9ubHlSZXN0Q2xpZW50KHJlcG8ucmVwb0luZm9fLCAocGF0aFN0cmluZywgZGF0YSwgaXNNZXJnZSwgdGFnKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG9PbkRhdGFVcGRhdGUocmVwbywgcGF0aFN0cmluZywgZGF0YSwgaXNNZXJnZSwgdGFnKTtcclxuICAgICAgICB9LCByZXBvLmF1dGhUb2tlblByb3ZpZGVyXywgcmVwby5hcHBDaGVja1Byb3ZpZGVyXyk7XHJcbiAgICAgICAgLy8gTWlub3IgaGFjazogRmlyZSBvbkNvbm5lY3QgaW1tZWRpYXRlbHksIHNpbmNlIHRoZXJlJ3Mgbm8gYWN0dWFsIGNvbm5lY3Rpb24uXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXBvT25Db25uZWN0U3RhdHVzKHJlcG8sIC8qIGNvbm5lY3RTdGF0dXM9ICovIHRydWUpLCAwKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFZhbGlkYXRlIGF1dGhPdmVycmlkZVxyXG4gICAgICAgIGlmICh0eXBlb2YgYXV0aE92ZXJyaWRlICE9PSAndW5kZWZpbmVkJyAmJiBhdXRoT3ZlcnJpZGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhdXRoT3ZlcnJpZGUgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb2JqZWN0cyBhcmUgc3VwcG9ydGVkIGZvciBvcHRpb24gZGF0YWJhc2VBdXRoVmFyaWFibGVPdmVycmlkZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoYXV0aE92ZXJyaWRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGF1dGhPdmVycmlkZSBwcm92aWRlZDogJyArIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fID0gbmV3IFBlcnNpc3RlbnRDb25uZWN0aW9uKHJlcG8ucmVwb0luZm9fLCBhcHBJZCwgKHBhdGhTdHJpbmcsIGRhdGEsIGlzTWVyZ2UsIHRhZykgPT4ge1xyXG4gICAgICAgICAgICByZXBvT25EYXRhVXBkYXRlKHJlcG8sIHBhdGhTdHJpbmcsIGRhdGEsIGlzTWVyZ2UsIHRhZyk7XHJcbiAgICAgICAgfSwgKGNvbm5lY3RTdGF0dXMpID0+IHtcclxuICAgICAgICAgICAgcmVwb09uQ29ubmVjdFN0YXR1cyhyZXBvLCBjb25uZWN0U3RhdHVzKTtcclxuICAgICAgICB9LCAodXBkYXRlcykgPT4ge1xyXG4gICAgICAgICAgICByZXBvT25TZXJ2ZXJJbmZvVXBkYXRlKHJlcG8sIHVwZGF0ZXMpO1xyXG4gICAgICAgIH0sIHJlcG8uYXV0aFRva2VuUHJvdmlkZXJfLCByZXBvLmFwcENoZWNrUHJvdmlkZXJfLCBhdXRoT3ZlcnJpZGUpO1xyXG4gICAgICAgIHJlcG8uc2VydmVyXyA9IHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fO1xyXG4gICAgfVxyXG4gICAgcmVwby5hdXRoVG9rZW5Qcm92aWRlcl8uYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcih0b2tlbiA9PiB7XHJcbiAgICAgICAgcmVwby5zZXJ2ZXJfLnJlZnJlc2hBdXRoVG9rZW4odG9rZW4pO1xyXG4gICAgfSk7XHJcbiAgICByZXBvLmFwcENoZWNrUHJvdmlkZXJfLmFkZFRva2VuQ2hhbmdlTGlzdGVuZXIocmVzdWx0ID0+IHtcclxuICAgICAgICByZXBvLnNlcnZlcl8ucmVmcmVzaEFwcENoZWNrVG9rZW4ocmVzdWx0LnRva2VuKTtcclxuICAgIH0pO1xyXG4gICAgLy8gSW4gdGhlIGNhc2Ugb2YgbXVsdGlwbGUgUmVwb3MgZm9yIHRoZSBzYW1lIHJlcG9JbmZvIChpLmUuIHRoZXJlIGFyZSBtdWx0aXBsZSBGaXJlYmFzZS5Db250ZXh0cyBiZWluZyB1c2VkKSxcclxuICAgIC8vIHdlIG9ubHkgd2FudCB0byBjcmVhdGUgb25lIFN0YXRzUmVwb3J0ZXIuICBBcyBzdWNoLCB3ZSdsbCByZXBvcnQgc3RhdHMgb3ZlciB0aGUgZmlyc3QgUmVwbyBjcmVhdGVkLlxyXG4gICAgcmVwby5zdGF0c1JlcG9ydGVyXyA9IHN0YXRzTWFuYWdlckdldE9yQ3JlYXRlUmVwb3J0ZXIocmVwby5yZXBvSW5mb18sICgpID0+IG5ldyBTdGF0c1JlcG9ydGVyKHJlcG8uc3RhdHNfLCByZXBvLnNlcnZlcl8pKTtcclxuICAgIC8vIFVzZWQgZm9yIC5pbmZvLlxyXG4gICAgcmVwby5pbmZvRGF0YV8gPSBuZXcgU25hcHNob3RIb2xkZXIoKTtcclxuICAgIHJlcG8uaW5mb1N5bmNUcmVlXyA9IG5ldyBTeW5jVHJlZSh7XHJcbiAgICAgICAgc3RhcnRMaXN0ZW5pbmc6IChxdWVyeSwgdGFnLCBjdXJyZW50SGFzaEZuLCBvbkNvbXBsZXRlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBpbmZvRXZlbnRzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSByZXBvLmluZm9EYXRhXy5nZXROb2RlKHF1ZXJ5Ll9wYXRoKTtcclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBwb3NzaWJseSBhIGhhY2ssIGJ1dCB3ZSBoYXZlIGRpZmZlcmVudCBzZW1hbnRpY3MgZm9yIC5pbmZvIGVuZHBvaW50cy4gV2UgZG9uJ3QgcmFpc2UgbnVsbCBldmVudHNcclxuICAgICAgICAgICAgLy8gb24gaW5pdGlhbCBkYXRhLi4uXHJcbiAgICAgICAgICAgIGlmICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGluZm9FdmVudHMgPSBzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlKHJlcG8uaW5mb1N5bmNUcmVlXywgcXVlcnkuX3BhdGgsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZSgnb2snKTtcclxuICAgICAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpbmZvRXZlbnRzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RvcExpc3RlbmluZzogKCkgPT4geyB9XHJcbiAgICB9KTtcclxuICAgIHJlcG9VcGRhdGVJbmZvKHJlcG8sICdjb25uZWN0ZWQnLCBmYWxzZSk7XHJcbiAgICByZXBvLnNlcnZlclN5bmNUcmVlXyA9IG5ldyBTeW5jVHJlZSh7XHJcbiAgICAgICAgc3RhcnRMaXN0ZW5pbmc6IChxdWVyeSwgdGFnLCBjdXJyZW50SGFzaEZuLCBvbkNvbXBsZXRlKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG8uc2VydmVyXy5saXN0ZW4ocXVlcnksIGN1cnJlbnRIYXNoRm4sIHRhZywgKHN0YXR1cywgZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gb25Db21wbGV0ZShzdGF0dXMsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgcXVlcnkuX3BhdGgsIGV2ZW50cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBObyBzeW5jaHJvbm91cyBldmVudHMgZm9yIG5ldHdvcmstYmFja2VkIHN5bmMgdHJlZXNcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RvcExpc3RlbmluZzogKHF1ZXJ5LCB0YWcpID0+IHtcclxuICAgICAgICAgICAgcmVwby5zZXJ2ZXJfLnVubGlzdGVuKHF1ZXJ5LCB0YWcpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMsIHRha2luZyB0aGUgc2VydmVyIG9mZnNldCBpbnRvIGFjY291bnQgaWYgd2UgaGF2ZSBvbmUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvU2VydmVyVGltZShyZXBvKSB7XHJcbiAgICBjb25zdCBvZmZzZXROb2RlID0gcmVwby5pbmZvRGF0YV8uZ2V0Tm9kZShuZXcgUGF0aCgnLmluZm8vc2VydmVyVGltZU9mZnNldCcpKTtcclxuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldE5vZGUudmFsKCkgfHwgMDtcclxuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIG9mZnNldDtcclxufVxyXG4vKipcclxuICogR2VuZXJhdGUgU2VydmVyVmFsdWVzIHVzaW5nIHNvbWUgdmFyaWFibGVzIGZyb20gdGhlIHJlcG8gb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pIHtcclxuICAgIHJldHVybiBnZW5lcmF0ZVdpdGhWYWx1ZXMoe1xyXG4gICAgICAgIHRpbWVzdGFtcDogcmVwb1NlcnZlclRpbWUocmVwbylcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxsZWQgYnkgcmVhbHRpbWUgd2hlbiB3ZSBnZXQgbmV3IG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlci5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9PbkRhdGFVcGRhdGUocmVwbywgcGF0aFN0cmluZywgZGF0YSwgaXNNZXJnZSwgdGFnKSB7XHJcbiAgICAvLyBGb3IgdGVzdGluZy5cclxuICAgIHJlcG8uZGF0YVVwZGF0ZUNvdW50Kys7XHJcbiAgICBjb25zdCBwYXRoID0gbmV3IFBhdGgocGF0aFN0cmluZyk7XHJcbiAgICBkYXRhID0gcmVwby5pbnRlcmNlcHRTZXJ2ZXJEYXRhQ2FsbGJhY2tfXHJcbiAgICAgICAgPyByZXBvLmludGVyY2VwdFNlcnZlckRhdGFDYWxsYmFja18ocGF0aFN0cmluZywgZGF0YSlcclxuICAgICAgICA6IGRhdGE7XHJcbiAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgaWYgKGlzTWVyZ2UpIHtcclxuICAgICAgICAgICAgY29uc3QgdGFnZ2VkQ2hpbGRyZW4gPSBtYXAoZGF0YSwgKHJhdykgPT4gbm9kZUZyb21KU09OKHJhdykpO1xyXG4gICAgICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFwcGx5VGFnZ2VkUXVlcnlNZXJnZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgdGFnZ2VkQ2hpbGRyZW4sIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0YWdnZWRTbmFwID0gbm9kZUZyb21KU09OKGRhdGEpO1xyXG4gICAgICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFwcGx5VGFnZ2VkUXVlcnlPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIHRhZ2dlZFNuYXAsIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNNZXJnZSkge1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZWRDaGlsZHJlbiA9IG1hcChkYXRhLCAocmF3KSA9PiBub2RlRnJvbUpTT04ocmF3KSk7XHJcbiAgICAgICAgZXZlbnRzID0gc3luY1RyZWVBcHBseVNlcnZlck1lcmdlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgc25hcCA9IG5vZGVGcm9tSlNPTihkYXRhKTtcclxuICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoLCBzbmFwKTtcclxuICAgIH1cclxuICAgIGxldCBhZmZlY3RlZFBhdGggPSBwYXRoO1xyXG4gICAgaWYgKGV2ZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gU2luY2Ugd2UgaGF2ZSBhIGxpc3RlbmVyIG91dHN0YW5kaW5nIGZvciBlYWNoIHRyYW5zYWN0aW9uLCByZWNlaXZpbmcgYW55IGV2ZW50c1xyXG4gICAgICAgIC8vIGlzIGEgcHJveHkgZm9yIHNvbWUgY2hhbmdlIGhhdmluZyBvY2N1cnJlZC5cclxuICAgICAgICBhZmZlY3RlZFBhdGggPSByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgcGF0aCk7XHJcbiAgICB9XHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBhZmZlY3RlZFBhdGgsIGV2ZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb09uQ29ubmVjdFN0YXR1cyhyZXBvLCBjb25uZWN0U3RhdHVzKSB7XHJcbiAgICByZXBvVXBkYXRlSW5mbyhyZXBvLCAnY29ubmVjdGVkJywgY29ubmVjdFN0YXR1cyk7XHJcbiAgICBpZiAoY29ubmVjdFN0YXR1cyA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXBvUnVuT25EaXNjb25uZWN0RXZlbnRzKHJlcG8pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcG9PblNlcnZlckluZm9VcGRhdGUocmVwbywgdXBkYXRlcykge1xyXG4gICAgZWFjaCh1cGRhdGVzLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHJlcG9VcGRhdGVJbmZvKHJlcG8sIGtleSwgdmFsdWUpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb1VwZGF0ZUluZm8ocmVwbywgcGF0aFN0cmluZywgdmFsdWUpIHtcclxuICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aCgnLy5pbmZvLycgKyBwYXRoU3RyaW5nKTtcclxuICAgIGNvbnN0IG5ld05vZGUgPSBub2RlRnJvbUpTT04odmFsdWUpO1xyXG4gICAgcmVwby5pbmZvRGF0YV8udXBkYXRlU25hcHNob3QocGF0aCwgbmV3Tm9kZSk7XHJcbiAgICBjb25zdCBldmVudHMgPSBzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlKHJlcG8uaW5mb1N5bmNUcmVlXywgcGF0aCwgbmV3Tm9kZSk7XHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBwYXRoLCBldmVudHMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9HZXROZXh0V3JpdGVJZChyZXBvKSB7XHJcbiAgICByZXR1cm4gcmVwby5uZXh0V3JpdGVJZF8rKztcclxufVxyXG4vKipcclxuICogVGhlIHB1cnBvc2Ugb2YgYGdldFZhbHVlYCBpcyB0byByZXR1cm4gdGhlIGxhdGVzdCBrbm93biB2YWx1ZVxyXG4gKiBzYXRpc2Z5aW5nIGBxdWVyeWAuXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIHdpbGwgZmlyc3QgY2hlY2sgZm9yIGluLW1lbW9yeSBjYWNoZWQgdmFsdWVzXHJcbiAqIGJlbG9uZ2luZyB0byBhY3RpdmUgbGlzdGVuZXJzLiBJZiB0aGV5IGFyZSBmb3VuZCwgc3VjaCB2YWx1ZXNcclxuICogYXJlIGNvbnNpZGVyZWQgdG8gYmUgdGhlIG1vc3QgdXAtdG8tZGF0ZS5cclxuICpcclxuICogSWYgdGhlIGNsaWVudCBpcyBub3QgY29ubmVjdGVkLCB0aGlzIG1ldGhvZCB3aWxsIHdhaXQgdW50aWwgdGhlXHJcbiAqICByZXBvIGhhcyBlc3RhYmxpc2hlZCBhIGNvbm5lY3Rpb24gYW5kIHRoZW4gcmVxdWVzdCB0aGUgdmFsdWUgZm9yIGBxdWVyeWAuXHJcbiAqIElmIHRoZSBjbGllbnQgaXMgbm90IGFibGUgdG8gcmV0cmlldmUgdGhlIHF1ZXJ5IHJlc3VsdCBmb3IgYW5vdGhlciByZWFzb24sXHJcbiAqIGl0IHJlcG9ydHMgYW4gZXJyb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0byBzdXJmYWNlIGEgdmFsdWUgZm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb0dldFZhbHVlKHJlcG8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbikge1xyXG4gICAgLy8gT25seSBhY3RpdmUgcXVlcmllcyBhcmUgY2FjaGVkLiBUaGVyZSBpcyBubyBwZXJzaXN0ZWQgY2FjaGUuXHJcbiAgICBjb25zdCBjYWNoZWQgPSBzeW5jVHJlZUdldFNlcnZlclZhbHVlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeSk7XHJcbiAgICBpZiAoY2FjaGVkICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVwby5zZXJ2ZXJfLmdldChxdWVyeSkudGhlbihwYXlsb2FkID0+IHtcclxuICAgICAgICBjb25zdCBub2RlID0gbm9kZUZyb21KU09OKHBheWxvYWQpLndpdGhJbmRleChxdWVyeS5fcXVlcnlQYXJhbXMuZ2V0SW5kZXgoKSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmVsb3cgd2Ugc2ltdWxhdGUgdGhlIGFjdGlvbnMgb2YgYW4gYG9ubHlPbmNlYCBgb25WYWx1ZSgpYCBldmVudCB3aGVyZTpcclxuICAgICAgICAgKiBBZGQgYW4gZXZlbnQgcmVnaXN0cmF0aW9uLFxyXG4gICAgICAgICAqIFVwZGF0ZSBkYXRhIGF0IHRoZSBwYXRoLFxyXG4gICAgICAgICAqIFJhaXNlIGFueSBldmVudHMsXHJcbiAgICAgICAgICogQ2xlYW51cCB0aGUgU3luY1RyZWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBzeW5jVHJlZUFkZEV2ZW50UmVnaXN0cmF0aW9uKHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIHRydWUpO1xyXG4gICAgICAgIGxldCBldmVudHM7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSkge1xyXG4gICAgICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeS5fcGF0aCwgbm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0YWcgPSBzeW5jVHJlZVRhZ0ZvclF1ZXJ5KHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeSk7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQXBwbHlUYWdnZWRRdWVyeU92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcXVlcnkuX3BhdGgsIG5vZGUsIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogV2UgbmVlZCB0byByYWlzZSBldmVudHMgaW4gdGhlIHNjZW5hcmlvIHdoZXJlIGBnZXQoKWAgaXMgY2FsbGVkIGF0IGEgcGFyZW50IHBhdGgsIGFuZFxyXG4gICAgICAgICAqIHdoaWxlIHRoZSBgZ2V0KClgIGlzIHBlbmRpbmcsIGBvblZhbHVlYCBpcyBjYWxsZWQgYXQgYSBjaGlsZCBsb2NhdGlvbi4gV2hpbGUgZ2V0KCkgaXMgd2FpdGluZ1xyXG4gICAgICAgICAqIGZvciB0aGUgZGF0YSwgYG9uVmFsdWVgIHdpbGwgcmVnaXN0ZXIgYSBuZXcgZXZlbnQuIFRoZW4sIGdldCgpIHdpbGwgY29tZSBiYWNrLCBhbmQgdXBkYXRlIHRoZSBzeW5jVHJlZVxyXG4gICAgICAgICAqIGFuZCBpdHMgY29ycmVzcG9uZGluZyBzZXJ2ZXJDYWNoZSwgaW5jbHVkaW5nIHRoZSBjaGlsZCBsb2NhdGlvbiB3aGVyZSBgb25WYWx1ZWAgaXMgY2FsbGVkLiBUaGVuLFxyXG4gICAgICAgICAqIGBvblZhbHVlYCB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50IGZyb20gdGhlIHNlcnZlciwgYnV0IGxvb2sgYXQgdGhlIHN5bmNUcmVlIGFuZCBzZWUgdGhhdCB0aGUgZGF0YSByZWNlaXZlZFxyXG4gICAgICAgICAqIGZyb20gdGhlIHNlcnZlciBpcyBhbHJlYWR5IGF0IHRoZSBTeW5jUG9pbnQsIGFuZCBzbyB0aGUgYG9uVmFsdWVgIGNhbGxiYWNrIHdpbGwgbmV2ZXIgZ2V0IGZpcmVkLlxyXG4gICAgICAgICAqIENhbGxpbmcgYGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKClgIGlzIHRoZSBjb3JyZWN0IHdheSB0byBwcm9wYWdhdGUgdGhlIGV2ZW50cyBhbmRcclxuICAgICAgICAgKiBlbnN1cmUgdGhlIGNvcnJlc3BvbmRpbmcgY2hpbGQgZXZlbnRzIHdpbGwgZ2V0IGZpcmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHF1ZXJ5Ll9wYXRoLCBldmVudHMpO1xyXG4gICAgICAgIHN5bmNUcmVlUmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24ocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9LCBlcnIgPT4ge1xyXG4gICAgICAgIHJlcG9Mb2cocmVwbywgJ2dldCBmb3IgcXVlcnkgJyArIHN0cmluZ2lmeShxdWVyeSkgKyAnIGZhaWxlZDogJyArIGVycik7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihlcnIpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9TZXRXaXRoUHJpb3JpdHkocmVwbywgcGF0aCwgbmV3VmFsLCBuZXdQcmlvcml0eSwgb25Db21wbGV0ZSkge1xyXG4gICAgcmVwb0xvZyhyZXBvLCAnc2V0Jywge1xyXG4gICAgICAgIHBhdGg6IHBhdGgudG9TdHJpbmcoKSxcclxuICAgICAgICB2YWx1ZTogbmV3VmFsLFxyXG4gICAgICAgIHByaW9yaXR5OiBuZXdQcmlvcml0eVxyXG4gICAgfSk7XHJcbiAgICAvLyBUT0RPOiBPcHRpbWl6ZSB0aGlzIGJlaGF2aW9yIHRvIGVpdGhlciAoYSkgc3RvcmUgZmxhZyB0byBza2lwIHJlc29sdmluZyB3aGVyZSBwb3NzaWJsZSBhbmQgLyBvclxyXG4gICAgLy8gKGIpIHN0b3JlIHVucmVzb2x2ZWQgcGF0aHMgb24gSlNPTiBwYXJzZVxyXG4gICAgY29uc3Qgc2VydmVyVmFsdWVzID0gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pO1xyXG4gICAgY29uc3QgbmV3Tm9kZVVucmVzb2x2ZWQgPSBub2RlRnJvbUpTT04obmV3VmFsLCBuZXdQcmlvcml0eSk7XHJcbiAgICBjb25zdCBleGlzdGluZyA9IHN5bmNUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCk7XHJcbiAgICBjb25zdCBuZXdOb2RlID0gcmVzb2x2ZURlZmVycmVkVmFsdWVTbmFwc2hvdChuZXdOb2RlVW5yZXNvbHZlZCwgZXhpc3RpbmcsIHNlcnZlclZhbHVlcyk7XHJcbiAgICBjb25zdCB3cml0ZUlkID0gcmVwb0dldE5leHRXcml0ZUlkKHJlcG8pO1xyXG4gICAgY29uc3QgZXZlbnRzID0gc3luY1RyZWVBcHBseVVzZXJPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIG5ld05vZGUsIHdyaXRlSWQsIHRydWUpO1xyXG4gICAgZXZlbnRRdWV1ZVF1ZXVlRXZlbnRzKHJlcG8uZXZlbnRRdWV1ZV8sIGV2ZW50cyk7XHJcbiAgICByZXBvLnNlcnZlcl8ucHV0KHBhdGgudG9TdHJpbmcoKSwgbmV3Tm9kZVVucmVzb2x2ZWQudmFsKC8qZXhwb3J0PSovIHRydWUpLCAoc3RhdHVzLCBlcnJvclJlYXNvbikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBzdGF0dXMgPT09ICdvayc7XHJcbiAgICAgICAgaWYgKCFzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgIHdhcm4oJ3NldCBhdCAnICsgcGF0aCArICcgZmFpbGVkOiAnICsgc3RhdHVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2xlYXJFdmVudHMgPSBzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgd3JpdGVJZCwgIXN1Y2Nlc3MpO1xyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIGNsZWFyRXZlbnRzKTtcclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgYWZmZWN0ZWRQYXRoID0gcmVwb0Fib3J0VHJhbnNhY3Rpb25zKHJlcG8sIHBhdGgpO1xyXG4gICAgcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIGFmZmVjdGVkUGF0aCk7XHJcbiAgICAvLyBXZSBxdWV1ZWQgdGhlIGV2ZW50cyBhYm92ZSwgc28ganVzdCBmbHVzaCB0aGUgcXVldWUgaGVyZVxyXG4gICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgYWZmZWN0ZWRQYXRoLCBbXSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb1VwZGF0ZShyZXBvLCBwYXRoLCBjaGlsZHJlblRvTWVyZ2UsIG9uQ29tcGxldGUpIHtcclxuICAgIHJlcG9Mb2cocmVwbywgJ3VwZGF0ZScsIHsgcGF0aDogcGF0aC50b1N0cmluZygpLCB2YWx1ZTogY2hpbGRyZW5Ub01lcmdlIH0pO1xyXG4gICAgLy8gU3RhcnQgd2l0aCBvdXIgZXhpc3RpbmcgZGF0YSBhbmQgbWVyZ2UgZWFjaCBjaGlsZCBpbnRvIGl0LlxyXG4gICAgbGV0IGVtcHR5ID0gdHJ1ZTtcclxuICAgIGNvbnN0IHNlcnZlclZhbHVlcyA9IHJlcG9HZW5lcmF0ZVNlcnZlclZhbHVlcyhyZXBvKTtcclxuICAgIGNvbnN0IGNoYW5nZWRDaGlsZHJlbiA9IHt9O1xyXG4gICAgZWFjaChjaGlsZHJlblRvTWVyZ2UsIChjaGFuZ2VkS2V5LCBjaGFuZ2VkVmFsdWUpID0+IHtcclxuICAgICAgICBlbXB0eSA9IGZhbHNlO1xyXG4gICAgICAgIGNoYW5nZWRDaGlsZHJlbltjaGFuZ2VkS2V5XSA9IHJlc29sdmVEZWZlcnJlZFZhbHVlVHJlZShwYXRoQ2hpbGQocGF0aCwgY2hhbmdlZEtleSksIG5vZGVGcm9tSlNPTihjaGFuZ2VkVmFsdWUpLCByZXBvLnNlcnZlclN5bmNUcmVlXywgc2VydmVyVmFsdWVzKTtcclxuICAgIH0pO1xyXG4gICAgaWYgKCFlbXB0eSkge1xyXG4gICAgICAgIGNvbnN0IHdyaXRlSWQgPSByZXBvR2V0TmV4dFdyaXRlSWQocmVwbyk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRzID0gc3luY1RyZWVBcHBseVVzZXJNZXJnZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZUlkKTtcclxuICAgICAgICBldmVudFF1ZXVlUXVldWVFdmVudHMocmVwby5ldmVudFF1ZXVlXywgZXZlbnRzKTtcclxuICAgICAgICByZXBvLnNlcnZlcl8ubWVyZ2UocGF0aC50b1N0cmluZygpLCBjaGlsZHJlblRvTWVyZ2UsIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBzdGF0dXMgPT09ICdvayc7XHJcbiAgICAgICAgICAgIGlmICghc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgd2FybigndXBkYXRlIGF0ICcgKyBwYXRoICsgJyBmYWlsZWQ6ICcgKyBzdGF0dXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNsZWFyRXZlbnRzID0gc3luY1RyZWVBY2tVc2VyV3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHdyaXRlSWQsICFzdWNjZXNzKTtcclxuICAgICAgICAgICAgY29uc3QgYWZmZWN0ZWRQYXRoID0gY2xlYXJFdmVudHMubGVuZ3RoID4gMCA/IHJlcG9SZXJ1blRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoKSA6IHBhdGg7XHJcbiAgICAgICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIGFmZmVjdGVkUGF0aCwgY2xlYXJFdmVudHMpO1xyXG4gICAgICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBlYWNoKGNoaWxkcmVuVG9NZXJnZSwgKGNoYW5nZWRQYXRoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFmZmVjdGVkUGF0aCA9IHJlcG9BYm9ydFRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoQ2hpbGQocGF0aCwgY2hhbmdlZFBhdGgpKTtcclxuICAgICAgICAgICAgcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIGFmZmVjdGVkUGF0aCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gV2UgcXVldWVkIHRoZSBldmVudHMgYWJvdmUsIHNvIGp1c3QgZmx1c2ggdGhlIHF1ZXVlIGhlcmVcclxuICAgICAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBwYXRoLCBbXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsb2coXCJ1cGRhdGUoKSBjYWxsZWQgd2l0aCBlbXB0eSBkYXRhLiAgRG9uJ3QgZG8gYW55dGhpbmcuXCIpO1xyXG4gICAgICAgIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIG9uQ29tcGxldGUsICdvaycsIHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYWxsIG9mIHRoZSBjaGFuZ2VzIHN0b3JlZCB1cCBpbiB0aGUgb25EaXNjb25uZWN0XyB0cmVlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1J1bk9uRGlzY29ubmVjdEV2ZW50cyhyZXBvKSB7XHJcbiAgICByZXBvTG9nKHJlcG8sICdvbkRpc2Nvbm5lY3RFdmVudHMnKTtcclxuICAgIGNvbnN0IHNlcnZlclZhbHVlcyA9IHJlcG9HZW5lcmF0ZVNlcnZlclZhbHVlcyhyZXBvKTtcclxuICAgIGNvbnN0IHJlc29sdmVkT25EaXNjb25uZWN0VHJlZSA9IG5ld1NwYXJzZVNuYXBzaG90VHJlZSgpO1xyXG4gICAgc3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaFRyZWUocmVwby5vbkRpc2Nvbm5lY3RfLCBuZXdFbXB0eVBhdGgoKSwgKHBhdGgsIG5vZGUpID0+IHtcclxuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVEZWZlcnJlZFZhbHVlVHJlZShwYXRoLCBub2RlLCByZXBvLnNlcnZlclN5bmNUcmVlXywgc2VydmVyVmFsdWVzKTtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlcihyZXNvbHZlZE9uRGlzY29ubmVjdFRyZWUsIHBhdGgsIHJlc29sdmVkKTtcclxuICAgIH0pO1xyXG4gICAgbGV0IGV2ZW50cyA9IFtdO1xyXG4gICAgc3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaFRyZWUocmVzb2x2ZWRPbkRpc2Nvbm5lY3RUcmVlLCBuZXdFbXB0eVBhdGgoKSwgKHBhdGgsIHNuYXApID0+IHtcclxuICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQXBwbHlTZXJ2ZXJPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIHNuYXApKTtcclxuICAgICAgICBjb25zdCBhZmZlY3RlZFBhdGggPSByZXBvQWJvcnRUcmFuc2FjdGlvbnMocmVwbywgcGF0aCk7XHJcbiAgICAgICAgcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIGFmZmVjdGVkUGF0aCk7XHJcbiAgICB9KTtcclxuICAgIHJlcG8ub25EaXNjb25uZWN0XyA9IG5ld1NwYXJzZVNuYXBzaG90VHJlZSgpO1xyXG4gICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgbmV3RW1wdHlQYXRoKCksIGV2ZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb09uRGlzY29ubmVjdENhbmNlbChyZXBvLCBwYXRoLCBvbkNvbXBsZXRlKSB7XHJcbiAgICByZXBvLnNlcnZlcl8ub25EaXNjb25uZWN0Q2FuY2VsKHBhdGgudG9TdHJpbmcoKSwgKHN0YXR1cywgZXJyb3JSZWFzb24pID0+IHtcclxuICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XHJcbiAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZUZvcmdldChyZXBvLm9uRGlzY29ubmVjdF8sIHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9PbkRpc2Nvbm5lY3RTZXQocmVwbywgcGF0aCwgdmFsdWUsIG9uQ29tcGxldGUpIHtcclxuICAgIGNvbnN0IG5ld05vZGUgPSBub2RlRnJvbUpTT04odmFsdWUpO1xyXG4gICAgcmVwby5zZXJ2ZXJfLm9uRGlzY29ubmVjdFB1dChwYXRoLnRvU3RyaW5nKCksIG5ld05vZGUudmFsKC8qZXhwb3J0PSovIHRydWUpLCAoc3RhdHVzLCBlcnJvclJlYXNvbikgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIocmVwby5vbkRpc2Nvbm5lY3RfLCBwYXRoLCBuZXdOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVwb0NhbGxPbkNvbXBsZXRlQ2FsbGJhY2socmVwbywgb25Db21wbGV0ZSwgc3RhdHVzLCBlcnJvclJlYXNvbik7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZXBvT25EaXNjb25uZWN0U2V0V2l0aFByaW9yaXR5KHJlcG8sIHBhdGgsIHZhbHVlLCBwcmlvcml0eSwgb25Db21wbGV0ZSkge1xyXG4gICAgY29uc3QgbmV3Tm9kZSA9IG5vZGVGcm9tSlNPTih2YWx1ZSwgcHJpb3JpdHkpO1xyXG4gICAgcmVwby5zZXJ2ZXJfLm9uRGlzY29ubmVjdFB1dChwYXRoLnRvU3RyaW5nKCksIG5ld05vZGUudmFsKC8qZXhwb3J0PSovIHRydWUpLCAoc3RhdHVzLCBlcnJvclJlYXNvbikgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIocmVwby5vbkRpc2Nvbm5lY3RfLCBwYXRoLCBuZXdOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVwb0NhbGxPbkNvbXBsZXRlQ2FsbGJhY2socmVwbywgb25Db21wbGV0ZSwgc3RhdHVzLCBlcnJvclJlYXNvbik7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZXBvT25EaXNjb25uZWN0VXBkYXRlKHJlcG8sIHBhdGgsIGNoaWxkcmVuVG9NZXJnZSwgb25Db21wbGV0ZSkge1xyXG4gICAgaWYgKGlzRW1wdHkoY2hpbGRyZW5Ub01lcmdlKSkge1xyXG4gICAgICAgIGxvZyhcIm9uRGlzY29ubmVjdCgpLnVwZGF0ZSgpIGNhbGxlZCB3aXRoIGVtcHR5IGRhdGEuICBEb24ndCBkbyBhbnl0aGluZy5cIik7XHJcbiAgICAgICAgcmVwb0NhbGxPbkNvbXBsZXRlQ2FsbGJhY2socmVwbywgb25Db21wbGV0ZSwgJ29rJywgdW5kZWZpbmVkKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZXBvLnNlcnZlcl8ub25EaXNjb25uZWN0TWVyZ2UocGF0aC50b1N0cmluZygpLCBjaGlsZHJlblRvTWVyZ2UsIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICBlYWNoKGNoaWxkcmVuVG9NZXJnZSwgKGNoaWxkTmFtZSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDaGlsZE5vZGUgPSBub2RlRnJvbUpTT04oY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZVJlbWVtYmVyKHJlcG8ub25EaXNjb25uZWN0XywgcGF0aENoaWxkKHBhdGgsIGNoaWxkTmFtZSksIG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9BZGRFdmVudENhbGxiYWNrRm9yUXVlcnkocmVwbywgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKSB7XHJcbiAgICBsZXQgZXZlbnRzO1xyXG4gICAgaWYgKHBhdGhHZXRGcm9udChxdWVyeS5fcGF0aCkgPT09ICcuaW5mbycpIHtcclxuICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFkZEV2ZW50UmVnaXN0cmF0aW9uKHJlcG8uaW5mb1N5bmNUcmVlXywgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQWRkRXZlbnRSZWdpc3RyYXRpb24ocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbik7XHJcbiAgICB9XHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNBdFBhdGgocmVwby5ldmVudFF1ZXVlXywgcXVlcnkuX3BhdGgsIGV2ZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb1JlbW92ZUV2ZW50Q2FsbGJhY2tGb3JRdWVyeShyZXBvLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pIHtcclxuICAgIC8vIFRoZXNlIGFyZSBndWFyYW50ZWVkIG5vdCB0byByYWlzZSBldmVudHMsIHNpbmNlIHdlJ3JlIG5vdCBwYXNzaW5nIGluIGEgY2FuY2VsRXJyb3IuIEhvd2V2ZXIsIHdlIGNhbiBmdXR1cmUtcHJvb2ZcclxuICAgIC8vIGEgbGl0dGxlIGJpdCBieSBoYW5kbGluZyB0aGUgcmV0dXJuIHZhbHVlcyBhbnl3YXlzLlxyXG4gICAgbGV0IGV2ZW50cztcclxuICAgIGlmIChwYXRoR2V0RnJvbnQocXVlcnkuX3BhdGgpID09PSAnLmluZm8nKSB7XHJcbiAgICAgICAgZXZlbnRzID0gc3luY1RyZWVSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihyZXBvLmluZm9TeW5jVHJlZV8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBldmVudHMgPSBzeW5jVHJlZVJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzQXRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHF1ZXJ5Ll9wYXRoLCBldmVudHMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9JbnRlcnJ1cHQocmVwbykge1xyXG4gICAgaWYgKHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fKSB7XHJcbiAgICAgICAgcmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8uaW50ZXJydXB0KElOVEVSUlVQVF9SRUFTT04pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcG9SZXN1bWUocmVwbykge1xyXG4gICAgaWYgKHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fKSB7XHJcbiAgICAgICAgcmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8ucmVzdW1lKElOVEVSUlVQVF9SRUFTT04pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcG9Mb2cocmVwbywgLi4udmFyQXJncykge1xyXG4gICAgbGV0IHByZWZpeCA9ICcnO1xyXG4gICAgaWYgKHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fKSB7XHJcbiAgICAgICAgcHJlZml4ID0gcmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8uaWQgKyAnOic7XHJcbiAgICB9XHJcbiAgICBsb2cocHJlZml4LCAuLi52YXJBcmdzKTtcclxufVxyXG5mdW5jdGlvbiByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBjYWxsYmFjaywgc3RhdHVzLCBlcnJvclJlYXNvbikge1xyXG4gICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgZXhjZXB0aW9uR3VhcmQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSAoc3RhdHVzIHx8ICdlcnJvcicpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGNvZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JSZWFzb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9ICc6ICcgKyBlcnJvclJlYXNvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdHJhbnNhY3Rpb24sIGFkZHMgaXQgdG8gdGhlIHRyYW5zYWN0aW9ucyB3ZSdyZSB0cmFja2luZywgYW5kXHJcbiAqIHNlbmRzIGl0IHRvIHRoZSBzZXJ2ZXIgaWYgcG9zc2libGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gUGF0aCBhdCB3aGljaCB0byBkbyB0cmFuc2FjdGlvbi5cclxuICogQHBhcmFtIHRyYW5zYWN0aW9uVXBkYXRlIC0gVXBkYXRlIGNhbGxiYWNrLlxyXG4gKiBAcGFyYW0gb25Db21wbGV0ZSAtIENvbXBsZXRpb24gY2FsbGJhY2suXHJcbiAqIEBwYXJhbSB1bndhdGNoZXIgLSBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHRyYW5zYWN0aW9uIG5vIGxvbmdlclxyXG4gKiBuZWVkIGRhdGEgdXBkYXRlcyBmb3IgYHBhdGhgLlxyXG4gKiBAcGFyYW0gYXBwbHlMb2NhbGx5IC0gV2hldGhlciBvciBub3QgdG8gbWFrZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyB2aXNpYmxlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvU3RhcnRUcmFuc2FjdGlvbihyZXBvLCBwYXRoLCB0cmFuc2FjdGlvblVwZGF0ZSwgb25Db21wbGV0ZSwgdW53YXRjaGVyLCBhcHBseUxvY2FsbHkpIHtcclxuICAgIHJlcG9Mb2cocmVwbywgJ3RyYW5zYWN0aW9uIG9uICcgKyBwYXRoKTtcclxuICAgIC8vIEluaXRpYWxpemUgdHJhbnNhY3Rpb24uXHJcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcclxuICAgICAgICBwYXRoLFxyXG4gICAgICAgIHVwZGF0ZTogdHJhbnNhY3Rpb25VcGRhdGUsXHJcbiAgICAgICAgb25Db21wbGV0ZSxcclxuICAgICAgICAvLyBPbmUgb2YgVHJhbnNhY3Rpb25TdGF0dXMgZW51bXMuXHJcbiAgICAgICAgc3RhdHVzOiBudWxsLFxyXG4gICAgICAgIC8vIFVzZWQgd2hlbiBjb21iaW5pbmcgdHJhbnNhY3Rpb25zIGF0IGRpZmZlcmVudCBsb2NhdGlvbnMgdG8gZmlndXJlIG91dFxyXG4gICAgICAgIC8vIHdoaWNoIG9uZSBnb2VzIGZpcnN0LlxyXG4gICAgICAgIG9yZGVyOiBMVUlER2VuZXJhdG9yKCksXHJcbiAgICAgICAgLy8gV2hldGhlciB0byByYWlzZSBsb2NhbCBldmVudHMgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgYXBwbHlMb2NhbGx5LFxyXG4gICAgICAgIC8vIENvdW50IG9mIGhvdyBtYW55IHRpbWVzIHdlJ3ZlIHJldHJpZWQgdGhlIHRyYW5zYWN0aW9uLlxyXG4gICAgICAgIHJldHJ5Q291bnQ6IDAsXHJcbiAgICAgICAgLy8gRnVuY3Rpb24gdG8gY2FsbCB0byBjbGVhbiB1cCBvdXIgLm9uKCkgbGlzdGVuZXIuXHJcbiAgICAgICAgdW53YXRjaGVyLFxyXG4gICAgICAgIC8vIFN0b3JlcyB3aHkgYSB0cmFuc2FjdGlvbiB3YXMgYWJvcnRlZC5cclxuICAgICAgICBhYm9ydFJlYXNvbjogbnVsbCxcclxuICAgICAgICBjdXJyZW50V3JpdGVJZDogbnVsbCxcclxuICAgICAgICBjdXJyZW50SW5wdXRTbmFwc2hvdDogbnVsbCxcclxuICAgICAgICBjdXJyZW50T3V0cHV0U25hcHNob3RSYXc6IG51bGwsXHJcbiAgICAgICAgY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQ6IG51bGxcclxuICAgIH07XHJcbiAgICAvLyBSdW4gdHJhbnNhY3Rpb24gaW5pdGlhbGx5LlxyXG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gcmVwb0dldExhdGVzdFN0YXRlKHJlcG8sIHBhdGgsIHVuZGVmaW5lZCk7XHJcbiAgICB0cmFuc2FjdGlvbi5jdXJyZW50SW5wdXRTbmFwc2hvdCA9IGN1cnJlbnRTdGF0ZTtcclxuICAgIGNvbnN0IG5ld1ZhbCA9IHRyYW5zYWN0aW9uLnVwZGF0ZShjdXJyZW50U3RhdGUudmFsKCkpO1xyXG4gICAgaWYgKG5ld1ZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLy8gQWJvcnQgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgdHJhbnNhY3Rpb24udW53YXRjaGVyKCk7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmF3ID0gbnVsbDtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZCA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25Db21wbGV0ZShudWxsLCBmYWxzZSwgdHJhbnNhY3Rpb24uY3VycmVudElucHV0U25hcHNob3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKCd0cmFuc2FjdGlvbiBmYWlsZWQ6IERhdGEgcmV0dXJuZWQgJywgbmV3VmFsLCB0cmFuc2FjdGlvbi5wYXRoKTtcclxuICAgICAgICAvLyBNYXJrIGFzIHJ1biBhbmQgYWRkIHRvIG91ciBxdWV1ZS5cclxuICAgICAgICB0cmFuc2FjdGlvbi5zdGF0dXMgPSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLztcclxuICAgICAgICBjb25zdCBxdWV1ZU5vZGUgPSB0cmVlU3ViVHJlZShyZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXywgcGF0aCk7XHJcbiAgICAgICAgY29uc3Qgbm9kZVF1ZXVlID0gdHJlZUdldFZhbHVlKHF1ZXVlTm9kZSkgfHwgW107XHJcbiAgICAgICAgbm9kZVF1ZXVlLnB1c2godHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIHRyZWVTZXRWYWx1ZShxdWV1ZU5vZGUsIG5vZGVRdWV1ZSk7XHJcbiAgICAgICAgLy8gVXBkYXRlIHZpc2libGVEYXRhIGFuZCByYWlzZSBldmVudHNcclxuICAgICAgICAvLyBOb3RlOiBXZSBpbnRlbnRpb25hbGx5IHJhaXNlIGV2ZW50cyBhZnRlciB1cGRhdGluZyBhbGwgb2Ygb3VyXHJcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlIHRoZSB1c2VyIGNvdWxkIHN0YXJ0IG5ldyB0cmFuc2FjdGlvbnMgZnJvbSB0aGVcclxuICAgICAgICAvLyBldmVudCBjYWxsYmFja3MuXHJcbiAgICAgICAgbGV0IHByaW9yaXR5Rm9yTm9kZTtcclxuICAgICAgICBpZiAodHlwZW9mIG5ld1ZhbCA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgbmV3VmFsICE9PSBudWxsICYmXHJcbiAgICAgICAgICAgIGNvbnRhaW5zKG5ld1ZhbCwgJy5wcmlvcml0eScpKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIHByaW9yaXR5Rm9yTm9kZSA9IHNhZmVHZXQobmV3VmFsLCAnLnByaW9yaXR5Jyk7XHJcbiAgICAgICAgICAgIGFzc2VydChpc1ZhbGlkUHJpb3JpdHkocHJpb3JpdHlGb3JOb2RlKSwgJ0ludmFsaWQgcHJpb3JpdHkgcmV0dXJuZWQgYnkgdHJhbnNhY3Rpb24uICcgK1xyXG4gICAgICAgICAgICAgICAgJ1ByaW9yaXR5IG11c3QgYmUgYSB2YWxpZCBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gc3luY1RyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoKSB8fFxyXG4gICAgICAgICAgICAgICAgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgIHByaW9yaXR5Rm9yTm9kZSA9IGN1cnJlbnROb2RlLmdldFByaW9yaXR5KCkudmFsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlcnZlclZhbHVlcyA9IHJlcG9HZW5lcmF0ZVNlcnZlclZhbHVlcyhyZXBvKTtcclxuICAgICAgICBjb25zdCBuZXdOb2RlVW5yZXNvbHZlZCA9IG5vZGVGcm9tSlNPTihuZXdWYWwsIHByaW9yaXR5Rm9yTm9kZSk7XHJcbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QobmV3Tm9kZVVucmVzb2x2ZWQsIGN1cnJlbnRTdGF0ZSwgc2VydmVyVmFsdWVzKTtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSYXcgPSBuZXdOb2RlVW5yZXNvbHZlZDtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZCA9IG5ld05vZGU7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQgPSByZXBvR2V0TmV4dFdyaXRlSWQocmVwbyk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRzID0gc3luY1RyZWVBcHBseVVzZXJPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIG5ld05vZGUsIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLCB0cmFuc2FjdGlvbi5hcHBseUxvY2FsbHkpO1xyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIGV2ZW50cyk7XHJcbiAgICAgICAgcmVwb1NlbmRSZWFkeVRyYW5zYWN0aW9ucyhyZXBvLCByZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBleGNsdWRlU2V0cyAtIEEgc3BlY2lmaWMgc2V0IHRvIGV4Y2x1ZGVcclxuICovXHJcbmZ1bmN0aW9uIHJlcG9HZXRMYXRlc3RTdGF0ZShyZXBvLCBwYXRoLCBleGNsdWRlU2V0cykge1xyXG4gICAgcmV0dXJuIChzeW5jVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIGV4Y2x1ZGVTZXRzKSB8fFxyXG4gICAgICAgIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcclxufVxyXG4vKipcclxuICogU2VuZHMgYW55IGFscmVhZHktcnVuIHRyYW5zYWN0aW9ucyB0aGF0IGFyZW4ndCB3YWl0aW5nIGZvciBvdXRzdGFuZGluZ1xyXG4gKiB0cmFuc2FjdGlvbnMgdG8gY29tcGxldGUuXHJcbiAqXHJcbiAqIEV4dGVybmFsbHkgaXQncyBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIGJ1dCBpdCBjYWxscyBpdHNlbGYgcmVjdXJzaXZlbHlcclxuICogd2l0aCBhIHBhcnRpY3VsYXIgdHJhbnNhY3Rpb25RdWV1ZVRyZWUgbm9kZSB0byByZWN1cnNlIHRocm91Z2ggdGhlIHRyZWUuXHJcbiAqXHJcbiAqIEBwYXJhbSBub2RlIC0gdHJhbnNhY3Rpb25RdWV1ZVRyZWUgbm9kZSB0byBzdGFydCBhdC5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9TZW5kUmVhZHlUcmFuc2FjdGlvbnMocmVwbywgbm9kZSA9IHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfKSB7XHJcbiAgICAvLyBCZWZvcmUgcmVjdXJzaW5nLCBtYWtlIHN1cmUgYW55IGNvbXBsZXRlZCB0cmFuc2FjdGlvbnMgYXJlIHJlbW92ZWQuXHJcbiAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICByZXBvUHJ1bmVDb21wbGV0ZWRUcmFuc2FjdGlvbnNCZWxvd05vZGUocmVwbywgbm9kZSk7XHJcbiAgICB9XHJcbiAgICBpZiAodHJlZUdldFZhbHVlKG5vZGUpKSB7XHJcbiAgICAgICAgY29uc3QgcXVldWUgPSByZXBvQnVpbGRUcmFuc2FjdGlvblF1ZXVlKHJlcG8sIG5vZGUpO1xyXG4gICAgICAgIGFzc2VydChxdWV1ZS5sZW5ndGggPiAwLCAnU2VuZGluZyB6ZXJvIGxlbmd0aCB0cmFuc2FjdGlvbiBxdWV1ZScpO1xyXG4gICAgICAgIGNvbnN0IGFsbFJ1biA9IHF1ZXVlLmV2ZXJ5KCh0cmFuc2FjdGlvbikgPT4gdHJhbnNhY3Rpb24uc3RhdHVzID09PSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLyk7XHJcbiAgICAgICAgLy8gSWYgdGhleSdyZSBhbGwgcnVuIChhbmQgbm90IHNlbnQpLCB3ZSBjYW4gc2VuZCB0aGVtLiAgRWxzZSwgd2UgbXVzdCB3YWl0LlxyXG4gICAgICAgIGlmIChhbGxSdW4pIHtcclxuICAgICAgICAgICAgcmVwb1NlbmRUcmFuc2FjdGlvblF1ZXVlKHJlcG8sIHRyZWVHZXRQYXRoKG5vZGUpLCBxdWV1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHJlZUhhc0NoaWxkcmVuKG5vZGUpKSB7XHJcbiAgICAgICAgdHJlZUZvckVhY2hDaGlsZChub2RlLCBjaGlsZE5vZGUgPT4ge1xyXG4gICAgICAgICAgICByZXBvU2VuZFJlYWR5VHJhbnNhY3Rpb25zKHJlcG8sIGNoaWxkTm9kZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGEgbGlzdCBvZiBydW4gdHJhbnNhY3Rpb25zLCBzZW5kIHRoZW0gdG8gdGhlIHNlcnZlciBhbmQgdGhlbiBoYW5kbGVcclxuICogdGhlIHJlc3VsdCAoc3VjY2VzcyBvciBmYWlsdXJlKS5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBUaGUgbG9jYXRpb24gb2YgdGhlIHF1ZXVlLlxyXG4gKiBAcGFyYW0gcXVldWUgLSBRdWV1ZSBvZiB0cmFuc2FjdGlvbnMgdW5kZXIgdGhlIHNwZWNpZmllZCBsb2NhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9TZW5kVHJhbnNhY3Rpb25RdWV1ZShyZXBvLCBwYXRoLCBxdWV1ZSkge1xyXG4gICAgLy8gTWFyayB0cmFuc2FjdGlvbnMgYXMgc2VudCBhbmQgaW5jcmVtZW50IHJldHJ5IGNvdW50IVxyXG4gICAgY29uc3Qgc2V0c1RvSWdub3JlID0gcXVldWUubWFwKHR4biA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHR4bi5jdXJyZW50V3JpdGVJZDtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbGF0ZXN0U3RhdGUgPSByZXBvR2V0TGF0ZXN0U3RhdGUocmVwbywgcGF0aCwgc2V0c1RvSWdub3JlKTtcclxuICAgIGxldCBzbmFwVG9TZW5kID0gbGF0ZXN0U3RhdGU7XHJcbiAgICBjb25zdCBsYXRlc3RIYXNoID0gbGF0ZXN0U3RhdGUuaGFzaCgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHR4biA9IHF1ZXVlW2ldO1xyXG4gICAgICAgIGFzc2VydCh0eG4uc3RhdHVzID09PSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLywgJ3RyeVRvU2VuZFRyYW5zYWN0aW9uUXVldWVfOiBpdGVtcyBpbiBxdWV1ZSBzaG91bGQgYWxsIGJlIHJ1bi4nKTtcclxuICAgICAgICB0eG4uc3RhdHVzID0gMSAvKiBUcmFuc2FjdGlvblN0YXR1cy5TRU5UICovO1xyXG4gICAgICAgIHR4bi5yZXRyeUNvdW50Kys7XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHBhdGgsIHR4bi5wYXRoKTtcclxuICAgICAgICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gdG8gdGhpcyBwb2ludCwgdGhlIG91dHB1dCBzbmFwc2hvdCBtdXN0IGJlIGRlZmluZWQuXHJcbiAgICAgICAgc25hcFRvU2VuZCA9IHNuYXBUb1NlbmQudXBkYXRlQ2hpbGQocmVsYXRpdmVQYXRoIC8qKiBAdHlwZSB7IU5vZGV9ICovLCB0eG4uY3VycmVudE91dHB1dFNuYXBzaG90UmF3KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRhdGFUb1NlbmQgPSBzbmFwVG9TZW5kLnZhbCh0cnVlKTtcclxuICAgIGNvbnN0IHBhdGhUb1NlbmQgPSBwYXRoO1xyXG4gICAgLy8gU2VuZCB0aGUgcHV0LlxyXG4gICAgcmVwby5zZXJ2ZXJfLnB1dChwYXRoVG9TZW5kLnRvU3RyaW5nKCksIGRhdGFUb1NlbmQsIChzdGF0dXMpID0+IHtcclxuICAgICAgICByZXBvTG9nKHJlcG8sICd0cmFuc2FjdGlvbiBwdXQgcmVzcG9uc2UnLCB7XHJcbiAgICAgICAgICAgIHBhdGg6IHBhdGhUb1NlbmQudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgc3RhdHVzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IGV2ZW50cyA9IFtdO1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgLy8gUXVldWUgdXAgdGhlIGNhbGxiYWNrcyBhbmQgZmlyZSB0aGVtIGFmdGVyIGNsZWFuaW5nIHVwIGFsbCBvZiBvdXJcclxuICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlIHRoZSBjYWxsYmFjayBjb3VsZCB0cmlnZ2VyIG1vcmVcclxuICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb25zIG9yIHNldHMuXHJcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSAyIC8qIFRyYW5zYWN0aW9uU3RhdHVzLkNPTVBMRVRFRCAqLztcclxuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBY2tVc2VyV3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXVlW2ldLmN1cnJlbnRXcml0ZUlkKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocXVldWVbaV0ub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5ldmVyIHVuc2V0IHRoZSBvdXRwdXQgc25hcHNob3QsIGFuZCBnaXZlbiB0aGF0IHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbiBpcyBjb21wbGV0ZSwgaXQgc2hvdWxkIGJlIHNldFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKCgpID0+IHF1ZXVlW2ldLm9uQ29tcGxldGUobnVsbCwgdHJ1ZSwgcXVldWVbaV0uY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnVud2F0Y2hlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5vdyByZW1vdmUgdGhlIGNvbXBsZXRlZCB0cmFuc2FjdGlvbnMuXHJcbiAgICAgICAgICAgIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCB0cmVlU3ViVHJlZShyZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXywgcGF0aCkpO1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBtYXkgYmUgcGVuZGluZyB0cmFuc2FjdGlvbnMgdGhhdCB3ZSBjYW4gbm93IHNlbmQuXHJcbiAgICAgICAgICAgIHJlcG9TZW5kUmVhZHlUcmFuc2FjdGlvbnMocmVwbywgcmVwby50cmFuc2FjdGlvblF1ZXVlVHJlZV8pO1xyXG4gICAgICAgICAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBwYXRoLCBldmVudHMpO1xyXG4gICAgICAgICAgICAvLyBGaW5hbGx5LCB0cmlnZ2VyIG9uQ29tcGxldGUgY2FsbGJhY2tzLlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZXhjZXB0aW9uR3VhcmQoY2FsbGJhY2tzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb25zIGFyZSBubyBsb25nZXIgc2VudC4gIFVwZGF0ZSB0aGVpciBzdGF0dXMgYXBwcm9wcmlhdGVseS5cclxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ2RhdGFzdGFsZScpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocXVldWVbaV0uc3RhdHVzID09PSAzIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlNFTlRfTkVFRFNfQUJPUlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gNCAvKiBUcmFuc2FjdGlvblN0YXR1cy5ORUVEU19BQk9SVCAqLztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IDAgLyogVHJhbnNhY3Rpb25TdGF0dXMuUlVOICovO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ3RyYW5zYWN0aW9uIGF0ICcgKyBwYXRoVG9TZW5kLnRvU3RyaW5nKCkgKyAnIGZhaWxlZDogJyArIHN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gNCAvKiBUcmFuc2FjdGlvblN0YXR1cy5ORUVEU19BQk9SVCAqLztcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5hYm9ydFJlYXNvbiA9IHN0YXR1cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgbGF0ZXN0SGFzaCk7XHJcbn1cclxuLyoqXHJcbiAqIEZpbmRzIGFsbCB0cmFuc2FjdGlvbnMgZGVwZW5kZW50IG9uIHRoZSBkYXRhIGF0IGNoYW5nZWRQYXRoIGFuZCByZXJ1bnMgdGhlbS5cclxuICpcclxuICogU2hvdWxkIGJlIGNhbGxlZCBhbnkgdGltZSBjYWNoZWQgZGF0YSBjaGFuZ2VzLlxyXG4gKlxyXG4gKiBSZXR1cm4gdGhlIGhpZ2hlc3QgcGF0aCB0aGF0IHdhcyBhZmZlY3RlZCBieSByZXJ1bm5pbmcgdHJhbnNhY3Rpb25zLiBUaGlzXHJcbiAqIGlzIHRoZSBwYXRoIGF0IHdoaWNoIGV2ZW50cyBuZWVkIHRvIGJlIHJhaXNlZCBmb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBjaGFuZ2VkUGF0aCAtIFRoZSBwYXRoIGluIG1lcmdlZERhdGEgdGhhdCBjaGFuZ2VkLlxyXG4gKiBAcmV0dXJucyBUaGUgcm9vdG1vc3QgcGF0aCB0aGF0IHdhcyBhZmZlY3RlZCBieSByZXJ1bm5pbmcgdHJhbnNhY3Rpb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIGNoYW5nZWRQYXRoKSB7XHJcbiAgICBjb25zdCByb290TW9zdFRyYW5zYWN0aW9uTm9kZSA9IHJlcG9HZXRBbmNlc3RvclRyYW5zYWN0aW9uTm9kZShyZXBvLCBjaGFuZ2VkUGF0aCk7XHJcbiAgICBjb25zdCBwYXRoID0gdHJlZUdldFBhdGgocm9vdE1vc3RUcmFuc2FjdGlvbk5vZGUpO1xyXG4gICAgY29uc3QgcXVldWUgPSByZXBvQnVpbGRUcmFuc2FjdGlvblF1ZXVlKHJlcG8sIHJvb3RNb3N0VHJhbnNhY3Rpb25Ob2RlKTtcclxuICAgIHJlcG9SZXJ1blRyYW5zYWN0aW9uUXVldWUocmVwbywgcXVldWUsIHBhdGgpO1xyXG4gICAgcmV0dXJuIHBhdGg7XHJcbn1cclxuLyoqXHJcbiAqIERvZXMgYWxsIHRoZSB3b3JrIG9mIHJlcnVubmluZyB0cmFuc2FjdGlvbnMgKGFzIHdlbGwgYXMgY2xlYW5zIHVwIGFib3J0ZWRcclxuICogdHJhbnNhY3Rpb25zIGFuZCB3aGF0bm90KS5cclxuICpcclxuICogQHBhcmFtIHF1ZXVlIC0gVGhlIHF1ZXVlIG9mIHRyYW5zYWN0aW9ucyB0byBydW4uXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdGhlIHF1ZXVlIGlzIGZvci5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9SZXJ1blRyYW5zYWN0aW9uUXVldWUocmVwbywgcXVldWUsIHBhdGgpIHtcclxuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG8hXHJcbiAgICB9XHJcbiAgICAvLyBRdWV1ZSB1cCB0aGUgY2FsbGJhY2tzIGFuZCBmaXJlIHRoZW0gYWZ0ZXIgY2xlYW5pbmcgdXAgYWxsIG9mIG91clxyXG4gICAgLy8gdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlIHRoZSBjYWxsYmFjayBjb3VsZCB0cmlnZ2VyIG1vcmUgdHJhbnNhY3Rpb25zIG9yXHJcbiAgICAvLyBzZXRzLlxyXG4gICAgY29uc3QgY2FsbGJhY2tzID0gW107XHJcbiAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAvLyBJZ25vcmUgYWxsIG9mIHRoZSBzZXRzIHdlJ3JlIGdvaW5nIHRvIHJlLXJ1bi5cclxuICAgIGNvbnN0IHR4bnNUb1JlcnVuID0gcXVldWUuZmlsdGVyKHEgPT4ge1xyXG4gICAgICAgIHJldHVybiBxLnN0YXR1cyA9PT0gMCAvKiBUcmFuc2FjdGlvblN0YXR1cy5SVU4gKi87XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHNldHNUb0lnbm9yZSA9IHR4bnNUb1JlcnVuLm1hcChxID0+IHtcclxuICAgICAgICByZXR1cm4gcS5jdXJyZW50V3JpdGVJZDtcclxuICAgIH0pO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gcXVldWVbaV07XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHBhdGgsIHRyYW5zYWN0aW9uLnBhdGgpO1xyXG4gICAgICAgIGxldCBhYm9ydFRyYW5zYWN0aW9uID0gZmFsc2UsIGFib3J0UmVhc29uO1xyXG4gICAgICAgIGFzc2VydChyZWxhdGl2ZVBhdGggIT09IG51bGwsICdyZXJ1blRyYW5zYWN0aW9uc1VuZGVyTm9kZV86IHJlbGF0aXZlUGF0aCBzaG91bGQgbm90IGJlIG51bGwuJyk7XHJcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnN0YXR1cyA9PT0gNCAvKiBUcmFuc2FjdGlvblN0YXR1cy5ORUVEU19BQk9SVCAqLykge1xyXG4gICAgICAgICAgICBhYm9ydFRyYW5zYWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgYWJvcnRSZWFzb24gPSB0cmFuc2FjdGlvbi5hYm9ydFJlYXNvbjtcclxuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQsIHRydWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHJhbnNhY3Rpb24uc3RhdHVzID09PSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLykge1xyXG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24ucmV0cnlDb3VudCA+PSBNQVhfVFJBTlNBQ1RJT05fUkVUUklFUykge1xyXG4gICAgICAgICAgICAgICAgYWJvcnRUcmFuc2FjdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBhYm9ydFJlYXNvbiA9ICdtYXhyZXRyeSc7XHJcbiAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQWNrVXNlcldyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHJlcnVucyBhIHRyYW5zYWN0aW9uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHJlcG9HZXRMYXRlc3RTdGF0ZShyZXBvLCB0cmFuc2FjdGlvbi5wYXRoLCBzZXRzVG9JZ25vcmUpO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudElucHV0U25hcHNob3QgPSBjdXJyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RhdGEgPSBxdWV1ZVtpXS51cGRhdGUoY3VycmVudE5vZGUudmFsKCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0RhdGEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKCd0cmFuc2FjdGlvbiBmYWlsZWQ6IERhdGEgcmV0dXJuZWQgJywgbmV3RGF0YSwgdHJhbnNhY3Rpb24ucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0RhdGFOb2RlID0gbm9kZUZyb21KU09OKG5ld0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc0V4cGxpY2l0UHJpb3JpdHkgPSB0eXBlb2YgbmV3RGF0YSA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGF0YSAhPSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zKG5ld0RhdGEsICcucHJpb3JpdHknKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0V4cGxpY2l0UHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgb2xkIHByaW9yaXR5IGlmIHRoZXJlIHdhc24ndCBhIHByaW9yaXR5IGV4cGxpY2l0bHkgc3BlY2lmaWVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhTm9kZSA9IG5ld0RhdGFOb2RlLnVwZGF0ZVByaW9yaXR5KGN1cnJlbnROb2RlLmdldFByaW9yaXR5KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRXcml0ZUlkID0gdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyVmFsdWVzID0gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGVSZXNvbHZlZCA9IHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QobmV3RGF0YU5vZGUsIGN1cnJlbnROb2RlLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJhdyA9IG5ld0RhdGFOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJlc29sdmVkID0gbmV3Tm9kZVJlc29sdmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkID0gcmVwb0dldE5leHRXcml0ZUlkKHJlcG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE11dGF0ZXMgc2V0c1RvSWdub3JlIGluIHBsYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0c1RvSWdub3JlLnNwbGljZShzZXRzVG9JZ25vcmUuaW5kZXhPZihvbGRXcml0ZUlkKSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFwcGx5VXNlck92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgdHJhbnNhY3Rpb24ucGF0aCwgbmV3Tm9kZVJlc29sdmVkLCB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCwgdHJhbnNhY3Rpb24uYXBwbHlMb2NhbGx5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgb2xkV3JpdGVJZCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRUcmFuc2FjdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRSZWFzb24gPSAnbm9kYXRhJztcclxuICAgICAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQWNrVXNlcldyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIGV2ZW50cyk7XHJcbiAgICAgICAgZXZlbnRzID0gW107XHJcbiAgICAgICAgaWYgKGFib3J0VHJhbnNhY3Rpb24pIHtcclxuICAgICAgICAgICAgLy8gQWJvcnQuXHJcbiAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IDIgLyogVHJhbnNhY3Rpb25TdGF0dXMuQ09NUExFVEVEICovO1xyXG4gICAgICAgICAgICAvLyBSZW1vdmluZyBhIGxpc3RlbmVyIGNhbiB0cmlnZ2VyIHBydW5pbmcgd2hpY2ggY2FuIG11Y2sgd2l0aFxyXG4gICAgICAgICAgICAvLyBtZXJnZWREYXRhL3Zpc2libGVEYXRhIChhcyBpdCBwcnVuZXMgZGF0YSkuIFNvIGRlZmVyIHRoZSB1bndhdGNoZXJcclxuICAgICAgICAgICAgLy8gdW50aWwgd2UncmUgZG9uZS5cclxuICAgICAgICAgICAgKGZ1bmN0aW9uICh1bndhdGNoZXIpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodW53YXRjaGVyLCBNYXRoLmZsb29yKDApKTtcclxuICAgICAgICAgICAgfSkocXVldWVbaV0udW53YXRjaGVyKTtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlW2ldLm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhYm9ydFJlYXNvbiA9PT0gJ25vZGF0YScpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaCgoKSA9PiBxdWV1ZVtpXS5vbkNvbXBsZXRlKG51bGwsIGZhbHNlLCBxdWV1ZVtpXS5jdXJyZW50SW5wdXRTbmFwc2hvdCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goKCkgPT4gcXVldWVbaV0ub25Db21wbGV0ZShuZXcgRXJyb3IoYWJvcnRSZWFzb24pLCBmYWxzZSwgbnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ2xlYW4gdXAgY29tcGxldGVkIHRyYW5zYWN0aW9ucy5cclxuICAgIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCByZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXyk7XHJcbiAgICAvLyBOb3cgZmlyZSBjYWxsYmFja3MsIG5vdyB0aGF0IHdlJ3JlIGluIGEgZ29vZCwga25vd24gc3RhdGUuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGV4Y2VwdGlvbkd1YXJkKGNhbGxiYWNrc1tpXSk7XHJcbiAgICB9XHJcbiAgICAvLyBUcnkgdG8gc2VuZCB0aGUgdHJhbnNhY3Rpb24gcmVzdWx0IHRvIHRoZSBzZXJ2ZXIuXHJcbiAgICByZXBvU2VuZFJlYWR5VHJhbnNhY3Rpb25zKHJlcG8sIHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgcm9vdG1vc3QgYW5jZXN0b3Igbm9kZSBvZiB0aGUgc3BlY2lmaWVkIHBhdGggdGhhdCBoYXMgYSBwZW5kaW5nXHJcbiAqIHRyYW5zYWN0aW9uIG9uIGl0LCBvciBqdXN0IHJldHVybnMgdGhlIG5vZGUgZm9yIHRoZSBnaXZlbiBwYXRoIGlmIHRoZXJlIGFyZVxyXG4gKiBubyBwZW5kaW5nIHRyYW5zYWN0aW9ucyBvbiBhbnkgYW5jZXN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGxvY2F0aW9uIHRvIHN0YXJ0IGF0LlxyXG4gKiBAcmV0dXJucyBUaGUgcm9vdG1vc3Qgbm9kZSB3aXRoIGEgdHJhbnNhY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvR2V0QW5jZXN0b3JUcmFuc2FjdGlvbk5vZGUocmVwbywgcGF0aCkge1xyXG4gICAgbGV0IGZyb250O1xyXG4gICAgLy8gU3RhcnQgYXQgdGhlIHJvb3QgYW5kIHdhbGsgZGVlcGVyIGludG8gdGhlIHRyZWUgdG93YXJkcyBwYXRoIHVudGlsIHdlXHJcbiAgICAvLyBmaW5kIGEgbm9kZSB3aXRoIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxyXG4gICAgbGV0IHRyYW5zYWN0aW9uTm9kZSA9IHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfO1xyXG4gICAgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICB3aGlsZSAoZnJvbnQgIT09IG51bGwgJiYgdHJlZUdldFZhbHVlKHRyYW5zYWN0aW9uTm9kZSkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRyYW5zYWN0aW9uTm9kZSA9IHRyZWVTdWJUcmVlKHRyYW5zYWN0aW9uTm9kZSwgZnJvbnQpO1xyXG4gICAgICAgIHBhdGggPSBwYXRoUG9wRnJvbnQocGF0aCk7XHJcbiAgICAgICAgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25Ob2RlO1xyXG59XHJcbi8qKlxyXG4gKiBCdWlsZHMgdGhlIHF1ZXVlIG9mIGFsbCB0cmFuc2FjdGlvbnMgYXQgb3IgYmVsb3cgdGhlIHNwZWNpZmllZFxyXG4gKiB0cmFuc2FjdGlvbk5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB0cmFuc2FjdGlvbk5vZGVcclxuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBxdWV1ZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9CdWlsZFRyYW5zYWN0aW9uUXVldWUocmVwbywgdHJhbnNhY3Rpb25Ob2RlKSB7XHJcbiAgICAvLyBXYWxrIGFueSBjaGlsZCB0cmFuc2FjdGlvbiBxdWV1ZXMgYW5kIGFnZ3JlZ2F0ZSB0aGVtIGludG8gYSBzaW5nbGUgcXVldWUuXHJcbiAgICBjb25zdCB0cmFuc2FjdGlvblF1ZXVlID0gW107XHJcbiAgICByZXBvQWdncmVnYXRlVHJhbnNhY3Rpb25RdWV1ZXNGb3JOb2RlKHJlcG8sIHRyYW5zYWN0aW9uTm9kZSwgdHJhbnNhY3Rpb25RdWV1ZSk7XHJcbiAgICAvLyBTb3J0IHRoZW0gYnkgdGhlIG9yZGVyIHRoZSB0cmFuc2FjdGlvbnMgd2VyZSBjcmVhdGVkLlxyXG4gICAgdHJhbnNhY3Rpb25RdWV1ZS5zb3J0KChhLCBiKSA9PiBhLm9yZGVyIC0gYi5vcmRlcik7XHJcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25RdWV1ZTtcclxufVxyXG5mdW5jdGlvbiByZXBvQWdncmVnYXRlVHJhbnNhY3Rpb25RdWV1ZXNGb3JOb2RlKHJlcG8sIG5vZGUsIHF1ZXVlKSB7XHJcbiAgICBjb25zdCBub2RlUXVldWUgPSB0cmVlR2V0VmFsdWUobm9kZSk7XHJcbiAgICBpZiAobm9kZVF1ZXVlKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlUXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcXVldWUucHVzaChub2RlUXVldWVbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRyZWVGb3JFYWNoQ2hpbGQobm9kZSwgY2hpbGQgPT4ge1xyXG4gICAgICAgIHJlcG9BZ2dyZWdhdGVUcmFuc2FjdGlvblF1ZXVlc0Zvck5vZGUocmVwbywgY2hpbGQsIHF1ZXVlKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmUgQ09NUExFVEVEIHRyYW5zYWN0aW9ucyBhdCBvciBiZWxvdyB0aGlzIG5vZGUgaW4gdGhlIHRyYW5zYWN0aW9uUXVldWVUcmVlXy5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCBub2RlKSB7XHJcbiAgICBjb25zdCBxdWV1ZSA9IHRyZWVHZXRWYWx1ZShub2RlKTtcclxuICAgIGlmIChxdWV1ZSkge1xyXG4gICAgICAgIGxldCB0byA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgZnJvbSA9IDA7IGZyb20gPCBxdWV1ZS5sZW5ndGg7IGZyb20rKykge1xyXG4gICAgICAgICAgICBpZiAocXVldWVbZnJvbV0uc3RhdHVzICE9PSAyIC8qIFRyYW5zYWN0aW9uU3RhdHVzLkNPTVBMRVRFRCAqLykge1xyXG4gICAgICAgICAgICAgICAgcXVldWVbdG9dID0gcXVldWVbZnJvbV07XHJcbiAgICAgICAgICAgICAgICB0bysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IHRvO1xyXG4gICAgICAgIHRyZWVTZXRWYWx1ZShub2RlLCBxdWV1ZS5sZW5ndGggPiAwID8gcXVldWUgOiB1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgdHJlZUZvckVhY2hDaGlsZChub2RlLCBjaGlsZE5vZGUgPT4ge1xyXG4gICAgICAgIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCBjaGlsZE5vZGUpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEFib3J0cyBhbGwgdHJhbnNhY3Rpb25zIG9uIGFuY2VzdG9ycyBvciBkZXNjZW5kYW50cyBvZiB0aGUgc3BlY2lmaWVkIHBhdGguXHJcbiAqIENhbGxlZCB3aGVuIGRvaW5nIGEgc2V0KCkgb3IgdXBkYXRlKCkgc2luY2Ugd2UgY29uc2lkZXIgdGhlbSBpbmNvbXBhdGlibGVcclxuICogd2l0aCB0cmFuc2FjdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gUGF0aCBmb3Igd2hpY2ggd2Ugd2FudCB0byBhYm9ydCByZWxhdGVkIHRyYW5zYWN0aW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9BYm9ydFRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoKSB7XHJcbiAgICBjb25zdCBhZmZlY3RlZFBhdGggPSB0cmVlR2V0UGF0aChyZXBvR2V0QW5jZXN0b3JUcmFuc2FjdGlvbk5vZGUocmVwbywgcGF0aCkpO1xyXG4gICAgY29uc3QgdHJhbnNhY3Rpb25Ob2RlID0gdHJlZVN1YlRyZWUocmVwby50cmFuc2FjdGlvblF1ZXVlVHJlZV8sIHBhdGgpO1xyXG4gICAgdHJlZUZvckVhY2hBbmNlc3Rvcih0cmFuc2FjdGlvbk5vZGUsIChub2RlKSA9PiB7XHJcbiAgICAgICAgcmVwb0Fib3J0VHJhbnNhY3Rpb25zT25Ob2RlKHJlcG8sIG5vZGUpO1xyXG4gICAgfSk7XHJcbiAgICByZXBvQWJvcnRUcmFuc2FjdGlvbnNPbk5vZGUocmVwbywgdHJhbnNhY3Rpb25Ob2RlKTtcclxuICAgIHRyZWVGb3JFYWNoRGVzY2VuZGFudCh0cmFuc2FjdGlvbk5vZGUsIChub2RlKSA9PiB7XHJcbiAgICAgICAgcmVwb0Fib3J0VHJhbnNhY3Rpb25zT25Ob2RlKHJlcG8sIG5vZGUpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gYWZmZWN0ZWRQYXRoO1xyXG59XHJcbi8qKlxyXG4gKiBBYm9ydCB0cmFuc2FjdGlvbnMgc3RvcmVkIGluIHRoaXMgdHJhbnNhY3Rpb24gcXVldWUgbm9kZS5cclxuICpcclxuICogQHBhcmFtIG5vZGUgLSBOb2RlIHRvIGFib3J0IHRyYW5zYWN0aW9ucyBmb3IuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvQWJvcnRUcmFuc2FjdGlvbnNPbk5vZGUocmVwbywgbm9kZSkge1xyXG4gICAgY29uc3QgcXVldWUgPSB0cmVlR2V0VmFsdWUobm9kZSk7XHJcbiAgICBpZiAocXVldWUpIHtcclxuICAgICAgICAvLyBRdWV1ZSB1cCB0aGUgY2FsbGJhY2tzIGFuZCBmaXJlIHRoZW0gYWZ0ZXIgY2xlYW5pbmcgdXAgYWxsIG9mIG91clxyXG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIHN0YXRlLCBzaW5jZSB0aGUgY2FsbGJhY2sgY291bGQgdHJpZ2dlciBtb3JlIHRyYW5zYWN0aW9uc1xyXG4gICAgICAgIC8vIG9yIHNldHMuXHJcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgLy8gR28gdGhyb3VnaCBxdWV1ZS4gIEFueSBhbHJlYWR5LXNlbnQgdHJhbnNhY3Rpb25zIG11c3QgYmUgbWFya2VkIGZvclxyXG4gICAgICAgIC8vIGFib3J0LCB3aGlsZSB0aGUgdW5zZW50IG9uZXMgY2FuIGJlIGltbWVkaWF0ZWx5IGFib3J0ZWQgYW5kIHJlbW92ZWQuXHJcbiAgICAgICAgbGV0IGV2ZW50cyA9IFtdO1xyXG4gICAgICAgIGxldCBsYXN0U2VudCA9IC0xO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlW2ldLnN0YXR1cyA9PT0gMyAvKiBUcmFuc2FjdGlvblN0YXR1cy5TRU5UX05FRURTX0FCT1JUICovKSA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHF1ZXVlW2ldLnN0YXR1cyA9PT0gMSAvKiBUcmFuc2FjdGlvblN0YXR1cy5TRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQobGFzdFNlbnQgPT09IGkgLSAxLCAnQWxsIFNFTlQgaXRlbXMgc2hvdWxkIGJlIGF0IGJlZ2lubmluZyBvZiBxdWV1ZS4nKTtcclxuICAgICAgICAgICAgICAgIGxhc3RTZW50ID0gaTtcclxuICAgICAgICAgICAgICAgIC8vIE1hcmsgdHJhbnNhY3Rpb24gZm9yIGFib3J0IHdoZW4gaXQgY29tZXMgYmFjay5cclxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IDMgLyogVHJhbnNhY3Rpb25TdGF0dXMuU0VOVF9ORUVEU19BQk9SVCAqLztcclxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLmFib3J0UmVhc29uID0gJ3NldCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQocXVldWVbaV0uc3RhdHVzID09PSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLywgJ1VuZXhwZWN0ZWQgdHJhbnNhY3Rpb24gc3RhdHVzIGluIGFib3J0Jyk7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gYWJvcnQgaXQgaW1tZWRpYXRlbHkuXHJcbiAgICAgICAgICAgICAgICBxdWV1ZVtpXS51bndhdGNoZXIoKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBY2tVc2VyV3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXVlW2ldLmN1cnJlbnRXcml0ZUlkLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocXVldWVbaV0ub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKHF1ZXVlW2ldLm9uQ29tcGxldGUuYmluZChudWxsLCBuZXcgRXJyb3IoJ3NldCcpLCBmYWxzZSwgbnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYXN0U2VudCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gV2UncmUgbm90IHdhaXRpbmcgZm9yIGFueSBzZW50IHRyYW5zYWN0aW9ucy4gIFdlIGNhbiBjbGVhciB0aGUgcXVldWUuXHJcbiAgICAgICAgICAgIHRyZWVTZXRWYWx1ZShub2RlLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0cmFuc2FjdGlvbnMgd2UgYWJvcnRlZC5cclxuICAgICAgICAgICAgcXVldWUubGVuZ3RoID0gbGFzdFNlbnQgKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOb3cgZmlyZSB0aGUgY2FsbGJhY2tzLlxyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHRyZWVHZXRQYXRoKG5vZGUpLCBldmVudHMpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV4Y2VwdGlvbkd1YXJkKGNhbGxiYWNrc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aFN0cmluZykge1xyXG4gICAgbGV0IHBhdGhTdHJpbmdEZWNvZGVkID0gJyc7XHJcbiAgICBjb25zdCBwaWVjZXMgPSBwYXRoU3RyaW5nLnNwbGl0KCcvJyk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChwaWVjZXNbaV0ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgcGllY2UgPSBwaWVjZXNbaV07XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBwaWVjZSA9IGRlY29kZVVSSUNvbXBvbmVudChwaWVjZS5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgICAgICBwYXRoU3RyaW5nRGVjb2RlZCArPSAnLycgKyBwaWVjZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aFN0cmluZ0RlY29kZWQ7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIGtleSB2YWx1ZSBoYXNoXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWNvZGVRdWVyeShxdWVyeVN0cmluZykge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IHt9O1xyXG4gICAgaWYgKHF1ZXJ5U3RyaW5nLmNoYXJBdCgwKSA9PT0gJz8nKSB7XHJcbiAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5zdWJzdHJpbmcoMSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcXVlcnlTdHJpbmcuc3BsaXQoJyYnKSkge1xyXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga3YgPSBzZWdtZW50LnNwbGl0KCc9Jyk7XHJcbiAgICAgICAgaWYgKGt2Lmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICByZXN1bHRzW2RlY29kZVVSSUNvbXBvbmVudChrdlswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KGt2WzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgcXVlcnkgc2VnbWVudCAnJHtzZWdtZW50fScgaW4gcXVlcnkgJyR7cXVlcnlTdHJpbmd9J2ApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG59XHJcbmNvbnN0IHBhcnNlUmVwb0luZm8gPSBmdW5jdGlvbiAoZGF0YVVSTCwgbm9kZUFkbWluKSB7XHJcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBwYXJzZURhdGFiYXNlVVJMKGRhdGFVUkwpLCBuYW1lc3BhY2UgPSBwYXJzZWRVcmwubmFtZXNwYWNlO1xyXG4gICAgaWYgKHBhcnNlZFVybC5kb21haW4gPT09ICdmaXJlYmFzZS5jb20nKSB7XHJcbiAgICAgICAgZmF0YWwocGFyc2VkVXJsLmhvc3QgK1xyXG4gICAgICAgICAgICAnIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuICcgK1xyXG4gICAgICAgICAgICAnUGxlYXNlIHVzZSA8WU9VUiBGSVJFQkFTRT4uZmlyZWJhc2Vpby5jb20gaW5zdGVhZCcpO1xyXG4gICAgfVxyXG4gICAgLy8gQ2F0Y2ggY29tbW9uIGVycm9yIG9mIHVuaW5pdGlhbGl6ZWQgbmFtZXNwYWNlIHZhbHVlLlxyXG4gICAgaWYgKCghbmFtZXNwYWNlIHx8IG5hbWVzcGFjZSA9PT0gJ3VuZGVmaW5lZCcpICYmXHJcbiAgICAgICAgcGFyc2VkVXJsLmRvbWFpbiAhPT0gJ2xvY2FsaG9zdCcpIHtcclxuICAgICAgICBmYXRhbCgnQ2Fubm90IHBhcnNlIEZpcmViYXNlIHVybC4gUGxlYXNlIHVzZSBodHRwczovLzxZT1VSIEZJUkVCQVNFPi5maXJlYmFzZWlvLmNvbScpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFwYXJzZWRVcmwuc2VjdXJlKSB7XHJcbiAgICAgICAgd2FybklmUGFnZUlzU2VjdXJlKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB3ZWJTb2NrZXRPbmx5ID0gcGFyc2VkVXJsLnNjaGVtZSA9PT0gJ3dzJyB8fCBwYXJzZWRVcmwuc2NoZW1lID09PSAnd3NzJztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVwb0luZm86IG5ldyBSZXBvSW5mbyhwYXJzZWRVcmwuaG9zdCwgcGFyc2VkVXJsLnNlY3VyZSwgbmFtZXNwYWNlLCB3ZWJTb2NrZXRPbmx5LCBub2RlQWRtaW4sIFxyXG4gICAgICAgIC8qcGVyc2lzdGVuY2VLZXk9Ki8gJycsIFxyXG4gICAgICAgIC8qaW5jbHVkZU5hbWVzcGFjZUluUXVlcnlQYXJhbXM9Ki8gbmFtZXNwYWNlICE9PSBwYXJzZWRVcmwuc3ViZG9tYWluKSxcclxuICAgICAgICBwYXRoOiBuZXcgUGF0aChwYXJzZWRVcmwucGF0aFN0cmluZylcclxuICAgIH07XHJcbn07XHJcbmNvbnN0IHBhcnNlRGF0YWJhc2VVUkwgPSBmdW5jdGlvbiAoZGF0YVVSTCkge1xyXG4gICAgLy8gRGVmYXVsdCB0byBlbXB0eSBzdHJpbmdzIGluIHRoZSBldmVudCBvZiBhIG1hbGZvcm1lZCBzdHJpbmcuXHJcbiAgICBsZXQgaG9zdCA9ICcnLCBkb21haW4gPSAnJywgc3ViZG9tYWluID0gJycsIHBhdGhTdHJpbmcgPSAnJywgbmFtZXNwYWNlID0gJyc7XHJcbiAgICAvLyBBbHdheXMgZGVmYXVsdCB0byBTU0wsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxyXG4gICAgbGV0IHNlY3VyZSA9IHRydWUsIHNjaGVtZSA9ICdodHRwcycsIHBvcnQgPSA0NDM7XHJcbiAgICAvLyBEb24ndCBkbyBhbnkgdmFsaWRhdGlvbiBoZXJlLiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciB2YWxpZGF0aW5nIHRoZSByZXN1bHQgb2YgcGFyc2luZy5cclxuICAgIGlmICh0eXBlb2YgZGF0YVVSTCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAvLyBQYXJzZSBzY2hlbWUuXHJcbiAgICAgICAgbGV0IGNvbG9uSW5kID0gZGF0YVVSTC5pbmRleE9mKCcvLycpO1xyXG4gICAgICAgIGlmIChjb2xvbkluZCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHNjaGVtZSA9IGRhdGFVUkwuc3Vic3RyaW5nKDAsIGNvbG9uSW5kIC0gMSk7XHJcbiAgICAgICAgICAgIGRhdGFVUkwgPSBkYXRhVVJMLnN1YnN0cmluZyhjb2xvbkluZCArIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQYXJzZSBob3N0LCBwYXRoLCBhbmQgcXVlcnkgc3RyaW5nLlxyXG4gICAgICAgIGxldCBzbGFzaEluZCA9IGRhdGFVUkwuaW5kZXhPZignLycpO1xyXG4gICAgICAgIGlmIChzbGFzaEluZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgc2xhc2hJbmQgPSBkYXRhVVJMLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHF1ZXN0aW9uTWFya0luZCA9IGRhdGFVUkwuaW5kZXhPZignPycpO1xyXG4gICAgICAgIGlmIChxdWVzdGlvbk1hcmtJbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHF1ZXN0aW9uTWFya0luZCA9IGRhdGFVUkwubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBob3N0ID0gZGF0YVVSTC5zdWJzdHJpbmcoMCwgTWF0aC5taW4oc2xhc2hJbmQsIHF1ZXN0aW9uTWFya0luZCkpO1xyXG4gICAgICAgIGlmIChzbGFzaEluZCA8IHF1ZXN0aW9uTWFya0luZCkge1xyXG4gICAgICAgICAgICAvLyBGb3IgcGF0aFN0cmluZywgcXVlc3Rpb25NYXJrSW5kIHdpbGwgYWx3YXlzIGNvbWUgYWZ0ZXIgc2xhc2hJbmRcclxuICAgICAgICAgICAgcGF0aFN0cmluZyA9IGRlY29kZVBhdGgoZGF0YVVSTC5zdWJzdHJpbmcoc2xhc2hJbmQsIHF1ZXN0aW9uTWFya0luZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IGRlY29kZVF1ZXJ5KGRhdGFVUkwuc3Vic3RyaW5nKE1hdGgubWluKGRhdGFVUkwubGVuZ3RoLCBxdWVzdGlvbk1hcmtJbmQpKSk7XHJcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnQsIHVzZSBzY2hlbWUgZm9yIGRldGVybWluaW5nIGlmIGl0J3Mgc2VjdXJlLlxyXG4gICAgICAgIGNvbG9uSW5kID0gaG9zdC5pbmRleE9mKCc6Jyk7XHJcbiAgICAgICAgaWYgKGNvbG9uSW5kID49IDApIHtcclxuICAgICAgICAgICAgc2VjdXJlID0gc2NoZW1lID09PSAnaHR0cHMnIHx8IHNjaGVtZSA9PT0gJ3dzcyc7XHJcbiAgICAgICAgICAgIHBvcnQgPSBwYXJzZUludChob3N0LnN1YnN0cmluZyhjb2xvbkluZCArIDEpLCAxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb2xvbkluZCA9IGhvc3QubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBob3N0V2l0aG91dFBvcnQgPSBob3N0LnNsaWNlKDAsIGNvbG9uSW5kKTtcclxuICAgICAgICBpZiAoaG9zdFdpdGhvdXRQb3J0LnRvTG93ZXJDYXNlKCkgPT09ICdsb2NhbGhvc3QnKSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9ICdsb2NhbGhvc3QnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChob3N0V2l0aG91dFBvcnQuc3BsaXQoJy4nKS5sZW5ndGggPD0gMikge1xyXG4gICAgICAgICAgICBkb21haW4gPSBob3N0V2l0aG91dFBvcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJbnRlcnByZXQgdGhlIHN1YmRvbWFpbiBvZiBhIDMgb3IgbW9yZSBjb21wb25lbnQgVVJMIGFzIHRoZSBuYW1lc3BhY2UgbmFtZS5cclxuICAgICAgICAgICAgY29uc3QgZG90SW5kID0gaG9zdC5pbmRleE9mKCcuJyk7XHJcbiAgICAgICAgICAgIHN1YmRvbWFpbiA9IGhvc3Quc3Vic3RyaW5nKDAsIGRvdEluZCkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgZG9tYWluID0gaG9zdC5zdWJzdHJpbmcoZG90SW5kICsgMSk7XHJcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBuYW1lc3BhY2VzIHRvIGxvd2VyY2FzZSB0byBzaGFyZSBzdG9yYWdlIC8gY29ubmVjdGlvbi5cclxuICAgICAgICAgICAgbmFtZXNwYWNlID0gc3ViZG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBbHdheXMgdHJlYXQgdGhlIHZhbHVlIG9mIHRoZSBgbnNgIGFzIHRoZSBuYW1lc3BhY2UgbmFtZSBpZiBpdCBpcyBwcmVzZW50LlxyXG4gICAgICAgIGlmICgnbnMnIGluIHF1ZXJ5UGFyYW1zKSB7XHJcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IHF1ZXJ5UGFyYW1zWyducyddO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaG9zdCxcclxuICAgICAgICBwb3J0LFxyXG4gICAgICAgIGRvbWFpbixcclxuICAgICAgICBzdWJkb21haW4sXHJcbiAgICAgICAgc2VjdXJlLFxyXG4gICAgICAgIHNjaGVtZSxcclxuICAgICAgICBwYXRoU3RyaW5nLFxyXG4gICAgICAgIG5hbWVzcGFjZVxyXG4gICAgfTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gTW9kZWxlZCBhZnRlciBiYXNlNjQgd2ViLXNhZmUgY2hhcnMsIGJ1dCBvcmRlcmVkIGJ5IEFTQ0lJLlxyXG5jb25zdCBQVVNIX0NIQVJTID0gJy0wMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xyXG4vKipcclxuICogRmFuY3kgSUQgZ2VuZXJhdG9yIHRoYXQgY3JlYXRlcyAyMC1jaGFyYWN0ZXIgc3RyaW5nIGlkZW50aWZpZXJzIHdpdGggdGhlXHJcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gKlxyXG4gKiAxLiBUaGV5J3JlIGJhc2VkIG9uIHRpbWVzdGFtcCBzbyB0aGF0IHRoZXkgc29ydCAqYWZ0ZXIqIGFueSBleGlzdGluZyBpZHMuXHJcbiAqIDIuIFRoZXkgY29udGFpbiA3Mi1iaXRzIG9mIHJhbmRvbSBkYXRhIGFmdGVyIHRoZSB0aW1lc3RhbXAgc28gdGhhdCBJRHMgd29uJ3RcclxuICogICAgY29sbGlkZSB3aXRoIG90aGVyIGNsaWVudHMnIElEcy5cclxuICogMy4gVGhleSBzb3J0ICpsZXhpY29ncmFwaGljYWxseSogKHNvIHRoZSB0aW1lc3RhbXAgaXMgY29udmVydGVkIHRvIGNoYXJhY3RlcnNcclxuICogICAgdGhhdCB3aWxsIHNvcnQgcHJvcGVybHkpLlxyXG4gKiA0LiBUaGV5J3JlIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZy4gRXZlbiBpZiB5b3UgZ2VuZXJhdGUgbW9yZSB0aGFuIG9uZSBpblxyXG4gKiAgICB0aGUgc2FtZSB0aW1lc3RhbXAsIHRoZSBsYXR0ZXIgb25lcyB3aWxsIHNvcnQgYWZ0ZXIgdGhlIGZvcm1lciBvbmVzLiBXZSBkb1xyXG4gKiAgICB0aGlzIGJ5IHVzaW5nIHRoZSBwcmV2aW91cyByYW5kb20gYml0cyBidXQgXCJpbmNyZW1lbnRpbmdcIiB0aGVtIGJ5IDEgKG9ubHlcclxuICogICAgaW4gdGhlIGNhc2Ugb2YgYSB0aW1lc3RhbXAgY29sbGlzaW9uKS5cclxuICovXHJcbmNvbnN0IG5leHRQdXNoSWQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gVGltZXN0YW1wIG9mIGxhc3QgcHVzaCwgdXNlZCB0byBwcmV2ZW50IGxvY2FsIGNvbGxpc2lvbnMgaWYgeW91IHB1c2ggdHdpY2VcclxuICAgIC8vIGluIG9uZSBtcy5cclxuICAgIGxldCBsYXN0UHVzaFRpbWUgPSAwO1xyXG4gICAgLy8gV2UgZ2VuZXJhdGUgNzItYml0cyBvZiByYW5kb21uZXNzIHdoaWNoIGdldCB0dXJuZWQgaW50byAxMiBjaGFyYWN0ZXJzIGFuZFxyXG4gICAgLy8gYXBwZW5kZWQgdG8gdGhlIHRpbWVzdGFtcCB0byBwcmV2ZW50IGNvbGxpc2lvbnMgd2l0aCBvdGhlciBjbGllbnRzLiBXZVxyXG4gICAgLy8gc3RvcmUgdGhlIGxhc3QgY2hhcmFjdGVycyB3ZSBnZW5lcmF0ZWQgYmVjYXVzZSBpbiB0aGUgZXZlbnQgb2YgYSBjb2xsaXNpb24sXHJcbiAgICAvLyB3ZSdsbCB1c2UgdGhvc2Ugc2FtZSBjaGFyYWN0ZXJzIGV4Y2VwdCBcImluY3JlbWVudGVkXCIgYnkgb25lLlxyXG4gICAgY29uc3QgbGFzdFJhbmRDaGFycyA9IFtdO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub3cpIHtcclxuICAgICAgICBjb25zdCBkdXBsaWNhdGVUaW1lID0gbm93ID09PSBsYXN0UHVzaFRpbWU7XHJcbiAgICAgICAgbGFzdFB1c2hUaW1lID0gbm93O1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGNvbnN0IHRpbWVTdGFtcENoYXJzID0gbmV3IEFycmF5KDgpO1xyXG4gICAgICAgIGZvciAoaSA9IDc7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHRpbWVTdGFtcENoYXJzW2ldID0gUFVTSF9DSEFSUy5jaGFyQXQobm93ICUgNjQpO1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBDYW4ndCB1c2UgPDwgaGVyZSBiZWNhdXNlIGphdmFzY3JpcHQgd2lsbCBjb252ZXJ0IHRvIGludCBhbmQgbG9zZVxyXG4gICAgICAgICAgICAvLyB0aGUgdXBwZXIgYml0cy5cclxuICAgICAgICAgICAgbm93ID0gTWF0aC5mbG9vcihub3cgLyA2NCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydChub3cgPT09IDAsICdDYW5ub3QgcHVzaCBhdCB0aW1lID09IDAnKTtcclxuICAgICAgICBsZXQgaWQgPSB0aW1lU3RhbXBDaGFycy5qb2luKCcnKTtcclxuICAgICAgICBpZiAoIWR1cGxpY2F0ZVRpbWUpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxhc3RSYW5kQ2hhcnNbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA2NCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSB0aW1lc3RhbXAgaGFzbid0IGNoYW5nZWQgc2luY2UgbGFzdCBwdXNoLCB1c2UgdGhlIHNhbWUgcmFuZG9tXHJcbiAgICAgICAgICAgIC8vIG51bWJlciwgZXhjZXB0IGluY3JlbWVudGVkIGJ5IDEuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDExOyBpID49IDAgJiYgbGFzdFJhbmRDaGFyc1tpXSA9PT0gNjM7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgbGFzdFJhbmRDaGFyc1tpXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFzdFJhbmRDaGFyc1tpXSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgICAgICBpZCArPSBQVVNIX0NIQVJTLmNoYXJBdChsYXN0UmFuZENoYXJzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0KGlkLmxlbmd0aCA9PT0gMjAsICduZXh0UHVzaElkOiBMZW5ndGggc2hvdWxkIGJlIDIwLicpO1xyXG4gICAgICAgIHJldHVybiBpZDtcclxuICAgIH07XHJcbn0pKCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBFbmNhcHN1bGF0ZXMgdGhlIGRhdGEgbmVlZGVkIHRvIHJhaXNlIGFuIGV2ZW50XHJcbiAqL1xyXG5jbGFzcyBEYXRhRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gT25lIG9mOiB2YWx1ZSwgY2hpbGRfYWRkZWQsIGNoaWxkX2NoYW5nZWQsIGNoaWxkX21vdmVkLCBjaGlsZF9yZW1vdmVkXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRSZWdpc3RyYXRpb24gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB0byB3aXRoIHRoZSBldmVudCBkYXRhLiBVc2VyIHByb3ZpZGVkXHJcbiAgICAgKiBAcGFyYW0gc25hcHNob3QgLSBUaGUgZGF0YSBiYWNraW5nIHRoZSBldmVudFxyXG4gICAgICogQHBhcmFtIHByZXZOYW1lIC0gT3B0aW9uYWwsIHRoZSBuYW1lIG9mIHRoZSBwcmV2aW91cyBjaGlsZCBmb3IgY2hpbGRfKiBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGV2ZW50VHlwZSwgZXZlbnRSZWdpc3RyYXRpb24sIHNuYXBzaG90LCBwcmV2TmFtZSkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xyXG4gICAgICAgIHRoaXMuZXZlbnRSZWdpc3RyYXRpb24gPSBldmVudFJlZ2lzdHJhdGlvbjtcclxuICAgICAgICB0aGlzLnNuYXBzaG90ID0gc25hcHNob3Q7XHJcbiAgICAgICAgdGhpcy5wcmV2TmFtZSA9IHByZXZOYW1lO1xyXG4gICAgfVxyXG4gICAgZ2V0UGF0aCgpIHtcclxuICAgICAgICBjb25zdCByZWYgPSB0aGlzLnNuYXBzaG90LnJlZjtcclxuICAgICAgICBpZiAodGhpcy5ldmVudFR5cGUgPT09ICd2YWx1ZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZi5fcGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWYucGFyZW50Ll9wYXRoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEV2ZW50VHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFR5cGU7XHJcbiAgICB9XHJcbiAgICBnZXRFdmVudFJ1bm5lcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFJlZ2lzdHJhdGlvbi5nZXRFdmVudFJ1bm5lcih0aGlzKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5nZXRQYXRoKCkudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICc6JyArXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRUeXBlICtcclxuICAgICAgICAgICAgJzonICtcclxuICAgICAgICAgICAgc3RyaW5naWZ5KHRoaXMuc25hcHNob3QuZXhwb3J0VmFsKCkpKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDYW5jZWxFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihldmVudFJlZ2lzdHJhdGlvbiwgZXJyb3IsIHBhdGgpIHtcclxuICAgICAgICB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uID0gZXZlbnRSZWdpc3RyYXRpb247XHJcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICB9XHJcbiAgICBnZXRQYXRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGg7XHJcbiAgICB9XHJcbiAgICBnZXRFdmVudFR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuICdjYW5jZWwnO1xyXG4gICAgfVxyXG4gICAgZ2V0RXZlbnRSdW5uZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRSZWdpc3RyYXRpb24uZ2V0RXZlbnRSdW5uZXIodGhpcyk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLnRvU3RyaW5nKCkgKyAnOmNhbmNlbCc7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgd3JhcHBlciBjbGFzcyB0aGF0IGNvbnZlcnRzIGV2ZW50cyBmcm9tIHRoZSBkYXRhYmFzZUBleHAgU0RLIHRvIHRoZSBsZWdhY3lcclxuICogRGF0YWJhc2UgU0RLLiBFdmVudHMgYXJlIG5vdCBjb252ZXJ0ZWQgZGlyZWN0bHkgYXMgZXZlbnQgcmVnaXN0cmF0aW9uIHJlbGllc1xyXG4gKiBvbiByZWZlcmVuY2UgY29tcGFyaXNvbiBvZiB0aGUgb3JpZ2luYWwgdXNlciBjYWxsYmFjayAoc2VlIGBtYXRjaGVzKClgKSBhbmRcclxuICogcmVsaWVzIG9uIGVxdWFsaXR5IG9mIHRoZSBsZWdhY3kgU0RLJ3MgYGNvbnRleHRgIG9iamVjdC5cclxuICovXHJcbmNsYXNzIENhbGxiYWNrQ29udGV4dCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzbmFwc2hvdENhbGxiYWNrLCBjYW5jZWxDYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuc25hcHNob3RDYWxsYmFjayA9IHNuYXBzaG90Q2FsbGJhY2s7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxDYWxsYmFjayA9IGNhbmNlbENhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgb25WYWx1ZShleHBEYXRhU25hcHNob3QsIHByZXZpb3VzQ2hpbGROYW1lKSB7XHJcbiAgICAgICAgdGhpcy5zbmFwc2hvdENhbGxiYWNrLmNhbGwobnVsbCwgZXhwRGF0YVNuYXBzaG90LCBwcmV2aW91c0NoaWxkTmFtZSk7XHJcbiAgICB9XHJcbiAgICBvbkNhbmNlbChlcnJvcikge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLmhhc0NhbmNlbENhbGxiYWNrLCAnUmFpc2luZyBhIGNhbmNlbCBldmVudCBvbiBhIGxpc3RlbmVyIHdpdGggbm8gY2FuY2VsIGNhbGxiYWNrJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuY2VsQ2FsbGJhY2suY2FsbChudWxsLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgICBnZXQgaGFzQ2FuY2VsQ2FsbGJhY2soKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5jYW5jZWxDYWxsYmFjaztcclxuICAgIH1cclxuICAgIG1hdGNoZXMob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc25hcHNob3RDYWxsYmFjayA9PT0gb3RoZXIuc25hcHNob3RDYWxsYmFjayB8fFxyXG4gICAgICAgICAgICAodGhpcy5zbmFwc2hvdENhbGxiYWNrLnVzZXJDYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNuYXBzaG90Q2FsbGJhY2sudXNlckNhbGxiYWNrID09PVxyXG4gICAgICAgICAgICAgICAgICAgIG90aGVyLnNuYXBzaG90Q2FsbGJhY2sudXNlckNhbGxiYWNrICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNuYXBzaG90Q2FsbGJhY2suY29udGV4dCA9PT0gb3RoZXIuc25hcHNob3RDYWxsYmFjay5jb250ZXh0KSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBgb25EaXNjb25uZWN0YCBjbGFzcyBhbGxvd3MgeW91IHRvIHdyaXRlIG9yIGNsZWFyIGRhdGEgd2hlbiB5b3VyIGNsaWVudFxyXG4gKiBkaXNjb25uZWN0cyBmcm9tIHRoZSBEYXRhYmFzZSBzZXJ2ZXIuIFRoZXNlIHVwZGF0ZXMgb2NjdXIgd2hldGhlciB5b3VyXHJcbiAqIGNsaWVudCBkaXNjb25uZWN0cyBjbGVhbmx5IG9yIG5vdCwgc28geW91IGNhbiByZWx5IG9uIHRoZW0gdG8gY2xlYW4gdXAgZGF0YVxyXG4gKiBldmVuIGlmIGEgY29ubmVjdGlvbiBpcyBkcm9wcGVkIG9yIGEgY2xpZW50IGNyYXNoZXMuXHJcbiAqXHJcbiAqIFRoZSBgb25EaXNjb25uZWN0YCBjbGFzcyBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgdG8gbWFuYWdlIHByZXNlbmNlIGluXHJcbiAqIGFwcGxpY2F0aW9ucyB3aGVyZSBpdCBpcyB1c2VmdWwgdG8gZGV0ZWN0IGhvdyBtYW55IGNsaWVudHMgYXJlIGNvbm5lY3RlZCBhbmRcclxuICogd2hlbiBvdGhlciBjbGllbnRzIGRpc2Nvbm5lY3QuIFNlZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL29mZmxpbmUtY2FwYWJpbGl0aWVzIHwgRW5hYmxpbmcgT2ZmbGluZSBDYXBhYmlsaXRpZXMgaW4gSmF2YVNjcmlwdH1cclxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFRvIGF2b2lkIHByb2JsZW1zIHdoZW4gYSBjb25uZWN0aW9uIGlzIGRyb3BwZWQgYmVmb3JlIHRoZSByZXF1ZXN0cyBjYW4gYmVcclxuICogdHJhbnNmZXJyZWQgdG8gdGhlIERhdGFiYXNlIHNlcnZlciwgdGhlc2UgZnVuY3Rpb25zIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlXHJcbiAqIHdyaXRpbmcgYW55IGRhdGEuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgb25EaXNjb25uZWN0YCBvcGVyYXRpb25zIGFyZSBvbmx5IHRyaWdnZXJlZCBvbmNlLiBJZiB5b3Ugd2FudCBhblxyXG4gKiBvcGVyYXRpb24gdG8gb2NjdXIgZWFjaCB0aW1lIGEgZGlzY29ubmVjdCBvY2N1cnMsIHlvdSdsbCBuZWVkIHRvIHJlLWVzdGFibGlzaFxyXG4gKiB0aGUgYG9uRGlzY29ubmVjdGAgb3BlcmF0aW9ucyBlYWNoIHRpbWUgeW91IHJlY29ubmVjdC5cclxuICovXHJcbmNsYXNzIE9uRGlzY29ubmVjdCB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoX3JlcG8sIF9wYXRoKSB7XHJcbiAgICAgICAgdGhpcy5fcmVwbyA9IF9yZXBvO1xyXG4gICAgICAgIHRoaXMuX3BhdGggPSBfcGF0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FuY2VscyBhbGwgcHJldmlvdXNseSBxdWV1ZWQgYG9uRGlzY29ubmVjdCgpYCBzZXQgb3IgdXBkYXRlIGV2ZW50cyBmb3IgdGhpc1xyXG4gICAgICogbG9jYXRpb24gYW5kIGFsbCBjaGlsZHJlbi5cclxuICAgICAqXHJcbiAgICAgKiBJZiBhIHdyaXRlIGhhcyBiZWVuIHF1ZXVlZCBmb3IgdGhpcyBsb2NhdGlvbiB2aWEgYSBgc2V0KClgIG9yIGB1cGRhdGUoKWAgYXQgYVxyXG4gICAgICogcGFyZW50IGxvY2F0aW9uLCB0aGUgd3JpdGUgYXQgdGhpcyBsb2NhdGlvbiB3aWxsIGJlIGNhbmNlbGVkLCB0aG91Z2ggd3JpdGVzXHJcbiAgICAgKiB0byBzaWJsaW5nIGxvY2F0aW9ucyB3aWxsIHN0aWxsIG9jY3VyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIHRoZSBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHJlcG9PbkRpc2Nvbm5lY3RDYW5jZWwodGhpcy5fcmVwbywgdGhpcy5fcGF0aCwgZGVmZXJyZWQud3JhcENhbGxiYWNrKCgpID0+IHsgfSkpO1xyXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmVzIHRoZSBkYXRhIGF0IHRoaXMgbG9jYXRpb24gaXMgZGVsZXRlZCB3aGVuIHRoZSBjbGllbnQgaXMgZGlzY29ubmVjdGVkXHJcbiAgICAgKiAoZHVlIHRvIGNsb3NpbmcgdGhlIGJyb3dzZXIsIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZSwgb3IgbmV0d29yayBpc3N1ZXMpLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIHRoZSBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZSgpIHtcclxuICAgICAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnT25EaXNjb25uZWN0LnJlbW92ZScsIHRoaXMuX3BhdGgpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgcmVwb09uRGlzY29ubmVjdFNldCh0aGlzLl9yZXBvLCB0aGlzLl9wYXRoLCBudWxsLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiBpcyBzZXQgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZSB3aGVuIHRoZVxyXG4gICAgICogY2xpZW50IGlzIGRpc2Nvbm5lY3RlZCAoZHVlIHRvIGNsb3NpbmcgdGhlIGJyb3dzZXIsIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZSxcclxuICAgICAqIG9yIG5ldHdvcmsgaXNzdWVzKS5cclxuICAgICAqXHJcbiAgICAgKiBgc2V0KClgIGlzIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBpbXBsZW1lbnRpbmcgXCJwcmVzZW5jZVwiIHN5c3RlbXMsIHdoZXJlIGFcclxuICAgICAqIHZhbHVlIHNob3VsZCBiZSBjaGFuZ2VkIG9yIGNsZWFyZWQgd2hlbiBhIHVzZXIgZGlzY29ubmVjdHMgc28gdGhhdCB0aGV5XHJcbiAgICAgKiBhcHBlYXIgXCJvZmZsaW5lXCIgdG8gb3RoZXIgdXNlcnMuIFNlZVxyXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9vZmZsaW5lLWNhcGFiaWxpdGllcyB8IEVuYWJsaW5nIE9mZmxpbmUgQ2FwYWJpbGl0aWVzIGluIEphdmFTY3JpcHR9XHJcbiAgICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIHRoYXQgYG9uRGlzY29ubmVjdGAgb3BlcmF0aW9ucyBhcmUgb25seSB0cmlnZ2VyZWQgb25jZS4gSWYgeW91IHdhbnQgYW5cclxuICAgICAqIG9wZXJhdGlvbiB0byBvY2N1ciBlYWNoIHRpbWUgYSBkaXNjb25uZWN0IG9jY3VycywgeW91J2xsIG5lZWQgdG8gcmUtZXN0YWJsaXNoXHJcbiAgICAgKiB0aGUgYG9uRGlzY29ubmVjdGAgb3BlcmF0aW9ucyBlYWNoIHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4gdG8gdGhpcyBsb2NhdGlvbiBvbiBkaXNjb25uZWN0IChjYW5cclxuICAgICAqIGJlIGFuIG9iamVjdCwgYXJyYXksIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBudWxsKS5cclxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIHRoZSBEYXRhYmFzZSBpcyBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgc2V0KHZhbHVlKSB7XHJcbiAgICAgICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ09uRGlzY29ubmVjdC5zZXQnLCB0aGlzLl9wYXRoKTtcclxuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnT25EaXNjb25uZWN0LnNldCcsIHZhbHVlLCB0aGlzLl9wYXRoLCBmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICByZXBvT25EaXNjb25uZWN0U2V0KHRoaXMuX3JlcG8sIHRoaXMuX3BhdGgsIHZhbHVlLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiBpcyBzZXQgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZSBhbmQgcHJpb3JpdHlcclxuICAgICAqIHdoZW4gdGhlIGNsaWVudCBpcyBkaXNjb25uZWN0ZWQgKGR1ZSB0byBjbG9zaW5nIHRoZSBicm93c2VyLCBuYXZpZ2F0aW5nIHRvIGFcclxuICAgICAqIG5ldyBwYWdlLCBvciBuZXR3b3JrIGlzc3VlcykuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4gdG8gdGhpcyBsb2NhdGlvbiBvbiBkaXNjb25uZWN0IChjYW5cclxuICAgICAqIGJlIGFuIG9iamVjdCwgYXJyYXksIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBudWxsKS5cclxuICAgICAqIEBwYXJhbSBwcmlvcml0eSAtIFRoZSBwcmlvcml0eSB0byBiZSB3cml0dGVuIChzdHJpbmcsIG51bWJlciwgb3IgbnVsbCkuXHJcbiAgICAgKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHN5bmNocm9uaXphdGlvbiB0byB0aGUgRGF0YWJhc2UgaXMgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIHNldFdpdGhQcmlvcml0eSh2YWx1ZSwgcHJpb3JpdHkpIHtcclxuICAgICAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnT25EaXNjb25uZWN0LnNldFdpdGhQcmlvcml0eScsIHRoaXMuX3BhdGgpO1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdPbkRpc2Nvbm5lY3Quc2V0V2l0aFByaW9yaXR5JywgdmFsdWUsIHRoaXMuX3BhdGgsIGZhbHNlKTtcclxuICAgICAgICB2YWxpZGF0ZVByaW9yaXR5KCdPbkRpc2Nvbm5lY3Quc2V0V2l0aFByaW9yaXR5JywgcHJpb3JpdHksIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHJlcG9PbkRpc2Nvbm5lY3RTZXRXaXRoUHJpb3JpdHkodGhpcy5fcmVwbywgdGhpcy5fcGF0aCwgdmFsdWUsIHByaW9yaXR5LCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBtdWx0aXBsZSB2YWx1ZXMgYXQgdGhpcyBsb2NhdGlvbiB3aGVuIHRoZSBjbGllbnQgaXMgZGlzY29ubmVjdGVkIChkdWVcclxuICAgICAqIHRvIGNsb3NpbmcgdGhlIGJyb3dzZXIsIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZSwgb3IgbmV0d29yayBpc3N1ZXMpLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBgdmFsdWVzYCBhcmd1bWVudCBjb250YWlucyBtdWx0aXBsZSBwcm9wZXJ0eS12YWx1ZSBwYWlycyB0aGF0IHdpbGwgYmVcclxuICAgICAqIHdyaXR0ZW4gdG8gdGhlIERhdGFiYXNlIHRvZ2V0aGVyLiBFYWNoIGNoaWxkIHByb3BlcnR5IGNhbiBlaXRoZXIgYmUgYSBzaW1wbGVcclxuICAgICAqIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgXCJuYW1lXCIpIG9yIGEgcmVsYXRpdmUgcGF0aCAoZm9yIGV4YW1wbGUsIFwibmFtZS9maXJzdFwiKVxyXG4gICAgICogZnJvbSB0aGUgY3VycmVudCBsb2NhdGlvbiB0byB0aGUgZGF0YSB0byB1cGRhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQXMgb3Bwb3NlZCB0byB0aGUgYHNldCgpYCBtZXRob2QsIGB1cGRhdGUoKWAgY2FuIGJlIHVzZSB0byBzZWxlY3RpdmVseSB1cGRhdGVcclxuICAgICAqIG9ubHkgdGhlIHJlZmVyZW5jZWQgcHJvcGVydGllcyBhdCB0aGUgY3VycmVudCBsb2NhdGlvbiAoaW5zdGVhZCBvZiByZXBsYWNpbmdcclxuICAgICAqIGFsbCB0aGUgY2hpbGQgcHJvcGVydGllcyBhdCB0aGUgY3VycmVudCBsb2NhdGlvbikuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIE9iamVjdCBjb250YWluaW5nIG11bHRpcGxlIHZhbHVlcy5cclxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIHRoZSBEYXRhYmFzZSBpcyBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlKHZhbHVlcykge1xyXG4gICAgICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdPbkRpc2Nvbm5lY3QudXBkYXRlJywgdGhpcy5fcGF0aCk7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZU1lcmdlRGF0YUFyZygnT25EaXNjb25uZWN0LnVwZGF0ZScsIHZhbHVlcywgdGhpcy5fcGF0aCwgZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgcmVwb09uRGlzY29ubmVjdFVwZGF0ZSh0aGlzLl9yZXBvLCB0aGlzLl9wYXRoLCB2YWx1ZXMsIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBRdWVyeUltcGwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaGlkZWNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9yZXBvLCBfcGF0aCwgX3F1ZXJ5UGFyYW1zLCBfb3JkZXJCeUNhbGxlZCkge1xyXG4gICAgICAgIHRoaXMuX3JlcG8gPSBfcmVwbztcclxuICAgICAgICB0aGlzLl9wYXRoID0gX3BhdGg7XHJcbiAgICAgICAgdGhpcy5fcXVlcnlQYXJhbXMgPSBfcXVlcnlQYXJhbXM7XHJcbiAgICAgICAgdGhpcy5fb3JkZXJCeUNhbGxlZCA9IF9vcmRlckJ5Q2FsbGVkO1xyXG4gICAgfVxyXG4gICAgZ2V0IGtleSgpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkodGhpcy5fcGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcGF0aEdldEJhY2sodGhpcy5fcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHJlZigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlZmVyZW5jZUltcGwodGhpcy5fcmVwbywgdGhpcy5fcGF0aCk7XHJcbiAgICB9XHJcbiAgICBnZXQgX3F1ZXJ5SWRlbnRpZmllcigpIHtcclxuICAgICAgICBjb25zdCBvYmogPSBxdWVyeVBhcmFtc0dldFF1ZXJ5T2JqZWN0KHRoaXMuX3F1ZXJ5UGFyYW1zKTtcclxuICAgICAgICBjb25zdCBpZCA9IE9iamVjdFRvVW5pcXVlS2V5KG9iaik7XHJcbiAgICAgICAgcmV0dXJuIGlkID09PSAne30nID8gJ2RlZmF1bHQnIDogaWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFuIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcXVlcnkgcGFyYW1ldGVycyB1c2VkIGJ5IHRoaXMgUXVlcnkuXHJcbiAgICAgKi9cclxuICAgIGdldCBfcXVlcnlPYmplY3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5UGFyYW1zR2V0UXVlcnlPYmplY3QodGhpcy5fcXVlcnlQYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIG90aGVyID0gZ2V0TW9kdWxhckluc3RhbmNlKG90aGVyKTtcclxuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFF1ZXJ5SW1wbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzYW1lUmVwbyA9IHRoaXMuX3JlcG8gPT09IG90aGVyLl9yZXBvO1xyXG4gICAgICAgIGNvbnN0IHNhbWVQYXRoID0gcGF0aEVxdWFscyh0aGlzLl9wYXRoLCBvdGhlci5fcGF0aCk7XHJcbiAgICAgICAgY29uc3Qgc2FtZVF1ZXJ5SWRlbnRpZmllciA9IHRoaXMuX3F1ZXJ5SWRlbnRpZmllciA9PT0gb3RoZXIuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICByZXR1cm4gc2FtZVJlcG8gJiYgc2FtZVBhdGggJiYgc2FtZVF1ZXJ5SWRlbnRpZmllcjtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcG8udG9TdHJpbmcoKSArIHBhdGhUb1VybEVuY29kZWRTdHJpbmcodGhpcy5fcGF0aCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyB0aGF0IG5vIG90aGVyIG9yZGVyIGJ5IGNhbGwgaGFzIGJlZW4gbWFkZVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGwocXVlcnksIGZuTmFtZSkge1xyXG4gICAgaWYgKHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZuTmFtZSArIFwiOiBZb3UgY2FuJ3QgY29tYmluZSBtdWx0aXBsZSBvcmRlckJ5IGNhbGxzLlwiKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmFsaWRhdGVzIHN0YXJ0L2VuZCB2YWx1ZXMgZm9yIHF1ZXJpZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKHBhcmFtcykge1xyXG4gICAgbGV0IHN0YXJ0Tm9kZSA9IG51bGw7XHJcbiAgICBsZXQgZW5kTm9kZSA9IG51bGw7XHJcbiAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkpIHtcclxuICAgICAgICBzdGFydE5vZGUgPSBwYXJhbXMuZ2V0SW5kZXhTdGFydFZhbHVlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAocGFyYW1zLmhhc0VuZCgpKSB7XHJcbiAgICAgICAgZW5kTm9kZSA9IHBhcmFtcy5nZXRJbmRleEVuZFZhbHVlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAocGFyYW1zLmdldEluZGV4KCkgPT09IEtFWV9JTkRFWCkge1xyXG4gICAgICAgIGNvbnN0IHRvb01hbnlBcmdzRXJyb3IgPSAnUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB5b3UgbWF5IG9ubHkgcGFzcyBvbmUgYXJndW1lbnQgdG8gJyArXHJcbiAgICAgICAgICAgICdzdGFydEF0KCksIGVuZEF0KCksIG9yIGVxdWFsVG8oKS4nO1xyXG4gICAgICAgIGNvbnN0IHdyb25nQXJnVHlwZUVycm9yID0gJ1F1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IGtleSwgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksIHN0YXJ0QWZ0ZXIoKSwgJyArXHJcbiAgICAgICAgICAgICdlbmRBdCgpLCBlbmRCZWZvcmUoKSwgb3IgZXF1YWxUbygpIG11c3QgYmUgYSBzdHJpbmcuJztcclxuICAgICAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnROYW1lID0gcGFyYW1zLmdldEluZGV4U3RhcnROYW1lKCk7XHJcbiAgICAgICAgICAgIGlmIChzdGFydE5hbWUgIT09IE1JTl9OQU1FKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodG9vTWFueUFyZ3NFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN0YXJ0Tm9kZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih3cm9uZ0FyZ1R5cGVFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhcmFtcy5oYXNFbmQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbmROYW1lID0gcGFyYW1zLmdldEluZGV4RW5kTmFtZSgpO1xyXG4gICAgICAgICAgICBpZiAoZW5kTmFtZSAhPT0gTUFYX05BTUUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0b29NYW55QXJnc0Vycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZW5kTm9kZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih3cm9uZ0FyZ1R5cGVFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwYXJhbXMuZ2V0SW5kZXgoKSA9PT0gUFJJT1JJVFlfSU5ERVgpIHtcclxuICAgICAgICBpZiAoKHN0YXJ0Tm9kZSAhPSBudWxsICYmICFpc1ZhbGlkUHJpb3JpdHkoc3RhcnROb2RlKSkgfHxcclxuICAgICAgICAgICAgKGVuZE5vZGUgIT0gbnVsbCAmJiAhaXNWYWxpZFByaW9yaXR5KGVuZE5vZGUpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IHByaW9yaXR5LCB0aGUgZmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgJyArXHJcbiAgICAgICAgICAgICAgICAnc3RhcnRBZnRlcigpIGVuZEF0KCksIGVuZEJlZm9yZSgpLCBvciBlcXVhbFRvKCkgbXVzdCBiZSBhIHZhbGlkIHByaW9yaXR5IHZhbHVlICcgK1xyXG4gICAgICAgICAgICAgICAgJyhudWxsLCBhIG51bWJlciwgb3IgYSBzdHJpbmcpLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFzc2VydChwYXJhbXMuZ2V0SW5kZXgoKSBpbnN0YW5jZW9mIFBhdGhJbmRleCB8fFxyXG4gICAgICAgICAgICBwYXJhbXMuZ2V0SW5kZXgoKSA9PT0gVkFMVUVfSU5ERVgsICd1bmtub3duIGluZGV4IHR5cGUuJyk7XHJcbiAgICAgICAgaWYgKChzdGFydE5vZGUgIT0gbnVsbCAmJiB0eXBlb2Ygc3RhcnROb2RlID09PSAnb2JqZWN0JykgfHxcclxuICAgICAgICAgICAgKGVuZE5vZGUgIT0gbnVsbCAmJiB0eXBlb2YgZW5kTm9kZSA9PT0gJ29iamVjdCcpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnk6IEZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksIHN0YXJ0QWZ0ZXIoKSwgZW5kQXQoKSwgZW5kQmVmb3JlKCksIG9yICcgK1xyXG4gICAgICAgICAgICAgICAgJ2VxdWFsVG8oKSBjYW5ub3QgYmUgYW4gb2JqZWN0LicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmFsaWRhdGVzIHRoYXQgbGltaXQqIGhhcyBiZWVuIGNhbGxlZCB3aXRoIHRoZSBjb3JyZWN0IGNvbWJpbmF0aW9uIG9mIHBhcmFtZXRlcnNcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlTGltaXQocGFyYW1zKSB7XHJcbiAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkgJiZcclxuICAgICAgICBwYXJhbXMuaGFzRW5kKCkgJiZcclxuICAgICAgICBwYXJhbXMuaGFzTGltaXQoKSAmJlxyXG4gICAgICAgICFwYXJhbXMuaGFzQW5jaG9yZWRMaW1pdCgpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVlcnk6IENhbid0IGNvbWJpbmUgc3RhcnRBdCgpLCBzdGFydEFmdGVyKCksIGVuZEF0KCksIGVuZEJlZm9yZSgpLCBhbmQgbGltaXQoKS4gVXNlIFwiICtcclxuICAgICAgICAgICAgJ2xpbWl0VG9GaXJzdCgpIG9yIGxpbWl0VG9MYXN0KCkgaW5zdGVhZC4nKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBSZWZlcmVuY2VJbXBsIGV4dGVuZHMgUXVlcnlJbXBsIHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihyZXBvLCBwYXRoKSB7XHJcbiAgICAgICAgc3VwZXIocmVwbywgcGF0aCwgbmV3IFF1ZXJ5UGFyYW1zKCksIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGdldCBwYXJlbnQoKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IHBhdGhQYXJlbnQodGhpcy5fcGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudFBhdGggPT09IG51bGxcclxuICAgICAgICAgICAgPyBudWxsXHJcbiAgICAgICAgICAgIDogbmV3IFJlZmVyZW5jZUltcGwodGhpcy5fcmVwbywgcGFyZW50UGF0aCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcm9vdCgpIHtcclxuICAgICAgICBsZXQgcmVmID0gdGhpcztcclxuICAgICAgICB3aGlsZSAocmVmLnBhcmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZWYgPSByZWYucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVmO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIGBEYXRhU25hcHNob3RgIGNvbnRhaW5zIGRhdGEgZnJvbSBhIERhdGFiYXNlIGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBBbnkgdGltZSB5b3UgcmVhZCBkYXRhIGZyb20gdGhlIERhdGFiYXNlLCB5b3UgcmVjZWl2ZSB0aGUgZGF0YSBhcyBhXHJcbiAqIGBEYXRhU25hcHNob3RgLiBBIGBEYXRhU25hcHNob3RgIGlzIHBhc3NlZCB0byB0aGUgZXZlbnQgY2FsbGJhY2tzIHlvdSBhdHRhY2hcclxuICogd2l0aCBgb24oKWAgb3IgYG9uY2UoKWAuIFlvdSBjYW4gZXh0cmFjdCB0aGUgY29udGVudHMgb2YgdGhlIHNuYXBzaG90IGFzIGFcclxuICogSmF2YVNjcmlwdCBvYmplY3QgYnkgY2FsbGluZyB0aGUgYHZhbCgpYCBtZXRob2QuIEFsdGVybmF0aXZlbHksIHlvdSBjYW5cclxuICogdHJhdmVyc2UgaW50byB0aGUgc25hcHNob3QgYnkgY2FsbGluZyBgY2hpbGQoKWAgdG8gcmV0dXJuIGNoaWxkIHNuYXBzaG90c1xyXG4gKiAod2hpY2ggeW91IGNvdWxkIHRoZW4gY2FsbCBgdmFsKClgIG9uKS5cclxuICpcclxuICogQSBgRGF0YVNuYXBzaG90YCBpcyBhbiBlZmZpY2llbnRseSBnZW5lcmF0ZWQsIGltbXV0YWJsZSBjb3B5IG9mIHRoZSBkYXRhIGF0XHJcbiAqIGEgRGF0YWJhc2UgbG9jYXRpb24uIEl0IGNhbm5vdCBiZSBtb2RpZmllZCBhbmQgd2lsbCBuZXZlciBjaGFuZ2UgKHRvIG1vZGlmeVxyXG4gKiBkYXRhLCB5b3UgYWx3YXlzIGNhbGwgdGhlIGBzZXQoKWAgbWV0aG9kIG9uIGEgYFJlZmVyZW5jZWAgZGlyZWN0bHkpLlxyXG4gKi9cclxuY2xhc3MgRGF0YVNuYXBzaG90IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIF9ub2RlIC0gQSBTbmFwc2hvdE5vZGUgdG8gd3JhcC5cclxuICAgICAqIEBwYXJhbSByZWYgLSBUaGUgbG9jYXRpb24gdGhpcyBzbmFwc2hvdCBjYW1lIGZyb20uXHJcbiAgICAgKiBAcGFyYW0gX2luZGV4IC0gVGhlIGl0ZXJhdGlvbiBvcmRlciBmb3IgdGhpcyBzbmFwc2hvdFxyXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihfbm9kZSwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsb2NhdGlvbiBvZiB0aGlzIERhdGFTbmFwc2hvdC5cclxuICAgICAqL1xyXG4gICAgcmVmLCBfaW5kZXgpIHtcclxuICAgICAgICB0aGlzLl9ub2RlID0gX25vZGU7XHJcbiAgICAgICAgdGhpcy5yZWYgPSByZWY7XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBfaW5kZXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHByaW9yaXR5IHZhbHVlIG9mIHRoZSBkYXRhIGluIHRoaXMgYERhdGFTbmFwc2hvdGAuXHJcbiAgICAgKlxyXG4gICAgICogQXBwbGljYXRpb25zIG5lZWQgbm90IHVzZSBwcmlvcml0eSBidXQgY2FuIG9yZGVyIGNvbGxlY3Rpb25zIGJ5XHJcbiAgICAgKiBvcmRpbmFyeSBwcm9wZXJ0aWVzIChzZWVcclxuICAgICAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNzb3J0aW5nX2FuZF9maWx0ZXJpbmdfZGF0YSB8U29ydGluZyBhbmQgZmlsdGVyaW5nIGRhdGF9XHJcbiAgICAgKiApLlxyXG4gICAgICovXHJcbiAgICBnZXQgcHJpb3JpdHkoKSB7XHJcbiAgICAgICAgLy8gdHlwZWNhc3QgaGVyZSBiZWNhdXNlIHdlIG5ldmVyIHJldHVybiBkZWZlcnJlZCB2YWx1ZXMgb3IgaW50ZXJuYWwgcHJpb3JpdGllcyAoTUFYX1BSSU9SSVRZKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlLmdldFByaW9yaXR5KCkudmFsKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBrZXkgKGxhc3QgcGFydCBvZiB0aGUgcGF0aCkgb2YgdGhlIGxvY2F0aW9uIG9mIHRoaXMgYERhdGFTbmFwc2hvdGAuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGxhc3QgdG9rZW4gaW4gYSBEYXRhYmFzZSBsb2NhdGlvbiBpcyBjb25zaWRlcmVkIGl0cyBrZXkuIEZvciBleGFtcGxlLFxyXG4gICAgICogXCJhZGFcIiBpcyB0aGUga2V5IGZvciB0aGUgL3VzZXJzL2FkYS8gbm9kZS4gQWNjZXNzaW5nIHRoZSBrZXkgb24gYW55XHJcbiAgICAgKiBgRGF0YVNuYXBzaG90YCB3aWxsIHJldHVybiB0aGUga2V5IGZvciB0aGUgbG9jYXRpb24gdGhhdCBnZW5lcmF0ZWQgaXQuXHJcbiAgICAgKiBIb3dldmVyLCBhY2Nlc3NpbmcgdGhlIGtleSBvbiB0aGUgcm9vdCBVUkwgb2YgYSBEYXRhYmFzZSB3aWxsIHJldHVyblxyXG4gICAgICogYG51bGxgLlxyXG4gICAgICovXHJcbiAgICBnZXQga2V5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZi5rZXk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoaWxkIHByb3BlcnRpZXMgb2YgdGhpcyBgRGF0YVNuYXBzaG90YC4gKi9cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlLm51bUNoaWxkcmVuKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYW5vdGhlciBgRGF0YVNuYXBzaG90YCBmb3IgdGhlIGxvY2F0aW9uIGF0IHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBQYXNzaW5nIGEgcmVsYXRpdmUgcGF0aCB0byB0aGUgYGNoaWxkKClgIG1ldGhvZCBvZiBhIERhdGFTbmFwc2hvdCByZXR1cm5zXHJcbiAgICAgKiBhbm90aGVyIGBEYXRhU25hcHNob3RgIGZvciB0aGUgbG9jYXRpb24gYXQgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSBwYXRoLiBUaGVcclxuICAgICAqIHJlbGF0aXZlIHBhdGggY2FuIGVpdGhlciBiZSBhIHNpbXBsZSBjaGlsZCBuYW1lIChmb3IgZXhhbXBsZSwgXCJhZGFcIikgb3IgYVxyXG4gICAgICogZGVlcGVyLCBzbGFzaC1zZXBhcmF0ZWQgcGF0aCAoZm9yIGV4YW1wbGUsIFwiYWRhL25hbWUvZmlyc3RcIikuIElmIHRoZSBjaGlsZFxyXG4gICAgICogbG9jYXRpb24gaGFzIG5vIGRhdGEsIGFuIGVtcHR5IGBEYXRhU25hcHNob3RgICh0aGF0IGlzLCBhIGBEYXRhU25hcHNob3RgXHJcbiAgICAgKiB3aG9zZSB2YWx1ZSBpcyBgbnVsbGApIGlzIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gQSByZWxhdGl2ZSBwYXRoIHRvIHRoZSBsb2NhdGlvbiBvZiBjaGlsZCBkYXRhLlxyXG4gICAgICovXHJcbiAgICBjaGlsZChwYXRoKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gbmV3IFBhdGgocGF0aCk7XHJcbiAgICAgICAgY29uc3QgY2hpbGRSZWYgPSBjaGlsZCh0aGlzLnJlZiwgcGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhU25hcHNob3QodGhpcy5fbm9kZS5nZXRDaGlsZChjaGlsZFBhdGgpLCBjaGlsZFJlZiwgUFJJT1JJVFlfSU5ERVgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBgRGF0YVNuYXBzaG90YCBjb250YWlucyBhbnkgZGF0YS4gSXQgaXMgc2xpZ2h0bHkgbW9yZVxyXG4gICAgICogZWZmaWNpZW50IHRoYW4gdXNpbmcgYHNuYXBzaG90LnZhbCgpICE9PSBudWxsYC5cclxuICAgICAqL1xyXG4gICAgZXhpc3RzKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5fbm9kZS5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4cG9ydHMgdGhlIGVudGlyZSBjb250ZW50cyBvZiB0aGUgRGF0YVNuYXBzaG90IGFzIGEgSmF2YVNjcmlwdCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGBleHBvcnRWYWwoKWAgbWV0aG9kIGlzIHNpbWlsYXIgdG8gYHZhbCgpYCwgZXhjZXB0IHByaW9yaXR5IGluZm9ybWF0aW9uXHJcbiAgICAgKiBpcyBpbmNsdWRlZCAoaWYgYXZhaWxhYmxlKSwgbWFraW5nIGl0IHN1aXRhYmxlIGZvciBiYWNraW5nIHVwIHlvdXIgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgRGF0YVNuYXBzaG90J3MgY29udGVudHMgYXMgYSBKYXZhU2NyaXB0IHZhbHVlIChPYmplY3QsXHJcbiAgICAgKiAgIEFycmF5LCBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgYG51bGxgKS5cclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGV4cG9ydFZhbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZS52YWwodHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVudW1lcmF0ZXMgdGhlIHRvcC1sZXZlbCBjaGlsZHJlbiBpbiB0aGUgYEl0ZXJhdGVkRGF0YVNuYXBzaG90YC5cclxuICAgICAqXHJcbiAgICAgKiBCZWNhdXNlIG9mIHRoZSB3YXkgSmF2YVNjcmlwdCBvYmplY3RzIHdvcmssIHRoZSBvcmRlcmluZyBvZiBkYXRhIGluIHRoZVxyXG4gICAgICogSmF2YVNjcmlwdCBvYmplY3QgcmV0dXJuZWQgYnkgYHZhbCgpYCBpcyBub3QgZ3VhcmFudGVlZCB0byBtYXRjaCB0aGVcclxuICAgICAqIG9yZGVyaW5nIG9uIHRoZSBzZXJ2ZXIgbm9yIHRoZSBvcmRlcmluZyBvZiBgb25DaGlsZEFkZGVkKClgIGV2ZW50cy4gVGhhdCBpc1xyXG4gICAgICogd2hlcmUgYGZvckVhY2goKWAgY29tZXMgaW4gaGFuZHkuIEl0IGd1YXJhbnRlZXMgdGhlIGNoaWxkcmVuIG9mIGFcclxuICAgICAqIGBEYXRhU25hcHNob3RgIHdpbGwgYmUgaXRlcmF0ZWQgaW4gdGhlaXIgcXVlcnkgb3JkZXIuXHJcbiAgICAgKlxyXG4gICAgICogSWYgbm8gZXhwbGljaXQgYG9yZGVyQnkqKClgIG1ldGhvZCBpcyB1c2VkLCByZXN1bHRzIGFyZSByZXR1cm5lZFxyXG4gICAgICogb3JkZXJlZCBieSBrZXkgKHVubGVzcyBwcmlvcml0aWVzIGFyZSB1c2VkLCBpbiB3aGljaCBjYXNlLCByZXN1bHRzIGFyZVxyXG4gICAgICogcmV0dXJuZWQgYnkgcHJpb3JpdHkpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggY2hpbGQgRGF0YVNuYXBzaG90LlxyXG4gICAgICogVGhlIGNhbGxiYWNrIGNhbiByZXR1cm4gdHJ1ZSB0byBjYW5jZWwgZnVydGhlciBlbnVtZXJhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgZW51bWVyYXRpb24gd2FzIGNhbmNlbGVkIGR1ZSB0byB5b3VyIGNhbGxiYWNrIHJldHVybmluZ1xyXG4gICAgICogdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgZm9yRWFjaChhY3Rpb24pIHtcclxuICAgICAgICBpZiAodGhpcy5fbm9kZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGlsZHJlbk5vZGUgPSB0aGlzLl9ub2RlO1xyXG4gICAgICAgIC8vIFNhbml0aXplIHRoZSByZXR1cm4gdmFsdWUgdG8gYSBib29sZWFuLiBDaGlsZHJlbk5vZGUuZm9yRWFjaENoaWxkIGhhcyBhIHdlaXJkIHJldHVybiB0eXBlLi4uXHJcbiAgICAgICAgcmV0dXJuICEhY2hpbGRyZW5Ob2RlLmZvckVhY2hDaGlsZCh0aGlzLl9pbmRleCwgKGtleSwgbm9kZSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uKG5ldyBEYXRhU25hcHNob3Qobm9kZSwgY2hpbGQodGhpcy5yZWYsIGtleSksIFBSSU9SSVRZX0lOREVYKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGNoaWxkIHBhdGggaGFzIChub24tbnVsbCkgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIEEgcmVsYXRpdmUgcGF0aCB0byB0aGUgbG9jYXRpb24gb2YgYSBwb3RlbnRpYWwgY2hpbGQuXHJcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgZGF0YSBleGlzdHMgYXQgdGhlIHNwZWNpZmllZCBjaGlsZCBwYXRoOyBlbHNlXHJcbiAgICAgKiAgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgaGFzQ2hpbGQocGF0aCkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IG5ldyBQYXRoKHBhdGgpO1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5fbm9kZS5nZXRDaGlsZChjaGlsZFBhdGgpLmlzRW1wdHkoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgYERhdGFTbmFwc2hvdGAgaGFzIGFueSBub24tYG51bGxgIGNoaWxkXHJcbiAgICAgKiBwcm9wZXJ0aWVzLlxyXG4gICAgICpcclxuICAgICAqIFlvdSBjYW4gdXNlIGBoYXNDaGlsZHJlbigpYCB0byBkZXRlcm1pbmUgaWYgYSBgRGF0YVNuYXBzaG90YCBoYXMgYW55XHJcbiAgICAgKiBjaGlsZHJlbi4gSWYgaXQgZG9lcywgeW91IGNhbiBlbnVtZXJhdGUgdGhlbSB1c2luZyBgZm9yRWFjaCgpYC4gSWYgaXRcclxuICAgICAqIGRvZXNuJ3QsIHRoZW4gZWl0aGVyIHRoaXMgc25hcHNob3QgY29udGFpbnMgYSBwcmltaXRpdmUgdmFsdWUgKHdoaWNoIGNhbiBiZVxyXG4gICAgICogcmV0cmlldmVkIHdpdGggYHZhbCgpYCkgb3IgaXQgaXMgZW1wdHkgKGluIHdoaWNoIGNhc2UsIGB2YWwoKWAgd2lsbCByZXR1cm5cclxuICAgICAqIGBudWxsYCkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIHNuYXBzaG90IGhhcyBhbnkgY2hpbGRyZW47IGVsc2UgZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIGhhc0NoaWxkcmVuKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9ub2RlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX25vZGUuaXNFbXB0eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwb3J0VmFsKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4dHJhY3RzIGEgSmF2YVNjcmlwdCB2YWx1ZSBmcm9tIGEgYERhdGFTbmFwc2hvdGAuXHJcbiAgICAgKlxyXG4gICAgICogRGVwZW5kaW5nIG9uIHRoZSBkYXRhIGluIGEgYERhdGFTbmFwc2hvdGAsIHRoZSBgdmFsKClgIG1ldGhvZCBtYXkgcmV0dXJuIGFcclxuICAgICAqIHNjYWxhciB0eXBlIChzdHJpbmcsIG51bWJlciwgb3IgYm9vbGVhbiksIGFuIGFycmF5LCBvciBhbiBvYmplY3QuIEl0IG1heVxyXG4gICAgICogYWxzbyByZXR1cm4gbnVsbCwgaW5kaWNhdGluZyB0aGF0IHRoZSBgRGF0YVNuYXBzaG90YCBpcyBlbXB0eSAoY29udGFpbnMgbm9cclxuICAgICAqIGRhdGEpLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBEYXRhU25hcHNob3QncyBjb250ZW50cyBhcyBhIEphdmFTY3JpcHQgdmFsdWUgKE9iamVjdCxcclxuICAgICAqICAgQXJyYXksIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBgbnVsbGApLlxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgdmFsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlLnZhbCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBSZXR1cm5zIGEgYFJlZmVyZW5jZWAgcmVwcmVzZW50aW5nIHRoZSBsb2NhdGlvbiBpbiB0aGUgRGF0YWJhc2VcclxuICogY29ycmVzcG9uZGluZyB0byB0aGUgcHJvdmlkZWQgcGF0aC4gSWYgbm8gcGF0aCBpcyBwcm92aWRlZCwgdGhlIGBSZWZlcmVuY2VgXHJcbiAqIHdpbGwgcG9pbnQgdG8gdGhlIHJvb3Qgb2YgdGhlIERhdGFiYXNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gZGIgLSBUaGUgZGF0YWJhc2UgaW5zdGFuY2UgdG8gb2J0YWluIGEgcmVmZXJlbmNlIGZvci5cclxuICogQHBhcmFtIHBhdGggLSBPcHRpb25hbCBwYXRoIHJlcHJlc2VudGluZyB0aGUgbG9jYXRpb24gdGhlIHJldHVybmVkXHJcbiAqICAgYFJlZmVyZW5jZWAgd2lsbCBwb2ludC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgcmV0dXJuZWQgYFJlZmVyZW5jZWAgd2lsbFxyXG4gKiAgIHBvaW50IHRvIHRoZSByb290IG9mIHRoZSBEYXRhYmFzZS5cclxuICogQHJldHVybnMgSWYgYSBwYXRoIGlzIHByb3ZpZGVkLCBhIGBSZWZlcmVuY2VgXHJcbiAqICAgcG9pbnRpbmcgdG8gdGhlIHByb3ZpZGVkIHBhdGguIE90aGVyd2lzZSwgYSBgUmVmZXJlbmNlYCBwb2ludGluZyB0byB0aGVcclxuICogICByb290IG9mIHRoZSBEYXRhYmFzZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlZihkYiwgcGF0aCkge1xyXG4gICAgZGIgPSBnZXRNb2R1bGFySW5zdGFuY2UoZGIpO1xyXG4gICAgZGIuX2NoZWNrTm90RGVsZXRlZCgncmVmJyk7XHJcbiAgICByZXR1cm4gcGF0aCAhPT0gdW5kZWZpbmVkID8gY2hpbGQoZGIuX3Jvb3QsIHBhdGgpIDogZGIuX3Jvb3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBgUmVmZXJlbmNlYCByZXByZXNlbnRpbmcgdGhlIGxvY2F0aW9uIGluIHRoZSBEYXRhYmFzZVxyXG4gKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZCBGaXJlYmFzZSBVUkwuXHJcbiAqXHJcbiAqIEFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgdGhlIFVSTCBpcyBub3QgYSB2YWxpZCBGaXJlYmFzZSBEYXRhYmFzZSBVUkwgb3IgaXRcclxuICogaGFzIGEgZGlmZmVyZW50IGRvbWFpbiB0aGFuIHRoZSBjdXJyZW50IGBEYXRhYmFzZWAgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBhbGwgcXVlcnkgcGFyYW1ldGVycyAoYG9yZGVyQnlgLCBgbGltaXRUb0xhc3RgLCBldGMuKSBhcmUgaWdub3JlZFxyXG4gKiBhbmQgYXJlIG5vdCBhcHBsaWVkIHRvIHRoZSByZXR1cm5lZCBgUmVmZXJlbmNlYC5cclxuICpcclxuICogQHBhcmFtIGRiIC0gVGhlIGRhdGFiYXNlIGluc3RhbmNlIHRvIG9idGFpbiBhIHJlZmVyZW5jZSBmb3IuXHJcbiAqIEBwYXJhbSB1cmwgLSBUaGUgRmlyZWJhc2UgVVJMIGF0IHdoaWNoIHRoZSByZXR1cm5lZCBgUmVmZXJlbmNlYCB3aWxsXHJcbiAqICAgcG9pbnQuXHJcbiAqIEByZXR1cm5zIEEgYFJlZmVyZW5jZWAgcG9pbnRpbmcgdG8gdGhlIHByb3ZpZGVkXHJcbiAqICAgRmlyZWJhc2UgVVJMLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVmRnJvbVVSTChkYiwgdXJsKSB7XHJcbiAgICBkYiA9IGdldE1vZHVsYXJJbnN0YW5jZShkYik7XHJcbiAgICBkYi5fY2hlY2tOb3REZWxldGVkKCdyZWZGcm9tVVJMJyk7XHJcbiAgICBjb25zdCBwYXJzZWRVUkwgPSBwYXJzZVJlcG9JbmZvKHVybCwgZGIuX3JlcG8ucmVwb0luZm9fLm5vZGVBZG1pbik7XHJcbiAgICB2YWxpZGF0ZVVybCgncmVmRnJvbVVSTCcsIHBhcnNlZFVSTCk7XHJcbiAgICBjb25zdCByZXBvSW5mbyA9IHBhcnNlZFVSTC5yZXBvSW5mbztcclxuICAgIGlmICghZGIuX3JlcG8ucmVwb0luZm9fLmlzQ3VzdG9tSG9zdCgpICYmXHJcbiAgICAgICAgcmVwb0luZm8uaG9zdCAhPT0gZGIuX3JlcG8ucmVwb0luZm9fLmhvc3QpIHtcclxuICAgICAgICBmYXRhbCgncmVmRnJvbVVSTCcgK1xyXG4gICAgICAgICAgICAnOiBIb3N0IG5hbWUgZG9lcyBub3QgbWF0Y2ggdGhlIGN1cnJlbnQgZGF0YWJhc2U6ICcgK1xyXG4gICAgICAgICAgICAnKGZvdW5kICcgK1xyXG4gICAgICAgICAgICByZXBvSW5mby5ob3N0ICtcclxuICAgICAgICAgICAgJyBidXQgZXhwZWN0ZWQgJyArXHJcbiAgICAgICAgICAgIGRiLl9yZXBvLnJlcG9JbmZvXy5ob3N0ICtcclxuICAgICAgICAgICAgJyknKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZWYoZGIsIHBhcnNlZFVSTC5wYXRoLnRvU3RyaW5nKCkpO1xyXG59XHJcbi8qKlxyXG4gKiBHZXRzIGEgYFJlZmVyZW5jZWAgZm9yIHRoZSBsb2NhdGlvbiBhdCB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIHBhdGguXHJcbiAqXHJcbiAqIFRoZSByZWxhdGl2ZSBwYXRoIGNhbiBlaXRoZXIgYmUgYSBzaW1wbGUgY2hpbGQgbmFtZSAoZm9yIGV4YW1wbGUsIFwiYWRhXCIpIG9yXHJcbiAqIGEgZGVlcGVyIHNsYXNoLXNlcGFyYXRlZCBwYXRoIChmb3IgZXhhbXBsZSwgXCJhZGEvbmFtZS9maXJzdFwiKS5cclxuICpcclxuICogQHBhcmFtIHBhcmVudCAtIFRoZSBwYXJlbnQgbG9jYXRpb24uXHJcbiAqIEBwYXJhbSBwYXRoIC0gQSByZWxhdGl2ZSBwYXRoIGZyb20gdGhpcyBsb2NhdGlvbiB0byB0aGUgZGVzaXJlZCBjaGlsZFxyXG4gKiAgIGxvY2F0aW9uLlxyXG4gKiBAcmV0dXJucyBUaGUgc3BlY2lmaWVkIGNoaWxkIGxvY2F0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gY2hpbGQocGFyZW50LCBwYXRoKSB7XHJcbiAgICBwYXJlbnQgPSBnZXRNb2R1bGFySW5zdGFuY2UocGFyZW50KTtcclxuICAgIGlmIChwYXRoR2V0RnJvbnQocGFyZW50Ll9wYXRoKSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHZhbGlkYXRlUm9vdFBhdGhTdHJpbmcoJ2NoaWxkJywgJ3BhdGgnLCBwYXRoLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YWxpZGF0ZVBhdGhTdHJpbmcoJ2NoaWxkJywgJ3BhdGgnLCBwYXRoLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFJlZmVyZW5jZUltcGwocGFyZW50Ll9yZXBvLCBwYXRoQ2hpbGQocGFyZW50Ll9wYXRoLCBwYXRoKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gYE9uRGlzY29ubmVjdGAgb2JqZWN0IC0gc2VlXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvb2ZmbGluZS1jYXBhYmlsaXRpZXMgfCBFbmFibGluZyBPZmZsaW5lIENhcGFiaWxpdGllcyBpbiBKYXZhU2NyaXB0fVxyXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBob3cgdG8gdXNlIGl0LlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gVGhlIHJlZmVyZW5jZSB0byBhZGQgT25EaXNjb25uZWN0IHRyaWdnZXJzIGZvci5cclxuICovXHJcbmZ1bmN0aW9uIG9uRGlzY29ubmVjdChyZWYpIHtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgcmV0dXJuIG5ldyBPbkRpc2Nvbm5lY3QocmVmLl9yZXBvLCByZWYuX3BhdGgpO1xyXG59XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBuZXcgY2hpbGQgbG9jYXRpb24gdXNpbmcgYSB1bmlxdWUga2V5IGFuZCByZXR1cm5zIGl0c1xyXG4gKiBgUmVmZXJlbmNlYC5cclxuICpcclxuICogVGhpcyBpcyB0aGUgbW9zdCBjb21tb24gcGF0dGVybiBmb3IgYWRkaW5nIGRhdGEgdG8gYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLlxyXG4gKlxyXG4gKiBJZiB5b3UgcHJvdmlkZSBhIHZhbHVlIHRvIGBwdXNoKClgLCB0aGUgdmFsdWUgaXMgd3JpdHRlbiB0byB0aGVcclxuICogZ2VuZXJhdGVkIGxvY2F0aW9uLiBJZiB5b3UgZG9uJ3QgcGFzcyBhIHZhbHVlLCBub3RoaW5nIGlzIHdyaXR0ZW4gdG8gdGhlXHJcbiAqIGRhdGFiYXNlIGFuZCB0aGUgY2hpbGQgcmVtYWlucyBlbXB0eSAoYnV0IHlvdSBjYW4gdXNlIHRoZSBgUmVmZXJlbmNlYFxyXG4gKiBlbHNld2hlcmUpLlxyXG4gKlxyXG4gKiBUaGUgdW5pcXVlIGtleXMgZ2VuZXJhdGVkIGJ5IGBwdXNoKClgIGFyZSBvcmRlcmVkIGJ5IHRoZSBjdXJyZW50IHRpbWUsIHNvIHRoZVxyXG4gKiByZXN1bHRpbmcgbGlzdCBvZiBpdGVtcyBpcyBjaHJvbm9sb2dpY2FsbHkgc29ydGVkLiBUaGUga2V5cyBhcmUgYWxzb1xyXG4gKiBkZXNpZ25lZCB0byBiZSB1bmd1ZXNzYWJsZSAodGhleSBjb250YWluIDcyIHJhbmRvbSBiaXRzIG9mIGVudHJvcHkpLlxyXG4gKlxyXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI2FwcGVuZF90b19hX2xpc3Rfb2ZfZGF0YSB8IEFwcGVuZCB0byBhIGxpc3Qgb2YgZGF0YX0uXHJcbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGVibG9nLmNvbS8yMDE1LzAyL3RoZS0yMTIwLXdheXMtdG8tZW5zdXJlLXVuaXF1ZV82OC5odG1sIHwgVGhlIDJeMTIwIFdheXMgdG8gRW5zdXJlIFVuaXF1ZSBJZGVudGlmaWVyc30uXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXJlbnQgLSBUaGUgcGFyZW50IGxvY2F0aW9uLlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBPcHRpb25hbCB2YWx1ZSB0byBiZSB3cml0dGVuIGF0IHRoZSBnZW5lcmF0ZWQgbG9jYXRpb24uXHJcbiAqIEByZXR1cm5zIENvbWJpbmVkIGBQcm9taXNlYCBhbmQgYFJlZmVyZW5jZWA7IHJlc29sdmVzIHdoZW4gd3JpdGUgaXMgY29tcGxldGUsXHJcbiAqIGJ1dCBjYW4gYmUgdXNlZCBpbW1lZGlhdGVseSBhcyB0aGUgYFJlZmVyZW5jZWAgdG8gdGhlIGNoaWxkIGxvY2F0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gcHVzaChwYXJlbnQsIHZhbHVlKSB7XHJcbiAgICBwYXJlbnQgPSBnZXRNb2R1bGFySW5zdGFuY2UocGFyZW50KTtcclxuICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdwdXNoJywgcGFyZW50Ll9wYXRoKTtcclxuICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdwdXNoJywgdmFsdWUsIHBhcmVudC5fcGF0aCwgdHJ1ZSk7XHJcbiAgICBjb25zdCBub3cgPSByZXBvU2VydmVyVGltZShwYXJlbnQuX3JlcG8pO1xyXG4gICAgY29uc3QgbmFtZSA9IG5leHRQdXNoSWQobm93KTtcclxuICAgIC8vIHB1c2goKSByZXR1cm5zIGEgVGhlbm5hYmxlUmVmZXJlbmNlIHdob3NlIHByb21pc2UgaXMgZnVsZmlsbGVkIHdpdGggYVxyXG4gICAgLy8gcmVndWxhciBSZWZlcmVuY2UuIFdlIHVzZSBjaGlsZCgpIHRvIGNyZWF0ZSBoYW5kbGVzIHRvIHR3byBkaWZmZXJlbnRcclxuICAgIC8vIHJlZmVyZW5jZXMuIFRoZSBmaXJzdCBpcyB0dXJuZWQgaW50byBhIFRoZW5uYWJsZVJlZmVyZW5jZSBiZWxvdyBieSBhZGRpbmdcclxuICAgIC8vIHRoZW4oKSBhbmQgY2F0Y2goKSBtZXRob2RzIGFuZCBpcyB1c2VkIGFzIHRoZSByZXR1cm4gdmFsdWUgb2YgcHVzaCgpLiBUaGVcclxuICAgIC8vIHNlY29uZCByZW1haW5zIGEgcmVndWxhciBSZWZlcmVuY2UgYW5kIGlzIHVzZWQgYXMgdGhlIGZ1bGZpbGxlZCB2YWx1ZSBvZlxyXG4gICAgLy8gdGhlIGZpcnN0IFRoZW5uYWJsZVJlZmVyZW5jZS5cclxuICAgIGNvbnN0IHRoZW5uYWJsZVB1c2hSZWYgPSBjaGlsZChwYXJlbnQsIG5hbWUpO1xyXG4gICAgY29uc3QgcHVzaFJlZiA9IGNoaWxkKHBhcmVudCwgbmFtZSk7XHJcbiAgICBsZXQgcHJvbWlzZTtcclxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgcHJvbWlzZSA9IHNldChwdXNoUmVmLCB2YWx1ZSkudGhlbigoKSA9PiBwdXNoUmVmKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUocHVzaFJlZik7XHJcbiAgICB9XHJcbiAgICB0aGVubmFibGVQdXNoUmVmLnRoZW4gPSBwcm9taXNlLnRoZW4uYmluZChwcm9taXNlKTtcclxuICAgIHRoZW5uYWJsZVB1c2hSZWYuY2F0Y2ggPSBwcm9taXNlLnRoZW4uYmluZChwcm9taXNlLCB1bmRlZmluZWQpO1xyXG4gICAgcmV0dXJuIHRoZW5uYWJsZVB1c2hSZWY7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZXMgdGhlIGRhdGEgYXQgdGhpcyBEYXRhYmFzZSBsb2NhdGlvbi5cclxuICpcclxuICogQW55IGRhdGEgYXQgY2hpbGQgbG9jYXRpb25zIHdpbGwgYWxzbyBiZSBkZWxldGVkLlxyXG4gKlxyXG4gKiBUaGUgZWZmZWN0IG9mIHRoZSByZW1vdmUgd2lsbCBiZSB2aXNpYmxlIGltbWVkaWF0ZWx5IGFuZCB0aGUgY29ycmVzcG9uZGluZ1xyXG4gKiBldmVudCAndmFsdWUnIHdpbGwgYmUgdHJpZ2dlcmVkLiBTeW5jaHJvbml6YXRpb24gb2YgdGhlIHJlbW92ZSB0byB0aGVcclxuICogRmlyZWJhc2Ugc2VydmVycyB3aWxsIGFsc28gYmUgc3RhcnRlZCwgYW5kIHRoZSByZXR1cm5lZCBQcm9taXNlIHdpbGwgcmVzb2x2ZVxyXG4gKiB3aGVuIGNvbXBsZXRlLiBJZiBwcm92aWRlZCwgdGhlIG9uQ29tcGxldGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcclxuICogYXN5bmNocm9ub3VzbHkgYWZ0ZXIgc3luY2hyb25pemF0aW9uIGhhcyBmaW5pc2hlZC5cclxuICpcclxuICogQHBhcmFtIHJlZiAtIFRoZSBsb2NhdGlvbiB0byByZW1vdmUuXHJcbiAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gcmVtb3ZlIG9uIHNlcnZlciBpcyBjb21wbGV0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZShyZWYpIHtcclxuICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdyZW1vdmUnLCByZWYuX3BhdGgpO1xyXG4gICAgcmV0dXJuIHNldChyZWYsIG51bGwpO1xyXG59XHJcbi8qKlxyXG4gKiBXcml0ZXMgZGF0YSB0byB0aGlzIERhdGFiYXNlIGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBUaGlzIHdpbGwgb3ZlcndyaXRlIGFueSBkYXRhIGF0IHRoaXMgbG9jYXRpb24gYW5kIGFsbCBjaGlsZCBsb2NhdGlvbnMuXHJcbiAqXHJcbiAqIFRoZSBlZmZlY3Qgb2YgdGhlIHdyaXRlIHdpbGwgYmUgdmlzaWJsZSBpbW1lZGlhdGVseSwgYW5kIHRoZSBjb3JyZXNwb25kaW5nXHJcbiAqIGV2ZW50cyAoXCJ2YWx1ZVwiLCBcImNoaWxkX2FkZGVkXCIsIGV0Yy4pIHdpbGwgYmUgdHJpZ2dlcmVkLiBTeW5jaHJvbml6YXRpb24gb2ZcclxuICogdGhlIGRhdGEgdG8gdGhlIEZpcmViYXNlIHNlcnZlcnMgd2lsbCBhbHNvIGJlIHN0YXJ0ZWQsIGFuZCB0aGUgcmV0dXJuZWRcclxuICogUHJvbWlzZSB3aWxsIHJlc29sdmUgd2hlbiBjb21wbGV0ZS4gSWYgcHJvdmlkZWQsIHRoZSBgb25Db21wbGV0ZWAgY2FsbGJhY2tcclxuICogd2lsbCBiZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkgYWZ0ZXIgc3luY2hyb25pemF0aW9uIGhhcyBmaW5pc2hlZC5cclxuICpcclxuICogUGFzc2luZyBgbnVsbGAgZm9yIHRoZSBuZXcgdmFsdWUgaXMgZXF1aXZhbGVudCB0byBjYWxsaW5nIGByZW1vdmUoKWA7IG5hbWVseSxcclxuICogYWxsIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiBhbmQgYWxsIGNoaWxkIGxvY2F0aW9ucyB3aWxsIGJlIGRlbGV0ZWQuXHJcbiAqXHJcbiAqIGBzZXQoKWAgd2lsbCByZW1vdmUgYW55IHByaW9yaXR5IHN0b3JlZCBhdCB0aGlzIGxvY2F0aW9uLCBzbyBpZiBwcmlvcml0eSBpc1xyXG4gKiBtZWFudCB0byBiZSBwcmVzZXJ2ZWQsIHlvdSBuZWVkIHRvIHVzZSBgc2V0V2l0aFByaW9yaXR5KClgIGluc3RlYWQuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBtb2RpZnlpbmcgZGF0YSB3aXRoIGBzZXQoKWAgd2lsbCBjYW5jZWwgYW55IHBlbmRpbmcgdHJhbnNhY3Rpb25zXHJcbiAqIGF0IHRoYXQgbG9jYXRpb24sIHNvIGV4dHJlbWUgY2FyZSBzaG91bGQgYmUgdGFrZW4gaWYgbWl4aW5nIGBzZXQoKWAgYW5kXHJcbiAqIGB0cmFuc2FjdGlvbigpYCB0byBtb2RpZnkgdGhlIHNhbWUgZGF0YS5cclxuICpcclxuICogQSBzaW5nbGUgYHNldCgpYCB3aWxsIGdlbmVyYXRlIGEgc2luZ2xlIFwidmFsdWVcIiBldmVudCBhdCB0aGUgbG9jYXRpb24gd2hlcmVcclxuICogdGhlIGBzZXQoKWAgd2FzIHBlcmZvcm1lZC5cclxuICpcclxuICogQHBhcmFtIHJlZiAtIFRoZSBsb2NhdGlvbiB0byB3cml0ZSB0by5cclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4gKHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvYmplY3QsXHJcbiAqICAgYXJyYXksIG9yIG51bGwpLlxyXG4gKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHdyaXRlIHRvIHNlcnZlciBpcyBjb21wbGV0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHNldChyZWYsIHZhbHVlKSB7XHJcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcclxuICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdzZXQnLCByZWYuX3BhdGgpO1xyXG4gICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ3NldCcsIHZhbHVlLCByZWYuX3BhdGgsIGZhbHNlKTtcclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICByZXBvU2V0V2l0aFByaW9yaXR5KHJlZi5fcmVwbywgcmVmLl9wYXRoLCB2YWx1ZSwgXHJcbiAgICAvKnByaW9yaXR5PSovIG51bGwsIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG59XHJcbi8qKlxyXG4gKiBTZXRzIGEgcHJpb3JpdHkgZm9yIHRoZSBkYXRhIGF0IHRoaXMgRGF0YWJhc2UgbG9jYXRpb24uXHJcbiAqXHJcbiAqIEFwcGxpY2F0aW9ucyBuZWVkIG5vdCB1c2UgcHJpb3JpdHkgYnV0IGNhbiBvcmRlciBjb2xsZWN0aW9ucyBieVxyXG4gKiBvcmRpbmFyeSBwcm9wZXJ0aWVzIChzZWVcclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI3NvcnRpbmdfYW5kX2ZpbHRlcmluZ19kYXRhIHwgU29ydGluZyBhbmQgZmlsdGVyaW5nIGRhdGF9XHJcbiAqICkuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSBUaGUgbG9jYXRpb24gdG8gd3JpdGUgdG8uXHJcbiAqIEBwYXJhbSBwcmlvcml0eSAtIFRoZSBwcmlvcml0eSB0byBiZSB3cml0dGVuIChzdHJpbmcsIG51bWJlciwgb3IgbnVsbCkuXHJcbiAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gd3JpdGUgdG8gc2VydmVyIGlzIGNvbXBsZXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0UHJpb3JpdHkocmVmLCBwcmlvcml0eSkge1xyXG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XHJcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnc2V0UHJpb3JpdHknLCByZWYuX3BhdGgpO1xyXG4gICAgdmFsaWRhdGVQcmlvcml0eSgnc2V0UHJpb3JpdHknLCBwcmlvcml0eSwgZmFsc2UpO1xyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIHJlcG9TZXRXaXRoUHJpb3JpdHkocmVmLl9yZXBvLCBwYXRoQ2hpbGQocmVmLl9wYXRoLCAnLnByaW9yaXR5JyksIHByaW9yaXR5LCBudWxsLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG4vKipcclxuICogV3JpdGVzIGRhdGEgdGhlIERhdGFiYXNlIGxvY2F0aW9uLiBMaWtlIGBzZXQoKWAgYnV0IGFsc28gc3BlY2lmaWVzIHRoZVxyXG4gKiBwcmlvcml0eSBmb3IgdGhhdCBkYXRhLlxyXG4gKlxyXG4gKiBBcHBsaWNhdGlvbnMgbmVlZCBub3QgdXNlIHByaW9yaXR5IGJ1dCBjYW4gb3JkZXIgY29sbGVjdGlvbnMgYnlcclxuICogb3JkaW5hcnkgcHJvcGVydGllcyAoc2VlXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNzb3J0aW5nX2FuZF9maWx0ZXJpbmdfZGF0YSB8IFNvcnRpbmcgYW5kIGZpbHRlcmluZyBkYXRhfVxyXG4gKiApLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gVGhlIGxvY2F0aW9uIHRvIHdyaXRlIHRvLlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlbiAoc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9iamVjdCxcclxuICogICBhcnJheSwgb3IgbnVsbCkuXHJcbiAqIEBwYXJhbSBwcmlvcml0eSAtIFRoZSBwcmlvcml0eSB0byBiZSB3cml0dGVuIChzdHJpbmcsIG51bWJlciwgb3IgbnVsbCkuXHJcbiAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gd3JpdGUgdG8gc2VydmVyIGlzIGNvbXBsZXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0V2l0aFByaW9yaXR5KHJlZiwgdmFsdWUsIHByaW9yaXR5KSB7XHJcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnc2V0V2l0aFByaW9yaXR5JywgcmVmLl9wYXRoKTtcclxuICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdzZXRXaXRoUHJpb3JpdHknLCB2YWx1ZSwgcmVmLl9wYXRoLCBmYWxzZSk7XHJcbiAgICB2YWxpZGF0ZVByaW9yaXR5KCdzZXRXaXRoUHJpb3JpdHknLCBwcmlvcml0eSwgZmFsc2UpO1xyXG4gICAgaWYgKHJlZi5rZXkgPT09ICcubGVuZ3RoJyB8fCByZWYua2V5ID09PSAnLmtleXMnKSB7XHJcbiAgICAgICAgdGhyb3cgJ3NldFdpdGhQcmlvcml0eSBmYWlsZWQ6ICcgKyByZWYua2V5ICsgJyBpcyBhIHJlYWQtb25seSBvYmplY3QuJztcclxuICAgIH1cclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICByZXBvU2V0V2l0aFByaW9yaXR5KHJlZi5fcmVwbywgcmVmLl9wYXRoLCB2YWx1ZSwgcHJpb3JpdHksIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG59XHJcbi8qKlxyXG4gKiBXcml0ZXMgbXVsdGlwbGUgdmFsdWVzIHRvIHRoZSBEYXRhYmFzZSBhdCBvbmNlLlxyXG4gKlxyXG4gKiBUaGUgYHZhbHVlc2AgYXJndW1lbnQgY29udGFpbnMgbXVsdGlwbGUgcHJvcGVydHktdmFsdWUgcGFpcnMgdGhhdCB3aWxsIGJlXHJcbiAqIHdyaXR0ZW4gdG8gdGhlIERhdGFiYXNlIHRvZ2V0aGVyLiBFYWNoIGNoaWxkIHByb3BlcnR5IGNhbiBlaXRoZXIgYmUgYSBzaW1wbGVcclxuICogcHJvcGVydHkgKGZvciBleGFtcGxlLCBcIm5hbWVcIikgb3IgYSByZWxhdGl2ZSBwYXRoIChmb3IgZXhhbXBsZSxcclxuICogXCJuYW1lL2ZpcnN0XCIpIGZyb20gdGhlIGN1cnJlbnQgbG9jYXRpb24gdG8gdGhlIGRhdGEgdG8gdXBkYXRlLlxyXG4gKlxyXG4gKiBBcyBvcHBvc2VkIHRvIHRoZSBgc2V0KClgIG1ldGhvZCwgYHVwZGF0ZSgpYCBjYW4gYmUgdXNlIHRvIHNlbGVjdGl2ZWx5IHVwZGF0ZVxyXG4gKiBvbmx5IHRoZSByZWZlcmVuY2VkIHByb3BlcnRpZXMgYXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gKGluc3RlYWQgb2YgcmVwbGFjaW5nXHJcbiAqIGFsbCB0aGUgY2hpbGQgcHJvcGVydGllcyBhdCB0aGUgY3VycmVudCBsb2NhdGlvbikuXHJcbiAqXHJcbiAqIFRoZSBlZmZlY3Qgb2YgdGhlIHdyaXRlIHdpbGwgYmUgdmlzaWJsZSBpbW1lZGlhdGVseSwgYW5kIHRoZSBjb3JyZXNwb25kaW5nXHJcbiAqIGV2ZW50cyAoJ3ZhbHVlJywgJ2NoaWxkX2FkZGVkJywgZXRjLikgd2lsbCBiZSB0cmlnZ2VyZWQuIFN5bmNocm9uaXphdGlvbiBvZlxyXG4gKiB0aGUgZGF0YSB0byB0aGUgRmlyZWJhc2Ugc2VydmVycyB3aWxsIGFsc28gYmUgc3RhcnRlZCwgYW5kIHRoZSByZXR1cm5lZFxyXG4gKiBQcm9taXNlIHdpbGwgcmVzb2x2ZSB3aGVuIGNvbXBsZXRlLiBJZiBwcm92aWRlZCwgdGhlIGBvbkNvbXBsZXRlYCBjYWxsYmFja1xyXG4gKiB3aWxsIGJlIGNhbGxlZCBhc3luY2hyb25vdXNseSBhZnRlciBzeW5jaHJvbml6YXRpb24gaGFzIGZpbmlzaGVkLlxyXG4gKlxyXG4gKiBBIHNpbmdsZSBgdXBkYXRlKClgIHdpbGwgZ2VuZXJhdGUgYSBzaW5nbGUgXCJ2YWx1ZVwiIGV2ZW50IGF0IHRoZSBsb2NhdGlvblxyXG4gKiB3aGVyZSB0aGUgYHVwZGF0ZSgpYCB3YXMgcGVyZm9ybWVkLCByZWdhcmRsZXNzIG9mIGhvdyBtYW55IGNoaWxkcmVuIHdlcmVcclxuICogbW9kaWZpZWQuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBtb2RpZnlpbmcgZGF0YSB3aXRoIGB1cGRhdGUoKWAgd2lsbCBjYW5jZWwgYW55IHBlbmRpbmdcclxuICogdHJhbnNhY3Rpb25zIGF0IHRoYXQgbG9jYXRpb24sIHNvIGV4dHJlbWUgY2FyZSBzaG91bGQgYmUgdGFrZW4gaWYgbWl4aW5nXHJcbiAqIGB1cGRhdGUoKWAgYW5kIGB0cmFuc2FjdGlvbigpYCB0byBtb2RpZnkgdGhlIHNhbWUgZGF0YS5cclxuICpcclxuICogUGFzc2luZyBgbnVsbGAgdG8gYHVwZGF0ZSgpYCB3aWxsIHJlbW92ZSB0aGUgZGF0YSBhdCB0aGlzIGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBTZWVcclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlYmxvZy5jb20vMjAxNS8wOS9pbnRyb2R1Y2luZy1tdWx0aS1sb2NhdGlvbi11cGRhdGVzLWFuZF84Ni5odG1sIHwgSW50cm9kdWNpbmcgbXVsdGktbG9jYXRpb24gdXBkYXRlcyBhbmQgbW9yZX0uXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSBUaGUgbG9jYXRpb24gdG8gd3JpdGUgdG8uXHJcbiAqIEBwYXJhbSB2YWx1ZXMgLSBPYmplY3QgY29udGFpbmluZyBtdWx0aXBsZSB2YWx1ZXMuXHJcbiAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gdXBkYXRlIG9uIHNlcnZlciBpcyBjb21wbGV0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHVwZGF0ZShyZWYsIHZhbHVlcykge1xyXG4gICAgdmFsaWRhdGVGaXJlYmFzZU1lcmdlRGF0YUFyZygndXBkYXRlJywgdmFsdWVzLCByZWYuX3BhdGgsIGZhbHNlKTtcclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICByZXBvVXBkYXRlKHJlZi5fcmVwbywgcmVmLl9wYXRoLCB2YWx1ZXMsIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG59XHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBtb3N0IHVwLXRvLWRhdGUgcmVzdWx0IGZvciB0aGlzIHF1ZXJ5LlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnkgLSBUaGUgcXVlcnkgdG8gcnVuLlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB3aGljaCByZXNvbHZlcyB0byB0aGUgcmVzdWx0aW5nIERhdGFTbmFwc2hvdCBpZiBhIHZhbHVlIGlzXHJcbiAqIGF2YWlsYWJsZSwgb3IgcmVqZWN0cyBpZiB0aGUgY2xpZW50IGlzIHVuYWJsZSB0byByZXR1cm4gYSB2YWx1ZSAoZS5nLiwgaWYgdGhlXHJcbiAqIHNlcnZlciBpcyB1bnJlYWNoYWJsZSBhbmQgdGhlcmUgaXMgbm90aGluZyBjYWNoZWQpLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0KHF1ZXJ5KSB7XHJcbiAgICBxdWVyeSA9IGdldE1vZHVsYXJJbnN0YW5jZShxdWVyeSk7XHJcbiAgICBjb25zdCBjYWxsYmFja0NvbnRleHQgPSBuZXcgQ2FsbGJhY2tDb250ZXh0KCgpID0+IHsgfSk7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBuZXcgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbihjYWxsYmFja0NvbnRleHQpO1xyXG4gICAgcmV0dXJuIHJlcG9HZXRWYWx1ZShxdWVyeS5fcmVwbywgcXVlcnksIGNvbnRhaW5lcikudGhlbihub2RlID0+IHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGFTbmFwc2hvdChub2RlLCBuZXcgUmVmZXJlbmNlSW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgpLCBxdWVyeS5fcXVlcnlQYXJhbXMuZ2V0SW5kZXgoKSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogUmVwcmVzZW50cyByZWdpc3RyYXRpb24gZm9yICd2YWx1ZScgZXZlbnRzLlxyXG4gKi9cclxuY2xhc3MgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFja0NvbnRleHQpIHtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrQ29udGV4dCA9IGNhbGxiYWNrQ29udGV4dDtcclxuICAgIH1cclxuICAgIHJlc3BvbmRzVG8oZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50VHlwZSA9PT0gJ3ZhbHVlJztcclxuICAgIH1cclxuICAgIGNyZWF0ZUV2ZW50KGNoYW5nZSwgcXVlcnkpIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHF1ZXJ5Ll9xdWVyeVBhcmFtcy5nZXRJbmRleCgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0YUV2ZW50KCd2YWx1ZScsIHRoaXMsIG5ldyBEYXRhU25hcHNob3QoY2hhbmdlLnNuYXBzaG90Tm9kZSwgbmV3IFJlZmVyZW5jZUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoKSwgaW5kZXgpKTtcclxuICAgIH1cclxuICAgIGdldEV2ZW50UnVubmVyKGV2ZW50RGF0YSkge1xyXG4gICAgICAgIGlmIChldmVudERhdGEuZ2V0RXZlbnRUeXBlKCkgPT09ICdjYW5jZWwnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmNhbGxiYWNrQ29udGV4dC5vbkNhbmNlbChldmVudERhdGEuZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHRoaXMuY2FsbGJhY2tDb250ZXh0Lm9uVmFsdWUoZXZlbnREYXRhLnNuYXBzaG90LCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjcmVhdGVDYW5jZWxFdmVudChlcnJvciwgcGF0aCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhbGxiYWNrQ29udGV4dC5oYXNDYW5jZWxDYWxsYmFjaykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENhbmNlbEV2ZW50KHRoaXMsIGVycm9yLCBwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1hdGNoZXMob3RoZXIpIHtcclxuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFZhbHVlRXZlbnRSZWdpc3RyYXRpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIW90aGVyLmNhbGxiYWNrQ29udGV4dCB8fCAhdGhpcy5jYWxsYmFja0NvbnRleHQpIHtcclxuICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgc3BlY2lmaWVkLCB3ZSBjb25zaWRlciBpdCB0byBtYXRjaCBhbnkgY2FsbGJhY2suXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG90aGVyLmNhbGxiYWNrQ29udGV4dC5tYXRjaGVzKHRoaXMuY2FsbGJhY2tDb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYXNBbnlDYWxsYmFjaygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsYmFja0NvbnRleHQgIT09IG51bGw7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIHJlZ2lzdHJhdGlvbiBvZiBhIGNoaWxkX3ggZXZlbnQuXHJcbiAqL1xyXG5jbGFzcyBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGV2ZW50VHlwZSwgY2FsbGJhY2tDb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5ldmVudFR5cGUgPSBldmVudFR5cGU7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja0NvbnRleHQgPSBjYWxsYmFja0NvbnRleHQ7XHJcbiAgICB9XHJcbiAgICByZXNwb25kc1RvKGV2ZW50VHlwZSkge1xyXG4gICAgICAgIGxldCBldmVudFRvQ2hlY2sgPSBldmVudFR5cGUgPT09ICdjaGlsZHJlbl9hZGRlZCcgPyAnY2hpbGRfYWRkZWQnIDogZXZlbnRUeXBlO1xyXG4gICAgICAgIGV2ZW50VG9DaGVjayA9XHJcbiAgICAgICAgICAgIGV2ZW50VG9DaGVjayA9PT0gJ2NoaWxkcmVuX3JlbW92ZWQnID8gJ2NoaWxkX3JlbW92ZWQnIDogZXZlbnRUb0NoZWNrO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50VHlwZSA9PT0gZXZlbnRUb0NoZWNrO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlQ2FuY2VsRXZlbnQoZXJyb3IsIHBhdGgpIHtcclxuICAgICAgICBpZiAodGhpcy5jYWxsYmFja0NvbnRleHQuaGFzQ2FuY2VsQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYW5jZWxFdmVudCh0aGlzLCBlcnJvciwgcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjcmVhdGVFdmVudChjaGFuZ2UsIHF1ZXJ5KSB7XHJcbiAgICAgICAgYXNzZXJ0KGNoYW5nZS5jaGlsZE5hbWUgIT0gbnVsbCwgJ0NoaWxkIGV2ZW50cyBzaG91bGQgaGF2ZSBhIGNoaWxkTmFtZS4nKTtcclxuICAgICAgICBjb25zdCBjaGlsZFJlZiA9IGNoaWxkKG5ldyBSZWZlcmVuY2VJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCksIGNoYW5nZS5jaGlsZE5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gcXVlcnkuX3F1ZXJ5UGFyYW1zLmdldEluZGV4KCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhRXZlbnQoY2hhbmdlLnR5cGUsIHRoaXMsIG5ldyBEYXRhU25hcHNob3QoY2hhbmdlLnNuYXBzaG90Tm9kZSwgY2hpbGRSZWYsIGluZGV4KSwgY2hhbmdlLnByZXZOYW1lKTtcclxuICAgIH1cclxuICAgIGdldEV2ZW50UnVubmVyKGV2ZW50RGF0YSkge1xyXG4gICAgICAgIGlmIChldmVudERhdGEuZ2V0RXZlbnRUeXBlKCkgPT09ICdjYW5jZWwnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmNhbGxiYWNrQ29udGV4dC5vbkNhbmNlbChldmVudERhdGEuZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHRoaXMuY2FsbGJhY2tDb250ZXh0Lm9uVmFsdWUoZXZlbnREYXRhLnNuYXBzaG90LCBldmVudERhdGEucHJldk5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1hdGNoZXMob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5ldmVudFR5cGUgPT09IG90aGVyLmV2ZW50VHlwZSAmJlxyXG4gICAgICAgICAgICAgICAgKCF0aGlzLmNhbGxiYWNrQ29udGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICFvdGhlci5jYWxsYmFja0NvbnRleHQgfHxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrQ29udGV4dC5tYXRjaGVzKG90aGVyLmNhbGxiYWNrQ29udGV4dCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaGFzQW55Q2FsbGJhY2soKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5jYWxsYmFja0NvbnRleHQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihxdWVyeSwgZXZlbnRUeXBlLCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpIHtcclxuICAgIGxldCBjYW5jZWxDYWxsYmFjaztcclxuICAgIGlmICh0eXBlb2YgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgY2FuY2VsQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgb3B0aW9ucyA9IGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNhbmNlbENhbGxiYWNrID0gY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9ubHlPbmNlKSB7XHJcbiAgICAgICAgY29uc3QgdXNlckNhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICAgICAgY29uc3Qgb25jZUNhbGxiYWNrID0gKGRhdGFTbmFwc2hvdCwgcHJldmlvdXNDaGlsZE5hbWUpID0+IHtcclxuICAgICAgICAgICAgcmVwb1JlbW92ZUV2ZW50Q2FsbGJhY2tGb3JRdWVyeShxdWVyeS5fcmVwbywgcXVlcnksIGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIHVzZXJDYWxsYmFjayhkYXRhU25hcHNob3QsIHByZXZpb3VzQ2hpbGROYW1lKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIG9uY2VDYWxsYmFjay51c2VyQ2FsbGJhY2sgPSBjYWxsYmFjay51c2VyQ2FsbGJhY2s7XHJcbiAgICAgICAgb25jZUNhbGxiYWNrLmNvbnRleHQgPSBjYWxsYmFjay5jb250ZXh0O1xyXG4gICAgICAgIGNhbGxiYWNrID0gb25jZUNhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY2FsbGJhY2tDb250ZXh0ID0gbmV3IENhbGxiYWNrQ29udGV4dChjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2sgfHwgdW5kZWZpbmVkKTtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGV2ZW50VHlwZSA9PT0gJ3ZhbHVlJ1xyXG4gICAgICAgID8gbmV3IFZhbHVlRXZlbnRSZWdpc3RyYXRpb24oY2FsbGJhY2tDb250ZXh0KVxyXG4gICAgICAgIDogbmV3IENoaWxkRXZlbnRSZWdpc3RyYXRpb24oZXZlbnRUeXBlLCBjYWxsYmFja0NvbnRleHQpO1xyXG4gICAgcmVwb0FkZEV2ZW50Q2FsbGJhY2tGb3JRdWVyeShxdWVyeS5fcmVwbywgcXVlcnksIGNvbnRhaW5lcik7XHJcbiAgICByZXR1cm4gKCkgPT4gcmVwb1JlbW92ZUV2ZW50Q2FsbGJhY2tGb3JRdWVyeShxdWVyeS5fcmVwbywgcXVlcnksIGNvbnRhaW5lcik7XHJcbn1cclxuZnVuY3Rpb24gb25WYWx1ZShxdWVyeSwgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYWRkRXZlbnRMaXN0ZW5lcihxdWVyeSwgJ3ZhbHVlJywgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBvbkNoaWxkQWRkZWQocXVlcnksIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIocXVlcnksICdjaGlsZF9hZGRlZCcsIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gb25DaGlsZENoYW5nZWQocXVlcnksIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIocXVlcnksICdjaGlsZF9jaGFuZ2VkJywgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBvbkNoaWxkTW92ZWQocXVlcnksIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIocXVlcnksICdjaGlsZF9tb3ZlZCcsIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gb25DaGlsZFJlbW92ZWQocXVlcnksIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIocXVlcnksICdjaGlsZF9yZW1vdmVkJywgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKTtcclxufVxyXG4vKipcclxuICogRGV0YWNoZXMgYSBjYWxsYmFjayBwcmV2aW91c2x5IGF0dGFjaGVkIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgYG9uKigpYCAoYG9uVmFsdWVgLCBgb25DaGlsZEFkZGVkYCkgbGlzdGVuZXIuXHJcbiAqIE5vdGU6IFRoaXMgaXMgbm90IHRoZSByZWNvbW1lbmRlZCB3YXkgdG8gcmVtb3ZlIGEgbGlzdGVuZXIuIEluc3RlYWQsIHBsZWFzZSB1c2UgdGhlIHJldHVybmVkIGNhbGxiYWNrIGZ1bmN0aW9uIGZyb21cclxuICogdGhlIHJlc3BlY3RpdmUgYG9uKmAgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBEZXRhY2ggYSBjYWxsYmFjayBwcmV2aW91c2x5IGF0dGFjaGVkIHdpdGggYG9uKigpYC4gQ2FsbGluZyBgb2ZmKClgIG9uIGEgcGFyZW50IGxpc3RlbmVyXHJcbiAqIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgcmVtb3ZlIGxpc3RlbmVycyByZWdpc3RlcmVkIG9uIGNoaWxkIG5vZGVzLCBgb2ZmKClgXHJcbiAqIG11c3QgYWxzbyBiZSBjYWxsZWQgb24gYW55IGNoaWxkIGxpc3RlbmVycyB0byByZW1vdmUgdGhlIGNhbGxiYWNrLlxyXG4gKlxyXG4gKiBJZiBhIGNhbGxiYWNrIGlzIG5vdCBzcGVjaWZpZWQsIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRUeXBlXHJcbiAqIHdpbGwgYmUgcmVtb3ZlZC4gU2ltaWxhcmx5LCBpZiBubyBldmVudFR5cGUgaXMgc3BlY2lmaWVkLCBhbGwgY2FsbGJhY2tzXHJcbiAqIGZvciB0aGUgYFJlZmVyZW5jZWAgd2lsbCBiZSByZW1vdmVkLlxyXG4gKlxyXG4gKiBJbmRpdmlkdWFsIGxpc3RlbmVycyBjYW4gYWxzbyBiZSByZW1vdmVkIGJ5IGludm9raW5nIHRoZWlyIHVuc3Vic2NyaWJlXHJcbiAqIGNhbGxiYWNrcy5cclxuICpcclxuICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRoYXQgdGhlIGxpc3RlbmVyIHdhcyByZWdpc3RlcmVkIHdpdGguXHJcbiAqIEBwYXJhbSBldmVudFR5cGUgLSBPbmUgb2YgdGhlIGZvbGxvd2luZyBzdHJpbmdzOiBcInZhbHVlXCIsIFwiY2hpbGRfYWRkZWRcIixcclxuICogXCJjaGlsZF9jaGFuZ2VkXCIsIFwiY2hpbGRfcmVtb3ZlZFwiLCBvciBcImNoaWxkX21vdmVkLlwiIElmIG9taXR0ZWQsIGFsbCBjYWxsYmFja3NcclxuICogZm9yIHRoZSBgUmVmZXJlbmNlYCB3aWxsIGJlIHJlbW92ZWQuXHJcbiAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdhcyBwYXNzZWQgdG8gYG9uKClgIG9yXHJcbiAqIGB1bmRlZmluZWRgIHRvIHJlbW92ZSBhbGwgY2FsbGJhY2tzLlxyXG4gKi9cclxuZnVuY3Rpb24gb2ZmKHF1ZXJ5LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICBsZXQgY29udGFpbmVyID0gbnVsbDtcclxuICAgIGNvbnN0IGV4cENhbGxiYWNrID0gY2FsbGJhY2sgPyBuZXcgQ2FsbGJhY2tDb250ZXh0KGNhbGxiYWNrKSA6IG51bGw7XHJcbiAgICBpZiAoZXZlbnRUeXBlID09PSAndmFsdWUnKSB7XHJcbiAgICAgICAgY29udGFpbmVyID0gbmV3IFZhbHVlRXZlbnRSZWdpc3RyYXRpb24oZXhwQ2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgY29udGFpbmVyID0gbmV3IENoaWxkRXZlbnRSZWdpc3RyYXRpb24oZXZlbnRUeXBlLCBleHBDYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICByZXBvUmVtb3ZlRXZlbnRDYWxsYmFja0ZvclF1ZXJ5KHF1ZXJ5Ll9yZXBvLCBxdWVyeSwgY29udGFpbmVyKTtcclxufVxyXG4vKipcclxuICogQSBgUXVlcnlDb25zdHJhaW50YCBpcyB1c2VkIHRvIG5hcnJvdyB0aGUgc2V0IG9mIGRvY3VtZW50cyByZXR1cm5lZCBieSBhXHJcbiAqIERhdGFiYXNlIHF1ZXJ5LiBgUXVlcnlDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIGVuZEF0fSxcclxuICoge0BsaW5rIGVuZEJlZm9yZX0sIHtAbGluayBzdGFydEF0fSwge0BsaW5rIHN0YXJ0QWZ0ZXJ9LCB7QGxpbmtcclxuICogbGltaXRUb0ZpcnN0fSwge0BsaW5rIGxpbWl0VG9MYXN0fSwge0BsaW5rIG9yZGVyQnlDaGlsZH0sXHJcbiAqIHtAbGluayBvcmRlckJ5Q2hpbGR9LCB7QGxpbmsgb3JkZXJCeUtleX0gLCB7QGxpbmsgb3JkZXJCeVByaW9yaXR5fSAsXHJcbiAqIHtAbGluayBvcmRlckJ5VmFsdWV9ICBvciB7QGxpbmsgZXF1YWxUb30gYW5kXHJcbiAqIGNhbiB0aGVuIGJlIHBhc3NlZCB0byB7QGxpbmsgcXVlcnl9IHRvIGNyZWF0ZSBhIG5ldyBxdWVyeSBpbnN0YW5jZSB0aGF0XHJcbiAqIGFsc28gY29udGFpbnMgdGhpcyBgUXVlcnlDb25zdHJhaW50YC5cclxuICovXHJcbmNsYXNzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbn1cclxuY2xhc3MgUXVlcnlFbmRBdENvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX3ZhbHVlLCBfa2V5KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdlbmRBdCc7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnZW5kQXQnLCB0aGlzLl92YWx1ZSwgcXVlcnkuX3BhdGgsIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zRW5kQXQocXVlcnkuX3F1ZXJ5UGFyYW1zLCB0aGlzLl92YWx1ZSwgdGhpcy5fa2V5KTtcclxuICAgICAgICB2YWxpZGF0ZUxpbWl0KG5ld1BhcmFtcyk7XHJcbiAgICAgICAgdmFsaWRhdGVRdWVyeUVuZHBvaW50cyhuZXdQYXJhbXMpO1xyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMuaGFzRW5kKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmRBdDogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQsICcgK1xyXG4gICAgICAgICAgICAgICAgJ2VuZEJlZm9yZSBvciBlcXVhbFRvKS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGBRdWVyeUNvbnN0cmFpbnRgIHdpdGggdGhlIHNwZWNpZmllZCBlbmRpbmcgcG9pbnQuXHJcbiAqXHJcbiAqIFVzaW5nIGBzdGFydEF0KClgLCBgc3RhcnRBZnRlcigpYCwgYGVuZEJlZm9yZSgpYCwgYGVuZEF0KClgIGFuZCBgZXF1YWxUbygpYFxyXG4gKiBhbGxvd3MgeW91IHRvIGNob29zZSBhcmJpdHJhcnkgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMgZm9yIHlvdXIgcXVlcmllcy5cclxuICpcclxuICogVGhlIGVuZGluZyBwb2ludCBpcyBpbmNsdXNpdmUsIHNvIGNoaWxkcmVuIHdpdGggZXhhY3RseSB0aGUgc3BlY2lmaWVkIHZhbHVlXHJcbiAqIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHF1ZXJ5LiBUaGUgb3B0aW9uYWwga2V5IGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvXHJcbiAqIGZ1cnRoZXIgbGltaXQgdGhlIHJhbmdlIG9mIHRoZSBxdWVyeS4gSWYgaXQgaXMgc3BlY2lmaWVkLCB0aGVuIGNoaWxkcmVuIHRoYXRcclxuICogaGF2ZSBleGFjdGx5IHRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBhbHNvIGhhdmUgYSBrZXkgbmFtZSBsZXNzIHRoYW4gb3IgZXF1YWxcclxuICogdG8gdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBlbmRBdCgpYCBpblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjZmlsdGVyaW5nX2RhdGEgfCBGaWx0ZXJpbmcgZGF0YX0uXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBlbmQgYXQuIFRoZSBhcmd1bWVudCB0eXBlIGRlcGVuZHMgb24gd2hpY2hcclxuICogYG9yZGVyQnkqKClgIGZ1bmN0aW9uIHdhcyB1c2VkIGluIHRoaXMgcXVlcnkuIFNwZWNpZnkgYSB2YWx1ZSB0aGF0IG1hdGNoZXNcclxuICogdGhlIGBvcmRlckJ5KigpYCB0eXBlLiBXaGVuIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBgb3JkZXJCeUtleSgpYCwgdGhlXHJcbiAqIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSBrZXkgLSBUaGUgY2hpbGQga2V5IHRvIGVuZCBhdCwgYW1vbmcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHByZXZpb3VzbHlcclxuICogc3BlY2lmaWVkIHByaW9yaXR5LiBUaGlzIGFyZ3VtZW50IGlzIG9ubHkgYWxsb3dlZCBpZiBvcmRlcmluZyBieSBjaGlsZCxcclxuICogdmFsdWUsIG9yIHByaW9yaXR5LlxyXG4gKi9cclxuZnVuY3Rpb24gZW5kQXQodmFsdWUsIGtleSkge1xyXG4gICAgdmFsaWRhdGVLZXkoJ2VuZEF0JywgJ2tleScsIGtleSwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5RW5kQXRDb25zdHJhaW50KHZhbHVlLCBrZXkpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5RW5kQmVmb3JlQ29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfdmFsdWUsIF9rZXkpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2VuZEJlZm9yZSc7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnZW5kQmVmb3JlJywgdGhpcy5fdmFsdWUsIHF1ZXJ5Ll9wYXRoLCBmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNFbmRCZWZvcmUocXVlcnkuX3F1ZXJ5UGFyYW1zLCB0aGlzLl92YWx1ZSwgdGhpcy5fa2V5KTtcclxuICAgICAgICB2YWxpZGF0ZUxpbWl0KG5ld1BhcmFtcyk7XHJcbiAgICAgICAgdmFsaWRhdGVRdWVyeUVuZHBvaW50cyhuZXdQYXJhbXMpO1xyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMuaGFzRW5kKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmRCZWZvcmU6IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGVuZEF0LCAnICtcclxuICAgICAgICAgICAgICAgICdlbmRCZWZvcmUgb3IgZXF1YWxUbykuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgbmV3UGFyYW1zLCBxdWVyeS5fb3JkZXJCeUNhbGxlZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBgUXVlcnlDb25zdHJhaW50YCB3aXRoIHRoZSBzcGVjaWZpZWQgZW5kaW5nIHBvaW50IChleGNsdXNpdmUpLlxyXG4gKlxyXG4gKiBVc2luZyBgc3RhcnRBdCgpYCwgYHN0YXJ0QWZ0ZXIoKWAsIGBlbmRCZWZvcmUoKWAsIGBlbmRBdCgpYCBhbmQgYGVxdWFsVG8oKWBcclxuICogYWxsb3dzIHlvdSB0byBjaG9vc2UgYXJiaXRyYXJ5IHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzIGZvciB5b3VyIHF1ZXJpZXMuXHJcbiAqXHJcbiAqIFRoZSBlbmRpbmcgcG9pbnQgaXMgZXhjbHVzaXZlLiBJZiBvbmx5IGEgdmFsdWUgaXMgcHJvdmlkZWQsIGNoaWxkcmVuXHJcbiAqIHdpdGggYSB2YWx1ZSBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCB2YWx1ZSB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBxdWVyeS5cclxuICogSWYgYSBrZXkgaXMgc3BlY2lmaWVkLCB0aGVuIGNoaWxkcmVuIG11c3QgaGF2ZSBhIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbFxyXG4gKiB0byB0aGUgc3BlY2lmaWVkIHZhbHVlIGFuZCBhIGtleSBuYW1lIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkIGtleS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGVuZCBiZWZvcmUuIFRoZSBhcmd1bWVudCB0eXBlIGRlcGVuZHMgb24gd2hpY2hcclxuICogYG9yZGVyQnkqKClgIGZ1bmN0aW9uIHdhcyB1c2VkIGluIHRoaXMgcXVlcnkuIFNwZWNpZnkgYSB2YWx1ZSB0aGF0IG1hdGNoZXNcclxuICogdGhlIGBvcmRlckJ5KigpYCB0eXBlLiBXaGVuIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBgb3JkZXJCeUtleSgpYCwgdGhlXHJcbiAqIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSBrZXkgLSBUaGUgY2hpbGQga2V5IHRvIGVuZCBiZWZvcmUsIGFtb25nIHRoZSBjaGlsZHJlbiB3aXRoIHRoZVxyXG4gKiBwcmV2aW91c2x5IHNwZWNpZmllZCBwcmlvcml0eS4gVGhpcyBhcmd1bWVudCBpcyBvbmx5IGFsbG93ZWQgaWYgb3JkZXJpbmcgYnlcclxuICogY2hpbGQsIHZhbHVlLCBvciBwcmlvcml0eS5cclxuICovXHJcbmZ1bmN0aW9uIGVuZEJlZm9yZSh2YWx1ZSwga2V5KSB7XHJcbiAgICB2YWxpZGF0ZUtleSgnZW5kQmVmb3JlJywgJ2tleScsIGtleSwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5RW5kQmVmb3JlQ29uc3RyYWludCh2YWx1ZSwga2V5KTtcclxufVxyXG5jbGFzcyBRdWVyeVN0YXJ0QXRDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF92YWx1ZSwgX2tleSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnc3RhcnRBdCc7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnc3RhcnRBdCcsIHRoaXMuX3ZhbHVlLCBxdWVyeS5fcGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNTdGFydEF0KHF1ZXJ5Ll9xdWVyeVBhcmFtcywgdGhpcy5fdmFsdWUsIHRoaXMuX2tleSk7XHJcbiAgICAgICAgdmFsaWRhdGVMaW1pdChuZXdQYXJhbXMpO1xyXG4gICAgICAgIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMobmV3UGFyYW1zKTtcclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmhhc1N0YXJ0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydEF0OiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBzdGFydEF0LCAnICtcclxuICAgICAgICAgICAgICAgICdzdGFydEJlZm9yZSBvciBlcXVhbFRvKS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGBRdWVyeUNvbnN0cmFpbnRgIHdpdGggdGhlIHNwZWNpZmllZCBzdGFydGluZyBwb2ludC5cclxuICpcclxuICogVXNpbmcgYHN0YXJ0QXQoKWAsIGBzdGFydEFmdGVyKClgLCBgZW5kQmVmb3JlKClgLCBgZW5kQXQoKWAgYW5kIGBlcXVhbFRvKClgXHJcbiAqIGFsbG93cyB5b3UgdG8gY2hvb3NlIGFyYml0cmFyeSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cyBmb3IgeW91ciBxdWVyaWVzLlxyXG4gKlxyXG4gKiBUaGUgc3RhcnRpbmcgcG9pbnQgaXMgaW5jbHVzaXZlLCBzbyBjaGlsZHJlbiB3aXRoIGV4YWN0bHkgdGhlIHNwZWNpZmllZCB2YWx1ZVxyXG4gKiB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBxdWVyeS4gVGhlIG9wdGlvbmFsIGtleSBhcmd1bWVudCBjYW4gYmUgdXNlZCB0b1xyXG4gKiBmdXJ0aGVyIGxpbWl0IHRoZSByYW5nZSBvZiB0aGUgcXVlcnkuIElmIGl0IGlzIHNwZWNpZmllZCwgdGhlbiBjaGlsZHJlbiB0aGF0XHJcbiAqIGhhdmUgZXhhY3RseSB0aGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYWxzbyBoYXZlIGEga2V5IG5hbWUgZ3JlYXRlciB0aGFuIG9yXHJcbiAqIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gKlxyXG4gKiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBgc3RhcnRBdCgpYCBpblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjZmlsdGVyaW5nX2RhdGEgfCBGaWx0ZXJpbmcgZGF0YX0uXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzdGFydCBhdC4gVGhlIGFyZ3VtZW50IHR5cGUgZGVwZW5kcyBvbiB3aGljaFxyXG4gKiBgb3JkZXJCeSooKWAgZnVuY3Rpb24gd2FzIHVzZWQgaW4gdGhpcyBxdWVyeS4gU3BlY2lmeSBhIHZhbHVlIHRoYXQgbWF0Y2hlc1xyXG4gKiB0aGUgYG9yZGVyQnkqKClgIHR5cGUuIFdoZW4gdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBvcmRlckJ5S2V5KClgLCB0aGVcclxuICogdmFsdWUgbXVzdCBiZSBhIHN0cmluZy5cclxuICogQHBhcmFtIGtleSAtIFRoZSBjaGlsZCBrZXkgdG8gc3RhcnQgYXQuIFRoaXMgYXJndW1lbnQgaXMgb25seSBhbGxvd2VkIGlmXHJcbiAqIG9yZGVyaW5nIGJ5IGNoaWxkLCB2YWx1ZSwgb3IgcHJpb3JpdHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdGFydEF0KHZhbHVlID0gbnVsbCwga2V5KSB7XHJcbiAgICB2YWxpZGF0ZUtleSgnc3RhcnRBdCcsICdrZXknLCBrZXksIHRydWUpO1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeVN0YXJ0QXRDb25zdHJhaW50KHZhbHVlLCBrZXkpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5U3RhcnRBZnRlckNvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX3ZhbHVlLCBfa2V5KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdzdGFydEFmdGVyJztcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdzdGFydEFmdGVyJywgdGhpcy5fdmFsdWUsIHF1ZXJ5Ll9wYXRoLCBmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNTdGFydEFmdGVyKHF1ZXJ5Ll9xdWVyeVBhcmFtcywgdGhpcy5fdmFsdWUsIHRoaXMuX2tleSk7XHJcbiAgICAgICAgdmFsaWRhdGVMaW1pdChuZXdQYXJhbXMpO1xyXG4gICAgICAgIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMobmV3UGFyYW1zKTtcclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmhhc1N0YXJ0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydEFmdGVyOiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBzdGFydEF0LCAnICtcclxuICAgICAgICAgICAgICAgICdzdGFydEFmdGVyLCBvciBlcXVhbFRvKS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGBRdWVyeUNvbnN0cmFpbnRgIHdpdGggdGhlIHNwZWNpZmllZCBzdGFydGluZyBwb2ludCAoZXhjbHVzaXZlKS5cclxuICpcclxuICogVXNpbmcgYHN0YXJ0QXQoKWAsIGBzdGFydEFmdGVyKClgLCBgZW5kQmVmb3JlKClgLCBgZW5kQXQoKWAgYW5kIGBlcXVhbFRvKClgXHJcbiAqIGFsbG93cyB5b3UgdG8gY2hvb3NlIGFyYml0cmFyeSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cyBmb3IgeW91ciBxdWVyaWVzLlxyXG4gKlxyXG4gKiBUaGUgc3RhcnRpbmcgcG9pbnQgaXMgZXhjbHVzaXZlLiBJZiBvbmx5IGEgdmFsdWUgaXMgcHJvdmlkZWQsIGNoaWxkcmVuXHJcbiAqIHdpdGggYSB2YWx1ZSBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCB2YWx1ZSB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBxdWVyeS5cclxuICogSWYgYSBrZXkgaXMgc3BlY2lmaWVkLCB0aGVuIGNoaWxkcmVuIG11c3QgaGF2ZSBhIHZhbHVlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbFxyXG4gKiB0byB0aGUgc3BlY2lmaWVkIHZhbHVlIGFuZCBhIGEga2V5IG5hbWUgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc3RhcnQgYWZ0ZXIuIFRoZSBhcmd1bWVudCB0eXBlIGRlcGVuZHMgb24gd2hpY2hcclxuICogYG9yZGVyQnkqKClgIGZ1bmN0aW9uIHdhcyB1c2VkIGluIHRoaXMgcXVlcnkuIFNwZWNpZnkgYSB2YWx1ZSB0aGF0IG1hdGNoZXNcclxuICogdGhlIGBvcmRlckJ5KigpYCB0eXBlLiBXaGVuIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBgb3JkZXJCeUtleSgpYCwgdGhlXHJcbiAqIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSBrZXkgLSBUaGUgY2hpbGQga2V5IHRvIHN0YXJ0IGFmdGVyLiBUaGlzIGFyZ3VtZW50IGlzIG9ubHkgYWxsb3dlZCBpZlxyXG4gKiBvcmRlcmluZyBieSBjaGlsZCwgdmFsdWUsIG9yIHByaW9yaXR5LlxyXG4gKi9cclxuZnVuY3Rpb24gc3RhcnRBZnRlcih2YWx1ZSwga2V5KSB7XHJcbiAgICB2YWxpZGF0ZUtleSgnc3RhcnRBZnRlcicsICdrZXknLCBrZXksIHRydWUpO1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeVN0YXJ0QWZ0ZXJDb25zdHJhaW50KHZhbHVlLCBrZXkpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5TGltaXRUb0ZpcnN0Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfbGltaXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2xpbWl0ID0gX2xpbWl0O1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdsaW1pdFRvRmlyc3QnO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNMaW1pdCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGltaXRUb0ZpcnN0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdFRvRmlyc3QgJyArXHJcbiAgICAgICAgICAgICAgICAnb3IgbGltaXRUb0xhc3QpLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIHF1ZXJ5UGFyYW1zTGltaXRUb0ZpcnN0KHF1ZXJ5Ll9xdWVyeVBhcmFtcywgdGhpcy5fbGltaXQpLCBxdWVyeS5fb3JkZXJCeUNhbGxlZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgYFF1ZXJ5Q29uc3RyYWludGAgdGhhdCBpZiBsaW1pdGVkIHRvIHRoZSBmaXJzdCBzcGVjaWZpYyBudW1iZXJcclxuICogb2YgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIFRoZSBgbGltaXRUb0ZpcnN0KClgIG1ldGhvZCBpcyB1c2VkIHRvIHNldCBhIG1heGltdW0gbnVtYmVyIG9mIGNoaWxkcmVuIHRvIGJlXHJcbiAqIHN5bmNlZCBmb3IgYSBnaXZlbiBjYWxsYmFjay4gSWYgd2Ugc2V0IGEgbGltaXQgb2YgMTAwLCB3ZSB3aWxsIGluaXRpYWxseSBvbmx5XHJcbiAqIHJlY2VpdmUgdXAgdG8gMTAwIGBjaGlsZF9hZGRlZGAgZXZlbnRzLiBJZiB3ZSBoYXZlIGZld2VyIHRoYW4gMTAwIG1lc3NhZ2VzXHJcbiAqIHN0b3JlZCBpbiBvdXIgRGF0YWJhc2UsIGEgYGNoaWxkX2FkZGVkYCBldmVudCB3aWxsIGZpcmUgZm9yIGVhY2ggbWVzc2FnZS5cclxuICogSG93ZXZlciwgaWYgd2UgaGF2ZSBvdmVyIDEwMCBtZXNzYWdlcywgd2Ugd2lsbCBvbmx5IHJlY2VpdmUgYSBgY2hpbGRfYWRkZWRgXHJcbiAqIGV2ZW50IGZvciB0aGUgZmlyc3QgMTAwIG9yZGVyZWQgbWVzc2FnZXMuIEFzIGl0ZW1zIGNoYW5nZSwgd2Ugd2lsbCByZWNlaXZlXHJcbiAqIGBjaGlsZF9yZW1vdmVkYCBldmVudHMgZm9yIGVhY2ggaXRlbSB0aGF0IGRyb3BzIG91dCBvZiB0aGUgYWN0aXZlIGxpc3Qgc29cclxuICogdGhhdCB0aGUgdG90YWwgbnVtYmVyIHN0YXlzIGF0IDEwMC5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYGxpbWl0VG9GaXJzdCgpYCBpblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjZmlsdGVyaW5nX2RhdGEgfCBGaWx0ZXJpbmcgZGF0YX0uXHJcbiAqXHJcbiAqIEBwYXJhbSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBub2RlcyB0byBpbmNsdWRlIGluIHRoaXMgcXVlcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBsaW1pdFRvRmlyc3QobGltaXQpIHtcclxuICAgIGlmICh0eXBlb2YgbGltaXQgIT09ICdudW1iZXInIHx8IE1hdGguZmxvb3IobGltaXQpICE9PSBsaW1pdCB8fCBsaW1pdCA8PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW1pdFRvRmlyc3Q6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBRdWVyeUxpbWl0VG9GaXJzdENvbnN0cmFpbnQobGltaXQpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5TGltaXRUb0xhc3RDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF9saW1pdCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fbGltaXQgPSBfbGltaXQ7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2xpbWl0VG9MYXN0JztcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMuaGFzTGltaXQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpbWl0VG9MYXN0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdFRvRmlyc3QgJyArXHJcbiAgICAgICAgICAgICAgICAnb3IgbGltaXRUb0xhc3QpLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIHF1ZXJ5UGFyYW1zTGltaXRUb0xhc3QocXVlcnkuX3F1ZXJ5UGFyYW1zLCB0aGlzLl9saW1pdCksIHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBgUXVlcnlDb25zdHJhaW50YCB0aGF0IGlzIGxpbWl0ZWQgdG8gcmV0dXJuIG9ubHkgdGhlIGxhc3RcclxuICogc3BlY2lmaWVkIG51bWJlciBvZiBjaGlsZHJlbi5cclxuICpcclxuICogVGhlIGBsaW1pdFRvTGFzdCgpYCBtZXRob2QgaXMgdXNlZCB0byBzZXQgYSBtYXhpbXVtIG51bWJlciBvZiBjaGlsZHJlbiB0byBiZVxyXG4gKiBzeW5jZWQgZm9yIGEgZ2l2ZW4gY2FsbGJhY2suIElmIHdlIHNldCBhIGxpbWl0IG9mIDEwMCwgd2Ugd2lsbCBpbml0aWFsbHkgb25seVxyXG4gKiByZWNlaXZlIHVwIHRvIDEwMCBgY2hpbGRfYWRkZWRgIGV2ZW50cy4gSWYgd2UgaGF2ZSBmZXdlciB0aGFuIDEwMCBtZXNzYWdlc1xyXG4gKiBzdG9yZWQgaW4gb3VyIERhdGFiYXNlLCBhIGBjaGlsZF9hZGRlZGAgZXZlbnQgd2lsbCBmaXJlIGZvciBlYWNoIG1lc3NhZ2UuXHJcbiAqIEhvd2V2ZXIsIGlmIHdlIGhhdmUgb3ZlciAxMDAgbWVzc2FnZXMsIHdlIHdpbGwgb25seSByZWNlaXZlIGEgYGNoaWxkX2FkZGVkYFxyXG4gKiBldmVudCBmb3IgdGhlIGxhc3QgMTAwIG9yZGVyZWQgbWVzc2FnZXMuIEFzIGl0ZW1zIGNoYW5nZSwgd2Ugd2lsbCByZWNlaXZlXHJcbiAqIGBjaGlsZF9yZW1vdmVkYCBldmVudHMgZm9yIGVhY2ggaXRlbSB0aGF0IGRyb3BzIG91dCBvZiB0aGUgYWN0aXZlIGxpc3Qgc29cclxuICogdGhhdCB0aGUgdG90YWwgbnVtYmVyIHN0YXlzIGF0IDEwMC5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYGxpbWl0VG9MYXN0KClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNmaWx0ZXJpbmdfZGF0YSB8IEZpbHRlcmluZyBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG5vZGVzIHRvIGluY2x1ZGUgaW4gdGhpcyBxdWVyeS5cclxuICovXHJcbmZ1bmN0aW9uIGxpbWl0VG9MYXN0KGxpbWl0KSB7XHJcbiAgICBpZiAodHlwZW9mIGxpbWl0ICE9PSAnbnVtYmVyJyB8fCBNYXRoLmZsb29yKGxpbWl0KSAhPT0gbGltaXQgfHwgbGltaXQgPD0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGltaXRUb0xhc3Q6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBRdWVyeUxpbWl0VG9MYXN0Q29uc3RyYWludChsaW1pdCk7XHJcbn1cclxuY2xhc3MgUXVlcnlPcmRlckJ5Q2hpbGRDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF9wYXRoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9wYXRoID0gX3BhdGg7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ29yZGVyQnlDaGlsZCc7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbChxdWVyeSwgJ29yZGVyQnlDaGlsZCcpO1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZFBhdGggPSBuZXcgUGF0aCh0aGlzLl9wYXRoKTtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocGFyc2VkUGF0aCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcmRlckJ5Q2hpbGQ6IGNhbm5vdCBwYXNzIGluIGVtcHR5IHBhdGguIFVzZSBvcmRlckJ5VmFsdWUoKSBpbnN0ZWFkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbmRleCA9IG5ldyBQYXRoSW5kZXgocGFyc2VkUGF0aCk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNPcmRlckJ5KHF1ZXJ5Ll9xdWVyeVBhcmFtcywgaW5kZXgpO1xyXG4gICAgICAgIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMobmV3UGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgXHJcbiAgICAgICAgLypvcmRlckJ5Q2FsbGVkPSovIHRydWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgb3JkZXJzIGJ5IHRoZSBzcGVjaWZpZWQgY2hpbGQga2V5LlxyXG4gKlxyXG4gKiBRdWVyaWVzIGNhbiBvbmx5IG9yZGVyIGJ5IG9uZSBrZXkgYXQgYSB0aW1lLiBDYWxsaW5nIGBvcmRlckJ5Q2hpbGQoKWBcclxuICogbXVsdGlwbGUgdGltZXMgb24gdGhlIHNhbWUgcXVlcnkgaXMgYW4gZXJyb3IuXHJcbiAqXHJcbiAqIEZpcmViYXNlIHF1ZXJpZXMgYWxsb3cgeW91IHRvIG9yZGVyIHlvdXIgZGF0YSBieSBhbnkgY2hpbGQga2V5IG9uIHRoZSBmbHkuXHJcbiAqIEhvd2V2ZXIsIGlmIHlvdSBrbm93IGluIGFkdmFuY2Ugd2hhdCB5b3VyIGluZGV4ZXMgd2lsbCBiZSwgeW91IGNhbiBkZWZpbmVcclxuICogdGhlbSB2aWEgdGhlIC5pbmRleE9uIHJ1bGUgaW4geW91ciBTZWN1cml0eSBSdWxlcyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLiBTZWVcclxuICogdGhle0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3NlY3VyaXR5L2luZGV4aW5nLWRhdGF9XHJcbiAqIHJ1bGUgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBvcmRlckJ5Q2hpbGQoKWAgaW5cclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI3NvcnRfZGF0YSB8IFNvcnQgZGF0YX0uXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gb3JkZXIgYnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBvcmRlckJ5Q2hpbGQocGF0aCkge1xyXG4gICAgaWYgKHBhdGggPT09ICcka2V5Jykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3JkZXJCeUNoaWxkOiBcIiRrZXlcIiBpcyBpbnZhbGlkLiAgVXNlIG9yZGVyQnlLZXkoKSBpbnN0ZWFkLicpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGF0aCA9PT0gJyRwcmlvcml0eScpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29yZGVyQnlDaGlsZDogXCIkcHJpb3JpdHlcIiBpcyBpbnZhbGlkLiAgVXNlIG9yZGVyQnlQcmlvcml0eSgpIGluc3RlYWQuJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwYXRoID09PSAnJHZhbHVlJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3JkZXJCeUNoaWxkOiBcIiR2YWx1ZVwiIGlzIGludmFsaWQuICBVc2Ugb3JkZXJCeVZhbHVlKCkgaW5zdGVhZC4nKTtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlUGF0aFN0cmluZygnb3JkZXJCeUNoaWxkJywgJ3BhdGgnLCBwYXRoLCBmYWxzZSk7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5T3JkZXJCeUNoaWxkQ29uc3RyYWludChwYXRoKTtcclxufVxyXG5jbGFzcyBRdWVyeU9yZGVyQnlLZXlDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ29yZGVyQnlLZXknO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGwocXVlcnksICdvcmRlckJ5S2V5Jyk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNPcmRlckJ5KHF1ZXJ5Ll9xdWVyeVBhcmFtcywgS0VZX0lOREVYKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIFxyXG4gICAgICAgIC8qb3JkZXJCeUNhbGxlZD0qLyB0cnVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBgUXVlcnlDb25zdHJhaW50YCB0aGF0IG9yZGVycyBieSB0aGUga2V5LlxyXG4gKlxyXG4gKiBTb3J0cyB0aGUgcmVzdWx0cyBvZiBhIHF1ZXJ5IGJ5IHRoZWlyIChhc2NlbmRpbmcpIGtleSB2YWx1ZXMuXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBvcmRlckJ5S2V5KClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNzb3J0X2RhdGEgfCBTb3J0IGRhdGF9LlxyXG4gKi9cclxuZnVuY3Rpb24gb3JkZXJCeUtleSgpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlPcmRlckJ5S2V5Q29uc3RyYWludCgpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5T3JkZXJCeVByaW9yaXR5Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdvcmRlckJ5UHJpb3JpdHknO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGwocXVlcnksICdvcmRlckJ5UHJpb3JpdHknKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc09yZGVyQnkocXVlcnkuX3F1ZXJ5UGFyYW1zLCBQUklPUklUWV9JTkRFWCk7XHJcbiAgICAgICAgdmFsaWRhdGVRdWVyeUVuZHBvaW50cyhuZXdQYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgbmV3UGFyYW1zLCBcclxuICAgICAgICAvKm9yZGVyQnlDYWxsZWQ9Ki8gdHJ1ZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgYFF1ZXJ5Q29uc3RyYWludGAgdGhhdCBvcmRlcnMgYnkgcHJpb3JpdHkuXHJcbiAqXHJcbiAqIEFwcGxpY2F0aW9ucyBuZWVkIG5vdCB1c2UgcHJpb3JpdHkgYnV0IGNhbiBvcmRlciBjb2xsZWN0aW9ucyBieVxyXG4gKiBvcmRpbmFyeSBwcm9wZXJ0aWVzIChzZWVcclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI3NvcnRfZGF0YSB8IFNvcnQgZGF0YX1cclxuICogZm9yIGFsdGVybmF0aXZlcyB0byBwcmlvcml0eS5cclxuICovXHJcbmZ1bmN0aW9uIG9yZGVyQnlQcmlvcml0eSgpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlPcmRlckJ5UHJpb3JpdHlDb25zdHJhaW50KCk7XHJcbn1cclxuY2xhc3MgUXVlcnlPcmRlckJ5VmFsdWVDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ29yZGVyQnlWYWx1ZSc7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbChxdWVyeSwgJ29yZGVyQnlWYWx1ZScpO1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zT3JkZXJCeShxdWVyeS5fcXVlcnlQYXJhbXMsIFZBTFVFX0lOREVYKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIFxyXG4gICAgICAgIC8qb3JkZXJCeUNhbGxlZD0qLyB0cnVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBgUXVlcnlDb25zdHJhaW50YCB0aGF0IG9yZGVycyBieSB2YWx1ZS5cclxuICpcclxuICogSWYgdGhlIGNoaWxkcmVuIG9mIGEgcXVlcnkgYXJlIGFsbCBzY2FsYXIgdmFsdWVzIChzdHJpbmcsIG51bWJlciwgb3JcclxuICogYm9vbGVhbiksIHlvdSBjYW4gb3JkZXIgdGhlIHJlc3VsdHMgYnkgdGhlaXIgKGFzY2VuZGluZykgdmFsdWVzLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBgb3JkZXJCeVZhbHVlKClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNzb3J0X2RhdGEgfCBTb3J0IGRhdGF9LlxyXG4gKi9cclxuZnVuY3Rpb24gb3JkZXJCeVZhbHVlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeU9yZGVyQnlWYWx1ZUNvbnN0cmFpbnQoKTtcclxufVxyXG5jbGFzcyBRdWVyeUVxdWFsVG9WYWx1ZUNvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX3ZhbHVlLCBfa2V5KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdlcXVhbFRvJztcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdlcXVhbFRvJywgdGhpcy5fdmFsdWUsIHF1ZXJ5Ll9wYXRoLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNTdGFydCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXF1YWxUbzogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gc3RhcnRBdC9zdGFydEFmdGVyIG9yICcgK1xyXG4gICAgICAgICAgICAgICAgJ2VxdWFsVG8pLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmhhc0VuZCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXF1YWxUbzogRW5kaW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGVuZEF0L2VuZEJlZm9yZSBvciAnICtcclxuICAgICAgICAgICAgICAgICdlcXVhbFRvKS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUVuZEF0Q29uc3RyYWludCh0aGlzLl92YWx1ZSwgdGhpcy5fa2V5KS5fYXBwbHkobmV3IFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQodGhpcy5fdmFsdWUsIHRoaXMuX2tleSkuX2FwcGx5KHF1ZXJ5KSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBgUXVlcnlDb25zdHJhaW50YCB0aGF0IGluY2x1ZGVzIGNoaWxkcmVuIHRoYXQgbWF0Y2ggdGhlIHNwZWNpZmllZFxyXG4gKiB2YWx1ZS5cclxuICpcclxuICogVXNpbmcgYHN0YXJ0QXQoKWAsIGBzdGFydEFmdGVyKClgLCBgZW5kQmVmb3JlKClgLCBgZW5kQXQoKWAgYW5kIGBlcXVhbFRvKClgXHJcbiAqIGFsbG93cyB5b3UgdG8gY2hvb3NlIGFyYml0cmFyeSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cyBmb3IgeW91ciBxdWVyaWVzLlxyXG4gKlxyXG4gKiBUaGUgb3B0aW9uYWwga2V5IGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvIGZ1cnRoZXIgbGltaXQgdGhlIHJhbmdlIG9mIHRoZVxyXG4gKiBxdWVyeS4gSWYgaXQgaXMgc3BlY2lmaWVkLCB0aGVuIGNoaWxkcmVuIHRoYXQgaGF2ZSBleGFjdGx5IHRoZSBzcGVjaWZpZWRcclxuICogdmFsdWUgbXVzdCBhbHNvIGhhdmUgZXhhY3RseSB0aGUgc3BlY2lmaWVkIGtleSBhcyB0aGVpciBrZXkgbmFtZS4gVGhpcyBjYW4gYmVcclxuICogdXNlZCB0byBmaWx0ZXIgcmVzdWx0IHNldHMgd2l0aCBtYW55IG1hdGNoZXMgZm9yIHRoZSBzYW1lIHZhbHVlLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBgZXF1YWxUbygpYCBpblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjZmlsdGVyaW5nX2RhdGEgfCBGaWx0ZXJpbmcgZGF0YX0uXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBtYXRjaCBmb3IuIFRoZSBhcmd1bWVudCB0eXBlIGRlcGVuZHMgb24gd2hpY2hcclxuICogYG9yZGVyQnkqKClgIGZ1bmN0aW9uIHdhcyB1c2VkIGluIHRoaXMgcXVlcnkuIFNwZWNpZnkgYSB2YWx1ZSB0aGF0IG1hdGNoZXNcclxuICogdGhlIGBvcmRlckJ5KigpYCB0eXBlLiBXaGVuIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBgb3JkZXJCeUtleSgpYCwgdGhlXHJcbiAqIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSBrZXkgLSBUaGUgY2hpbGQga2V5IHRvIHN0YXJ0IGF0LCBhbW9uZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGVcclxuICogcHJldmlvdXNseSBzcGVjaWZpZWQgcHJpb3JpdHkuIFRoaXMgYXJndW1lbnQgaXMgb25seSBhbGxvd2VkIGlmIG9yZGVyaW5nIGJ5XHJcbiAqIGNoaWxkLCB2YWx1ZSwgb3IgcHJpb3JpdHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBlcXVhbFRvKHZhbHVlLCBrZXkpIHtcclxuICAgIHZhbGlkYXRlS2V5KCdlcXVhbFRvJywgJ2tleScsIGtleSwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5RXF1YWxUb1ZhbHVlQ29uc3RyYWludCh2YWx1ZSwga2V5KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpbW11dGFibGUgaW5zdGFuY2Ugb2YgYFF1ZXJ5YCB0aGF0IGlzIGV4dGVuZGVkIHRvIGFsc28gaW5jbHVkZVxyXG4gKiBhZGRpdGlvbmFsIHF1ZXJ5IGNvbnN0cmFpbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnkgLSBUaGUgUXVlcnkgaW5zdGFuY2UgdG8gdXNlIGFzIGEgYmFzZSBmb3IgdGhlIG5ldyBjb25zdHJhaW50cy5cclxuICogQHBhcmFtIHF1ZXJ5Q29uc3RyYWludHMgLSBUaGUgbGlzdCBvZiBgUXVlcnlDb25zdHJhaW50YHMgdG8gYXBwbHkuXHJcbiAqIEB0aHJvd3MgaWYgYW55IG9mIHRoZSBwcm92aWRlZCBxdWVyeSBjb25zdHJhaW50cyBjYW5ub3QgYmUgY29tYmluZWQgd2l0aCB0aGVcclxuICogZXhpc3Rpbmcgb3IgbmV3IGNvbnN0cmFpbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnkocXVlcnksIC4uLnF1ZXJ5Q29uc3RyYWludHMpIHtcclxuICAgIGxldCBxdWVyeUltcGwgPSBnZXRNb2R1bGFySW5zdGFuY2UocXVlcnkpO1xyXG4gICAgZm9yIChjb25zdCBjb25zdHJhaW50IG9mIHF1ZXJ5Q29uc3RyYWludHMpIHtcclxuICAgICAgICBxdWVyeUltcGwgPSBjb25zdHJhaW50Ll9hcHBseShxdWVyeUltcGwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHF1ZXJ5SW1wbDtcclxufVxyXG4vKipcclxuICogRGVmaW5lIHJlZmVyZW5jZSBjb25zdHJ1Y3RvciBpbiB2YXJpb3VzIG1vZHVsZXNcclxuICpcclxuICogV2UgYXJlIGRvaW5nIHRoaXMgaGVyZSB0byBhdm9pZCBzZXZlcmFsIGNpcmN1bGFyXHJcbiAqIGRlcGVuZGVuY3kgaXNzdWVzXHJcbiAqL1xyXG5zeW5jUG9pbnRTZXRSZWZlcmVuY2VDb25zdHJ1Y3RvcihSZWZlcmVuY2VJbXBsKTtcclxuc3luY1RyZWVTZXRSZWZlcmVuY2VDb25zdHJ1Y3RvcihSZWZlcmVuY2VJbXBsKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoaXMgdmFyaWFibGUgaXMgYWxzbyBkZWZpbmVkIGluIHRoZSBmaXJlYmFzZSBOb2RlLmpzIEFkbWluIFNESy4gQmVmb3JlXHJcbiAqIG1vZGlmeWluZyB0aGlzIGRlZmluaXRpb24sIGNvbnN1bHQgdGhlIGRlZmluaXRpb24gaW46XHJcbiAqXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1hZG1pbi1ub2RlXHJcbiAqXHJcbiAqIGFuZCBtYWtlIHN1cmUgdGhlIHR3byBhcmUgY29uc2lzdGVudC5cclxuICovXHJcbmNvbnN0IEZJUkVCQVNFX0RBVEFCQVNFX0VNVUxBVE9SX0hPU1RfVkFSID0gJ0ZJUkVCQVNFX0RBVEFCQVNFX0VNVUxBVE9SX0hPU1QnO1xyXG4vKipcclxuICogQ3JlYXRlcyBhbmQgY2FjaGVzIGBSZXBvYCBpbnN0YW5jZXMuXHJcbiAqL1xyXG5jb25zdCByZXBvcyA9IHt9O1xyXG4vKipcclxuICogSWYgdHJ1ZSwgYW55IG5ldyBgUmVwb2Agd2lsbCBiZSBjcmVhdGVkIHRvIHVzZSBgUmVhZG9ubHlSZXN0Q2xpZW50YCAoZm9yIHRlc3RpbmcgcHVycG9zZXMpLlxyXG4gKi9cclxubGV0IHVzZVJlc3RDbGllbnQgPSBmYWxzZTtcclxuLyoqXHJcbiAqIFVwZGF0ZSBhbiBleGlzdGluZyBgUmVwb2AgaW4gcGxhY2UgdG8gcG9pbnQgdG8gYSBuZXcgaG9zdC9wb3J0LlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb01hbmFnZXJBcHBseUVtdWxhdG9yU2V0dGluZ3MocmVwbywgaG9zdCwgcG9ydCwgdG9rZW5Qcm92aWRlcikge1xyXG4gICAgcmVwby5yZXBvSW5mb18gPSBuZXcgUmVwb0luZm8oYCR7aG9zdH06JHtwb3J0fWAsIFxyXG4gICAgLyogc2VjdXJlPSAqLyBmYWxzZSwgcmVwby5yZXBvSW5mb18ubmFtZXNwYWNlLCByZXBvLnJlcG9JbmZvXy53ZWJTb2NrZXRPbmx5LCByZXBvLnJlcG9JbmZvXy5ub2RlQWRtaW4sIHJlcG8ucmVwb0luZm9fLnBlcnNpc3RlbmNlS2V5LCByZXBvLnJlcG9JbmZvXy5pbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtcywgXHJcbiAgICAvKmlzVXNpbmdFbXVsYXRvcj0qLyB0cnVlKTtcclxuICAgIGlmICh0b2tlblByb3ZpZGVyKSB7XHJcbiAgICAgICAgcmVwby5hdXRoVG9rZW5Qcm92aWRlcl8gPSB0b2tlblByb3ZpZGVyO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGV2ZXIgYmUgY2FsbGVkIHRvIENSRUFURSBhIG5ldyBkYXRhYmFzZSBpbnN0YW5jZS5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvTWFuYWdlckRhdGFiYXNlRnJvbUFwcChhcHAsIGF1dGhQcm92aWRlciwgYXBwQ2hlY2tQcm92aWRlciwgdXJsLCBub2RlQWRtaW4pIHtcclxuICAgIGxldCBkYlVybCA9IHVybCB8fCBhcHAub3B0aW9ucy5kYXRhYmFzZVVSTDtcclxuICAgIGlmIChkYlVybCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKCFhcHAub3B0aW9ucy5wcm9qZWN0SWQpIHtcclxuICAgICAgICAgICAgZmF0YWwoXCJDYW4ndCBkZXRlcm1pbmUgRmlyZWJhc2UgRGF0YWJhc2UgVVJMLiBCZSBzdXJlIHRvIGluY2x1ZGUgXCIgK1xyXG4gICAgICAgICAgICAgICAgJyBhIFByb2plY3QgSUQgd2hlbiBjYWxsaW5nIGZpcmViYXNlLmluaXRpYWxpemVBcHAoKS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbG9nKCdVc2luZyBkZWZhdWx0IGhvc3QgZm9yIHByb2plY3QgJywgYXBwLm9wdGlvbnMucHJvamVjdElkKTtcclxuICAgICAgICBkYlVybCA9IGAke2FwcC5vcHRpb25zLnByb2plY3RJZH0tZGVmYXVsdC1ydGRiLmZpcmViYXNlaW8uY29tYDtcclxuICAgIH1cclxuICAgIGxldCBwYXJzZWRVcmwgPSBwYXJzZVJlcG9JbmZvKGRiVXJsLCBub2RlQWRtaW4pO1xyXG4gICAgbGV0IHJlcG9JbmZvID0gcGFyc2VkVXJsLnJlcG9JbmZvO1xyXG4gICAgbGV0IGlzRW11bGF0b3I7XHJcbiAgICBsZXQgZGJFbXVsYXRvckhvc3QgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52KSB7XHJcbiAgICAgICAgZGJFbXVsYXRvckhvc3QgPSBwcm9jZXNzLmVudltGSVJFQkFTRV9EQVRBQkFTRV9FTVVMQVRPUl9IT1NUX1ZBUl07XHJcbiAgICB9XHJcbiAgICBpZiAoZGJFbXVsYXRvckhvc3QpIHtcclxuICAgICAgICBpc0VtdWxhdG9yID0gdHJ1ZTtcclxuICAgICAgICBkYlVybCA9IGBodHRwOi8vJHtkYkVtdWxhdG9ySG9zdH0/bnM9JHtyZXBvSW5mby5uYW1lc3BhY2V9YDtcclxuICAgICAgICBwYXJzZWRVcmwgPSBwYXJzZVJlcG9JbmZvKGRiVXJsLCBub2RlQWRtaW4pO1xyXG4gICAgICAgIHJlcG9JbmZvID0gcGFyc2VkVXJsLnJlcG9JbmZvO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaXNFbXVsYXRvciA9ICFwYXJzZWRVcmwucmVwb0luZm8uc2VjdXJlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYXV0aFRva2VuUHJvdmlkZXIgPSBub2RlQWRtaW4gJiYgaXNFbXVsYXRvclxyXG4gICAgICAgID8gbmV3IEVtdWxhdG9yVG9rZW5Qcm92aWRlcihFbXVsYXRvclRva2VuUHJvdmlkZXIuT1dORVIpXHJcbiAgICAgICAgOiBuZXcgRmlyZWJhc2VBdXRoVG9rZW5Qcm92aWRlcihhcHAubmFtZSwgYXBwLm9wdGlvbnMsIGF1dGhQcm92aWRlcik7XHJcbiAgICB2YWxpZGF0ZVVybCgnSW52YWxpZCBGaXJlYmFzZSBEYXRhYmFzZSBVUkwnLCBwYXJzZWRVcmwpO1xyXG4gICAgaWYgKCFwYXRoSXNFbXB0eShwYXJzZWRVcmwucGF0aCkpIHtcclxuICAgICAgICBmYXRhbCgnRGF0YWJhc2UgVVJMIG11c3QgcG9pbnQgdG8gdGhlIHJvb3Qgb2YgYSBGaXJlYmFzZSBEYXRhYmFzZSAnICtcclxuICAgICAgICAgICAgJyhub3QgaW5jbHVkaW5nIGEgY2hpbGQgcGF0aCkuJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXBvID0gcmVwb01hbmFnZXJDcmVhdGVSZXBvKHJlcG9JbmZvLCBhcHAsIGF1dGhUb2tlblByb3ZpZGVyLCBuZXcgQXBwQ2hlY2tUb2tlblByb3ZpZGVyKGFwcC5uYW1lLCBhcHBDaGVja1Byb3ZpZGVyKSk7XHJcbiAgICByZXR1cm4gbmV3IERhdGFiYXNlKHJlcG8sIGFwcCk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgcmVwbyBhbmQgbWFrZSBzdXJlIGl0IGlzIGRpc2Nvbm5lY3RlZC5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHJlcG9NYW5hZ2VyRGVsZXRlUmVwbyhyZXBvLCBhcHBOYW1lKSB7XHJcbiAgICBjb25zdCBhcHBSZXBvcyA9IHJlcG9zW2FwcE5hbWVdO1xyXG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLi4uXHJcbiAgICBpZiAoIWFwcFJlcG9zIHx8IGFwcFJlcG9zW3JlcG8ua2V5XSAhPT0gcmVwbykge1xyXG4gICAgICAgIGZhdGFsKGBEYXRhYmFzZSAke2FwcE5hbWV9KCR7cmVwby5yZXBvSW5mb199KSBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQuYCk7XHJcbiAgICB9XHJcbiAgICByZXBvSW50ZXJydXB0KHJlcG8pO1xyXG4gICAgZGVsZXRlIGFwcFJlcG9zW3JlcG8ua2V5XTtcclxufVxyXG4vKipcclxuICogRW5zdXJlcyBhIHJlcG8gZG9lc24ndCBhbHJlYWR5IGV4aXN0IGFuZCB0aGVuIGNyZWF0ZXMgb25lIHVzaW5nIHRoZVxyXG4gKiBwcm92aWRlZCBhcHAuXHJcbiAqXHJcbiAqIEBwYXJhbSByZXBvSW5mbyAtIFRoZSBtZXRhZGF0YSBhYm91dCB0aGUgUmVwb1xyXG4gKiBAcmV0dXJucyBUaGUgUmVwbyBvYmplY3QgZm9yIHRoZSBzcGVjaWZpZWQgc2VydmVyIC8gcmVwb05hbWUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvTWFuYWdlckNyZWF0ZVJlcG8ocmVwb0luZm8sIGFwcCwgYXV0aFRva2VuUHJvdmlkZXIsIGFwcENoZWNrUHJvdmlkZXIpIHtcclxuICAgIGxldCBhcHBSZXBvcyA9IHJlcG9zW2FwcC5uYW1lXTtcclxuICAgIGlmICghYXBwUmVwb3MpIHtcclxuICAgICAgICBhcHBSZXBvcyA9IHt9O1xyXG4gICAgICAgIHJlcG9zW2FwcC5uYW1lXSA9IGFwcFJlcG9zO1xyXG4gICAgfVxyXG4gICAgbGV0IHJlcG8gPSBhcHBSZXBvc1tyZXBvSW5mby50b1VSTFN0cmluZygpXTtcclxuICAgIGlmIChyZXBvKSB7XHJcbiAgICAgICAgZmF0YWwoJ0RhdGFiYXNlIGluaXRpYWxpemVkIG11bHRpcGxlIHRpbWVzLiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBmb3JtYXQgb2YgdGhlIGRhdGFiYXNlIFVSTCBtYXRjaGVzIHdpdGggZWFjaCBkYXRhYmFzZSgpIGNhbGwuJyk7XHJcbiAgICB9XHJcbiAgICByZXBvID0gbmV3IFJlcG8ocmVwb0luZm8sIHVzZVJlc3RDbGllbnQsIGF1dGhUb2tlblByb3ZpZGVyLCBhcHBDaGVja1Byb3ZpZGVyKTtcclxuICAgIGFwcFJlcG9zW3JlcG9JbmZvLnRvVVJMU3RyaW5nKCldID0gcmVwbztcclxuICAgIHJldHVybiByZXBvO1xyXG59XHJcbi8qKlxyXG4gKiBGb3JjZXMgdXMgdG8gdXNlIFJlYWRvbmx5UmVzdENsaWVudCBpbnN0ZWFkIG9mIFBlcnNpc3RlbnRDb25uZWN0aW9uIGZvciBuZXcgUmVwb3MuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvTWFuYWdlckZvcmNlUmVzdENsaWVudChmb3JjZVJlc3RDbGllbnQpIHtcclxuICAgIHVzZVJlc3RDbGllbnQgPSBmb3JjZVJlc3RDbGllbnQ7XHJcbn1cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIEZpcmViYXNlIFJlYWx0aW1lIERhdGFiYXNlLlxyXG4gKi9cclxuY2xhc3MgRGF0YWJhc2Uge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9yZXBvSW50ZXJuYWwsIFxyXG4gICAgLyoqIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgUmVhbHRpbWUgRGF0YWJhc2UgaW5zdGFuY2UuICovXHJcbiAgICBhcHApIHtcclxuICAgICAgICB0aGlzLl9yZXBvSW50ZXJuYWwgPSBfcmVwb0ludGVybmFsO1xyXG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xyXG4gICAgICAgIC8qKiBSZXByZXNlbnRzIGEgYERhdGFiYXNlYCBpbnN0YW5jZS4gKi9cclxuICAgICAgICB0aGlzWyd0eXBlJ10gPSAnZGF0YWJhc2UnO1xyXG4gICAgICAgIC8qKiBUcmFjayBpZiB0aGUgaW5zdGFuY2UgaGFzIGJlZW4gdXNlZCAocm9vdCBvciByZXBvIGFjY2Vzc2VkKSAqL1xyXG4gICAgICAgIHRoaXMuX2luc3RhbmNlU3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZ2V0IF9yZXBvKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5faW5zdGFuY2VTdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHJlcG9TdGFydCh0aGlzLl9yZXBvSW50ZXJuYWwsIHRoaXMuYXBwLm9wdGlvbnMuYXBwSWQsIHRoaXMuYXBwLm9wdGlvbnNbJ2RhdGFiYXNlQXV0aFZhcmlhYmxlT3ZlcnJpZGUnXSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlU3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXBvSW50ZXJuYWw7XHJcbiAgICB9XHJcbiAgICBnZXQgX3Jvb3QoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9yb290SW50ZXJuYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fcm9vdEludGVybmFsID0gbmV3IFJlZmVyZW5jZUltcGwodGhpcy5fcmVwbywgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdEludGVybmFsO1xyXG4gICAgfVxyXG4gICAgX2RlbGV0ZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcm9vdEludGVybmFsICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlcG9NYW5hZ2VyRGVsZXRlUmVwbyh0aGlzLl9yZXBvLCB0aGlzLmFwcC5uYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVwb0ludGVybmFsID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fcm9vdEludGVybmFsID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgX2NoZWNrTm90RGVsZXRlZChhcGlOYW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3RJbnRlcm5hbCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmYXRhbCgnQ2Fubm90IGNhbGwgJyArIGFwaU5hbWUgKyAnIG9uIGEgZGVsZXRlZCBkYXRhYmFzZS4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tUcmFuc3BvcnRJbml0KCkge1xyXG4gICAgaWYgKFRyYW5zcG9ydE1hbmFnZXIuSVNfVFJBTlNQT1JUX0lOSVRJQUxJWkVEKSB7XHJcbiAgICAgICAgd2FybignVHJhbnNwb3J0IGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWQuIFBsZWFzZSBjYWxsIHRoaXMgZnVuY3Rpb24gYmVmb3JlIGNhbGxpbmcgcmVmIG9yIHNldHRpbmcgdXAgYSBsaXN0ZW5lcicpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBGb3JjZSB0aGUgdXNlIG9mIHdlYnNvY2tldHMgaW5zdGVhZCBvZiBsb25nUG9sbGluZy5cclxuICovXHJcbmZ1bmN0aW9uIGZvcmNlV2ViU29ja2V0cygpIHtcclxuICAgIGNoZWNrVHJhbnNwb3J0SW5pdCgpO1xyXG4gICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3coKTtcclxufVxyXG4vKipcclxuICogRm9yY2UgdGhlIHVzZSBvZiBsb25nUG9sbGluZyBpbnN0ZWFkIG9mIHdlYnNvY2tldHMuIFRoaXMgd2lsbCBiZSBpZ25vcmVkIGlmIHdlYnNvY2tldCBwcm90b2NvbCBpcyB1c2VkIGluIGRhdGFiYXNlVVJMLlxyXG4gKi9cclxuZnVuY3Rpb24gZm9yY2VMb25nUG9sbGluZygpIHtcclxuICAgIGNoZWNrVHJhbnNwb3J0SW5pdCgpO1xyXG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5mb3JjZURpc2FsbG93KCk7XHJcbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VBbGxvdygpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiB0aGUgUmVhbHRpbWUgRGF0YWJhc2UgU0RLIHRoYXQgaXMgYXNzb2NpYXRlZFxyXG4gKiB3aXRoIHRoZSBwcm92aWRlZCB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0uIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIHdpdGhcclxuICogd2l0aCBkZWZhdWx0IHNldHRpbmdzIGlmIG5vIGluc3RhbmNlIGV4aXN0cyBvciBpZiB0aGUgZXhpc3RpbmcgaW5zdGFuY2UgdXNlc1xyXG4gKiBhIGN1c3RvbSBkYXRhYmFzZSBVUkwuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBUaGUge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGluc3RhbmNlIHRoYXQgdGhlIHJldHVybmVkIFJlYWx0aW1lXHJcbiAqIERhdGFiYXNlIGluc3RhbmNlIGlzIGFzc29jaWF0ZWQgd2l0aC5cclxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgb2YgdGhlIFJlYWx0aW1lIERhdGFiYXNlIGluc3RhbmNlIHRvIGNvbm5lY3QgdG8uIElmIG5vdFxyXG4gKiBwcm92aWRlZCwgdGhlIFNESyBjb25uZWN0cyB0byB0aGUgZGVmYXVsdCBpbnN0YW5jZSBvZiB0aGUgRmlyZWJhc2UgQXBwLlxyXG4gKiBAcmV0dXJucyBUaGUgYERhdGFiYXNlYCBpbnN0YW5jZSBvZiB0aGUgcHJvdmlkZWQgYXBwLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RGF0YWJhc2UoYXBwID0gZ2V0QXBwKCksIHVybCkge1xyXG4gICAgY29uc3QgZGIgPSBfZ2V0UHJvdmlkZXIoYXBwLCAnZGF0YWJhc2UnKS5nZXRJbW1lZGlhdGUoe1xyXG4gICAgICAgIGlkZW50aWZpZXI6IHVybFxyXG4gICAgfSk7XHJcbiAgICBpZiAoIWRiLl9pbnN0YW5jZVN0YXJ0ZWQpIHtcclxuICAgICAgICBjb25zdCBlbXVsYXRvciA9IGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCgnZGF0YWJhc2UnKTtcclxuICAgICAgICBpZiAoZW11bGF0b3IpIHtcclxuICAgICAgICAgICAgY29ubmVjdERhdGFiYXNlRW11bGF0b3IoZGIsIC4uLmVtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGI7XHJcbn1cclxuLyoqXHJcbiAqIE1vZGlmeSB0aGUgcHJvdmlkZWQgaW5zdGFuY2UgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgUmVhbHRpbWUgRGF0YWJhc2VcclxuICogZW11bGF0b3IuXHJcbiAqXHJcbiAqIDxwPk5vdGU6IFRoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBwZXJmb3JtaW5nIGFueSBvdGhlciBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBkYiAtIFRoZSBpbnN0YW5jZSB0byBtb2RpZnkuXHJcbiAqIEBwYXJhbSBob3N0IC0gVGhlIGVtdWxhdG9yIGhvc3QgKGV4OiBsb2NhbGhvc3QpXHJcbiAqIEBwYXJhbSBwb3J0IC0gVGhlIGVtdWxhdG9yIHBvcnQgKGV4OiA4MDgwKVxyXG4gKiBAcGFyYW0gb3B0aW9ucy5tb2NrVXNlclRva2VuIC0gdGhlIG1vY2sgYXV0aCB0b2tlbiB0byB1c2UgZm9yIHVuaXQgdGVzdGluZyBTZWN1cml0eSBSdWxlc1xyXG4gKi9cclxuZnVuY3Rpb24gY29ubmVjdERhdGFiYXNlRW11bGF0b3IoZGIsIGhvc3QsIHBvcnQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgZGIgPSBnZXRNb2R1bGFySW5zdGFuY2UoZGIpO1xyXG4gICAgZGIuX2NoZWNrTm90RGVsZXRlZCgndXNlRW11bGF0b3InKTtcclxuICAgIGlmIChkYi5faW5zdGFuY2VTdGFydGVkKSB7XHJcbiAgICAgICAgZmF0YWwoJ0Nhbm5vdCBjYWxsIHVzZUVtdWxhdG9yKCkgYWZ0ZXIgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZC4nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlcG8gPSBkYi5fcmVwb0ludGVybmFsO1xyXG4gICAgbGV0IHRva2VuUHJvdmlkZXIgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAocmVwby5yZXBvSW5mb18ubm9kZUFkbWluKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubW9ja1VzZXJUb2tlbikge1xyXG4gICAgICAgICAgICBmYXRhbCgnbW9ja1VzZXJUb2tlbiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBBZG1pbiBTREsuIEZvciBjbGllbnQgYWNjZXNzIHdpdGggbW9jayB1c2VycywgcGxlYXNlIHVzZSB0aGUgXCJmaXJlYmFzZVwiIHBhY2thZ2UgaW5zdGVhZCBvZiBcImZpcmViYXNlLWFkbWluXCIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRva2VuUHJvdmlkZXIgPSBuZXcgRW11bGF0b3JUb2tlblByb3ZpZGVyKEVtdWxhdG9yVG9rZW5Qcm92aWRlci5PV05FUik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChvcHRpb25zLm1vY2tVc2VyVG9rZW4pIHtcclxuICAgICAgICBjb25zdCB0b2tlbiA9IHR5cGVvZiBvcHRpb25zLm1vY2tVc2VyVG9rZW4gPT09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgID8gb3B0aW9ucy5tb2NrVXNlclRva2VuXHJcbiAgICAgICAgICAgIDogY3JlYXRlTW9ja1VzZXJUb2tlbihvcHRpb25zLm1vY2tVc2VyVG9rZW4sIGRiLmFwcC5vcHRpb25zLnByb2plY3RJZCk7XHJcbiAgICAgICAgdG9rZW5Qcm92aWRlciA9IG5ldyBFbXVsYXRvclRva2VuUHJvdmlkZXIodG9rZW4pO1xyXG4gICAgfVxyXG4gICAgLy8gTW9kaWZ5IHRoZSByZXBvIHRvIGFwcGx5IGVtdWxhdG9yIHNldHRpbmdzXHJcbiAgICByZXBvTWFuYWdlckFwcGx5RW11bGF0b3JTZXR0aW5ncyhyZXBvLCBob3N0LCBwb3J0LCB0b2tlblByb3ZpZGVyKTtcclxufVxyXG4vKipcclxuICogRGlzY29ubmVjdHMgZnJvbSB0aGUgc2VydmVyIChhbGwgRGF0YWJhc2Ugb3BlcmF0aW9ucyB3aWxsIGJlIGNvbXBsZXRlZFxyXG4gKiBvZmZsaW5lKS5cclxuICpcclxuICogVGhlIGNsaWVudCBhdXRvbWF0aWNhbGx5IG1haW50YWlucyBhIHBlcnNpc3RlbnQgY29ubmVjdGlvbiB0byB0aGUgRGF0YWJhc2VcclxuICogc2VydmVyLCB3aGljaCB3aWxsIHJlbWFpbiBhY3RpdmUgaW5kZWZpbml0ZWx5IGFuZCByZWNvbm5lY3Qgd2hlblxyXG4gKiBkaXNjb25uZWN0ZWQuIEhvd2V2ZXIsIHRoZSBgZ29PZmZsaW5lKClgIGFuZCBgZ29PbmxpbmUoKWAgbWV0aG9kcyBtYXkgYmUgdXNlZFxyXG4gKiB0byBjb250cm9sIHRoZSBjbGllbnQgY29ubmVjdGlvbiBpbiBjYXNlcyB3aGVyZSBhIHBlcnNpc3RlbnQgY29ubmVjdGlvbiBpc1xyXG4gKiB1bmRlc2lyYWJsZS5cclxuICpcclxuICogV2hpbGUgb2ZmbGluZSwgdGhlIGNsaWVudCB3aWxsIG5vIGxvbmdlciByZWNlaXZlIGRhdGEgdXBkYXRlcyBmcm9tIHRoZVxyXG4gKiBEYXRhYmFzZS4gSG93ZXZlciwgYWxsIERhdGFiYXNlIG9wZXJhdGlvbnMgcGVyZm9ybWVkIGxvY2FsbHkgd2lsbCBjb250aW51ZSB0b1xyXG4gKiBpbW1lZGlhdGVseSBmaXJlIGV2ZW50cywgYWxsb3dpbmcgeW91ciBhcHBsaWNhdGlvbiB0byBjb250aW51ZSBiZWhhdmluZ1xyXG4gKiBub3JtYWxseS4gQWRkaXRpb25hbGx5LCBlYWNoIG9wZXJhdGlvbiBwZXJmb3JtZWQgbG9jYWxseSB3aWxsIGF1dG9tYXRpY2FsbHlcclxuICogYmUgcXVldWVkIGFuZCByZXRyaWVkIHVwb24gcmVjb25uZWN0aW9uIHRvIHRoZSBEYXRhYmFzZSBzZXJ2ZXIuXHJcbiAqXHJcbiAqIFRvIHJlY29ubmVjdCB0byB0aGUgRGF0YWJhc2UgYW5kIGJlZ2luIHJlY2VpdmluZyByZW1vdGUgZXZlbnRzLCBzZWVcclxuICogYGdvT25saW5lKClgLlxyXG4gKlxyXG4gKiBAcGFyYW0gZGIgLSBUaGUgaW5zdGFuY2UgdG8gZGlzY29ubmVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGdvT2ZmbGluZShkYikge1xyXG4gICAgZGIgPSBnZXRNb2R1bGFySW5zdGFuY2UoZGIpO1xyXG4gICAgZGIuX2NoZWNrTm90RGVsZXRlZCgnZ29PZmZsaW5lJyk7XHJcbiAgICByZXBvSW50ZXJydXB0KGRiLl9yZXBvKTtcclxufVxyXG4vKipcclxuICogUmVjb25uZWN0cyB0byB0aGUgc2VydmVyIGFuZCBzeW5jaHJvbml6ZXMgdGhlIG9mZmxpbmUgRGF0YWJhc2Ugc3RhdGVcclxuICogd2l0aCB0aGUgc2VydmVyIHN0YXRlLlxyXG4gKlxyXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCBhZnRlciBkaXNhYmxpbmcgdGhlIGFjdGl2ZSBjb25uZWN0aW9uIHdpdGhcclxuICogYGdvT2ZmbGluZSgpYC4gT25jZSByZWNvbm5lY3RlZCwgdGhlIGNsaWVudCB3aWxsIHRyYW5zbWl0IHRoZSBwcm9wZXIgZGF0YVxyXG4gKiBhbmQgZmlyZSB0aGUgYXBwcm9wcmlhdGUgZXZlbnRzIHNvIHRoYXQgeW91ciBjbGllbnQgXCJjYXRjaGVzIHVwXCJcclxuICogYXV0b21hdGljYWxseS5cclxuICpcclxuICogQHBhcmFtIGRiIC0gVGhlIGluc3RhbmNlIHRvIHJlY29ubmVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGdvT25saW5lKGRiKSB7XHJcbiAgICBkYiA9IGdldE1vZHVsYXJJbnN0YW5jZShkYik7XHJcbiAgICBkYi5fY2hlY2tOb3REZWxldGVkKCdnb09ubGluZScpO1xyXG4gICAgcmVwb1Jlc3VtZShkYi5fcmVwbyk7XHJcbn1cclxuZnVuY3Rpb24gZW5hYmxlTG9nZ2luZyhsb2dnZXIsIHBlcnNpc3RlbnQpIHtcclxuICAgIGVuYWJsZUxvZ2dpbmckMShsb2dnZXIsIHBlcnNpc3RlbnQpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyRGF0YWJhc2UodmFyaWFudCkge1xyXG4gICAgc2V0U0RLVmVyc2lvbihTREtfVkVSU0lPTiQxKTtcclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KCdkYXRhYmFzZScsIChjb250YWluZXIsIHsgaW5zdGFuY2VJZGVudGlmaWVyOiB1cmwgfSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFwcCA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICAgICAgY29uc3QgYXV0aFByb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhdXRoLWludGVybmFsJyk7XHJcbiAgICAgICAgY29uc3QgYXBwQ2hlY2tQcm92aWRlciA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwLWNoZWNrLWludGVybmFsJyk7XHJcbiAgICAgICAgcmV0dXJuIHJlcG9NYW5hZ2VyRGF0YWJhc2VGcm9tQXBwKGFwcCwgYXV0aFByb3ZpZGVyLCBhcHBDaGVja1Byb3ZpZGVyLCB1cmwpO1xyXG4gICAgfSwgXCJQVUJMSUNcIiAvKiBDb21wb25lbnRUeXBlLlBVQkxJQyAqLykuc2V0TXVsdGlwbGVJbnN0YW5jZXModHJ1ZSkpO1xyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sIHZhcmlhbnQpO1xyXG4gICAgLy8gQlVJTERfVEFSR0VUIHdpbGwgYmUgcmVwbGFjZWQgYnkgdmFsdWVzIGxpa2UgZXNtNSwgZXNtMjAxNywgY2pzNSwgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uLCAnZXNtMjAxNycpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IFNFUlZFUl9USU1FU1RBTVAgPSB7XHJcbiAgICAnLnN2JzogJ3RpbWVzdGFtcCdcclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgYSBwbGFjZWhvbGRlciB2YWx1ZSBmb3IgYXV0by1wb3B1bGF0aW5nIHRoZSBjdXJyZW50IHRpbWVzdGFtcCAodGltZVxyXG4gKiBzaW5jZSB0aGUgVW5peCBlcG9jaCwgaW4gbWlsbGlzZWNvbmRzKSBhcyBkZXRlcm1pbmVkIGJ5IHRoZSBGaXJlYmFzZVxyXG4gKiBzZXJ2ZXJzLlxyXG4gKi9cclxuZnVuY3Rpb24gc2VydmVyVGltZXN0YW1wKCkge1xyXG4gICAgcmV0dXJuIFNFUlZFUl9USU1FU1RBTVA7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBwbGFjZWhvbGRlciB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGF0b21pY2FsbHkgaW5jcmVtZW50IHRoZVxyXG4gKiBjdXJyZW50IGRhdGFiYXNlIHZhbHVlIGJ5IHRoZSBwcm92aWRlZCBkZWx0YS5cclxuICpcclxuICogQHBhcmFtIGRlbHRhIC0gdGhlIGFtb3VudCB0byBtb2RpZnkgdGhlIGN1cnJlbnQgdmFsdWUgYXRvbWljYWxseS5cclxuICogQHJldHVybnMgQSBwbGFjZWhvbGRlciB2YWx1ZSBmb3IgbW9kaWZ5aW5nIGRhdGEgYXRvbWljYWxseSBzZXJ2ZXItc2lkZS5cclxuICovXHJcbmZ1bmN0aW9uIGluY3JlbWVudChkZWx0YSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAnLnN2Jzoge1xyXG4gICAgICAgICAgICAnaW5jcmVtZW50JzogZGVsdGFcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIHR5cGUgZm9yIHRoZSByZXNvbHZlIHZhbHVlIG9mIHtAbGluayBydW5UcmFuc2FjdGlvbn0uXHJcbiAqL1xyXG5jbGFzcyBUcmFuc2FjdGlvblJlc3VsdCB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogV2hldGhlciB0aGUgdHJhbnNhY3Rpb24gd2FzIHN1Y2Nlc3NmdWxseSBjb21taXR0ZWQuICovXHJcbiAgICBjb21taXR0ZWQsIFxyXG4gICAgLyoqIFRoZSByZXN1bHRpbmcgZGF0YSBzbmFwc2hvdC4gKi9cclxuICAgIHNuYXBzaG90KSB7XHJcbiAgICAgICAgdGhpcy5jb21taXR0ZWQgPSBjb21taXR0ZWQ7XHJcbiAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC4gKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4geyBjb21taXR0ZWQ6IHRoaXMuY29tbWl0dGVkLCBzbmFwc2hvdDogdGhpcy5zbmFwc2hvdC50b0pTT04oKSB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBdG9taWNhbGx5IG1vZGlmaWVzIHRoZSBkYXRhIGF0IHRoaXMgbG9jYXRpb24uXHJcbiAqXHJcbiAqIEF0b21pY2FsbHkgbW9kaWZ5IHRoZSBkYXRhIGF0IHRoaXMgbG9jYXRpb24uIFVubGlrZSBhIG5vcm1hbCBgc2V0KClgLCB3aGljaFxyXG4gKiBqdXN0IG92ZXJ3cml0ZXMgdGhlIGRhdGEgcmVnYXJkbGVzcyBvZiBpdHMgcHJldmlvdXMgdmFsdWUsIGBydW5UcmFuc2FjdGlvbigpYCBpc1xyXG4gKiB1c2VkIHRvIG1vZGlmeSB0aGUgZXhpc3RpbmcgdmFsdWUgdG8gYSBuZXcgdmFsdWUsIGVuc3VyaW5nIHRoZXJlIGFyZSBub1xyXG4gKiBjb25mbGljdHMgd2l0aCBvdGhlciBjbGllbnRzIHdyaXRpbmcgdG8gdGhlIHNhbWUgbG9jYXRpb24gYXQgdGhlIHNhbWUgdGltZS5cclxuICpcclxuICogVG8gYWNjb21wbGlzaCB0aGlzLCB5b3UgcGFzcyBgcnVuVHJhbnNhY3Rpb24oKWAgYW4gdXBkYXRlIGZ1bmN0aW9uIHdoaWNoIGlzXHJcbiAqIHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBjdXJyZW50IHZhbHVlIGludG8gYSBuZXcgdmFsdWUuIElmIGFub3RoZXIgY2xpZW50XHJcbiAqIHdyaXRlcyB0byB0aGUgbG9jYXRpb24gYmVmb3JlIHlvdXIgbmV3IHZhbHVlIGlzIHN1Y2Nlc3NmdWxseSB3cml0dGVuLCB5b3VyXHJcbiAqIHVwZGF0ZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoIHRoZSBuZXcgY3VycmVudCB2YWx1ZSwgYW5kIHRoZVxyXG4gKiB3cml0ZSB3aWxsIGJlIHJldHJpZWQuIFRoaXMgd2lsbCBoYXBwZW4gcmVwZWF0ZWRseSB1bnRpbCB5b3VyIHdyaXRlIHN1Y2NlZWRzXHJcbiAqIHdpdGhvdXQgY29uZmxpY3Qgb3IgeW91IGFib3J0IHRoZSB0cmFuc2FjdGlvbiBieSBub3QgcmV0dXJuaW5nIGEgdmFsdWUgZnJvbVxyXG4gKiB5b3VyIHVwZGF0ZSBmdW5jdGlvbi5cclxuICpcclxuICogTm90ZTogTW9kaWZ5aW5nIGRhdGEgd2l0aCBgc2V0KClgIHdpbGwgY2FuY2VsIGFueSBwZW5kaW5nIHRyYW5zYWN0aW9ucyBhdFxyXG4gKiB0aGF0IGxvY2F0aW9uLCBzbyBleHRyZW1lIGNhcmUgc2hvdWxkIGJlIHRha2VuIGlmIG1peGluZyBgc2V0KClgIGFuZFxyXG4gKiBgcnVuVHJhbnNhY3Rpb24oKWAgdG8gdXBkYXRlIHRoZSBzYW1lIGRhdGEuXHJcbiAqXHJcbiAqIE5vdGU6IFdoZW4gdXNpbmcgdHJhbnNhY3Rpb25zIHdpdGggU2VjdXJpdHkgYW5kIEZpcmViYXNlIFJ1bGVzIGluIHBsYWNlLCBiZVxyXG4gKiBhd2FyZSB0aGF0IGEgY2xpZW50IG5lZWRzIGAucmVhZGAgYWNjZXNzIGluIGFkZGl0aW9uIHRvIGAud3JpdGVgIGFjY2VzcyBpblxyXG4gKiBvcmRlciB0byBwZXJmb3JtIGEgdHJhbnNhY3Rpb24uIFRoaXMgaXMgYmVjYXVzZSB0aGUgY2xpZW50LXNpZGUgbmF0dXJlIG9mXHJcbiAqIHRyYW5zYWN0aW9ucyByZXF1aXJlcyB0aGUgY2xpZW50IHRvIHJlYWQgdGhlIGRhdGEgaW4gb3JkZXIgdG8gdHJhbnNhY3Rpb25hbGx5XHJcbiAqIHVwZGF0ZSBpdC5cclxuICpcclxuICogQHBhcmFtIHJlZiAtIFRoZSBsb2NhdGlvbiB0byBhdG9taWNhbGx5IG1vZGlmeS5cclxuICogQHBhcmFtIHRyYW5zYWN0aW9uVXBkYXRlIC0gQSBkZXZlbG9wZXItc3VwcGxpZWQgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBwYXNzZWRcclxuICogdGhlIGN1cnJlbnQgZGF0YSBzdG9yZWQgYXQgdGhpcyBsb2NhdGlvbiAoYXMgYSBKYXZhU2NyaXB0IG9iamVjdCkuIFRoZVxyXG4gKiBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIHRoZSBuZXcgdmFsdWUgaXQgd291bGQgbGlrZSB3cml0dGVuIChhcyBhIEphdmFTY3JpcHRcclxuICogb2JqZWN0KS4gSWYgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQgKGkuZS4geW91IHJldHVybiB3aXRoIG5vIGFyZ3VtZW50cykgdGhlXHJcbiAqIHRyYW5zYWN0aW9uIHdpbGwgYmUgYWJvcnRlZCBhbmQgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiB3aWxsIG5vdCBiZVxyXG4gKiBtb2RpZmllZC5cclxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdCB0byBjb25maWd1cmUgdHJhbnNhY3Rpb25zLlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgYG9uQ29tcGxldGVgXHJcbiAqIGNhbGxiYWNrIHRvIGhhbmRsZSBzdWNjZXNzIGFuZCBmYWlsdXJlLlxyXG4gKi9cclxuZnVuY3Rpb24gcnVuVHJhbnNhY3Rpb24ocmVmLCBcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxudHJhbnNhY3Rpb25VcGRhdGUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ1JlZmVyZW5jZS50cmFuc2FjdGlvbicsIHJlZi5fcGF0aCk7XHJcbiAgICBpZiAocmVmLmtleSA9PT0gJy5sZW5ndGgnIHx8IHJlZi5rZXkgPT09ICcua2V5cycpIHtcclxuICAgICAgICB0aHJvdyAoJ1JlZmVyZW5jZS50cmFuc2FjdGlvbiBmYWlsZWQ6ICcgKyByZWYua2V5ICsgJyBpcyBhIHJlYWQtb25seSBvYmplY3QuJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhcHBseUxvY2FsbHkgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXBwbHlMb2NhbGx5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIGNvbnN0IHByb21pc2VDb21wbGV0ZSA9IChlcnJvciwgY29tbWl0dGVkLCBub2RlKSA9PiB7XHJcbiAgICAgICAgbGV0IGRhdGFTbmFwc2hvdCA9IG51bGw7XHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkYXRhU25hcHNob3QgPSBuZXcgRGF0YVNuYXBzaG90KG5vZGUsIG5ldyBSZWZlcmVuY2VJbXBsKHJlZi5fcmVwbywgcmVmLl9wYXRoKSwgUFJJT1JJVFlfSU5ERVgpO1xyXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKG5ldyBUcmFuc2FjdGlvblJlc3VsdChjb21taXR0ZWQsIGRhdGFTbmFwc2hvdCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBBZGQgYSB3YXRjaCB0byBtYWtlIHN1cmUgd2UgZ2V0IHNlcnZlciB1cGRhdGVzLlxyXG4gICAgY29uc3QgdW53YXRjaGVyID0gb25WYWx1ZShyZWYsICgpID0+IHsgfSk7XHJcbiAgICByZXBvU3RhcnRUcmFuc2FjdGlvbihyZWYuX3JlcG8sIHJlZi5fcGF0aCwgdHJhbnNhY3Rpb25VcGRhdGUsIHByb21pc2VDb21wbGV0ZSwgdW53YXRjaGVyLCBhcHBseUxvY2FsbHkpO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuUGVyc2lzdGVudENvbm5lY3Rpb247XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcblBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5zaW1wbGVMaXN0ZW4gPSBmdW5jdGlvbiAocGF0aFN0cmluZywgb25Db21wbGV0ZSkge1xyXG4gICAgdGhpcy5zZW5kUmVxdWVzdCgncScsIHsgcDogcGF0aFN0cmluZyB9LCBvbkNvbXBsZXRlKTtcclxufTtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLmVjaG8gPSBmdW5jdGlvbiAoZGF0YSwgb25FY2hvKSB7XHJcbiAgICB0aGlzLnNlbmRSZXF1ZXN0KCdlY2hvJywgeyBkOiBkYXRhIH0sIG9uRWNobyk7XHJcbn07XHJcbi8vIFJlYWxUaW1lQ29ubmVjdGlvbiBwcm9wZXJ0aWVzIHRoYXQgd2UgdXNlIGluIHRlc3RzLlxyXG5Db25uZWN0aW9uO1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBoaWphY2tIYXNoID0gZnVuY3Rpb24gKG5ld0hhc2gpIHtcclxuICAgIGNvbnN0IG9sZFB1dCA9IFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5wdXQ7XHJcbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHtcclxuICAgICAgICBpZiAoaGFzaCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGhhc2ggPSBuZXdIYXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9sZFB1dC5jYWxsKHRoaXMsIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnB1dCA9IG9sZFB1dDtcclxuICAgIH07XHJcbn07XHJcblJlcG9JbmZvO1xyXG4vKipcclxuICogRm9yY2VzIHRoZSBSZXBvTWFuYWdlciB0byBjcmVhdGUgUmVwb3MgdGhhdCB1c2UgUmVhZG9ubHlSZXN0Q2xpZW50IGluc3RlYWQgb2YgUGVyc2lzdGVudENvbm5lY3Rpb24uXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3QgZm9yY2VSZXN0Q2xpZW50ID0gZnVuY3Rpb24gKGZvcmNlUmVzdENsaWVudCkge1xyXG4gICAgcmVwb01hbmFnZXJGb3JjZVJlc3RDbGllbnQoZm9yY2VSZXN0Q2xpZW50KTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFVzZWQgYnkgY29uc29sZSB0byBjcmVhdGUgYSBkYXRhYmFzZSBiYXNlZCBvbiB0aGUgYXBwLFxyXG4gKiBwYXNzZWQgZGF0YWJhc2UgVVJMIGFuZCBhIGN1c3RvbSBhdXRoIGltcGxlbWVudGF0aW9uLlxyXG4gKiBAaW50ZXJuYWxcclxuICogQHBhcmFtIGFwcCAtIEEgdmFsaWQgRmlyZWJhc2VBcHAtbGlrZSBvYmplY3RcclxuICogQHBhcmFtIHVybCAtIEEgdmFsaWQgRmlyZWJhc2UgZGF0YWJhc2VVUkxcclxuICogQHBhcmFtIHZlcnNpb24gLSBjdXN0b20gdmVyc2lvbiBlLmcuIGZpcmViYXNlLWFkbWluIHZlcnNpb25cclxuICogQHBhcmFtIGN1c3RvbUFwcENoZWNrSW1wbCAtIGN1c3RvbSBhcHAgY2hlY2sgaW1wbGVtZW50YXRpb25cclxuICogQHBhcmFtIGN1c3RvbUF1dGhJbXBsIC0gY3VzdG9tIGF1dGggaW1wbGVtZW50YXRpb25cclxuICovXHJcbmZ1bmN0aW9uIF9pbml0U3RhbmRhbG9uZSh7IGFwcCwgdXJsLCB2ZXJzaW9uLCBjdXN0b21BdXRoSW1wbCwgY3VzdG9tQXBwQ2hlY2tJbXBsLCBub2RlQWRtaW4gPSBmYWxzZSB9KSB7XHJcbiAgICBzZXRTREtWZXJzaW9uKHZlcnNpb24pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wb25lbnRDb250YWluZXIoJ2RhdGFiYXNlLXN0YW5kYWxvbmUnKSBpcyBqdXN0IGEgcGxhY2Vob2xkZXIgdGhhdCBkb2Vzbid0IHBlcmZvcm1cclxuICAgICAqIGFueSBhY3R1YWwgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGNvbXBvbmVudENvbnRhaW5lciA9IG5ldyBDb21wb25lbnRDb250YWluZXIoJ2RhdGFiYXNlLXN0YW5kYWxvbmUnKTtcclxuICAgIGNvbnN0IGF1dGhQcm92aWRlciA9IG5ldyBQcm92aWRlcignYXV0aC1pbnRlcm5hbCcsIGNvbXBvbmVudENvbnRhaW5lcik7XHJcbiAgICBsZXQgYXBwQ2hlY2tQcm92aWRlcjtcclxuICAgIGlmIChjdXN0b21BcHBDaGVja0ltcGwpIHtcclxuICAgICAgICBhcHBDaGVja1Byb3ZpZGVyID0gbmV3IFByb3ZpZGVyKCdhcHAtY2hlY2staW50ZXJuYWwnLCBjb21wb25lbnRDb250YWluZXIpO1xyXG4gICAgICAgIGFwcENoZWNrUHJvdmlkZXIuc2V0Q29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2FwcC1jaGVjay1pbnRlcm5hbCcsICgpID0+IGN1c3RvbUFwcENoZWNrSW1wbCwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKSk7XHJcbiAgICB9XHJcbiAgICBhdXRoUHJvdmlkZXIuc2V0Q29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2F1dGgtaW50ZXJuYWwnLCAoKSA9PiBjdXN0b21BdXRoSW1wbCwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKSk7XHJcbiAgICByZXR1cm4gcmVwb01hbmFnZXJEYXRhYmFzZUZyb21BcHAoYXBwLCBhdXRoUHJvdmlkZXIsIGFwcENoZWNrUHJvdmlkZXIsIHVybCwgbm9kZUFkbWluKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5zZXRXZWJTb2NrZXRJbXBsKFdlYnNvY2tldC5DbGllbnQpO1xyXG5yZWdpc3RlckRhdGFiYXNlKCdub2RlJyk7XG5cbmV4cG9ydCB7IERhdGFTbmFwc2hvdCwgRGF0YWJhc2UsIE9uRGlzY29ubmVjdCwgUXVlcnlDb25zdHJhaW50LCBUcmFuc2FjdGlvblJlc3VsdCwgUXVlcnlJbXBsIGFzIF9RdWVyeUltcGwsIFF1ZXJ5UGFyYW1zIGFzIF9RdWVyeVBhcmFtcywgUmVmZXJlbmNlSW1wbCBhcyBfUmVmZXJlbmNlSW1wbCwgZm9yY2VSZXN0Q2xpZW50IGFzIF9URVNUX0FDQ0VTU19mb3JjZVJlc3RDbGllbnQsIGhpamFja0hhc2ggYXMgX1RFU1RfQUNDRVNTX2hpamFja0hhc2gsIF9pbml0U3RhbmRhbG9uZSwgcmVwb01hbmFnZXJEYXRhYmFzZUZyb21BcHAgYXMgX3JlcG9NYW5hZ2VyRGF0YWJhc2VGcm9tQXBwLCBzZXRTREtWZXJzaW9uIGFzIF9zZXRTREtWZXJzaW9uLCB2YWxpZGF0ZVBhdGhTdHJpbmcgYXMgX3ZhbGlkYXRlUGF0aFN0cmluZywgdmFsaWRhdGVXcml0YWJsZVBhdGggYXMgX3ZhbGlkYXRlV3JpdGFibGVQYXRoLCBjaGlsZCwgY29ubmVjdERhdGFiYXNlRW11bGF0b3IsIGVuYWJsZUxvZ2dpbmcsIGVuZEF0LCBlbmRCZWZvcmUsIGVxdWFsVG8sIGZvcmNlTG9uZ1BvbGxpbmcsIGZvcmNlV2ViU29ja2V0cywgZ2V0LCBnZXREYXRhYmFzZSwgZ29PZmZsaW5lLCBnb09ubGluZSwgaW5jcmVtZW50LCBsaW1pdFRvRmlyc3QsIGxpbWl0VG9MYXN0LCBvZmYsIG9uQ2hpbGRBZGRlZCwgb25DaGlsZENoYW5nZWQsIG9uQ2hpbGRNb3ZlZCwgb25DaGlsZFJlbW92ZWQsIG9uRGlzY29ubmVjdCwgb25WYWx1ZSwgb3JkZXJCeUNoaWxkLCBvcmRlckJ5S2V5LCBvcmRlckJ5UHJpb3JpdHksIG9yZGVyQnlWYWx1ZSwgcHVzaCwgcXVlcnksIHJlZiwgcmVmRnJvbVVSTCwgcmVtb3ZlLCBydW5UcmFuc2FjdGlvbiwgc2VydmVyVGltZXN0YW1wLCBzZXQsIHNldFByaW9yaXR5LCBzZXRXaXRoUHJpb3JpdHksIHN0YXJ0QWZ0ZXIsIHN0YXJ0QXQsIHVwZGF0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiV2Vic29ja2V0Iiwic3RyaW5naWZ5IiwianNvbkV2YWwiLCJjb250YWlucyIsImFzc2VydCIsImlzTm9kZVNkayIsInN0cmluZ1RvQnl0ZUFycmF5IiwiU2hhMSIsImJhc2U2NCIsImRlZXBDb3B5IiwiYmFzZTY0RW5jb2RlIiwiaXNNb2JpbGVDb3Jkb3ZhIiwic3RyaW5nTGVuZ3RoIiwiRGVmZXJyZWQiLCJzYWZlR2V0IiwiaXNBZG1pbiIsImlzVmFsaWRGb3JtYXQiLCJpc0VtcHR5IiwiaXNSZWFjdE5hdGl2ZSIsImFzc2VydGlvbkVycm9yIiwibWFwIiwicXVlcnlzdHJpbmciLCJlcnJvclByZWZpeCIsImdldE1vZHVsYXJJbnN0YW5jZSIsImdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCIsImNyZWF0ZU1vY2tVc2VyVG9rZW4iLCJMb2dnZXIiLCJMb2dMZXZlbCIsIl9nZXRQcm92aWRlciIsImdldEFwcCIsIlNES19WRVJTSU9OIiwiU0RLX1ZFUlNJT04kMSIsIl9yZWdpc3RlckNvbXBvbmVudCIsInJlZ2lzdGVyVmVyc2lvbiIsIkNvbXBvbmVudCIsIkNvbXBvbmVudENvbnRhaW5lciIsIlByb3ZpZGVyIiwiUFJPVE9DT0xfVkVSU0lPTiIsIlZFUlNJT05fUEFSQU0iLCJUUkFOU1BPUlRfU0VTU0lPTl9QQVJBTSIsIlJFRkVSRVJfUEFSQU0iLCJGT1JHRV9SRUYiLCJGT1JHRV9ET01BSU5fUkUiLCJMQVNUX1NFU1NJT05fUEFSQU0iLCJBUFBMSUNBVElPTl9JRF9QQVJBTSIsIkFQUF9DSEVDS19UT0tFTl9QQVJBTSIsIldFQlNPQ0tFVCIsIkxPTkdfUE9MTElORyIsIkRPTVN0b3JhZ2VXcmFwcGVyIiwiY29uc3RydWN0b3IiLCJkb21TdG9yYWdlXyIsInByZWZpeF8iLCJzZXQiLCJrZXkiLCJ2YWx1ZSIsInJlbW92ZUl0ZW0iLCJwcmVmaXhlZE5hbWVfIiwic2V0SXRlbSIsImdldCIsInN0b3JlZFZhbCIsImdldEl0ZW0iLCJyZW1vdmUiLCJuYW1lIiwidG9TdHJpbmciLCJNZW1vcnlTdG9yYWdlIiwiY2FjaGVfIiwiaXNJbk1lbW9yeVN0b3JhZ2UiLCJjcmVhdGVTdG9yYWdlZm9yIiwiZG9tU3RvcmFnZU5hbWUiLCJ3aW5kb3ciLCJkb21TdG9yYWdlIiwiZSIsIlBlcnNpc3RlbnRTdG9yYWdlIiwiU2Vzc2lvblN0b3JhZ2UiLCJsb2dDbGllbnQiLCJMVUlER2VuZXJhdG9yIiwiaWQiLCJzaGExIiwic3RyIiwidXRmOEJ5dGVzIiwidXBkYXRlIiwic2hhMUJ5dGVzIiwiZGlnZXN0IiwiZW5jb2RlQnl0ZUFycmF5IiwiYnVpbGRMb2dNZXNzYWdlXyIsInZhckFyZ3MiLCJtZXNzYWdlIiwiaSIsImxlbmd0aCIsImFyZyIsIkFycmF5IiwiaXNBcnJheSIsImFwcGx5IiwibG9nZ2VyIiwiZmlyc3RMb2dfIiwiZW5hYmxlTG9nZ2luZyQxIiwibG9nZ2VyXyIsInBlcnNpc3RlbnQiLCJsb2dMZXZlbCIsIlZFUkJPU0UiLCJsb2ciLCJiaW5kIiwibG9nV3JhcHBlciIsInByZWZpeCIsImVycm9yIiwiZmF0YWwiLCJFcnJvciIsIndhcm4iLCJ3YXJuSWZQYWdlSXNTZWN1cmUiLCJsb2NhdGlvbiIsInByb3RvY29sIiwiaW5kZXhPZiIsImlzSW52YWxpZEpTT05OdW1iZXIiLCJkYXRhIiwiTnVtYmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJORUdBVElWRV9JTkZJTklUWSIsImV4ZWN1dGVXaGVuRE9NUmVhZHkiLCJmbiIsImRvY3VtZW50IiwicmVhZHlTdGF0ZSIsImNhbGxlZCIsIndyYXBwZWRGbiIsImJvZHkiLCJzZXRUaW1lb3V0IiwiTWF0aCIsImZsb29yIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiTUlOX05BTUUiLCJNQVhfTkFNRSIsIm5hbWVDb21wYXJlIiwiYSIsImIiLCJhQXNJbnQiLCJ0cnlQYXJzZUludCIsImJBc0ludCIsInN0cmluZ0NvbXBhcmUiLCJyZXF1aXJlS2V5Iiwib2JqIiwiT2JqZWN0VG9VbmlxdWVLZXkiLCJrZXlzIiwiayIsInB1c2giLCJzb3J0Iiwic3BsaXRTdHJpbmdCeVNpemUiLCJzZWdzaXplIiwibGVuIiwiZGF0YVNlZ3MiLCJjIiwic3Vic3RyaW5nIiwiZWFjaCIsImhhc093blByb3BlcnR5IiwiZG91YmxlVG9JRUVFNzU0U3RyaW5nIiwidiIsImViaXRzIiwiZmJpdHMiLCJiaWFzIiwicyIsImYiLCJsbiIsIkluZmluaXR5IiwiYWJzIiwicG93IiwibWluIiwiTE4yIiwicm91bmQiLCJiaXRzIiwicmV2ZXJzZSIsImpvaW4iLCJoZXhCeXRlU3RyaW5nIiwiaGV4Qnl0ZSIsInBhcnNlSW50Iiwic3Vic3RyIiwidG9Mb3dlckNhc2UiLCJpc0Nocm9tZUV4dGVuc2lvbkNvbnRlbnRTY3JpcHQiLCJ0ZXN0IiwiaHJlZiIsImlzV2luZG93c1N0b3JlQXBwIiwiV2luZG93cyIsIlVJIiwiZXJyb3JGb3JTZXJ2ZXJDb2RlIiwiY29kZSIsInF1ZXJ5IiwicmVhc29uIiwiX3BhdGgiLCJ0b1VwcGVyQ2FzZSIsIklOVEVHRVJfUkVHRVhQXyIsIlJlZ0V4cCIsIklOVEVHRVJfMzJfTUlOIiwiSU5URUdFUl8zMl9NQVgiLCJpbnRWYWwiLCJleGNlcHRpb25HdWFyZCIsInN0YWNrIiwiYmVpbmdDcmF3bGVkIiwidXNlckFnZW50Iiwic2VhcmNoIiwic2V0VGltZW91dE5vbkJsb2NraW5nIiwidGltZSIsInRpbWVvdXQiLCJEZW5vIiwidW5yZWZUaW1lciIsIlJlcG9JbmZvIiwiaG9zdCIsInNlY3VyZSIsIm5hbWVzcGFjZSIsIndlYlNvY2tldE9ubHkiLCJub2RlQWRtaW4iLCJwZXJzaXN0ZW5jZUtleSIsImluY2x1ZGVOYW1lc3BhY2VJblF1ZXJ5UGFyYW1zIiwiaXNVc2luZ0VtdWxhdG9yIiwiX2hvc3QiLCJfZG9tYWluIiwiaW50ZXJuYWxIb3N0IiwiaXNDYWNoZWFibGVIb3N0IiwiaXNDdXN0b21Ib3N0IiwibmV3SG9zdCIsInRvVVJMU3RyaW5nIiwicmVwb0luZm9OZWVkc1F1ZXJ5UGFyYW0iLCJyZXBvSW5mbyIsInJlcG9JbmZvQ29ubmVjdGlvblVSTCIsInR5cGUiLCJwYXJhbXMiLCJjb25uVVJMIiwicGFpcnMiLCJTdGF0c0NvbGxlY3Rpb24iLCJjb3VudGVyc18iLCJpbmNyZW1lbnRDb3VudGVyIiwiYW1vdW50IiwiY29sbGVjdGlvbnMiLCJyZXBvcnRlcnMiLCJzdGF0c01hbmFnZXJHZXRDb2xsZWN0aW9uIiwiaGFzaFN0cmluZyIsInN0YXRzTWFuYWdlckdldE9yQ3JlYXRlUmVwb3J0ZXIiLCJjcmVhdG9yRnVuY3Rpb24iLCJzZXRTREtWZXJzaW9uIiwidmVyc2lvbiIsIldFQlNPQ0tFVF9NQVhfRlJBTUVfU0laRSIsIldFQlNPQ0tFVF9LRUVQQUxJVkVfSU5URVJWQUwiLCJXZWJTb2NrZXRJbXBsIiwiTW96V2ViU29ja2V0IiwiV2ViU29ja2V0Iiwic2V0V2ViU29ja2V0SW1wbCIsImltcGwiLCJXZWJTb2NrZXRDb25uZWN0aW9uIiwiY29ubklkIiwiYXBwbGljYXRpb25JZCIsImFwcENoZWNrVG9rZW4iLCJhdXRoVG9rZW4iLCJ0cmFuc3BvcnRTZXNzaW9uSWQiLCJsYXN0U2Vzc2lvbklkIiwia2VlcGFsaXZlVGltZXIiLCJmcmFtZXMiLCJ0b3RhbEZyYW1lcyIsImJ5dGVzU2VudCIsImJ5dGVzUmVjZWl2ZWQiLCJsb2dfIiwic3RhdHNfIiwiY29ubmVjdGlvblVSTF8iLCJ1cmxQYXJhbXMiLCJob3N0bmFtZSIsIm9wZW4iLCJvbk1lc3NhZ2UiLCJvbkRpc2Nvbm5lY3QiLCJldmVyQ29ubmVjdGVkXyIsIm9wdGlvbnMiLCJkZXZpY2UiLCJoZWFkZXJzIiwicHJvY2VzcyIsInBsYXRmb3JtIiwiZW52IiwicHJveHkiLCJvcmlnaW4iLCJteVNvY2siLCJvbkNsb3NlZF8iLCJvbm9wZW4iLCJvbmNsb3NlIiwib25tZXNzYWdlIiwibSIsImhhbmRsZUluY29taW5nRnJhbWUiLCJvbmVycm9yIiwic3RhcnQiLCJmb3JjZURpc2FsbG93IiwiZm9yY2VEaXNhbGxvd18iLCJpc0F2YWlsYWJsZSIsImlzT2xkQW5kcm9pZCIsIm5hdmlnYXRvciIsIm9sZEFuZHJvaWRSZWdleCIsIm9sZEFuZHJvaWRNYXRjaCIsIm1hdGNoIiwicGFyc2VGbG9hdCIsInByZXZpb3VzbHlGYWlsZWQiLCJtYXJrQ29ubmVjdGlvbkhlYWx0aHkiLCJhcHBlbmRGcmFtZV8iLCJmdWxsTWVzcyIsImpzb25NZXNzIiwiaGFuZGxlTmV3RnJhbWVDb3VudF8iLCJmcmFtZUNvdW50IiwiZXh0cmFjdEZyYW1lQ291bnRfIiwiaXNOYU4iLCJtZXNzIiwicmVzZXRLZWVwQWxpdmUiLCJyZW1haW5pbmdEYXRhIiwic2VuZCIsImRhdGFTdHIiLCJzZW5kU3RyaW5nXyIsIlN0cmluZyIsInNodXRkb3duXyIsImlzQ2xvc2VkXyIsImNsZWFySW50ZXJ2YWwiLCJjbG9zZSIsInNldEludGVydmFsIiwicmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeSIsImhlYWx0aHlUaW1lb3V0IiwiQXBwQ2hlY2tUb2tlblByb3ZpZGVyIiwiYXBwTmFtZV8iLCJhcHBDaGVja1Byb3ZpZGVyIiwiYXBwQ2hlY2siLCJnZXRJbW1lZGlhdGUiLCJvcHRpb25hbCIsInRoZW4iLCJnZXRUb2tlbiIsImZvcmNlUmVmcmVzaCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lciIsImxpc3RlbmVyIiwiX2EiLCJhZGRUb2tlbkxpc3RlbmVyIiwibm90aWZ5Rm9ySW52YWxpZFRva2VuIiwiRmlyZWJhc2VBdXRoVG9rZW5Qcm92aWRlciIsImZpcmViYXNlT3B0aW9uc18iLCJhdXRoUHJvdmlkZXJfIiwiYXV0aF8iLCJvbkluaXQiLCJhdXRoIiwiY2F0Y2giLCJhZGRBdXRoVG9rZW5MaXN0ZW5lciIsInJlbW92ZVRva2VuQ2hhbmdlTGlzdGVuZXIiLCJyZW1vdmVBdXRoVG9rZW5MaXN0ZW5lciIsImVycm9yTWVzc2FnZSIsIkVtdWxhdG9yVG9rZW5Qcm92aWRlciIsImFjY2Vzc1Rva2VuIiwiT1dORVIiLCJQYWNrZXRSZWNlaXZlciIsIm9uTWVzc2FnZV8iLCJwZW5kaW5nUmVzcG9uc2VzIiwiY3VycmVudFJlc3BvbnNlTnVtIiwiY2xvc2VBZnRlclJlc3BvbnNlIiwib25DbG9zZSIsImNsb3NlQWZ0ZXIiLCJyZXNwb25zZU51bSIsImNhbGxiYWNrIiwiaGFuZGxlUmVzcG9uc2UiLCJyZXF1ZXN0TnVtIiwidG9Qcm9jZXNzIiwiRklSRUJBU0VfTE9OR1BPTExfU1RBUlRfUEFSQU0iLCJGSVJFQkFTRV9MT05HUE9MTF9DTE9TRV9DT01NQU5EIiwiRklSRUJBU0VfTE9OR1BPTExfQ09NTUFORF9DQl9OQU1FIiwiRklSRUJBU0VfTE9OR1BPTExfREFUQV9DQl9OQU1FIiwiRklSRUJBU0VfTE9OR1BPTExfSURfUEFSQU0iLCJGSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTSIsIkZJUkVCQVNFX0xPTkdQT0xMX1NFUklBTF9QQVJBTSIsIkZJUkVCQVNFX0xPTkdQT0xMX0NBTExCQUNLX0lEX1BBUkFNIiwiRklSRUJBU0VfTE9OR1BPTExfU0VHTUVOVF9OVU1fUEFSQU0iLCJGSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UU19JTl9QQUNLRVQiLCJGSVJFQkFTRV9MT05HUE9MTF9EQVRBX1BBUkFNIiwiRklSRUJBU0VfTE9OR1BPTExfRElTQ09OTl9GUkFNRV9SRVFVRVNUX1BBUkFNIiwiTUFYX1VSTF9EQVRBX1NJWkUiLCJTRUdfSEVBREVSX1NJWkUiLCJNQVhfUEFZTE9BRF9TSVpFIiwiS0VFUEFMSVZFX1JFUVVFU1RfSU5URVJWQUwiLCJMUF9DT05ORUNUX1RJTUVPVVQiLCJCcm93c2VyUG9sbENvbm5lY3Rpb24iLCJ1cmxGbiIsImN1clNlZ21lbnROdW0iLCJvbkRpc2Nvbm5lY3RfIiwibXlQYWNrZXRPcmRlcmVyIiwiY29ubmVjdFRpbWVvdXRUaW1lcl8iLCJzY3JpcHRUYWdIb2xkZXIiLCJGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlciIsImFyZ3MiLCJjb21tYW5kIiwiYXJnMSIsImFyZzIiLCJhcmczIiwiYXJnNCIsImluY3JlbWVudEluY29taW5nQnl0ZXNfIiwiY2xlYXJUaW1lb3V0IiwicGFzc3dvcmQiLCJzZW5kTmV3UG9sbHMiLCJwTiIsInJhbmRvbSIsInVuaXF1ZUNhbGxiYWNrSWRlbnRpZmllciIsImNvbm5lY3RVUkwiLCJhZGRUYWciLCJzdGFydExvbmdQb2xsIiwiYWRkRGlzY29ubmVjdFBpbmdGcmFtZSIsImZvcmNlQWxsb3ciLCJmb3JjZUFsbG93XyIsImNyZWF0ZUVsZW1lbnQiLCJteURpc2Nvbm5GcmFtZSIsInJlbW92ZUNoaWxkIiwiYmFzZTY0ZGF0YSIsImVucXVldWVTZWdtZW50IiwicHciLCJzcmMiLCJzdHlsZSIsImRpc3BsYXkiLCJhcHBlbmRDaGlsZCIsImNvbW1hbmRDQiIsIm9uTWVzc2FnZUNCIiwib3V0c3RhbmRpbmdSZXF1ZXN0cyIsIlNldCIsInBlbmRpbmdTZWdzIiwiY3VycmVudFNlcmlhbCIsIm15SUZyYW1lIiwiY3JlYXRlSUZyYW1lXyIsInNjcmlwdCIsImN1cnJlbnREb21haW4iLCJkb21haW4iLCJpZnJhbWVDb250ZW50cyIsImRvYyIsIndyaXRlIiwiaWZyYW1lIiwiY29udGVudFdpbmRvdyIsImNvbnRlbnREb2N1bWVudCIsImFsaXZlIiwidGV4dENvbnRlbnQiLCJteUlEIiwibXlQVyIsIm5ld1JlcXVlc3RfIiwic2l6ZSIsInRoZVVSTCIsImN1ckRhdGFTdHJpbmciLCJuZXh0U2VnIiwiZCIsInRoZVNlZyIsInNoaWZ0Iiwic2VnIiwidHMiLCJhZGRMb25nUG9sbFRhZ18iLCJzZWdudW0iLCJ0b3RhbHNlZ3MiLCJ1cmwiLCJzZXJpYWwiLCJhZGQiLCJkb05ld1JlcXVlc3QiLCJkZWxldGUiLCJrZWVwYWxpdmVUaW1lb3V0IiwicmVhZHlTdGF0ZUNCIiwibG9hZENCIiwiZG9Ob2RlTG9uZ1BvbGwiLCJuZXdTY3JpcHQiLCJhc3luYyIsIm9ubG9hZCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJzdGF0ZSIsInBhcmVudE5vZGUiLCJUcmFuc3BvcnRNYW5hZ2VyIiwiaW5pdFRyYW5zcG9ydHNfIiwiQUxMX1RSQU5TUE9SVFMiLCJJU19UUkFOU1BPUlRfSU5JVElBTElaRUQiLCJnbG9iYWxUcmFuc3BvcnRJbml0aWFsaXplZF8iLCJpc1dlYlNvY2tldHNBdmFpbGFibGUiLCJpc1NraXBQb2xsQ29ubmVjdGlvbiIsInRyYW5zcG9ydHNfIiwidHJhbnNwb3J0cyIsInRyYW5zcG9ydCIsImluaXRpYWxUcmFuc3BvcnQiLCJ1cGdyYWRlVHJhbnNwb3J0IiwiVVBHUkFERV9USU1FT1VUIiwiREVMQVlfQkVGT1JFX1NFTkRJTkdfRVhUUkFfUkVRVUVTVFMiLCJCWVRFU19TRU5UX0hFQUxUSFlfT1ZFUlJJREUiLCJCWVRFU19SRUNFSVZFRF9IRUFMVEhZX09WRVJSSURFIiwiTUVTU0FHRV9UWVBFIiwiTUVTU0FHRV9EQVRBIiwiQ09OVFJPTF9TSFVURE9XTiIsIkNPTlRST0xfUkVTRVQiLCJDT05UUk9MX0VSUk9SIiwiQ09OVFJPTF9QT05HIiwiU1dJVENIX0FDSyIsIkVORF9UUkFOU01JU1NJT04iLCJQSU5HIiwiU0VSVkVSX0hFTExPIiwiQ29ubmVjdGlvbiIsInJlcG9JbmZvXyIsImFwcGxpY2F0aW9uSWRfIiwiYXBwQ2hlY2tUb2tlbl8iLCJhdXRoVG9rZW5fIiwib25SZWFkeV8iLCJvbktpbGxfIiwiY29ubmVjdGlvbkNvdW50IiwicGVuZGluZ0RhdGFNZXNzYWdlcyIsInN0YXRlXyIsInRyYW5zcG9ydE1hbmFnZXJfIiwic3RhcnRfIiwiY29ubiIsImNvbm5fIiwibmV4dFRyYW5zcG9ydElkXyIsInByaW1hcnlSZXNwb25zZXNSZXF1aXJlZF8iLCJvbk1lc3NhZ2VSZWNlaXZlZCIsImNvbm5SZWNlaXZlcl8iLCJvbkNvbm5lY3Rpb25Mb3N0IiwiZGlzY29ublJlY2VpdmVyXyIsInR4XyIsInJ4XyIsInNlY29uZGFyeUNvbm5fIiwiaXNIZWFsdGh5XyIsImhlYWx0aHlUaW1lb3V0TVMiLCJoZWFsdGh5VGltZW91dF8iLCJldmVyQ29ubmVjdGVkIiwib25Db25uZWN0aW9uTG9zdF8iLCJvblNlY29uZGFyeUNvbm5lY3Rpb25Mb3N0XyIsIm9uUHJpbWFyeU1lc3NhZ2VSZWNlaXZlZF8iLCJvblNlY29uZGFyeU1lc3NhZ2VSZWNlaXZlZF8iLCJzZW5kUmVxdWVzdCIsImRhdGFNc2ciLCJtc2ciLCJ0Iiwic2VuZERhdGFfIiwidHJ5Q2xlYW51cENvbm5lY3Rpb24iLCJvblNlY29uZGFyeUNvbnRyb2xfIiwiY29udHJvbERhdGEiLCJjbWQiLCJ1cGdyYWRlSWZTZWNvbmRhcnlIZWFsdGh5XyIsInNlY29uZGFyeVJlc3BvbnNlc1JlcXVpcmVkXyIsInBhcnNlZERhdGEiLCJsYXllciIsInByb2NlZWRXaXRoVXBncmFkZV8iLCJvbkNvbnRyb2xfIiwib25EYXRhTWVzc2FnZV8iLCJvblByaW1hcnlSZXNwb25zZV8iLCJwYXlsb2FkIiwiaGFuZHNoYWtlUGF5bG9hZCIsIk9iamVjdCIsImFzc2lnbiIsImgiLCJvbkhhbmRzaGFrZV8iLCJvbkNvbm5lY3Rpb25TaHV0ZG93bl8iLCJvblJlc2V0XyIsInNlbmRQaW5nT25QcmltYXJ5SWZOZWNlc3NhcnlfIiwiaGFuZHNoYWtlIiwidGltZXN0YW1wIiwic2Vzc2lvbklkIiwib25Db25uZWN0aW9uRXN0YWJsaXNoZWRfIiwidHJ5U3RhcnRVcGdyYWRlXyIsInN0YXJ0VXBncmFkZV8iLCJjbG9zZUNvbm5lY3Rpb25zXyIsIlNlcnZlckFjdGlvbnMiLCJwdXQiLCJwYXRoU3RyaW5nIiwib25Db21wbGV0ZSIsImhhc2giLCJtZXJnZSIsInJlZnJlc2hBdXRoVG9rZW4iLCJ0b2tlbiIsInJlZnJlc2hBcHBDaGVja1Rva2VuIiwib25EaXNjb25uZWN0UHV0Iiwib25EaXNjb25uZWN0TWVyZ2UiLCJvbkRpc2Nvbm5lY3RDYW5jZWwiLCJyZXBvcnRTdGF0cyIsInN0YXRzIiwiRXZlbnRFbWl0dGVyIiwiYWxsb3dlZEV2ZW50c18iLCJsaXN0ZW5lcnNfIiwidHJpZ2dlciIsImV2ZW50VHlwZSIsImxpc3RlbmVycyIsImNvbnRleHQiLCJvbiIsInZhbGlkYXRlRXZlbnRUeXBlXyIsImV2ZW50RGF0YSIsImdldEluaXRpYWxFdmVudCIsIm9mZiIsInNwbGljZSIsImZpbmQiLCJldCIsIk9ubGluZU1vbml0b3IiLCJvbmxpbmVfIiwiZ2V0SW5zdGFuY2UiLCJjdXJyZW50bHlPbmxpbmUiLCJNQVhfUEFUSF9ERVBUSCIsIk1BWF9QQVRIX0xFTkdUSF9CWVRFUyIsIlBhdGgiLCJwYXRoT3JTdHJpbmciLCJwaWVjZU51bSIsInBpZWNlc18iLCJzcGxpdCIsImNvcHlUbyIsInBpZWNlTnVtXyIsIm5ld0VtcHR5UGF0aCIsInBhdGhHZXRGcm9udCIsInBhdGgiLCJwYXRoR2V0TGVuZ3RoIiwicGF0aFBvcEZyb250IiwicGF0aEdldEJhY2siLCJwYXRoVG9VcmxFbmNvZGVkU3RyaW5nIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicGF0aFNsaWNlIiwiYmVnaW4iLCJzbGljZSIsInBhdGhQYXJlbnQiLCJwaWVjZXMiLCJwYXRoQ2hpbGQiLCJjaGlsZFBhdGhPYmoiLCJjaGlsZFBpZWNlcyIsInBhdGhJc0VtcHR5IiwibmV3UmVsYXRpdmVQYXRoIiwib3V0ZXJQYXRoIiwiaW5uZXJQYXRoIiwib3V0ZXIiLCJpbm5lciIsInBhdGhDb21wYXJlIiwibGVmdCIsInJpZ2h0IiwibGVmdEtleXMiLCJyaWdodEtleXMiLCJjbXAiLCJwYXRoRXF1YWxzIiwib3RoZXIiLCJqIiwicGF0aENvbnRhaW5zIiwiVmFsaWRhdGlvblBhdGgiLCJlcnJvclByZWZpeF8iLCJwYXJ0c18iLCJieXRlTGVuZ3RoXyIsIm1heCIsInZhbGlkYXRpb25QYXRoQ2hlY2tWYWxpZCIsInZhbGlkYXRpb25QYXRoUHVzaCIsInZhbGlkYXRpb25QYXRoIiwiY2hpbGQiLCJ2YWxpZGF0aW9uUGF0aFBvcCIsImxhc3QiLCJwb3AiLCJ2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmciLCJWaXNpYmlsaXR5TW9uaXRvciIsImhpZGRlbiIsInZpc2liaWxpdHlDaGFuZ2UiLCJ2aXNpYmxlXyIsInZpc2libGUiLCJSRUNPTk5FQ1RfTUlOX0RFTEFZIiwiUkVDT05ORUNUX01BWF9ERUxBWV9ERUZBVUxUIiwiUkVDT05ORUNUX01BWF9ERUxBWV9GT1JfQURNSU5TIiwiUkVDT05ORUNUX0RFTEFZX01VTFRJUExJRVIiLCJSRUNPTk5FQ1RfREVMQVlfUkVTRVRfVElNRU9VVCIsIlNFUlZFUl9LSUxMX0lOVEVSUlVQVF9SRUFTT04iLCJJTlZBTElEX1RPS0VOX1RIUkVTSE9MRCIsIlBlcnNpc3RlbnRDb25uZWN0aW9uIiwib25EYXRhVXBkYXRlXyIsIm9uQ29ubmVjdFN0YXR1c18iLCJvblNlcnZlckluZm9VcGRhdGVfIiwiYXV0aFRva2VuUHJvdmlkZXJfIiwiYXBwQ2hlY2tUb2tlblByb3ZpZGVyXyIsImF1dGhPdmVycmlkZV8iLCJuZXh0UGVyc2lzdGVudENvbm5lY3Rpb25JZF8iLCJpbnRlcnJ1cHRSZWFzb25zXyIsImxpc3RlbnMiLCJNYXAiLCJvdXRzdGFuZGluZ1B1dHNfIiwib3V0c3RhbmRpbmdHZXRzXyIsIm91dHN0YW5kaW5nUHV0Q291bnRfIiwib3V0c3RhbmRpbmdHZXRDb3VudF8iLCJvbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfIiwiY29ubmVjdGVkXyIsInJlY29ubmVjdERlbGF5XyIsIm1heFJlY29ubmVjdERlbGF5XyIsInNlY3VyaXR5RGVidWdDYWxsYmFja18iLCJlc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfIiwicmVxdWVzdENCSGFzaF8iLCJyZXF1ZXN0TnVtYmVyXyIsInJlYWx0aW1lXyIsImZvcmNlVG9rZW5SZWZyZXNoXyIsImludmFsaWRBdXRoVG9rZW5Db3VudF8iLCJpbnZhbGlkQXBwQ2hlY2tUb2tlbkNvdW50XyIsImZpcnN0Q29ubmVjdGlvbl8iLCJsYXN0Q29ubmVjdGlvbkF0dGVtcHRUaW1lXyIsImxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXyIsIm9uVmlzaWJsZV8iLCJvbk9ubGluZV8iLCJhY3Rpb24iLCJvblJlc3BvbnNlIiwiY3VyUmVxTnVtIiwiciIsImluaXRDb25uZWN0aW9uXyIsImRlZmVycmVkIiwicmVxdWVzdCIsInAiLCJxIiwiX3F1ZXJ5T2JqZWN0Iiwib3V0c3RhbmRpbmdHZXQiLCJpbmRleCIsInNlbmRHZXRfIiwicHJvbWlzZSIsImxpc3RlbiIsImN1cnJlbnRIYXNoRm4iLCJ0YWciLCJxdWVyeUlkIiwiX3F1ZXJ5SWRlbnRpZmllciIsImhhcyIsIl9xdWVyeVBhcmFtcyIsImlzRGVmYXVsdCIsImxvYWRzQWxsRGF0YSIsImxpc3RlblNwZWMiLCJoYXNoRm4iLCJzZW5kTGlzdGVuXyIsInJlcSIsInN0YXR1cyIsIndhcm5Pbkxpc3Rlbldhcm5pbmdzXyIsImN1cnJlbnRMaXN0ZW5TcGVjIiwicmVtb3ZlTGlzdGVuXyIsIndhcm5pbmdzIiwiaW5kZXhTcGVjIiwiZ2V0SW5kZXgiLCJpbmRleFBhdGgiLCJ0cnlBdXRoIiwicmVkdWNlUmVjb25uZWN0RGVsYXlJZkFkbWluQ3JlZGVudGlhbF8iLCJjcmVkZW50aWFsIiwiaXNGaXJlYmFzZVNlY3JldCIsInRyeUFwcENoZWNrIiwiYXV0aE1ldGhvZCIsInJlcXVlc3REYXRhIiwiY3JlZCIsInJlcyIsIm9uQXV0aFJldm9rZWRfIiwib25BcHBDaGVja1Jldm9rZWRfIiwidW5saXN0ZW4iLCJzZW5kVW5saXN0ZW5fIiwicXVlcnlPYmoiLCJzZW5kT25EaXNjb25uZWN0XyIsInJlc3BvbnNlIiwicHV0SW50ZXJuYWwiLCJ1bmRlZmluZWQiLCJzZW5kUHV0XyIsInF1ZXVlZCIsInJlc3VsdCIsImVycm9yUmVhc29uIiwicmVxTnVtIiwib25EYXRhUHVzaF8iLCJvbkxpc3RlblJldm9rZWRfIiwib25TZWN1cml0eURlYnVnUGFja2V0XyIsIkRhdGUiLCJnZXRUaW1lIiwiaGFuZGxlVGltZXN0YW1wXyIsInNlbmRDb25uZWN0U3RhdHNfIiwicmVzdG9yZVN0YXRlXyIsInNjaGVkdWxlQ29ubmVjdF8iLCJlc3RhYmxpc2hDb25uZWN0aW9uXyIsIm9ubGluZSIsIm9uUmVhbHRpbWVEaXNjb25uZWN0XyIsImNhbmNlbFNlbnRUcmFuc2FjdGlvbnNfIiwic2hvdWxkUmVjb25uZWN0XyIsInRpbWVTaW5jZUxhc3RDb25uZWN0U3VjY2VlZGVkIiwidGltZVNpbmNlTGFzdENvbm5lY3RBdHRlbXB0IiwicmVjb25uZWN0RGVsYXkiLCJvbkRhdGFNZXNzYWdlIiwib25SZWFkeSIsIm5leHRDb25uZWN0aW9uSWRfIiwiY2FuY2VsZWQiLCJjb25uZWN0aW9uIiwiY2xvc2VGbiIsInNlbmRSZXF1ZXN0Rm4iLCJhbGwiLCJpbnRlcnJ1cHQiLCJyZXN1bWUiLCJkZWx0YSIsInNlcnZlclRpbWVPZmZzZXQiLCJub3JtYWxpemVkUGF0aFN0cmluZyIsInN0YXR1c0NvZGUiLCJleHBsYW5hdGlvbiIsImNvbnNvbGUiLCJyZXBsYWNlIiwicXVlcmllcyIsInZhbHVlcyIsImNsaWVudE5hbWUiLCJOYW1lZE5vZGUiLCJub2RlIiwiV3JhcCIsIkluZGV4IiwiZ2V0Q29tcGFyZSIsImNvbXBhcmUiLCJpbmRleGVkVmFsdWVDaGFuZ2VkIiwib2xkTm9kZSIsIm5ld05vZGUiLCJvbGRXcmFwcGVkIiwibmV3V3JhcHBlZCIsIm1pblBvc3QiLCJNSU4iLCJfX0VNUFRZX05PREUiLCJLZXlJbmRleCIsInZhbCIsImlzRGVmaW5lZE9uIiwibWF4UG9zdCIsIm1ha2VQb3N0IiwiaW5kZXhWYWx1ZSIsIktFWV9JTkRFWCIsIlNvcnRlZE1hcEl0ZXJhdG9yIiwic3RhcnRLZXkiLCJjb21wYXJhdG9yIiwiaXNSZXZlcnNlXyIsInJlc3VsdEdlbmVyYXRvcl8iLCJub2RlU3RhY2tfIiwiZ2V0TmV4dCIsImhhc05leHQiLCJwZWVrIiwiTExSQk5vZGUiLCJjb2xvciIsIlJFRCIsIlNvcnRlZE1hcCIsIkVNUFRZX05PREUiLCJjb3B5IiwiY291bnQiLCJpbm9yZGVyVHJhdmVyc2FsIiwicmV2ZXJzZVRyYXZlcnNhbCIsIm1pbl8iLCJtaW5LZXkiLCJtYXhLZXkiLCJpbnNlcnQiLCJuIiwiZml4VXBfIiwicmVtb3ZlTWluXyIsImlzUmVkXyIsIm1vdmVSZWRMZWZ0XyIsInNtYWxsZXN0Iiwicm90YXRlUmlnaHRfIiwibW92ZVJlZFJpZ2h0XyIsInJvdGF0ZUxlZnRfIiwiY29sb3JGbGlwXyIsIm5sIiwibnIiLCJjaGVja01heERlcHRoXyIsImJsYWNrRGVwdGgiLCJjaGVja18iLCJCTEFDSyIsIkxMUkJFbXB0eU5vZGUiLCJjb21wYXJhdG9yXyIsInJvb3RfIiwiZ2V0UHJlZGVjZXNzb3JLZXkiLCJyaWdodFBhcmVudCIsImdldEl0ZXJhdG9yIiwicmVzdWx0R2VuZXJhdG9yIiwiZ2V0SXRlcmF0b3JGcm9tIiwiZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbSIsImdldFJldmVyc2VJdGVyYXRvciIsIk5BTUVfT05MWV9DT01QQVJBVE9SIiwiTkFNRV9DT01QQVJBVE9SIiwiTUFYX05PREUkMiIsInNldE1heE5vZGUkMSIsInByaW9yaXR5SGFzaFRleHQiLCJwcmlvcml0eSIsInZhbGlkYXRlUHJpb3JpdHlOb2RlIiwicHJpb3JpdHlOb2RlIiwiaXNMZWFmTm9kZSIsImdldFByaW9yaXR5IiwiX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvciIsIkxlYWZOb2RlIiwidmFsdWVfIiwicHJpb3JpdHlOb2RlXyIsImxhenlIYXNoXyIsInVwZGF0ZVByaW9yaXR5IiwibmV3UHJpb3JpdHlOb2RlIiwiZ2V0SW1tZWRpYXRlQ2hpbGQiLCJjaGlsZE5hbWUiLCJnZXRDaGlsZCIsImhhc0NoaWxkIiwiZ2V0UHJlZGVjZXNzb3JDaGlsZE5hbWUiLCJjaGlsZE5vZGUiLCJ1cGRhdGVJbW1lZGlhdGVDaGlsZCIsIm5ld0NoaWxkTm9kZSIsInVwZGF0ZUNoaWxkIiwiZnJvbnQiLCJudW1DaGlsZHJlbiIsImZvckVhY2hDaGlsZCIsImV4cG9ydEZvcm1hdCIsImdldFZhbHVlIiwidG9IYXNoIiwiY29tcGFyZVRvIiwiY29tcGFyZVRvTGVhZk5vZGVfIiwib3RoZXJMZWFmIiwib3RoZXJMZWFmVHlwZSIsInRoaXNMZWFmVHlwZSIsIm90aGVySW5kZXgiLCJWQUxVRV9UWVBFX09SREVSIiwidGhpc0luZGV4Iiwid2l0aEluZGV4IiwiaXNJbmRleGVkIiwiZXF1YWxzIiwibm9kZUZyb21KU09OJDEiLCJNQVhfTk9ERSQxIiwic2V0Tm9kZUZyb21KU09OIiwic2V0TWF4Tm9kZSIsIlByaW9yaXR5SW5kZXgiLCJhUHJpb3JpdHkiLCJiUHJpb3JpdHkiLCJpbmRleENtcCIsIlBSSU9SSVRZX0lOREVYIiwiTE9HXzIiLCJCYXNlMTJOdW0iLCJsb2dCYXNlMiIsIm51bSIsImJpdE1hc2siLCJjdXJyZW50XyIsIm1hc2siLCJiaXRzXyIsIm5leHRCaXRJc09uZSIsImJ1aWxkQ2hpbGRTZXQiLCJjaGlsZExpc3QiLCJrZXlGbiIsIm1hcFNvcnRGbiIsImJ1aWxkQmFsYW5jZWRUcmVlIiwibG93IiwiaGlnaCIsIm5hbWVkTm9kZSIsIm1pZGRsZSIsImJ1aWxkRnJvbTEyQXJyYXkiLCJiYXNlMTIiLCJyb290IiwiYnVpbGRQZW5uYW50IiwiY2h1bmtTaXplIiwiY2hpbGRUcmVlIiwiYXR0YWNoUGVubmFudCIsInBlbm5hbnQiLCJpc09uZSIsIl9kZWZhdWx0SW5kZXhNYXAiLCJmYWxsYmFja09iamVjdCIsIkluZGV4TWFwIiwiaW5kZXhlc18iLCJpbmRleFNldF8iLCJEZWZhdWx0IiwiaW5kZXhLZXkiLCJzb3J0ZWRNYXAiLCJoYXNJbmRleCIsImluZGV4RGVmaW5pdGlvbiIsImFkZEluZGV4IiwiZXhpc3RpbmdDaGlsZHJlbiIsInNhd0luZGV4ZWRWYWx1ZSIsIml0ZXIiLCJuZXh0IiwibmV3SW5kZXgiLCJpbmRleE5hbWUiLCJuZXdJbmRleFNldCIsIm5ld0luZGV4ZXMiLCJhZGRUb0luZGV4ZXMiLCJpbmRleGVkQ2hpbGRyZW4iLCJleGlzdGluZ1NuYXAiLCJuZXdDaGlsZHJlbiIsInJlbW92ZUZyb21JbmRleGVzIiwiQ2hpbGRyZW5Ob2RlIiwiY2hpbGRyZW5fIiwiaW5kZXhNYXBfIiwibmV3SW5kZXhNYXAiLCJuZXdQcmlvcml0eSIsIm5ld0ltbWVkaWF0ZUNoaWxkIiwibnVtS2V5cyIsImFsbEludGVnZXJLZXlzIiwiYXJyYXkiLCJjaGlsZEhhc2giLCJpZHgiLCJyZXNvbHZlSW5kZXhfIiwicHJlZGVjZXNzb3IiLCJnZXRGaXJzdENoaWxkTmFtZSIsImdldEZpcnN0Q2hpbGQiLCJnZXRMYXN0Q2hpbGROYW1lIiwiZ2V0TGFzdENoaWxkIiwid3JhcHBlZE5vZGUiLCJzdGFydFBvc3QiLCJpdGVyYXRvciIsImVuZFBvc3QiLCJNQVhfTk9ERSIsIm90aGVyQ2hpbGRyZW5Ob2RlIiwidGhpc0l0ZXIiLCJvdGhlckl0ZXIiLCJ0aGlzQ3VycmVudCIsIm90aGVyQ3VycmVudCIsIk1heE5vZGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiTUFYIiwiVVNFX0hJTlpFIiwibm9kZUZyb21KU09OIiwianNvbiIsImpzb25MZWFmIiwiY2hpbGRyZW4iLCJjaGlsZHJlbkhhdmVQcmlvcml0eSIsImhpbnplSnNvbk9iaiIsImNoaWxkU2V0Iiwic29ydGVkQ2hpbGRTZXQiLCJjaGlsZERhdGEiLCJQYXRoSW5kZXgiLCJpbmRleFBhdGhfIiwiZXh0cmFjdENoaWxkIiwic25hcCIsImFDaGlsZCIsImJDaGlsZCIsInZhbHVlTm9kZSIsIlZhbHVlSW5kZXgiLCJWQUxVRV9JTkRFWCIsImNoYW5nZVZhbHVlIiwic25hcHNob3ROb2RlIiwiY2hhbmdlQ2hpbGRBZGRlZCIsImNoYW5nZUNoaWxkUmVtb3ZlZCIsImNoYW5nZUNoaWxkQ2hhbmdlZCIsIm9sZFNuYXAiLCJjaGFuZ2VDaGlsZE1vdmVkIiwiSW5kZXhlZEZpbHRlciIsImluZGV4XyIsIm5ld0NoaWxkIiwiYWZmZWN0ZWRQYXRoIiwic291cmNlIiwib3B0Q2hhbmdlQWNjdW11bGF0b3IiLCJvbGRDaGlsZCIsInRyYWNrQ2hpbGRDaGFuZ2UiLCJ1cGRhdGVGdWxsTm9kZSIsIm5ld1NuYXAiLCJmaWx0ZXJzTm9kZXMiLCJnZXRJbmRleGVkRmlsdGVyIiwiUmFuZ2VkRmlsdGVyIiwiaW5kZXhlZEZpbHRlcl8iLCJzdGFydFBvc3RfIiwiZ2V0U3RhcnRQb3N0XyIsImVuZFBvc3RfIiwiZ2V0RW5kUG9zdF8iLCJzdGFydElzSW5jbHVzaXZlXyIsInN0YXJ0QWZ0ZXJTZXRfIiwiZW5kSXNJbmNsdXNpdmVfIiwiZW5kQmVmb3JlU2V0XyIsImdldFN0YXJ0UG9zdCIsImdldEVuZFBvc3QiLCJtYXRjaGVzIiwiaXNXaXRoaW5TdGFydCIsImlzV2l0aGluRW5kIiwiZmlsdGVyZWQiLCJzZWxmIiwiaGFzU3RhcnQiLCJzdGFydE5hbWUiLCJnZXRJbmRleFN0YXJ0TmFtZSIsImdldEluZGV4U3RhcnRWYWx1ZSIsImhhc0VuZCIsImVuZE5hbWUiLCJnZXRJbmRleEVuZE5hbWUiLCJnZXRJbmRleEVuZFZhbHVlIiwiTGltaXRlZEZpbHRlciIsIndpdGhpbkRpcmVjdGlvbmFsU3RhcnQiLCJyZXZlcnNlXyIsIndpdGhpbkVuZFBvc3QiLCJ3aXRoaW5TdGFydFBvc3QiLCJ3aXRoaW5EaXJlY3Rpb25hbEVuZCIsImNvbXBhcmVSZXMiLCJyYW5nZWRGaWx0ZXJfIiwibGltaXRfIiwiZ2V0TGltaXQiLCJpc1ZpZXdGcm9tTGVmdCIsImZ1bGxMaW1pdFVwZGF0ZUNoaWxkXyIsImluUmFuZ2UiLCJjaGlsZEtleSIsImNoaWxkU25hcCIsImNoYW5nZUFjY3VtdWxhdG9yIiwib2xkRXZlbnRDYWNoZSIsIm5ld0NoaWxkTmFtZWROb2RlIiwid2luZG93Qm91bmRhcnkiLCJvbGRDaGlsZFNuYXAiLCJuZXh0Q2hpbGQiLCJnZXRDaGlsZEFmdGVyQ2hpbGQiLCJjb21wYXJlTmV4dCIsInJlbWFpbnNJbldpbmRvdyIsIm5ld0V2ZW50Q2FjaGUiLCJuZXh0Q2hpbGRJblJhbmdlIiwiUXVlcnlQYXJhbXMiLCJsaW1pdFNldF8iLCJzdGFydFNldF8iLCJzdGFydE5hbWVTZXRfIiwiZW5kU2V0XyIsImVuZE5hbWVTZXRfIiwidmlld0Zyb21fIiwiaW5kZXhTdGFydFZhbHVlXyIsImluZGV4U3RhcnROYW1lXyIsImluZGV4RW5kVmFsdWVfIiwiaW5kZXhFbmROYW1lXyIsImhhc0xpbWl0IiwiaGFzQW5jaG9yZWRMaW1pdCIsInF1ZXJ5UGFyYW1zR2V0Tm9kZUZpbHRlciIsInF1ZXJ5UGFyYW1zIiwicXVlcnlQYXJhbXNMaW1pdFRvRmlyc3QiLCJuZXdMaW1pdCIsIm5ld1BhcmFtcyIsInF1ZXJ5UGFyYW1zTGltaXRUb0xhc3QiLCJxdWVyeVBhcmFtc1N0YXJ0QXQiLCJxdWVyeVBhcmFtc1N0YXJ0QWZ0ZXIiLCJxdWVyeVBhcmFtc0VuZEF0IiwicXVlcnlQYXJhbXNFbmRCZWZvcmUiLCJxdWVyeVBhcmFtc09yZGVyQnkiLCJxdWVyeVBhcmFtc1RvUmVzdFF1ZXJ5U3RyaW5nUGFyYW1ldGVycyIsInFzIiwib3JkZXJCeSIsInN0YXJ0UGFyYW0iLCJlbmRQYXJhbSIsInF1ZXJ5UGFyYW1zR2V0UXVlcnlPYmplY3QiLCJ2aWV3RnJvbSIsIlJlYWRvbmx5UmVzdENsaWVudCIsImxpc3RlbnNfIiwiZ2V0TGlzdGVuSWRfIiwibGlzdGVuSWQiLCJ0aGlzTGlzdGVuIiwicXVlcnlTdHJpbmdQYXJhbWV0ZXJzIiwicmVzdFJlcXVlc3RfIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJyZXNwb25zZVRleHQiLCJTbmFwc2hvdEhvbGRlciIsInJvb3ROb2RlXyIsImdldE5vZGUiLCJ1cGRhdGVTbmFwc2hvdCIsIm5ld1NuYXBzaG90Tm9kZSIsIm5ld1NwYXJzZVNuYXBzaG90VHJlZSIsInNwYXJzZVNuYXBzaG90VHJlZVJlbWVtYmVyIiwic3BhcnNlU25hcHNob3RUcmVlIiwiY2xlYXIiLCJzcGFyc2VTbmFwc2hvdFRyZWVGb3JnZXQiLCJ0cmVlIiwic2FmZVRvUmVtb3ZlIiwic3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaFRyZWUiLCJwcmVmaXhQYXRoIiwiZnVuYyIsInNwYXJzZVNuYXBzaG90VHJlZUZvckVhY2hDaGlsZCIsImZvckVhY2giLCJTdGF0c0xpc3RlbmVyIiwiY29sbGVjdGlvbl8iLCJsYXN0XyIsIm5ld1N0YXRzIiwic3RhdCIsIkZJUlNUX1NUQVRTX01JTl9USU1FIiwiRklSU1RfU1RBVFNfTUFYX1RJTUUiLCJSRVBPUlRfU1RBVFNfSU5URVJWQUwiLCJTdGF0c1JlcG9ydGVyIiwiY29sbGVjdGlvbiIsInNlcnZlcl8iLCJzdGF0c1RvUmVwb3J0XyIsInN0YXRzTGlzdGVuZXJfIiwicmVwb3J0U3RhdHNfIiwicmVwb3J0ZWRTdGF0cyIsImhhdmVTdGF0c1RvUmVwb3J0IiwiT3BlcmF0aW9uVHlwZSIsIm5ld09wZXJhdGlvblNvdXJjZVVzZXIiLCJmcm9tVXNlciIsImZyb21TZXJ2ZXIiLCJ0YWdnZWQiLCJuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXIiLCJuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXJUYWdnZWRRdWVyeSIsIkFja1VzZXJXcml0ZSIsImFmZmVjdGVkVHJlZSIsInJldmVydCIsIkFDS19VU0VSX1dSSVRFIiwib3BlcmF0aW9uRm9yQ2hpbGQiLCJzdWJ0cmVlIiwiTGlzdGVuQ29tcGxldGUiLCJMSVNURU5fQ09NUExFVEUiLCJPdmVyd3JpdGUiLCJPVkVSV1JJVEUiLCJNZXJnZSIsIk1FUkdFIiwiQ2FjaGVOb2RlIiwibm9kZV8iLCJmdWxseUluaXRpYWxpemVkXyIsImZpbHRlcmVkXyIsImlzRnVsbHlJbml0aWFsaXplZCIsImlzRmlsdGVyZWQiLCJpc0NvbXBsZXRlRm9yUGF0aCIsImlzQ29tcGxldGVGb3JDaGlsZCIsIkV2ZW50R2VuZXJhdG9yIiwicXVlcnlfIiwiZXZlbnRHZW5lcmF0b3JHZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXMiLCJldmVudEdlbmVyYXRvciIsImNoYW5nZXMiLCJldmVudENhY2hlIiwiZXZlbnRSZWdpc3RyYXRpb25zIiwiZXZlbnRzIiwibW92ZXMiLCJjaGFuZ2UiLCJldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZSIsInJlZ2lzdHJhdGlvbnMiLCJmaWx0ZXJlZENoYW5nZXMiLCJmaWx0ZXIiLCJldmVudEdlbmVyYXRvckNvbXBhcmVDaGFuZ2VzIiwibWF0ZXJpYWxpemVkQ2hhbmdlIiwiZXZlbnRHZW5lcmF0b3JNYXRlcmlhbGl6ZVNpbmdsZUNoYW5nZSIsInJlZ2lzdHJhdGlvbiIsInJlc3BvbmRzVG8iLCJjcmVhdGVFdmVudCIsInByZXZOYW1lIiwiYVdyYXBwZWQiLCJiV3JhcHBlZCIsIm5ld1ZpZXdDYWNoZSIsInNlcnZlckNhY2hlIiwidmlld0NhY2hlVXBkYXRlRXZlbnRTbmFwIiwidmlld0NhY2hlIiwiZXZlbnRTbmFwIiwiY29tcGxldGUiLCJ2aWV3Q2FjaGVVcGRhdGVTZXJ2ZXJTbmFwIiwic2VydmVyU25hcCIsInZpZXdDYWNoZUdldENvbXBsZXRlRXZlbnRTbmFwIiwidmlld0NhY2hlR2V0Q29tcGxldGVTZXJ2ZXJTbmFwIiwiZW1wdHlDaGlsZHJlblNpbmdsZXRvbiIsIkVtcHR5Q2hpbGRyZW4iLCJJbW11dGFibGVUcmVlIiwiZnJvbU9iamVjdCIsImNoaWxkUGF0aCIsImZpbmRSb290TW9zdE1hdGNoaW5nUGF0aEFuZFZhbHVlIiwicmVsYXRpdmVQYXRoIiwicHJlZGljYXRlIiwiY2hpbGRFeGlzdGluZ1BhdGhBbmRWYWx1ZSIsImZ1bGxQYXRoIiwiZmluZFJvb3RNb3N0VmFsdWVBbmRQYXRoIiwidG9TZXQiLCJzZXRUcmVlIiwibmV3VHJlZSIsImZvbGQiLCJmb2xkXyIsInBhdGhTb0ZhciIsImFjY3VtIiwiZmluZE9uUGF0aCIsImZpbmRPblBhdGhfIiwicGF0aFRvRm9sbG93IiwiZm9yZWFjaE9uUGF0aCIsImZvcmVhY2hPblBhdGhfIiwiY3VycmVudFJlbGF0aXZlUGF0aCIsImZvcmVhY2giLCJmb3JlYWNoXyIsImZvcmVhY2hDaGlsZCIsIkNvbXBvdW5kV3JpdGUiLCJ3cml0ZVRyZWVfIiwiZW1wdHkiLCJjb21wb3VuZFdyaXRlQWRkV3JpdGUiLCJjb21wb3VuZFdyaXRlIiwicm9vdG1vc3QiLCJyb290TW9zdFBhdGgiLCJuZXdXcml0ZVRyZWUiLCJjb21wb3VuZFdyaXRlQWRkV3JpdGVzIiwidXBkYXRlcyIsIm5ld1dyaXRlIiwiY29tcG91bmRXcml0ZVJlbW92ZVdyaXRlIiwiY29tcG91bmRXcml0ZUhhc0NvbXBsZXRlV3JpdGUiLCJjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVOb2RlIiwiY29tcG91bmRXcml0ZUdldENvbXBsZXRlQ2hpbGRyZW4iLCJjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlIiwic2hhZG93aW5nTm9kZSIsImNvbXBvdW5kV3JpdGVJc0VtcHR5IiwiY29tcG91bmRXcml0ZUFwcGx5IiwiYXBwbHlTdWJ0cmVlV3JpdGUiLCJ3cml0ZVRyZWUiLCJwcmlvcml0eVdyaXRlIiwid3JpdGVUcmVlQ2hpbGRXcml0ZXMiLCJuZXdXcml0ZVRyZWVSZWYiLCJ3cml0ZVRyZWVBZGRPdmVyd3JpdGUiLCJ3cml0ZUlkIiwibGFzdFdyaXRlSWQiLCJhbGxXcml0ZXMiLCJ2aXNpYmxlV3JpdGVzIiwid3JpdGVUcmVlQWRkTWVyZ2UiLCJjaGFuZ2VkQ2hpbGRyZW4iLCJ3cml0ZVRyZWVHZXRXcml0ZSIsInJlY29yZCIsIndyaXRlVHJlZVJlbW92ZVdyaXRlIiwiZmluZEluZGV4Iiwid3JpdGVUb1JlbW92ZSIsInJlbW92ZWRXcml0ZVdhc1Zpc2libGUiLCJyZW1vdmVkV3JpdGVPdmVybGFwc1dpdGhPdGhlcldyaXRlcyIsImN1cnJlbnRXcml0ZSIsIndyaXRlVHJlZVJlY29yZENvbnRhaW5zUGF0aF8iLCJ3cml0ZVRyZWVSZXNldFRyZWVfIiwid3JpdGVSZWNvcmQiLCJ3cml0ZVRyZWVMYXllclRyZWVfIiwid3JpdGVUcmVlRGVmYXVsdEZpbHRlcl8iLCJ3cml0ZXMiLCJ0cmVlUm9vdCIsIndyaXRlUGF0aCIsImRlZXBOb2RlIiwid3JpdGVUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZSIsInRyZWVQYXRoIiwiY29tcGxldGVTZXJ2ZXJDYWNoZSIsIndyaXRlSWRzVG9FeGNsdWRlIiwiaW5jbHVkZUhpZGRlbldyaXRlcyIsInN1Yk1lcmdlIiwibGF5ZXJlZENhY2hlIiwibWVyZ2VBdFBhdGgiLCJ3cml0ZVRyZWVDYWxjQ29tcGxldGVFdmVudENoaWxkcmVuIiwiY29tcGxldGVTZXJ2ZXJDaGlsZHJlbiIsImNvbXBsZXRlQ2hpbGRyZW4iLCJ0b3BMZXZlbFNldCIsIndyaXRlVHJlZUNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUiLCJleGlzdGluZ0V2ZW50U25hcCIsImV4aXN0aW5nU2VydmVyU25hcCIsImNoaWxkTWVyZ2UiLCJ3cml0ZVRyZWVDYWxjQ29tcGxldGVDaGlsZCIsIndyaXRlVHJlZVNoYWRvd2luZ1dyaXRlIiwid3JpdGVUcmVlQ2FsY0luZGV4ZWRTbGljZSIsImNvbXBsZXRlU2VydmVyRGF0YSIsInRvSXRlcmF0ZSIsIm5vZGVzIiwid3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZSIsIndyaXRlVHJlZVJlZiIsIndyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4iLCJ3cml0ZVRyZWVSZWZDYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlIiwid3JpdGVUcmVlUmVmU2hhZG93aW5nV3JpdGUiLCJ3cml0ZVRyZWVSZWZDYWxjSW5kZXhlZFNsaWNlIiwid3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlQ2hpbGQiLCJleGlzdGluZ1NlcnZlckNhY2hlIiwid3JpdGVUcmVlUmVmQ2hpbGQiLCJDaGlsZENoYW5nZUFjY3VtdWxhdG9yIiwiY2hhbmdlTWFwIiwib2xkQ2hhbmdlIiwib2xkVHlwZSIsImdldENoYW5nZXMiLCJmcm9tIiwiTm9Db21wbGV0ZUNoaWxkU291cmNlXyIsImdldENvbXBsZXRlQ2hpbGQiLCJOT19DT01QTEVURV9DSElMRF9TT1VSQ0UiLCJXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlIiwid3JpdGVzXyIsInZpZXdDYWNoZV8iLCJvcHRDb21wbGV0ZVNlcnZlckNhY2hlXyIsInNlcnZlck5vZGUiLCJuZXdWaWV3UHJvY2Vzc29yIiwidmlld1Byb2Nlc3NvckFzc2VydEluZGV4ZWQiLCJ2aWV3UHJvY2Vzc29yIiwidmlld1Byb2Nlc3NvckFwcGx5T3BlcmF0aW9uIiwib2xkVmlld0NhY2hlIiwib3BlcmF0aW9uIiwid3JpdGVzQ2FjaGUiLCJjb21wbGV0ZUNhY2hlIiwiYWNjdW11bGF0b3IiLCJmaWx0ZXJTZXJ2ZXJOb2RlIiwib3ZlcndyaXRlIiwidmlld1Byb2Nlc3NvckFwcGx5VXNlck92ZXJ3cml0ZSIsInZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck92ZXJ3cml0ZSIsInZpZXdQcm9jZXNzb3JBcHBseVVzZXJNZXJnZSIsInZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck1lcmdlIiwiYWNrVXNlcldyaXRlIiwidmlld1Byb2Nlc3NvckFja1VzZXJXcml0ZSIsInZpZXdQcm9jZXNzb3JSZXZlcnRVc2VyV3JpdGUiLCJ2aWV3UHJvY2Vzc29yTGlzdGVuQ29tcGxldGUiLCJ2aWV3UHJvY2Vzc29yTWF5YmVBZGRWYWx1ZUV2ZW50IiwiaXNMZWFmT3JFbXB0eSIsIm9sZENvbXBsZXRlU25hcCIsInZpZXdQcm9jZXNzb3JHZW5lcmF0ZUV2ZW50Q2FjaGVBZnRlclNlcnZlckV2ZW50IiwiY2hhbmdlUGF0aCIsIm9sZEV2ZW50U25hcCIsImNvbXBsZXRlRXZlbnRDaGlsZHJlbiIsImNvbXBsZXRlTm9kZSIsIm9sZEV2ZW50Tm9kZSIsInVwZGF0ZWRQcmlvcml0eSIsImNoaWxkQ2hhbmdlUGF0aCIsIm5ld0V2ZW50Q2hpbGQiLCJldmVudENoaWxkVXBkYXRlIiwiY2hhbmdlZFNuYXAiLCJvbGRTZXJ2ZXJTbmFwIiwibmV3U2VydmVyQ2FjaGUiLCJzZXJ2ZXJGaWx0ZXIiLCJuZXdTZXJ2ZXJOb2RlIiwibmV3RXZlbnRTbmFwIiwidmlld1Byb2Nlc3NvckNhY2hlSGFzQ2hpbGQiLCJjdXJWaWV3Q2FjaGUiLCJ2aWV3UHJvY2Vzc29yQXBwbHlNZXJnZSIsInZpZXdNZXJnZVRyZWUiLCJzZXJ2ZXJDaGlsZCIsImNoaWxkTWVyZ2VUcmVlIiwiaXNVbmtub3duRGVlcE1lcmdlIiwiYWNrUGF0aCIsIm1lcmdlUGF0aCIsInNlcnZlckNhY2hlUGF0aCIsIm9sZFNlcnZlck5vZGUiLCJzZXJ2ZXJDaGlsZHJlbiIsIlZpZXciLCJpbml0aWFsVmlld0NhY2hlIiwiZXZlbnRSZWdpc3RyYXRpb25zXyIsImluZGV4RmlsdGVyIiwicHJvY2Vzc29yXyIsImluaXRpYWxTZXJ2ZXJDYWNoZSIsImluaXRpYWxFdmVudENhY2hlIiwiZXZlbnRHZW5lcmF0b3JfIiwidmlld0dldFNlcnZlckNhY2hlIiwidmlldyIsInZpZXdHZXRDb21wbGV0ZU5vZGUiLCJ2aWV3R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZSIsImNhY2hlIiwidmlld0lzRW1wdHkiLCJ2aWV3QWRkRXZlbnRSZWdpc3RyYXRpb24iLCJldmVudFJlZ2lzdHJhdGlvbiIsInZpZXdSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbiIsImNhbmNlbEVycm9yIiwiY2FuY2VsRXZlbnRzIiwibWF5YmVFdmVudCIsImNyZWF0ZUNhbmNlbEV2ZW50IiwicmVtYWluaW5nIiwiZXhpc3RpbmciLCJoYXNBbnlDYWxsYmFjayIsImNvbmNhdCIsInZpZXdBcHBseU9wZXJhdGlvbiIsInZpZXdHZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXNfIiwidmlld0dldEluaXRpYWxFdmVudHMiLCJpbml0aWFsQ2hhbmdlcyIsImV2ZW50Tm9kZSIsInJlZmVyZW5jZUNvbnN0cnVjdG9yJDEiLCJTeW5jUG9pbnQiLCJ2aWV3cyIsInN5bmNQb2ludFNldFJlZmVyZW5jZUNvbnN0cnVjdG9yIiwic3luY1BvaW50R2V0UmVmZXJlbmNlQ29uc3RydWN0b3IiLCJzeW5jUG9pbnRJc0VtcHR5Iiwic3luY1BvaW50Iiwic3luY1BvaW50QXBwbHlPcGVyYXRpb24iLCJvcHRDb21wbGV0ZVNlcnZlckNhY2hlIiwic3luY1BvaW50R2V0VmlldyIsInNlcnZlckNhY2hlQ29tcGxldGUiLCJldmVudENhY2hlQ29tcGxldGUiLCJzeW5jUG9pbnRBZGRFdmVudFJlZ2lzdHJhdGlvbiIsInN5bmNQb2ludFJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uIiwicmVtb3ZlZCIsImhhZENvbXBsZXRlVmlldyIsInN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyIsInZpZXdRdWVyeUlkIiwiZW50cmllcyIsIl9yZXBvIiwic3luY1BvaW50R2V0UXVlcnlWaWV3cyIsInN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUiLCJzeW5jUG9pbnRWaWV3Rm9yUXVlcnkiLCJzeW5jUG9pbnRHZXRDb21wbGV0ZVZpZXciLCJzeW5jUG9pbnRWaWV3RXhpc3RzRm9yUXVlcnkiLCJyZWZlcmVuY2VDb25zdHJ1Y3RvciIsInN5bmNUcmVlU2V0UmVmZXJlbmNlQ29uc3RydWN0b3IiLCJzeW5jVHJlZUdldFJlZmVyZW5jZUNvbnN0cnVjdG9yIiwic3luY1RyZWVOZXh0UXVlcnlUYWdfIiwiU3luY1RyZWUiLCJsaXN0ZW5Qcm92aWRlcl8iLCJzeW5jUG9pbnRUcmVlXyIsInBlbmRpbmdXcml0ZVRyZWVfIiwidGFnVG9RdWVyeU1hcCIsInF1ZXJ5VG9UYWdNYXAiLCJzeW5jVHJlZUFwcGx5VXNlck92ZXJ3cml0ZSIsInN5bmNUcmVlIiwibmV3RGF0YSIsInN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfIiwic3luY1RyZWVBcHBseVVzZXJNZXJnZSIsImNoYW5nZVRyZWUiLCJzeW5jVHJlZUFja1VzZXJXcml0ZSIsIm5lZWRUb1JlZXZhbHVhdGUiLCJzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlIiwic3luY1RyZWVBcHBseVNlcnZlck1lcmdlIiwic3luY1RyZWVBcHBseUxpc3RlbkNvbXBsZXRlIiwic3luY1RyZWVBcHBseVRhZ2dlZExpc3RlbkNvbXBsZXRlIiwicXVlcnlLZXkiLCJzeW5jVHJlZVF1ZXJ5S2V5Rm9yVGFnXyIsInN5bmNUcmVlUGFyc2VRdWVyeUtleV8iLCJxdWVyeVBhdGgiLCJvcCIsInN5bmNUcmVlQXBwbHlUYWdnZWRPcGVyYXRpb25fIiwic3luY1RyZWVSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbiIsInNraXBMaXN0ZW5lckRlZHVwIiwibWF5YmVTeW5jUG9pbnQiLCJyZW1vdmVkQW5kRXZlbnRzIiwicmVtb3ZpbmdEZWZhdWx0IiwiY292ZXJlZCIsInBhcmVudFN5bmNQb2ludCIsIm5ld1ZpZXdzIiwic3luY1RyZWVDb2xsZWN0RGlzdGluY3RWaWV3c0ZvclN1YlRyZWVfIiwibmV3UXVlcnkiLCJzeW5jVHJlZUNyZWF0ZUxpc3RlbmVyRm9yVmlld18iLCJzdGFydExpc3RlbmluZyIsInN5bmNUcmVlUXVlcnlGb3JMaXN0ZW5pbmdfIiwic3luY1RyZWVUYWdGb3JRdWVyeSIsImRlZmF1bHRUYWciLCJzdG9wTGlzdGVuaW5nIiwicXVlcnlUb1JlbW92ZSIsInRhZ1RvUmVtb3ZlIiwic3luY1RyZWVNYWtlUXVlcnlLZXlfIiwic3luY1RyZWVSZW1vdmVUYWdzXyIsInN5bmNUcmVlQXBwbHlUYWdnZWRRdWVyeU92ZXJ3cml0ZSIsInN5bmNUcmVlQXBwbHlUYWdnZWRRdWVyeU1lcmdlIiwic3luY1RyZWVBZGRFdmVudFJlZ2lzdHJhdGlvbiIsInNraXBTZXR1cExpc3RlbmVyIiwiZm91bmRBbmNlc3RvckRlZmF1bHRWaWV3IiwicGF0aFRvU3luY1BvaW50Iiwic3AiLCJjaGlsZFN5bmNQb2ludCIsInZpZXdBbHJlYWR5RXhpc3RzIiwic3luY1RyZWVHZXROZXh0UXVlcnlUYWdfIiwic3luY1RyZWVTZXR1cExpc3RlbmVyXyIsInN5bmNUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZSIsImluY2x1ZGVIaWRkZW5TZXRzIiwic3luY1RyZWVHZXRTZXJ2ZXJWYWx1ZSIsInNlcnZlckNhY2hlTm9kZSIsInN5bmNUcmVlQXBwbHlPcGVyYXRpb25IZWxwZXJfIiwic3luY1BvaW50VHJlZSIsInN5bmNUcmVlQXBwbHlPcGVyYXRpb25EZXNjZW5kYW50c0hlbHBlcl8iLCJjaGlsZE9wZXJhdGlvbiIsImNoaWxkU2VydmVyQ2FjaGUiLCJjaGlsZFdyaXRlc0NhY2hlIiwic3BsaXRJbmRleCIsIm1heWJlQ2hpbGRTeW5jUG9pbnQiLCJjaGlsZE1hcCIsImNvbXBsZXRlVmlldyIsIl9rZXkiLCJjaGlsZFZpZXdzIiwicmVtb3ZlZFF1ZXJ5IiwicmVtb3ZlZFF1ZXJ5S2V5IiwicmVtb3ZlZFF1ZXJ5VGFnIiwicXVlcmllc1RvU3RvcCIsImNoaWxkUXVlcmllcyIsInF1ZXJ5VG9TdG9wIiwiRXhpc3RpbmdWYWx1ZVByb3ZpZGVyIiwiRGVmZXJyZWRWYWx1ZVByb3ZpZGVyIiwic3luY1RyZWVfIiwicGF0aF8iLCJnZW5lcmF0ZVdpdGhWYWx1ZXMiLCJyZXNvbHZlRGVmZXJyZWRMZWFmVmFsdWUiLCJleGlzdGluZ1ZhbCIsInNlcnZlclZhbHVlcyIsInJlc29sdmVTY2FsYXJEZWZlcnJlZFZhbHVlIiwicmVzb2x2ZUNvbXBsZXhEZWZlcnJlZFZhbHVlIiwiSlNPTiIsInVudXNlZCIsImV4aXN0aW5nTm9kZSIsImxlYWYiLCJyZXNvbHZlRGVmZXJyZWRWYWx1ZVRyZWUiLCJyZXNvbHZlRGVmZXJyZWRWYWx1ZSIsInJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QiLCJyYXdQcmkiLCJsZWFmTm9kZSIsImNoaWxkcmVuTm9kZSIsIlRyZWUiLCJwYXJlbnQiLCJjaGlsZENvdW50IiwidHJlZVN1YlRyZWUiLCJwYXRoT2JqIiwidHJlZUdldFZhbHVlIiwidHJlZVNldFZhbHVlIiwidHJlZVVwZGF0ZVBhcmVudHMiLCJ0cmVlSGFzQ2hpbGRyZW4iLCJ0cmVlSXNFbXB0eSIsInRyZWVGb3JFYWNoQ2hpbGQiLCJ0cmVlRm9yRWFjaERlc2NlbmRhbnQiLCJpbmNsdWRlU2VsZiIsImNoaWxkcmVuRmlyc3QiLCJ0cmVlRm9yRWFjaEFuY2VzdG9yIiwidHJlZUdldFBhdGgiLCJ0cmVlVXBkYXRlQ2hpbGQiLCJjaGlsZEVtcHR5IiwiY2hpbGRFeGlzdHMiLCJJTlZBTElEX0tFWV9SRUdFWF8iLCJJTlZBTElEX1BBVEhfUkVHRVhfIiwiTUFYX0xFQUZfU0laRV8iLCJpc1ZhbGlkS2V5IiwiaXNWYWxpZFBhdGhTdHJpbmciLCJpc1ZhbGlkUm9vdFBhdGhTdHJpbmciLCJpc1ZhbGlkUHJpb3JpdHkiLCJ2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZyIsImZuTmFtZSIsInZhbGlkYXRlRmlyZWJhc2VEYXRhIiwiaGFzRG90VmFsdWUiLCJoYXNBY3R1YWxDaGlsZCIsInZhbGlkYXRlRmlyZWJhc2VNZXJnZVBhdGhzIiwibWVyZ2VQYXRocyIsImN1clBhdGgiLCJwcmV2UGF0aCIsInZhbGlkYXRlRmlyZWJhc2VNZXJnZURhdGFBcmciLCJlcnJvclByZWZpeCQxIiwidmFsaWRhdGVQcmlvcml0eSIsInZhbGlkYXRlS2V5IiwiYXJndW1lbnROYW1lIiwidmFsaWRhdGVQYXRoU3RyaW5nIiwidmFsaWRhdGVSb290UGF0aFN0cmluZyIsInZhbGlkYXRlV3JpdGFibGVQYXRoIiwidmFsaWRhdGVVcmwiLCJwYXJzZWRVcmwiLCJFdmVudFF1ZXVlIiwiZXZlbnRMaXN0c18iLCJyZWN1cnNpb25EZXB0aF8iLCJldmVudFF1ZXVlUXVldWVFdmVudHMiLCJldmVudFF1ZXVlIiwiZXZlbnREYXRhTGlzdCIsImN1cnJMaXN0IiwiZ2V0UGF0aCIsImV2ZW50UXVldWVSYWlzZUV2ZW50c0F0UGF0aCIsImV2ZW50UXVldWVSYWlzZVF1ZXVlZEV2ZW50c01hdGNoaW5nUHJlZGljYXRlIiwiZXZlbnRQYXRoIiwiZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgiLCJjaGFuZ2VkUGF0aCIsInNlbnRBbGwiLCJldmVudExpc3QiLCJldmVudExpc3RSYWlzZSIsImV2ZW50Rm4iLCJnZXRFdmVudFJ1bm5lciIsIklOVEVSUlVQVF9SRUFTT04iLCJNQVhfVFJBTlNBQ1RJT05fUkVUUklFUyIsIlJlcG8iLCJmb3JjZVJlc3RDbGllbnRfIiwiYXBwQ2hlY2tQcm92aWRlcl8iLCJkYXRhVXBkYXRlQ291bnQiLCJldmVudFF1ZXVlXyIsIm5leHRXcml0ZUlkXyIsImludGVyY2VwdFNlcnZlckRhdGFDYWxsYmFja18iLCJ0cmFuc2FjdGlvblF1ZXVlVHJlZV8iLCJwZXJzaXN0ZW50Q29ubmVjdGlvbl8iLCJyZXBvU3RhcnQiLCJyZXBvIiwiYXBwSWQiLCJhdXRoT3ZlcnJpZGUiLCJpc01lcmdlIiwicmVwb09uRGF0YVVwZGF0ZSIsInJlcG9PbkNvbm5lY3RTdGF0dXMiLCJjb25uZWN0U3RhdHVzIiwicmVwb09uU2VydmVySW5mb1VwZGF0ZSIsInN0YXRzUmVwb3J0ZXJfIiwiaW5mb0RhdGFfIiwiaW5mb1N5bmNUcmVlXyIsImluZm9FdmVudHMiLCJyZXBvVXBkYXRlSW5mbyIsInNlcnZlclN5bmNUcmVlXyIsInJlcG9TZXJ2ZXJUaW1lIiwib2Zmc2V0Tm9kZSIsIm9mZnNldCIsInJlcG9HZW5lcmF0ZVNlcnZlclZhbHVlcyIsInRhZ2dlZENoaWxkcmVuIiwicmF3IiwidGFnZ2VkU25hcCIsInJlcG9SZXJ1blRyYW5zYWN0aW9ucyIsInJlcG9SdW5PbkRpc2Nvbm5lY3RFdmVudHMiLCJyZXBvR2V0TmV4dFdyaXRlSWQiLCJyZXBvR2V0VmFsdWUiLCJjYWNoZWQiLCJlcnIiLCJyZXBvTG9nIiwicmVwb1NldFdpdGhQcmlvcml0eSIsIm5ld1ZhbCIsIm5ld05vZGVVbnJlc29sdmVkIiwic3VjY2VzcyIsImNsZWFyRXZlbnRzIiwicmVwb0NhbGxPbkNvbXBsZXRlQ2FsbGJhY2siLCJyZXBvQWJvcnRUcmFuc2FjdGlvbnMiLCJyZXBvVXBkYXRlIiwiY2hpbGRyZW5Ub01lcmdlIiwiY2hhbmdlZEtleSIsImNoYW5nZWRWYWx1ZSIsInJlc29sdmVkT25EaXNjb25uZWN0VHJlZSIsInJlc29sdmVkIiwicmVwb09uRGlzY29ubmVjdENhbmNlbCIsInJlcG9PbkRpc2Nvbm5lY3RTZXQiLCJyZXBvT25EaXNjb25uZWN0U2V0V2l0aFByaW9yaXR5IiwicmVwb09uRGlzY29ubmVjdFVwZGF0ZSIsInJlcG9BZGRFdmVudENhbGxiYWNrRm9yUXVlcnkiLCJyZXBvUmVtb3ZlRXZlbnRDYWxsYmFja0ZvclF1ZXJ5IiwicmVwb0ludGVycnVwdCIsInJlcG9SZXN1bWUiLCJyZXBvU3RhcnRUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uVXBkYXRlIiwidW53YXRjaGVyIiwiYXBwbHlMb2NhbGx5IiwidHJhbnNhY3Rpb24iLCJvcmRlciIsInJldHJ5Q291bnQiLCJhYm9ydFJlYXNvbiIsImN1cnJlbnRXcml0ZUlkIiwiY3VycmVudElucHV0U25hcHNob3QiLCJjdXJyZW50T3V0cHV0U25hcHNob3RSYXciLCJjdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZCIsImN1cnJlbnRTdGF0ZSIsInJlcG9HZXRMYXRlc3RTdGF0ZSIsInF1ZXVlTm9kZSIsIm5vZGVRdWV1ZSIsInByaW9yaXR5Rm9yTm9kZSIsImN1cnJlbnROb2RlIiwicmVwb1NlbmRSZWFkeVRyYW5zYWN0aW9ucyIsImV4Y2x1ZGVTZXRzIiwicmVwb1BydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlIiwicXVldWUiLCJyZXBvQnVpbGRUcmFuc2FjdGlvblF1ZXVlIiwiYWxsUnVuIiwiZXZlcnkiLCJyZXBvU2VuZFRyYW5zYWN0aW9uUXVldWUiLCJzZXRzVG9JZ25vcmUiLCJ0eG4iLCJsYXRlc3RTdGF0ZSIsInNuYXBUb1NlbmQiLCJsYXRlc3RIYXNoIiwiZGF0YVRvU2VuZCIsInBhdGhUb1NlbmQiLCJjYWxsYmFja3MiLCJyb290TW9zdFRyYW5zYWN0aW9uTm9kZSIsInJlcG9HZXRBbmNlc3RvclRyYW5zYWN0aW9uTm9kZSIsInJlcG9SZXJ1blRyYW5zYWN0aW9uUXVldWUiLCJ0eG5zVG9SZXJ1biIsImFib3J0VHJhbnNhY3Rpb24iLCJuZXdEYXRhTm9kZSIsImhhc0V4cGxpY2l0UHJpb3JpdHkiLCJvbGRXcml0ZUlkIiwibmV3Tm9kZVJlc29sdmVkIiwidHJhbnNhY3Rpb25Ob2RlIiwidHJhbnNhY3Rpb25RdWV1ZSIsInJlcG9BZ2dyZWdhdGVUcmFuc2FjdGlvblF1ZXVlc0Zvck5vZGUiLCJ0byIsInJlcG9BYm9ydFRyYW5zYWN0aW9uc09uTm9kZSIsImxhc3RTZW50IiwiZGVjb2RlUGF0aCIsInBhdGhTdHJpbmdEZWNvZGVkIiwicGllY2UiLCJkZWNvZGVVUklDb21wb25lbnQiLCJkZWNvZGVRdWVyeSIsInF1ZXJ5U3RyaW5nIiwicmVzdWx0cyIsImNoYXJBdCIsInNlZ21lbnQiLCJrdiIsInBhcnNlUmVwb0luZm8iLCJkYXRhVVJMIiwicGFyc2VEYXRhYmFzZVVSTCIsInNjaGVtZSIsInN1YmRvbWFpbiIsInBvcnQiLCJjb2xvbkluZCIsInNsYXNoSW5kIiwicXVlc3Rpb25NYXJrSW5kIiwiaG9zdFdpdGhvdXRQb3J0IiwiZG90SW5kIiwiUFVTSF9DSEFSUyIsIm5leHRQdXNoSWQiLCJsYXN0UHVzaFRpbWUiLCJsYXN0UmFuZENoYXJzIiwibm93IiwiZHVwbGljYXRlVGltZSIsInRpbWVTdGFtcENoYXJzIiwiRGF0YUV2ZW50Iiwic25hcHNob3QiLCJyZWYiLCJnZXRFdmVudFR5cGUiLCJleHBvcnRWYWwiLCJDYW5jZWxFdmVudCIsIkNhbGxiYWNrQ29udGV4dCIsInNuYXBzaG90Q2FsbGJhY2siLCJjYW5jZWxDYWxsYmFjayIsIm9uVmFsdWUiLCJleHBEYXRhU25hcHNob3QiLCJwcmV2aW91c0NoaWxkTmFtZSIsImNhbGwiLCJvbkNhbmNlbCIsImhhc0NhbmNlbENhbGxiYWNrIiwidXNlckNhbGxiYWNrIiwiT25EaXNjb25uZWN0IiwiY2FuY2VsIiwid3JhcENhbGxiYWNrIiwic2V0V2l0aFByaW9yaXR5IiwiUXVlcnlJbXBsIiwiX29yZGVyQnlDYWxsZWQiLCJSZWZlcmVuY2VJbXBsIiwiaXNFcXVhbCIsInNhbWVSZXBvIiwic2FtZVBhdGgiLCJzYW1lUXVlcnlJZGVudGlmaWVyIiwidG9KU09OIiwidmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGwiLCJ2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzIiwic3RhcnROb2RlIiwiZW5kTm9kZSIsInRvb01hbnlBcmdzRXJyb3IiLCJ3cm9uZ0FyZ1R5cGVFcnJvciIsInZhbGlkYXRlTGltaXQiLCJwYXJlbnRQYXRoIiwiRGF0YVNuYXBzaG90IiwiX25vZGUiLCJfaW5kZXgiLCJjaGlsZFJlZiIsImV4aXN0cyIsImhhc0NoaWxkcmVuIiwiZGIiLCJfY2hlY2tOb3REZWxldGVkIiwiX3Jvb3QiLCJyZWZGcm9tVVJMIiwicGFyc2VkVVJMIiwidGhlbm5hYmxlUHVzaFJlZiIsInB1c2hSZWYiLCJzZXRQcmlvcml0eSIsImNhbGxiYWNrQ29udGV4dCIsImNvbnRhaW5lciIsIlZhbHVlRXZlbnRSZWdpc3RyYXRpb24iLCJDaGlsZEV2ZW50UmVnaXN0cmF0aW9uIiwiZXZlbnRUb0NoZWNrIiwiY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMiLCJvbmx5T25jZSIsIm9uY2VDYWxsYmFjayIsImRhdGFTbmFwc2hvdCIsIm9uQ2hpbGRBZGRlZCIsIm9uQ2hpbGRDaGFuZ2VkIiwib25DaGlsZE1vdmVkIiwib25DaGlsZFJlbW92ZWQiLCJleHBDYWxsYmFjayIsIlF1ZXJ5Q29uc3RyYWludCIsIlF1ZXJ5RW5kQXRDb25zdHJhaW50IiwiX3ZhbHVlIiwiX2FwcGx5IiwiZW5kQXQiLCJRdWVyeUVuZEJlZm9yZUNvbnN0cmFpbnQiLCJlbmRCZWZvcmUiLCJRdWVyeVN0YXJ0QXRDb25zdHJhaW50Iiwic3RhcnRBdCIsIlF1ZXJ5U3RhcnRBZnRlckNvbnN0cmFpbnQiLCJzdGFydEFmdGVyIiwiUXVlcnlMaW1pdFRvRmlyc3RDb25zdHJhaW50IiwiX2xpbWl0IiwibGltaXRUb0ZpcnN0IiwibGltaXQiLCJRdWVyeUxpbWl0VG9MYXN0Q29uc3RyYWludCIsImxpbWl0VG9MYXN0IiwiUXVlcnlPcmRlckJ5Q2hpbGRDb25zdHJhaW50IiwicGFyc2VkUGF0aCIsIm9yZGVyQnlDaGlsZCIsIlF1ZXJ5T3JkZXJCeUtleUNvbnN0cmFpbnQiLCJhcmd1bWVudHMiLCJvcmRlckJ5S2V5IiwiUXVlcnlPcmRlckJ5UHJpb3JpdHlDb25zdHJhaW50Iiwib3JkZXJCeVByaW9yaXR5IiwiUXVlcnlPcmRlckJ5VmFsdWVDb25zdHJhaW50Iiwib3JkZXJCeVZhbHVlIiwiUXVlcnlFcXVhbFRvVmFsdWVDb25zdHJhaW50IiwiZXF1YWxUbyIsInF1ZXJ5Q29uc3RyYWludHMiLCJxdWVyeUltcGwiLCJjb25zdHJhaW50IiwiRklSRUJBU0VfREFUQUJBU0VfRU1VTEFUT1JfSE9TVF9WQVIiLCJyZXBvcyIsInVzZVJlc3RDbGllbnQiLCJyZXBvTWFuYWdlckFwcGx5RW11bGF0b3JTZXR0aW5ncyIsInRva2VuUHJvdmlkZXIiLCJyZXBvTWFuYWdlckRhdGFiYXNlRnJvbUFwcCIsImFwcCIsImF1dGhQcm92aWRlciIsImRiVXJsIiwiZGF0YWJhc2VVUkwiLCJwcm9qZWN0SWQiLCJpc0VtdWxhdG9yIiwiZGJFbXVsYXRvckhvc3QiLCJhdXRoVG9rZW5Qcm92aWRlciIsInJlcG9NYW5hZ2VyQ3JlYXRlUmVwbyIsIkRhdGFiYXNlIiwicmVwb01hbmFnZXJEZWxldGVSZXBvIiwiYXBwTmFtZSIsImFwcFJlcG9zIiwicmVwb01hbmFnZXJGb3JjZVJlc3RDbGllbnQiLCJmb3JjZVJlc3RDbGllbnQiLCJfcmVwb0ludGVybmFsIiwiX2luc3RhbmNlU3RhcnRlZCIsIl9yb290SW50ZXJuYWwiLCJfZGVsZXRlIiwiYXBpTmFtZSIsImNoZWNrVHJhbnNwb3J0SW5pdCIsImZvcmNlV2ViU29ja2V0cyIsImZvcmNlTG9uZ1BvbGxpbmciLCJnZXREYXRhYmFzZSIsImlkZW50aWZpZXIiLCJlbXVsYXRvciIsImNvbm5lY3REYXRhYmFzZUVtdWxhdG9yIiwibW9ja1VzZXJUb2tlbiIsImdvT2ZmbGluZSIsImdvT25saW5lIiwiZW5hYmxlTG9nZ2luZyIsInJlZ2lzdGVyRGF0YWJhc2UiLCJ2YXJpYW50IiwiaW5zdGFuY2VJZGVudGlmaWVyIiwiZ2V0UHJvdmlkZXIiLCJzZXRNdWx0aXBsZUluc3RhbmNlcyIsIlNFUlZFUl9USU1FU1RBTVAiLCJzZXJ2ZXJUaW1lc3RhbXAiLCJpbmNyZW1lbnQiLCJUcmFuc2FjdGlvblJlc3VsdCIsImNvbW1pdHRlZCIsInJ1blRyYW5zYWN0aW9uIiwicHJvbWlzZUNvbXBsZXRlIiwicHJvdG90eXBlIiwic2ltcGxlTGlzdGVuIiwiZWNobyIsIm9uRWNobyIsImhpamFja0hhc2giLCJuZXdIYXNoIiwib2xkUHV0IiwiX2luaXRTdGFuZGFsb25lIiwiY3VzdG9tQXV0aEltcGwiLCJjdXN0b21BcHBDaGVja0ltcGwiLCJjb21wb25lbnRDb250YWluZXIiLCJzZXRDb21wb25lbnQiLCJDbGllbnQiLCJfUXVlcnlJbXBsIiwiX1F1ZXJ5UGFyYW1zIiwiX1JlZmVyZW5jZUltcGwiLCJfVEVTVF9BQ0NFU1NfZm9yY2VSZXN0Q2xpZW50IiwiX1RFU1RfQUNDRVNTX2hpamFja0hhc2giLCJfcmVwb01hbmFnZXJEYXRhYmFzZUZyb21BcHAiLCJfc2V0U0RLVmVyc2lvbiIsIl92YWxpZGF0ZVBhdGhTdHJpbmciLCJfdmFsaWRhdGVXcml0YWJsZVBhdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/database/dist/node-esm/index.node.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@firebase/logger/dist/esm/index.esm2017.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   setUserLogHandler: () => (/* binding */ setUserLogHandler)\n/* harmony export */ });\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A container for all of the Logger instances\r\n */ const instances = [];\n/**\r\n * The JS SDK supports 5 log levels and also allows a user the ability to\r\n * silence the logs altogether.\r\n *\r\n * The order is a follows:\r\n * DEBUG < VERBOSE < INFO < WARN < ERROR\r\n *\r\n * All of the log types above the current log level will be captured (i.e. if\r\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\r\n * `VERBOSE` logs will not)\r\n */ var LogLevel;\n(function(LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nconst levelStringToEnum = {\n    \"debug\": LogLevel.DEBUG,\n    \"verbose\": LogLevel.VERBOSE,\n    \"info\": LogLevel.INFO,\n    \"warn\": LogLevel.WARN,\n    \"error\": LogLevel.ERROR,\n    \"silent\": LogLevel.SILENT\n};\n/**\r\n * The default log level\r\n */ const defaultLogLevel = LogLevel.INFO;\n/**\r\n * By default, `console.debug` is not displayed in the developer console (in\r\n * chrome). To avoid forcing users to have to opt-in to these logs twice\r\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\r\n * logs to the `console.log` function.\r\n */ const ConsoleMethod = {\n    [LogLevel.DEBUG]: \"log\",\n    [LogLevel.VERBOSE]: \"log\",\n    [LogLevel.INFO]: \"info\",\n    [LogLevel.WARN]: \"warn\",\n    [LogLevel.ERROR]: \"error\"\n};\n/**\r\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\r\n * messages on to their corresponding console counterparts (if the log method\r\n * is supported by the current log level)\r\n */ const defaultLogHandler = (instance, logType, ...args)=>{\n    if (logType < instance.logLevel) {\n        return;\n    }\n    const now = new Date().toISOString();\n    const method = ConsoleMethod[logType];\n    if (method) {\n        console[method](`[${now}]  ${instance.name}:`, ...args);\n    } else {\n        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\n    }\n};\nclass Logger {\n    /**\r\n     * Gives you an instance of a Logger to capture messages according to\r\n     * Firebase's logging scheme.\r\n     *\r\n     * @param name The name that the logs will be associated with\r\n     */ constructor(name){\n        this.name = name;\n        /**\r\n         * The log level of the given Logger instance.\r\n         */ this._logLevel = defaultLogLevel;\n        /**\r\n         * The main (internal) log handler for the Logger instance.\r\n         * Can be set to a new function in internal package code but not by user.\r\n         */ this._logHandler = defaultLogHandler;\n        /**\r\n         * The optional, additional, user-defined log handler for the Logger instance.\r\n         */ this._userLogHandler = null;\n        /**\r\n         * Capture the current instance for later use\r\n         */ instances.push(this);\n    }\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(val) {\n        if (!(val in LogLevel)) {\n            throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n        }\n        this._logLevel = val;\n    }\n    // Workaround for setter/getter having to be the same type.\n    setLogLevel(val) {\n        this._logLevel = typeof val === \"string\" ? levelStringToEnum[val] : val;\n    }\n    get logHandler() {\n        return this._logHandler;\n    }\n    set logHandler(val) {\n        if (typeof val !== \"function\") {\n            throw new TypeError(\"Value assigned to `logHandler` must be a function\");\n        }\n        this._logHandler = val;\n    }\n    get userLogHandler() {\n        return this._userLogHandler;\n    }\n    set userLogHandler(val) {\n        this._userLogHandler = val;\n    }\n    /**\r\n     * The functions below are all based on the `console` interface\r\n     */ debug(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);\n        this._logHandler(this, LogLevel.DEBUG, ...args);\n    }\n    log(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);\n        this._logHandler(this, LogLevel.VERBOSE, ...args);\n    }\n    info(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);\n        this._logHandler(this, LogLevel.INFO, ...args);\n    }\n    warn(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);\n        this._logHandler(this, LogLevel.WARN, ...args);\n    }\n    error(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);\n        this._logHandler(this, LogLevel.ERROR, ...args);\n    }\n}\nfunction setLogLevel(level) {\n    instances.forEach((inst)=>{\n        inst.setLogLevel(level);\n    });\n}\nfunction setUserLogHandler(logCallback, options) {\n    for (const instance of instances){\n        let customLogLevel = null;\n        if (options && options.level) {\n            customLogLevel = levelStringToEnum[options.level];\n        }\n        if (logCallback === null) {\n            instance.userLogHandler = null;\n        } else {\n            instance.userLogHandler = (instance, level, ...args)=>{\n                const message = args.map((arg)=>{\n                    if (arg == null) {\n                        return null;\n                    } else if (typeof arg === \"string\") {\n                        return arg;\n                    } else if (typeof arg === \"number\" || typeof arg === \"boolean\") {\n                        return arg.toString();\n                    } else if (arg instanceof Error) {\n                        return arg.message;\n                    } else {\n                        try {\n                            return JSON.stringify(arg);\n                        } catch (ignored) {\n                            return null;\n                        }\n                    }\n                }).filter((arg)=>arg).join(\" \");\n                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\n                    logCallback({\n                        level: LogLevel[level].toLowerCase(),\n                        message,\n                        args,\n                        type: instance.name\n                    });\n                }\n            };\n        }\n    }\n}\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2xvZ2dlci9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Q0FFQyxHQUNELE1BQU1BLFlBQVksRUFBRTtBQUNwQjs7Ozs7Ozs7OztDQVVDLEdBQ0QsSUFBSUM7QUFDSCxVQUFVQSxRQUFRO0lBQ2ZBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDbENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDcENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDakNBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDakNBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDbENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7QUFDdkMsR0FBR0EsWUFBYUEsQ0FBQUEsV0FBVyxDQUFDO0FBQzVCLE1BQU1DLG9CQUFvQjtJQUN0QixTQUFTRCxTQUFTRSxLQUFLO0lBQ3ZCLFdBQVdGLFNBQVNHLE9BQU87SUFDM0IsUUFBUUgsU0FBU0ksSUFBSTtJQUNyQixRQUFRSixTQUFTSyxJQUFJO0lBQ3JCLFNBQVNMLFNBQVNNLEtBQUs7SUFDdkIsVUFBVU4sU0FBU08sTUFBTTtBQUM3QjtBQUNBOztDQUVDLEdBQ0QsTUFBTUMsa0JBQWtCUixTQUFTSSxJQUFJO0FBQ3JDOzs7OztDQUtDLEdBQ0QsTUFBTUssZ0JBQWdCO0lBQ2xCLENBQUNULFNBQVNFLEtBQUssQ0FBQyxFQUFFO0lBQ2xCLENBQUNGLFNBQVNHLE9BQU8sQ0FBQyxFQUFFO0lBQ3BCLENBQUNILFNBQVNJLElBQUksQ0FBQyxFQUFFO0lBQ2pCLENBQUNKLFNBQVNLLElBQUksQ0FBQyxFQUFFO0lB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Szt3QkFDRCxJQUFJOzRCQUNBLE9BQU9JLEtBQUtDLFNBQVMsQ0FBQ0g7d0JBQzFCLEVBQ0EsT0FBT0ksU0FBUzs0QkFDWixPQUFPO3dCQUNYO29CQUNKO2dCQUNKLEdBQ0tDLE1BQU0sQ0FBQ0wsQ0FBQUEsTUFBT0EsS0FDZE0sSUFBSSxDQUFDO2dCQUNWLElBQUlmLFNBQVVNLENBQUFBLG1CQUFtQixRQUFRQSxtQkFBbUIsS0FBSyxJQUFJQSxpQkFBaUJqQyxTQUFTRyxRQUFRLEdBQUc7b0JBQ3RHNEIsWUFBWTt3QkFDUkosT0FBT3RDLFFBQVEsQ0FBQ3NDLE1BQU0sQ0FBQ2dCLFdBQVc7d0JBQ2xDVDt3QkFDQWhDO3dCQUNBMEMsTUFBTTVDLFNBQVNTLElBQUk7b0JBQ3ZCO2dCQUNKO1lBQ0o7UUFDSjtJQUNKO0FBQ0o7QUFFNEQsQ0FDNUQseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJlZS1uZXh0anMtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9sb2dnZXIvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcz8zOThlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNvbnRhaW5lciBmb3IgYWxsIG9mIHRoZSBMb2dnZXIgaW5zdGFuY2VzXHJcbiAqL1xyXG5jb25zdCBpbnN0YW5jZXMgPSBbXTtcclxuLyoqXHJcbiAqIFRoZSBKUyBTREsgc3VwcG9ydHMgNSBsb2cgbGV2ZWxzIGFuZCBhbHNvIGFsbG93cyBhIHVzZXIgdGhlIGFiaWxpdHkgdG9cclxuICogc2lsZW5jZSB0aGUgbG9ncyBhbHRvZ2V0aGVyLlxyXG4gKlxyXG4gKiBUaGUgb3JkZXIgaXMgYSBmb2xsb3dzOlxyXG4gKiBERUJVRyA8IFZFUkJPU0UgPCBJTkZPIDwgV0FSTiA8IEVSUk9SXHJcbiAqXHJcbiAqIEFsbCBvZiB0aGUgbG9nIHR5cGVzIGFib3ZlIHRoZSBjdXJyZW50IGxvZyBsZXZlbCB3aWxsIGJlIGNhcHR1cmVkIChpLmUuIGlmXHJcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgSU5GT2AsIGVycm9ycyB3aWxsIHN0aWxsIGJlIGxvZ2dlZCwgYnV0IGBERUJVR2AgYW5kXHJcbiAqIGBWRVJCT1NFYCBsb2dzIHdpbGwgbm90KVxyXG4gKi9cclxudmFyIExvZ0xldmVsO1xyXG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRFQlVHXCJdID0gMF0gPSBcIkRFQlVHXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlZFUkJPU0VcIl0gPSAxXSA9IFwiVkVSQk9TRVwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJJTkZPXCJdID0gMl0gPSBcIklORk9cIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiV0FSTlwiXSA9IDNdID0gXCJXQVJOXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVSUk9SXCJdID0gNF0gPSBcIkVSUk9SXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlNJTEVOVFwiXSA9IDVdID0gXCJTSUxFTlRcIjtcclxufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcclxuY29uc3QgbGV2ZWxTdHJpbmdUb0VudW0gPSB7XHJcbiAgICAnZGVidWcnOiBMb2dMZXZlbC5ERUJVRyxcclxuICAgICd2ZXJib3NlJzogTG9nTGV2ZWwuVkVSQk9TRSxcclxuICAgICdpbmZvJzogTG9nTGV2ZWwuSU5GTyxcclxuICAgICd3YXJuJzogTG9nTGV2ZWwuV0FSTixcclxuICAgICdlcnJvcic6IExvZ0xldmVsLkVSUk9SLFxyXG4gICAgJ3NpbGVudCc6IExvZ0xldmVsLlNJTEVOVFxyXG59O1xyXG4vKipcclxuICogVGhlIGRlZmF1bHQgbG9nIGxldmVsXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0TG9nTGV2ZWwgPSBMb2dMZXZlbC5JTkZPO1xyXG4vKipcclxuICogQnkgZGVmYXVsdCwgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBkaXNwbGF5ZWQgaW4gdGhlIGRldmVsb3BlciBjb25zb2xlIChpblxyXG4gKiBjaHJvbWUpLiBUbyBhdm9pZCBmb3JjaW5nIHVzZXJzIHRvIGhhdmUgdG8gb3B0LWluIHRvIHRoZXNlIGxvZ3MgdHdpY2VcclxuICogKGkuZS4gb25jZSBmb3IgZmlyZWJhc2UsIGFuZCBvbmNlIGluIHRoZSBjb25zb2xlKSwgd2UgYXJlIHNlbmRpbmcgYERFQlVHYFxyXG4gKiBsb2dzIHRvIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uLlxyXG4gKi9cclxuY29uc3QgQ29uc29sZU1ldGhvZCA9IHtcclxuICAgIFtMb2dMZXZlbC5ERUJVR106ICdsb2cnLFxyXG4gICAgW0xvZ0xldmVsLlZFUkJPU0VdOiAnbG9nJyxcclxuICAgIFtMb2dMZXZlbC5JTkZPXTogJ2luZm8nLFxyXG4gICAgW0xvZ0xldmVsLldBUk5dOiAnd2FybicsXHJcbiAgICBbTG9nTGV2ZWwuRVJST1JdOiAnZXJyb3InXHJcbn07XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBsb2cgaGFuZGxlciB3aWxsIGZvcndhcmQgREVCVUcsIFZFUkJPU0UsIElORk8sIFdBUk4sIGFuZCBFUlJPUlxyXG4gKiBtZXNzYWdlcyBvbiB0byB0aGVpciBjb3JyZXNwb25kaW5nIGNvbnNvbGUgY291bnRlcnBhcnRzIChpZiB0aGUgbG9nIG1ldGhvZFxyXG4gKiBpcyBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgbG9nIGxldmVsKVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdExvZ0hhbmRsZXIgPSAoaW5zdGFuY2UsIGxvZ1R5cGUsIC4uLmFyZ3MpID0+IHtcclxuICAgIGlmIChsb2dUeXBlIDwgaW5zdGFuY2UubG9nTGV2ZWwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgICBjb25zdCBtZXRob2QgPSBDb25zb2xlTWV0aG9kW2xvZ1R5cGVdO1xyXG4gICAgaWYgKG1ldGhvZCkge1xyXG4gICAgICAgIGNvbnNvbGVbbWV0aG9kXShgWyR7bm93fV0gICR7aW5zdGFuY2UubmFtZX06YCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRlZCB0byBsb2cgYSBtZXNzYWdlIHdpdGggYW4gaW52YWxpZCBsb2dUeXBlICh2YWx1ZTogJHtsb2dUeXBlfSlgKTtcclxuICAgIH1cclxufTtcclxuY2xhc3MgTG9nZ2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZXMgeW91IGFuIGluc3RhbmNlIG9mIGEgTG9nZ2VyIHRvIGNhcHR1cmUgbWVzc2FnZXMgYWNjb3JkaW5nIHRvXHJcbiAgICAgKiBGaXJlYmFzZSdzIGxvZ2dpbmcgc2NoZW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIHRoYXQgdGhlIGxvZ3Mgd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGhcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxvZyBsZXZlbCBvZiB0aGUgZ2l2ZW4gTG9nZ2VyIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gZGVmYXVsdExvZ0xldmVsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtYWluIChpbnRlcm5hbCkgbG9nIGhhbmRsZXIgZm9yIHRoZSBMb2dnZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQ2FuIGJlIHNldCB0byBhIG5ldyBmdW5jdGlvbiBpbiBpbnRlcm5hbCBwYWNrYWdlIGNvZGUgYnV0IG5vdCBieSB1c2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIgPSBkZWZhdWx0TG9nSGFuZGxlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb3B0aW9uYWwsIGFkZGl0aW9uYWwsIHVzZXItZGVmaW5lZCBsb2cgaGFuZGxlciBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FwdHVyZSB0aGUgY3VycmVudCBpbnN0YW5jZSBmb3IgbGF0ZXIgdXNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5zdGFuY2VzLnB1c2godGhpcyk7XHJcbiAgICB9XHJcbiAgICBnZXQgbG9nTGV2ZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0xldmVsO1xyXG4gICAgfVxyXG4gICAgc2V0IGxvZ0xldmVsKHZhbCkge1xyXG4gICAgICAgIGlmICghKHZhbCBpbiBMb2dMZXZlbCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2YWx1ZSBcIiR7dmFsfVwiIGFzc2lnbmVkIHRvIFxcYGxvZ0xldmVsXFxgYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLy8gV29ya2Fyb3VuZCBmb3Igc2V0dGVyL2dldHRlciBoYXZpbmcgdG8gYmUgdGhlIHNhbWUgdHlwZS5cclxuICAgIHNldExvZ0xldmVsKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyBsZXZlbFN0cmluZ1RvRW51bVt2YWxdIDogdmFsO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxvZ0hhbmRsZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0hhbmRsZXI7XHJcbiAgICB9XHJcbiAgICBzZXQgbG9nSGFuZGxlcih2YWwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZSBhc3NpZ25lZCB0byBgbG9nSGFuZGxlcmAgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBnZXQgdXNlckxvZ0hhbmRsZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJMb2dIYW5kbGVyO1xyXG4gICAgfVxyXG4gICAgc2V0IHVzZXJMb2dIYW5kbGVyKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBhbGwgYmFzZWQgb24gdGhlIGBjb25zb2xlYCBpbnRlcmZhY2VcclxuICAgICAqL1xyXG4gICAgZGVidWcoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGxvZyguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiZcclxuICAgICAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuVkVSQk9TRSwgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5WRVJCT1NFLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGluZm8oLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLklORk8sIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuSU5GTywgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICB3YXJuKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLldBUk4sIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZXJyb3IoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsZXZlbCkge1xyXG4gICAgaW5zdGFuY2VzLmZvckVhY2goaW5zdCA9PiB7XHJcbiAgICAgICAgaW5zdC5zZXRMb2dMZXZlbChsZXZlbCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBzZXRVc2VyTG9nSGFuZGxlcihsb2dDYWxsYmFjaywgb3B0aW9ucykge1xyXG4gICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcclxuICAgICAgICBsZXQgY3VzdG9tTG9nTGV2ZWwgPSBudWxsO1xyXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubGV2ZWwpIHtcclxuICAgICAgICAgICAgY3VzdG9tTG9nTGV2ZWwgPSBsZXZlbFN0cmluZ1RvRW51bVtvcHRpb25zLmxldmVsXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxvZ0NhbGxiYWNrID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnVzZXJMb2dIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnVzZXJMb2dIYW5kbGVyID0gKGluc3RhbmNlLCBsZXZlbCwgLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGFyZ3NcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGFyZyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGFyZyA9PiBhcmcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcclxuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+PSAoY3VzdG9tTG9nTGV2ZWwgIT09IG51bGwgJiYgY3VzdG9tTG9nTGV2ZWwgIT09IHZvaWQgMCA/IGN1c3RvbUxvZ0xldmVsIDogaW5zdGFuY2UubG9nTGV2ZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nQ2FsbGJhY2soe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogTG9nTGV2ZWxbbGV2ZWxdLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGluc3RhbmNlLm5hbWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgTG9nTGV2ZWwsIExvZ2dlciwgc2V0TG9nTGV2ZWwsIHNldFVzZXJMb2dIYW5kbGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbImluc3RhbmNlcyIsIkxvZ0xldmVsIiwibGV2ZWxTdHJpbmdUb0VudW0iLCJERUJVRyIsIlZFUkJPU0UiLCJJTkZPIiwiV0FSTiIsIkVSUk9SIiwiU0lMRU5UIiwiZGVmYXVsdExvZ0xldmVsIiwiQ29uc29sZU1ldGhvZCIsImRlZmF1bHRMb2dIYW5kbGVyIiwiaW5zdGFuY2UiLCJsb2dUeXBlIiwiYXJncyIsImxvZ0xldmVsIiwibm93IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwibWV0aG9kIiwiY29uc29sZSIsIm5hbWUiLCJFcnJvciIsIkxvZ2dlciIsImNvbnN0cnVjdG9yIiwiX2xvZ0xldmVsIiwiX2xvZ0hhbmRsZXIiLCJfdXNlckxvZ0hhbmRsZXIiLCJwdXNoIiwidmFsIiwiVHlwZUVycm9yIiwic2V0TG9nTGV2ZWwiLCJsb2dIYW5kbGVyIiwidXNlckxvZ0hhbmRsZXIiLCJkZWJ1ZyIsImxvZyIsImluZm8iLCJ3YXJuIiwiZXJyb3IiLCJsZXZlbCIsImZvckVhY2giLCJpbnN0Iiwic2V0VXNlckxvZ0hhbmRsZXIiLCJsb2dDYWxsYmFjayIsIm9wdGlvbnMiLCJjdXN0b21Mb2dMZXZlbCIsIm1lc3NhZ2UiLCJtYXAiLCJhcmciLCJ0b1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJpZ25vcmVkIiwiZmlsdGVyIiwiam9pbiIsInRvTG93ZXJDYXNlIiwidHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@firebase/util/dist/node-esm/index.node.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSTANTS: () => (/* binding */ CONSTANTS),\n/* harmony export */   DecodeBase64StringError: () => (/* binding */ DecodeBase64StringError),\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   ErrorFactory: () => (/* binding */ ErrorFactory),\n/* harmony export */   FirebaseError: () => (/* binding */ FirebaseError),\n/* harmony export */   MAX_VALUE_MILLIS: () => (/* binding */ MAX_VALUE_MILLIS),\n/* harmony export */   RANDOM_FACTOR: () => (/* binding */ RANDOM_FACTOR),\n/* harmony export */   Sha1: () => (/* binding */ Sha1),\n/* harmony export */   areCookiesEnabled: () => (/* binding */ areCookiesEnabled),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertionError: () => (/* binding */ assertionError),\n/* harmony export */   async: () => (/* binding */ async),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64Decode: () => (/* binding */ base64Decode),\n/* harmony export */   base64Encode: () => (/* binding */ base64Encode),\n/* harmony export */   base64urlEncodeWithoutPadding: () => (/* binding */ base64urlEncodeWithoutPadding),\n/* harmony export */   calculateBackoffMillis: () => (/* binding */ calculateBackoffMillis),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   createMockUserToken: () => (/* binding */ createMockUserToken),\n/* harmony export */   createSubscribe: () => (/* binding */ createSubscribe),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   deepExtend: () => (/* binding */ deepExtend),\n/* harmony export */   errorPrefix: () => (/* binding */ errorPrefix),\n/* harmony export */   extractQuerystring: () => (/* binding */ extractQuerystring),\n/* harmony export */   getDefaultAppConfig: () => (/* binding */ getDefaultAppConfig),\n/* harmony export */   getDefaultEmulatorHost: () => (/* binding */ getDefaultEmulatorHost),\n/* harmony export */   getDefaultEmulatorHostnameAndPort: () => (/* binding */ getDefaultEmulatorHostnameAndPort),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getExperimentalSetting: () => (/* binding */ getExperimentalSetting),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   getModularInstance: () => (/* binding */ getModularInstance),\n/* harmony export */   getUA: () => (/* binding */ getUA),\n/* harmony export */   isAdmin: () => (/* binding */ isAdmin),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isBrowserExtension: () => (/* binding */ isBrowserExtension),\n/* harmony export */   isElectron: () => (/* binding */ isElectron),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isIE: () => (/* binding */ isIE),\n/* harmony export */   isIndexedDBAvailable: () => (/* binding */ isIndexedDBAvailable),\n/* harmony export */   isMobileCordova: () => (/* binding */ isMobileCordova),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isNodeSdk: () => (/* binding */ isNodeSdk),\n/* harmony export */   isReactNative: () => (/* binding */ isReactNative),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isUWP: () => (/* binding */ isUWP),\n/* harmony export */   isValidFormat: () => (/* binding */ isValidFormat),\n/* harmony export */   isValidTimestamp: () => (/* binding */ isValidTimestamp),\n/* harmony export */   issuedAtTime: () => (/* binding */ issuedAtTime),\n/* harmony export */   jsonEval: () => (/* binding */ jsonEval),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   ordinal: () => (/* binding */ ordinal),\n/* harmony export */   promiseWithTimeout: () => (/* binding */ promiseWithTimeout),\n/* harmony export */   querystring: () => (/* binding */ querystring),\n/* harmony export */   querystringDecode: () => (/* binding */ querystringDecode),\n/* harmony export */   safeGet: () => (/* binding */ safeGet),\n/* harmony export */   stringLength: () => (/* binding */ stringLength),\n/* harmony export */   stringToByteArray: () => (/* binding */ stringToByteArray),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   uuidv4: () => (/* binding */ uuidv4),\n/* harmony export */   validateArgCount: () => (/* binding */ validateArgCount),\n/* harmony export */   validateCallback: () => (/* binding */ validateCallback),\n/* harmony export */   validateContextObject: () => (/* binding */ validateContextObject),\n/* harmony export */   validateIndexedDBOpenable: () => (/* binding */ validateIndexedDBOpenable),\n/* harmony export */   validateNamespace: () => (/* binding */ validateNamespace)\n/* harmony export */ });\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\r\n */ const CONSTANTS = {\n    /**\r\n     * @define {boolean} Whether this is the client Node.js SDK.\r\n     */ NODE_CLIENT: false,\n    /**\r\n     * @define {boolean} Whether this is the Admin Node.js SDK.\r\n     */ NODE_ADMIN: false,\n    /**\r\n     * Firebase SDK Version\r\n     */ SDK_VERSION: \"${JSCORE_VERSION}\"\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Throws an error if the provided assertion is falsy\r\n */ const assert = function(assertion, message) {\n    if (!assertion) {\n        throw assertionError(message);\n    }\n};\n/**\r\n * Returns an Error object suitable for throwing.\r\n */ const assertionError = function(message) {\n    return new Error(\"Firebase Database (\" + CONSTANTS.SDK_VERSION + \") INTERNAL ASSERT FAILED: \" + message);\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const stringToByteArray$1 = function(str) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let p = 0;\n    for(let i = 0; i < str.length; i++){\n        let c = str.charCodeAt(i);\n        if (c < 128) {\n            out[p++] = c;\n        } else if (c < 2048) {\n            out[p++] = c >> 6 | 192;\n            out[p++] = c & 63 | 128;\n        } else if ((c & 0xfc00) === 0xd800 && i + 1 < str.length && (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\n            // Surrogate Pair\n            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\n            out[p++] = c >> 18 | 240;\n            out[p++] = c >> 12 & 63 | 128;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        } else {\n            out[p++] = c >> 12 | 224;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        }\n    }\n    return out;\n};\n/**\r\n * Turns an array of numbers into the string given by the concatenation of the\r\n * characters to which the numbers correspond.\r\n * @param bytes Array of numbers representing characters.\r\n * @return Stringification of the array.\r\n */ const byteArrayToString = function(bytes) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let pos = 0, c = 0;\n    while(pos < bytes.length){\n        const c1 = bytes[pos++];\n        if (c1 < 128) {\n            out[c++] = String.fromCharCode(c1);\n        } else if (c1 > 191 && c1 < 224) {\n            const c2 = bytes[pos++];\n            out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);\n        } else if (c1 > 239 && c1 < 365) {\n            // Surrogate Pair\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            const c4 = bytes[pos++];\n            const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 0x10000;\n            out[c++] = String.fromCharCode(0xd800 + (u >> 10));\n            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\n        } else {\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n        }\n    }\n    return out.join(\"\");\n};\n// We define it as an object literal instead of a class because a class compiled down to es5 can't\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\n// Static lookup maps, lazily populated by init_()\nconst base64 = {\n    /**\r\n     * Maps bytes to characters.\r\n     */ byteToCharMap_: null,\n    /**\r\n     * Maps characters to bytes.\r\n     */ charToByteMap_: null,\n    /**\r\n     * Maps bytes to websafe characters.\r\n     * @private\r\n     */ byteToCharMapWebSafe_: null,\n    /**\r\n     * Maps websafe characters to bytes.\r\n     * @private\r\n     */ charToByteMapWebSafe_: null,\n    /**\r\n     * Our default alphabet, shared between\r\n     * ENCODED_VALS and ENCODED_VALS_WEBSAFE\r\n     */ ENCODED_VALS_BASE: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz\" + \"0123456789\",\n    /**\r\n     * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\r\n     */ get ENCODED_VALS () {\n        return this.ENCODED_VALS_BASE + \"+/=\";\n    },\n    /**\r\n     * Our websafe alphabet.\r\n     */ get ENCODED_VALS_WEBSAFE () {\n        return this.ENCODED_VALS_BASE + \"-_.\";\n    },\n    /**\r\n     * Whether this browser supports the atob and btoa functions. This extension\r\n     * started at Mozilla but is now implemented by many browsers. We use the\r\n     * ASSUME_* variables to avoid pulling in the full useragent detection library\r\n     * but still allowing the standard per-browser compilations.\r\n     *\r\n     */ HAS_NATIVE_SUPPORT: typeof atob === \"function\",\n    /**\r\n     * Base64-encode an array of bytes.\r\n     *\r\n     * @param input An array of bytes (numbers with\r\n     *     value in [0, 255]) to encode.\r\n     * @param webSafe Boolean indicating we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */ encodeByteArray (input, webSafe) {\n        if (!Array.isArray(input)) {\n            throw Error(\"encodeByteArray takes an array as a parameter\");\n        }\n        this.init_();\n        const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;\n        const output = [];\n        for(let i = 0; i < input.length; i += 3){\n            const byte1 = input[i];\n            const haveByte2 = i + 1 < input.length;\n            const byte2 = haveByte2 ? input[i + 1] : 0;\n            const haveByte3 = i + 2 < input.length;\n            const byte3 = haveByte3 ? input[i + 2] : 0;\n            const outByte1 = byte1 >> 2;\n            const outByte2 = (byte1 & 0x03) << 4 | byte2 >> 4;\n            let outByte3 = (byte2 & 0x0f) << 2 | byte3 >> 6;\n            let outByte4 = byte3 & 0x3f;\n            if (!haveByte3) {\n                outByte4 = 64;\n                if (!haveByte2) {\n                    outByte3 = 64;\n                }\n            }\n            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n        }\n        return output.join(\"\");\n    },\n    /**\r\n     * Base64-encode a string.\r\n     *\r\n     * @param input A string to encode.\r\n     * @param webSafe If true, we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */ encodeString (input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return btoa(input);\n        }\n        return this.encodeByteArray(stringToByteArray$1(input), webSafe);\n    },\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * @param input to decode.\r\n     * @param webSafe True if we should use the\r\n     *     alternative alphabet.\r\n     * @return string representing the decoded value.\r\n     */ decodeString (input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return atob(input);\n        }\n        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\n    },\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * In base-64 decoding, groups of four characters are converted into three\r\n     * bytes.  If the encoder did not apply padding, the input length may not\r\n     * be a multiple of 4.\r\n     *\r\n     * In this case, the last group will have fewer than 4 characters, and\r\n     * padding will be inferred.  If the group has one or two characters, it decodes\r\n     * to one byte.  If the group has three characters, it decodes to two bytes.\r\n     *\r\n     * @param input Input to decode.\r\n     * @param webSafe True if we should use the web-safe alphabet.\r\n     * @return bytes representing the decoded value.\r\n     */ decodeStringToByteArray (input, webSafe) {\n        this.init_();\n        const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;\n        const output = [];\n        for(let i = 0; i < input.length;){\n            const byte1 = charToByteMap[input.charAt(i++)];\n            const haveByte2 = i < input.length;\n            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n            ++i;\n            const haveByte3 = i < input.length;\n            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            const haveByte4 = i < input.length;\n            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n                throw new DecodeBase64StringError();\n            }\n            const outByte1 = byte1 << 2 | byte2 >> 4;\n            output.push(outByte1);\n            if (byte3 !== 64) {\n                const outByte2 = byte2 << 4 & 0xf0 | byte3 >> 2;\n                output.push(outByte2);\n                if (byte4 !== 64) {\n                    const outByte3 = byte3 << 6 & 0xc0 | byte4;\n                    output.push(outByte3);\n                }\n            }\n        }\n        return output;\n    },\n    /**\r\n     * Lazy static initialization function. Called before\r\n     * accessing any of the static map variables.\r\n     * @private\r\n     */ init_ () {\n        if (!this.byteToCharMap_) {\n            this.byteToCharMap_ = {};\n            this.charToByteMap_ = {};\n            this.byteToCharMapWebSafe_ = {};\n            this.charToByteMapWebSafe_ = {};\n            // We want quick mappings back and forth, so we precompute two maps.\n            for(let i = 0; i < this.ENCODED_VALS.length; i++){\n                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n                this.charToByteMap_[this.byteToCharMap_[i]] = i;\n                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n                // Be forgiving when decoding and correctly decode both encodings.\n                if (i >= this.ENCODED_VALS_BASE.length) {\n                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n                }\n            }\n        }\n    }\n};\n/**\r\n * An error encountered while decoding base64 string.\r\n */ class DecodeBase64StringError extends Error {\n    constructor(){\n        super(...arguments);\n        this.name = \"DecodeBase64StringError\";\n    }\n}\n/**\r\n * URL-safe base64 encoding\r\n */ const base64Encode = function(str) {\n    const utf8Bytes = stringToByteArray$1(str);\n    return base64.encodeByteArray(utf8Bytes, true);\n};\n/**\r\n * URL-safe base64 encoding (without \".\" padding in the end).\r\n * e.g. Used in JSON Web Token (JWT) parts.\r\n */ const base64urlEncodeWithoutPadding = function(str) {\n    // Use base64url encoding and remove padding in the end (dot characters).\n    return base64Encode(str).replace(/\\./g, \"\");\n};\n/**\r\n * URL-safe base64 decoding\r\n *\r\n * NOTE: DO NOT use the global atob() function - it does NOT support the\r\n * base64Url variant encoding.\r\n *\r\n * @param str To be decoded\r\n * @return Decoded result, if possible\r\n */ const base64Decode = function(str) {\n    try {\n        return base64.decodeString(str, true);\n    } catch (e) {\n        console.error(\"base64Decode failed: \", e);\n    }\n    return null;\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Do a deep-copy of basic JavaScript Objects or Arrays.\r\n */ function deepCopy(value) {\n    return deepExtend(undefined, value);\n}\n/**\r\n * Copy properties from source to target (recursively allows extension\r\n * of Objects and Arrays).  Scalar values in the target are over-written.\r\n * If target is undefined, an object of the appropriate type will be created\r\n * (and returned).\r\n *\r\n * We recursively copy all child properties of plain Objects in the source- so\r\n * that namespace- like dictionaries are merged.\r\n *\r\n * Note that the target can be a function, in which case the properties in\r\n * the source Object are copied onto it as static properties of the Function.\r\n *\r\n * Note: we don't merge __proto__ to prevent prototype pollution\r\n */ function deepExtend(target, source) {\n    if (!(source instanceof Object)) {\n        return source;\n    }\n    switch(source.constructor){\n        case Date:\n            // Treat Dates like scalars; if the target date object had any child\n            // properties - they will be lost!\n            const dateValue = source;\n            return new Date(dateValue.getTime());\n        case Object:\n            if (target === undefined) {\n                target = {};\n            }\n            break;\n        case Array:\n            // Always copy the array source and overwrite the target.\n            target = [];\n            break;\n        default:\n            // Not a plain Object - treat it as a scalar.\n            return source;\n    }\n    for(const prop in source){\n        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202\n        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {\n            continue;\n        }\n        target[prop] = deepExtend(target[prop], source[prop]);\n    }\n    return target;\n}\nfunction isValidKey(key) {\n    return key !== \"__proto__\";\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Polyfill for `globalThis` object.\r\n * @returns the `globalThis` object for the given environment.\r\n * @public\r\n */ function getGlobal() {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    if (false) {}\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    throw new Error(\"Unable to locate global object.\");\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const getDefaultsFromGlobal = ()=>getGlobal().__FIREBASE_DEFAULTS__;\n/**\r\n * Attempt to read defaults from a JSON string provided to\r\n * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in\r\n * process(.)env(.)__FIREBASE_DEFAULTS_PATH__\r\n * The dots are in parens because certain compilers (Vite?) cannot\r\n * handle seeing that variable in comments.\r\n * See https://github.com/firebase/firebase-js-sdk/issues/6838\r\n */ const getDefaultsFromEnvVariable = ()=>{\n    if (typeof process === \"undefined\" || typeof process.env === \"undefined\") {\n        return;\n    }\n    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;\n    if (defaultsJsonString) {\n        return JSON.parse(defaultsJsonString);\n    }\n};\nconst getDefaultsFromCookie = ()=>{\n    if (typeof document === \"undefined\") {\n        return;\n    }\n    let match;\n    try {\n        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);\n    } catch (e) {\n        // Some environments such as Angular Universal SSR have a\n        // `document` object but error on accessing `document.cookie`.\n        return;\n    }\n    const decoded = match && base64Decode(match[1]);\n    return decoded && JSON.parse(decoded);\n};\n/**\r\n * Get the __FIREBASE_DEFAULTS__ object. It checks in order:\r\n * (1) if such an object exists as a property of `globalThis`\r\n * (2) if such an object was provided on a shell environment variable\r\n * (3) if such an object exists in a cookie\r\n * @public\r\n */ const getDefaults = ()=>{\n    try {\n        return getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie();\n    } catch (e) {\n        /**\r\n         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due\r\n         * to any environment case we have not accounted for. Log to\r\n         * info instead of swallowing so we can find these unknown cases\r\n         * and add paths for them if needed.\r\n         */ console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);\n        return;\n    }\n};\n/**\r\n * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available\r\n * @public\r\n */ const getDefaultEmulatorHost = (productName)=>{\n    var _a, _b;\n    return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName];\n};\n/**\r\n * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a pair of hostname and port like `[\"::1\", 4000]` if available\r\n * @public\r\n */ const getDefaultEmulatorHostnameAndPort = (productName)=>{\n    const host = getDefaultEmulatorHost(productName);\n    if (!host) {\n        return undefined;\n    }\n    const separatorIndex = host.lastIndexOf(\":\"); // Finding the last since IPv6 addr also has colons.\n    if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {\n        throw new Error(`Invalid host ${host} with no separate hostname and port!`);\n    }\n    // eslint-disable-next-line no-restricted-globals\n    const port = parseInt(host.substring(separatorIndex + 1), 10);\n    if (host[0] === \"[\") {\n        // Bracket-quoted `[ipv6addr]:port` => return \"ipv6addr\" (without brackets).\n        return [\n            host.substring(1, separatorIndex - 1),\n            port\n        ];\n    } else {\n        return [\n            host.substring(0, separatorIndex),\n            port\n        ];\n    }\n};\n/**\r\n * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.\r\n * @public\r\n */ const getDefaultAppConfig = ()=>{\n    var _a;\n    return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config;\n};\n/**\r\n * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties\r\n * prefixed by \"_\")\r\n * @public\r\n */ const getExperimentalSetting = (name)=>{\n    var _a;\n    return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`];\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class Deferred {\n    constructor(){\n        this.reject = ()=>{};\n        this.resolve = ()=>{};\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n    /**\r\n     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\r\n     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\r\n     * and returns a node-style callback which will resolve or reject the Deferred's promise.\r\n     */ wrapCallback(callback) {\n        return (error, value)=>{\n            if (error) {\n                this.reject(error);\n            } else {\n                this.resolve(value);\n            }\n            if (typeof callback === \"function\") {\n                // Attaching noop handler just in case developer wasn't expecting\n                // promises\n                this.promise.catch(()=>{});\n                // Some of our callbacks don't expect a value and our own tests\n                // assert that the parameter length is 1\n                if (callback.length === 1) {\n                    callback(error);\n                } else {\n                    callback(error, value);\n                }\n            }\n        };\n    }\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function createMockUserToken(token, projectId) {\n    if (token.uid) {\n        throw new Error('The \"uid\" field is no longer supported by mockUserToken. Please use \"sub\" instead for Firebase Auth User ID.');\n    }\n    // Unsecured JWTs use \"none\" as the algorithm.\n    const header = {\n        alg: \"none\",\n        type: \"JWT\"\n    };\n    const project = projectId || \"demo-project\";\n    const iat = token.iat || 0;\n    const sub = token.sub || token.user_id;\n    if (!sub) {\n        throw new Error(\"mockUserToken must contain 'sub' or 'user_id' field!\");\n    }\n    const payload = Object.assign({\n        // Set all required fields to decent defaults\n        iss: `https://securetoken.google.com/${project}`,\n        aud: project,\n        iat,\n        exp: iat + 3600,\n        auth_time: iat,\n        sub,\n        user_id: sub,\n        firebase: {\n            sign_in_provider: \"custom\",\n            identities: {}\n        }\n    }, token);\n    // Unsecured JWTs use the empty string as a signature.\n    const signature = \"\";\n    return [\n        base64urlEncodeWithoutPadding(JSON.stringify(header)),\n        base64urlEncodeWithoutPadding(JSON.stringify(payload)),\n        signature\n    ].join(\".\");\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns navigator.userAgent string or '' if it's not defined.\r\n * @return user agent string\r\n */ function getUA() {\n    if (typeof navigator !== \"undefined\" && typeof navigator[\"userAgent\"] === \"string\") {\n        return navigator[\"userAgent\"];\n    } else {\n        return \"\";\n    }\n}\n/**\r\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\r\n *\r\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\r\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\r\n * wait for a callback.\r\n */ function isMobileCordova() {\n    return  false && 0;\n}\n/**\r\n * Detect Node.js.\r\n *\r\n * @return true if Node.js environment is detected or specified.\r\n */ // Node detection logic from: https://github.com/iliakan/detect-node/\nfunction isNode() {\n    var _a;\n    const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;\n    if (forceEnvironment === \"node\") {\n        return true;\n    } else if (forceEnvironment === \"browser\") {\n        return false;\n    }\n    try {\n        return Object.prototype.toString.call(global.process) === \"[object process]\";\n    } catch (e) {\n        return false;\n    }\n}\n/**\r\n * Detect Browser Environment\r\n */ function isBrowser() {\n    return typeof self === \"object\" && self.self === self;\n}\nfunction isBrowserExtension() {\n    const runtime = typeof chrome === \"object\" ? chrome.runtime : typeof browser === \"object\" ? browser.runtime : undefined;\n    return typeof runtime === \"object\" && runtime.id !== undefined;\n}\n/**\r\n * Detect React Native.\r\n *\r\n * @return true if ReactNative environment is detected.\r\n */ function isReactNative() {\n    return typeof navigator === \"object\" && navigator[\"product\"] === \"ReactNative\";\n}\n/** Detects Electron apps. */ function isElectron() {\n    return getUA().indexOf(\"Electron/\") >= 0;\n}\n/** Detects Internet Explorer. */ function isIE() {\n    const ua = getUA();\n    return ua.indexOf(\"MSIE \") >= 0 || ua.indexOf(\"Trident/\") >= 0;\n}\n/** Detects Universal Windows Platform apps. */ function isUWP() {\n    return getUA().indexOf(\"MSAppHost/\") >= 0;\n}\n/**\r\n * Detect whether the current SDK build is the Node version.\r\n *\r\n * @return true if it's the Node SDK build.\r\n */ function isNodeSdk() {\n    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\n}\n/** Returns true if we are running in Safari. */ function isSafari() {\n    return !isNode() && !!navigator.userAgent && navigator.userAgent.includes(\"Safari\") && !navigator.userAgent.includes(\"Chrome\");\n}\n/**\r\n * This method checks if indexedDB is supported by current browser/service worker context\r\n * @return true if indexedDB is supported by current browser/service worker context\r\n */ function isIndexedDBAvailable() {\n    try {\n        return typeof indexedDB === \"object\";\n    } catch (e) {\n        return false;\n    }\n}\n/**\r\n * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject\r\n * if errors occur during the database open operation.\r\n *\r\n * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox\r\n * private browsing)\r\n */ function validateIndexedDBOpenable() {\n    return new Promise((resolve, reject)=>{\n        try {\n            let preExist = true;\n            const DB_CHECK_NAME = \"validate-browser-context-for-indexeddb-analytics-module\";\n            const request = self.indexedDB.open(DB_CHECK_NAME);\n            request.onsuccess = ()=>{\n                request.result.close();\n                // delete database only when it doesn't pre-exist\n                if (!preExist) {\n                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);\n                }\n                resolve(true);\n            };\n            request.onupgradeneeded = ()=>{\n                preExist = false;\n            };\n            request.onerror = ()=>{\n                var _a;\n                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || \"\");\n            };\n        } catch (error) {\n            reject(error);\n        }\n    });\n}\n/**\r\n *\r\n * This method checks whether cookie is enabled within current browser\r\n * @return true if cookie is enabled within current browser\r\n */ function areCookiesEnabled() {\n    if (typeof navigator === \"undefined\" || !navigator.cookieEnabled) {\n        return false;\n    }\n    return true;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @fileoverview Standardized Firebase Error.\r\n *\r\n * Usage:\r\n *\r\n *   // Typescript string literals for type-safe codes\r\n *   type Err =\r\n *     'unknown' |\r\n *     'object-not-found'\r\n *     ;\r\n *\r\n *   // Closure enum for type-safe error codes\r\n *   // at-enum {string}\r\n *   var Err = {\r\n *     UNKNOWN: 'unknown',\r\n *     OBJECT_NOT_FOUND: 'object-not-found',\r\n *   }\r\n *\r\n *   let errors: Map<Err, string> = {\r\n *     'generic-error': \"Unknown error\",\r\n *     'file-not-found': \"Could not find file: {$file}\",\r\n *   };\r\n *\r\n *   // Type-safe function - must pass a valid error code as param.\r\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\r\n *\r\n *   ...\r\n *   throw error.create(Err.GENERIC);\r\n *   ...\r\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\r\n *   ...\r\n *   // Service: Could not file file: foo.txt (service/file-not-found).\r\n *\r\n *   catch (e) {\r\n *     assert(e.message === \"Could not find file: foo.txt.\");\r\n *     if ((e as FirebaseError)?.code === 'service/file-not-found') {\r\n *       console.log(\"Could not read file: \" + e['file']);\r\n *     }\r\n *   }\r\n */ const ERROR_NAME = \"FirebaseError\";\n// Based on code from:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\nclass FirebaseError extends Error {\n    constructor(/** The error code for this error. */ code, message, /** Custom data for this error. */ customData){\n        super(message);\n        this.code = code;\n        this.customData = customData;\n        /** The custom name for all FirebaseErrors. */ this.name = ERROR_NAME;\n        // Fix For ES5\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, FirebaseError.prototype);\n        // Maintains proper stack trace for where our error was thrown.\n        // Only available on V8.\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, ErrorFactory.prototype.create);\n        }\n    }\n}\nclass ErrorFactory {\n    constructor(service, serviceName, errors){\n        this.service = service;\n        this.serviceName = serviceName;\n        this.errors = errors;\n    }\n    create(code, ...data) {\n        const customData = data[0] || {};\n        const fullCode = `${this.service}/${code}`;\n        const template = this.errors[code];\n        const message = template ? replaceTemplate(template, customData) : \"Error\";\n        // Service Name: Error message (service/code).\n        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\n        const error = new FirebaseError(fullCode, fullMessage, customData);\n        return error;\n    }\n}\nfunction replaceTemplate(template, data) {\n    return template.replace(PATTERN, (_, key)=>{\n        const value = data[key];\n        return value != null ? String(value) : `<${key}?>`;\n    });\n}\nconst PATTERN = /\\{\\$([^}]+)}/g;\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Evaluates a JSON string into a javascript object.\r\n *\r\n * @param {string} str A string containing JSON.\r\n * @return {*} The javascript object representing the specified JSON.\r\n */ function jsonEval(str) {\n    return JSON.parse(str);\n}\n/**\r\n * Returns JSON representing a javascript object.\r\n * @param {*} data Javascript object to be stringified.\r\n * @return {string} The JSON contents of the object.\r\n */ function stringify(data) {\n    return JSON.stringify(data);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Decodes a Firebase auth. token into constituent parts.\r\n *\r\n * Notes:\r\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const decode = function(token) {\n    let header = {}, claims = {}, data = {}, signature = \"\";\n    try {\n        const parts = token.split(\".\");\n        header = jsonEval(base64Decode(parts[0]) || \"\");\n        claims = jsonEval(base64Decode(parts[1]) || \"\");\n        signature = parts[2];\n        data = claims[\"d\"] || {};\n        delete claims[\"d\"];\n    } catch (e) {}\n    return {\n        header,\n        claims,\n        data,\n        signature\n    };\n};\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\r\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const isValidTimestamp = function(token) {\n    const claims = decode(token).claims;\n    const now = Math.floor(new Date().getTime() / 1000);\n    let validSince = 0, validUntil = 0;\n    if (typeof claims === \"object\") {\n        if (claims.hasOwnProperty(\"nbf\")) {\n            validSince = claims[\"nbf\"];\n        } else if (claims.hasOwnProperty(\"iat\")) {\n            validSince = claims[\"iat\"];\n        }\n        if (claims.hasOwnProperty(\"exp\")) {\n            validUntil = claims[\"exp\"];\n        } else {\n            // token will expire after 24h by default\n            validUntil = validSince + 86400;\n        }\n    }\n    return !!now && !!validSince && !!validUntil && now >= validSince && now <= validUntil;\n};\n/**\r\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\r\n *\r\n * Notes:\r\n * - May return null if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const issuedAtTime = function(token) {\n    const claims = decode(token).claims;\n    if (typeof claims === \"object\" && claims.hasOwnProperty(\"iat\")) {\n        return claims[\"iat\"];\n    }\n    return null;\n};\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const isValidFormat = function(token) {\n    const decoded = decode(token), claims = decoded.claims;\n    return !!claims && typeof claims === \"object\" && claims.hasOwnProperty(\"iat\");\n};\n/**\r\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const isAdmin = function(token) {\n    const claims = decode(token).claims;\n    return typeof claims === \"object\" && claims[\"admin\"] === true;\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function contains(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction safeGet(obj, key) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        return obj[key];\n    } else {\n        return undefined;\n    }\n}\nfunction isEmpty(obj) {\n    for(const key in obj){\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction map(obj, fn, contextObj) {\n    const res = {};\n    for(const key in obj){\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            res[key] = fn.call(contextObj, obj[key], key, obj);\n        }\n    }\n    return res;\n}\n/**\r\n * Deep equal two objects. Support Arrays and Objects.\r\n */ function deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    for (const k of aKeys){\n        if (!bKeys.includes(k)) {\n            return false;\n        }\n        const aProp = a[k];\n        const bProp = b[k];\n        if (isObject(aProp) && isObject(bProp)) {\n            if (!deepEqual(aProp, bProp)) {\n                return false;\n            }\n        } else if (aProp !== bProp) {\n            return false;\n        }\n    }\n    for (const k of bKeys){\n        if (!aKeys.includes(k)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isObject(thing) {\n    return thing !== null && typeof thing === \"object\";\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Rejects if the given promise doesn't resolve in timeInMS milliseconds.\r\n * @internal\r\n */ function promiseWithTimeout(promise, timeInMS = 2000) {\n    const deferredPromise = new Deferred();\n    setTimeout(()=>deferredPromise.reject(\"timeout!\"), timeInMS);\n    promise.then(deferredPromise.resolve, deferredPromise.reject);\n    return deferredPromise.promise;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\r\n * params object (e.g. {arg: 'val', arg2: 'val2'})\r\n * Note: You must prepend it with ? when adding it to a URL.\r\n */ function querystring(querystringParams) {\n    const params = [];\n    for (const [key, value] of Object.entries(querystringParams)){\n        if (Array.isArray(value)) {\n            value.forEach((arrayVal)=>{\n                params.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(arrayVal));\n            });\n        } else {\n            params.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(value));\n        }\n    }\n    return params.length ? \"&\" + params.join(\"&\") : \"\";\n}\n/**\r\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\r\n * (e.g. {arg: 'val', arg2: 'val2'})\r\n */ function querystringDecode(querystring) {\n    const obj = {};\n    const tokens = querystring.replace(/^\\?/, \"\").split(\"&\");\n    tokens.forEach((token)=>{\n        if (token) {\n            const [key, value] = token.split(\"=\");\n            obj[decodeURIComponent(key)] = decodeURIComponent(value);\n        }\n    });\n    return obj;\n}\n/**\r\n * Extract the query string part of a URL, including the leading question mark (if present).\r\n */ function extractQuerystring(url) {\n    const queryStart = url.indexOf(\"?\");\n    if (!queryStart) {\n        return \"\";\n    }\n    const fragmentStart = url.indexOf(\"#\", queryStart);\n    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @fileoverview SHA-1 cryptographic hash.\r\n * Variable names follow the notation in FIPS PUB 180-3:\r\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\r\n *\r\n * Usage:\r\n *   var sha1 = new sha1();\r\n *   sha1.update(bytes);\r\n *   var hash = sha1.digest();\r\n *\r\n * Performance:\r\n *   Chrome 23:   ~400 Mbit/s\r\n *   Firefox 16:  ~250 Mbit/s\r\n *\r\n */ /**\r\n * SHA-1 cryptographic hash constructor.\r\n *\r\n * The properties declared here are discussed in the above algorithm document.\r\n * @constructor\r\n * @final\r\n * @struct\r\n */ class Sha1 {\n    constructor(){\n        /**\r\n         * Holds the previous values of accumulated variables a-e in the compress_\r\n         * function.\r\n         * @private\r\n         */ this.chain_ = [];\n        /**\r\n         * A buffer holding the partially computed hash result.\r\n         * @private\r\n         */ this.buf_ = [];\n        /**\r\n         * An array of 80 bytes, each a part of the message to be hashed.  Referred to\r\n         * as the message schedule in the docs.\r\n         * @private\r\n         */ this.W_ = [];\n        /**\r\n         * Contains data needed to pad messages less than 64 bytes.\r\n         * @private\r\n         */ this.pad_ = [];\n        /**\r\n         * @private {number}\r\n         */ this.inbuf_ = 0;\n        /**\r\n         * @private {number}\r\n         */ this.total_ = 0;\n        this.blockSize = 512 / 8;\n        this.pad_[0] = 128;\n        for(let i = 1; i < this.blockSize; ++i){\n            this.pad_[i] = 0;\n        }\n        this.reset();\n    }\n    reset() {\n        this.chain_[0] = 0x67452301;\n        this.chain_[1] = 0xefcdab89;\n        this.chain_[2] = 0x98badcfe;\n        this.chain_[3] = 0x10325476;\n        this.chain_[4] = 0xc3d2e1f0;\n        this.inbuf_ = 0;\n        this.total_ = 0;\n    }\n    /**\r\n     * Internal compress helper function.\r\n     * @param buf Block to compress.\r\n     * @param offset Offset of the block in the buffer.\r\n     * @private\r\n     */ compress_(buf, offset) {\n        if (!offset) {\n            offset = 0;\n        }\n        const W = this.W_;\n        // get 16 big endian words\n        if (typeof buf === \"string\") {\n            for(let i = 0; i < 16; i++){\n                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\n                // have a bug that turns the post-increment ++ operator into pre-increment\n                // during JIT compilation.  We have code that depends heavily on SHA-1 for\n                // correctness and which is affected by this bug, so I've removed all uses\n                // of post-increment ++ in which the result value is used.  We can revert\n                // this change once the Safari bug\n                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\n                // most clients have been updated.\n                W[i] = buf.charCodeAt(offset) << 24 | buf.charCodeAt(offset + 1) << 16 | buf.charCodeAt(offset + 2) << 8 | buf.charCodeAt(offset + 3);\n                offset += 4;\n            }\n        } else {\n            for(let i = 0; i < 16; i++){\n                W[i] = buf[offset] << 24 | buf[offset + 1] << 16 | buf[offset + 2] << 8 | buf[offset + 3];\n                offset += 4;\n            }\n        }\n        // expand to 80 words\n        for(let i = 16; i < 80; i++){\n            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n            W[i] = (t << 1 | t >>> 31) & 0xffffffff;\n        }\n        let a = this.chain_[0];\n        let b = this.chain_[1];\n        let c = this.chain_[2];\n        let d = this.chain_[3];\n        let e = this.chain_[4];\n        let f, k;\n        // TODO(user): Try to unroll this loop to speed up the computation.\n        for(let i = 0; i < 80; i++){\n            if (i < 40) {\n                if (i < 20) {\n                    f = d ^ b & (c ^ d);\n                    k = 0x5a827999;\n                } else {\n                    f = b ^ c ^ d;\n                    k = 0x6ed9eba1;\n                }\n            } else {\n                if (i < 60) {\n                    f = b & c | d & (b | c);\n                    k = 0x8f1bbcdc;\n                } else {\n                    f = b ^ c ^ d;\n                    k = 0xca62c1d6;\n                }\n            }\n            const t = (a << 5 | a >>> 27) + f + e + k + W[i] & 0xffffffff;\n            e = d;\n            d = c;\n            c = (b << 30 | b >>> 2) & 0xffffffff;\n            b = a;\n            a = t;\n        }\n        this.chain_[0] = this.chain_[0] + a & 0xffffffff;\n        this.chain_[1] = this.chain_[1] + b & 0xffffffff;\n        this.chain_[2] = this.chain_[2] + c & 0xffffffff;\n        this.chain_[3] = this.chain_[3] + d & 0xffffffff;\n        this.chain_[4] = this.chain_[4] + e & 0xffffffff;\n    }\n    update(bytes, length) {\n        // TODO(johnlenz): tighten the function signature and remove this check\n        if (bytes == null) {\n            return;\n        }\n        if (length === undefined) {\n            length = bytes.length;\n        }\n        const lengthMinusBlock = length - this.blockSize;\n        let n = 0;\n        // Using local instead of member variables gives ~5% speedup on Firefox 16.\n        const buf = this.buf_;\n        let inbuf = this.inbuf_;\n        // The outer while loop should execute at most twice.\n        while(n < length){\n            // When we have no data in the block to top up, we can directly process the\n            // input buffer (assuming it contains sufficient data). This gives ~25%\n            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\n            // the data is provided in large chunks (or in multiples of 64 bytes).\n            if (inbuf === 0) {\n                while(n <= lengthMinusBlock){\n                    this.compress_(bytes, n);\n                    n += this.blockSize;\n                }\n            }\n            if (typeof bytes === \"string\") {\n                while(n < length){\n                    buf[inbuf] = bytes.charCodeAt(n);\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        break;\n                    }\n                }\n            } else {\n                while(n < length){\n                    buf[inbuf] = bytes[n];\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        this.inbuf_ = inbuf;\n        this.total_ += length;\n    }\n    /** @override */ digest() {\n        const digest = [];\n        let totalBits = this.total_ * 8;\n        // Add pad 0x80 0x00*.\n        if (this.inbuf_ < 56) {\n            this.update(this.pad_, 56 - this.inbuf_);\n        } else {\n            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\n        }\n        // Add # bits.\n        for(let i = this.blockSize - 1; i >= 56; i--){\n            this.buf_[i] = totalBits & 255;\n            totalBits /= 256; // Don't use bit-shifting here!\n        }\n        this.compress_(this.buf_);\n        let n = 0;\n        for(let i = 0; i < 5; i++){\n            for(let j = 24; j >= 0; j -= 8){\n                digest[n] = this.chain_[i] >> j & 255;\n                ++n;\n            }\n        }\n        return digest;\n    }\n}\n/**\r\n * Helper to make a Subscribe function (just like Promise helps make a\r\n * Thenable).\r\n *\r\n * @param executor Function which can make calls to a single Observer\r\n *     as a proxy.\r\n * @param onNoObservers Callback when count of Observers goes to zero.\r\n */ function createSubscribe(executor, onNoObservers) {\n    const proxy = new ObserverProxy(executor, onNoObservers);\n    return proxy.subscribe.bind(proxy);\n}\n/**\r\n * Implement fan-out for any number of Observers attached via a subscribe\r\n * function.\r\n */ class ObserverProxy {\n    /**\r\n     * @param executor Function which can make calls to a single Observer\r\n     *     as a proxy.\r\n     * @param onNoObservers Callback when count of Observers goes to zero.\r\n     */ constructor(executor, onNoObservers){\n        this.observers = [];\n        this.unsubscribes = [];\n        this.observerCount = 0;\n        // Micro-task scheduling by calling task.then().\n        this.task = Promise.resolve();\n        this.finalized = false;\n        this.onNoObservers = onNoObservers;\n        // Call the executor asynchronously so subscribers that are called\n        // synchronously after the creation of the subscribe function\n        // can still receive the very first value generated in the executor.\n        this.task.then(()=>{\n            executor(this);\n        }).catch((e)=>{\n            this.error(e);\n        });\n    }\n    next(value) {\n        this.forEachObserver((observer)=>{\n            observer.next(value);\n        });\n    }\n    error(error) {\n        this.forEachObserver((observer)=>{\n            observer.error(error);\n        });\n        this.close(error);\n    }\n    complete() {\n        this.forEachObserver((observer)=>{\n            observer.complete();\n        });\n        this.close();\n    }\n    /**\r\n     * Subscribe function that can be used to add an Observer to the fan-out list.\r\n     *\r\n     * - We require that no event is sent to a subscriber sychronously to their\r\n     *   call to subscribe().\r\n     */ subscribe(nextOrObserver, error, complete) {\n        let observer;\n        if (nextOrObserver === undefined && error === undefined && complete === undefined) {\n            throw new Error(\"Missing Observer.\");\n        }\n        // Assemble an Observer object when passed as callback functions.\n        if (implementsAnyMethods(nextOrObserver, [\n            \"next\",\n            \"error\",\n            \"complete\"\n        ])) {\n            observer = nextOrObserver;\n        } else {\n            observer = {\n                next: nextOrObserver,\n                error,\n                complete\n            };\n        }\n        if (observer.next === undefined) {\n            observer.next = noop;\n        }\n        if (observer.error === undefined) {\n            observer.error = noop;\n        }\n        if (observer.complete === undefined) {\n            observer.complete = noop;\n        }\n        const unsub = this.unsubscribeOne.bind(this, this.observers.length);\n        // Attempt to subscribe to a terminated Observable - we\n        // just respond to the Observer with the final error or complete\n        // event.\n        if (this.finalized) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.task.then(()=>{\n                try {\n                    if (this.finalError) {\n                        observer.error(this.finalError);\n                    } else {\n                        observer.complete();\n                    }\n                } catch (e) {\n                // nothing\n                }\n                return;\n            });\n        }\n        this.observers.push(observer);\n        return unsub;\n    }\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\n    // any unsubscribed Observer.\n    unsubscribeOne(i) {\n        if (this.observers === undefined || this.observers[i] === undefined) {\n            return;\n        }\n        delete this.observers[i];\n        this.observerCount -= 1;\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n            this.onNoObservers(this);\n        }\n    }\n    forEachObserver(fn) {\n        if (this.finalized) {\n            // Already closed by previous event....just eat the additional values.\n            return;\n        }\n        // Since sendOne calls asynchronously - there is no chance that\n        // this.observers will become undefined.\n        for(let i = 0; i < this.observers.length; i++){\n            this.sendOne(i, fn);\n        }\n    }\n    // Call the Observer via one of it's callback function. We are careful to\n    // confirm that the observe has not been unsubscribed since this asynchronous\n    // function had been queued.\n    sendOne(i, fn) {\n        // Execute the callback asynchronously\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(()=>{\n            if (this.observers !== undefined && this.observers[i] !== undefined) {\n                try {\n                    fn(this.observers[i]);\n                } catch (e) {\n                    // Ignore exceptions raised in Observers or missing methods of an\n                    // Observer.\n                    // Log error to console. b/31404806\n                    if (typeof console !== \"undefined\" && console.error) {\n                        console.error(e);\n                    }\n                }\n            }\n        });\n    }\n    close(err) {\n        if (this.finalized) {\n            return;\n        }\n        this.finalized = true;\n        if (err !== undefined) {\n            this.finalError = err;\n        }\n        // Proxy is no longer needed - garbage collect references\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(()=>{\n            this.observers = undefined;\n            this.onNoObservers = undefined;\n        });\n    }\n}\n/** Turn synchronous function into one called asynchronously. */ // eslint-disable-next-line @typescript-eslint/ban-types\nfunction async(fn, onError) {\n    return (...args)=>{\n        Promise.resolve(true).then(()=>{\n            fn(...args);\n        }).catch((error)=>{\n            if (onError) {\n                onError(error);\n            }\n        });\n    };\n}\n/**\r\n * Return true if the object passed in implements any of the named methods.\r\n */ function implementsAnyMethods(obj, methods) {\n    if (typeof obj !== \"object\" || obj === null) {\n        return false;\n    }\n    for (const method of methods){\n        if (method in obj && typeof obj[method] === \"function\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction noop() {\n// do nothing\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Check to make sure the appropriate number of arguments are provided for a public function.\r\n * Throws an error if it fails.\r\n *\r\n * @param fnName The function name\r\n * @param minCount The minimum number of arguments to allow for the function call\r\n * @param maxCount The maximum number of argument to allow for the function call\r\n * @param argCount The actual number of arguments provided.\r\n */ const validateArgCount = function(fnName, minCount, maxCount, argCount) {\n    let argError;\n    if (argCount < minCount) {\n        argError = \"at least \" + minCount;\n    } else if (argCount > maxCount) {\n        argError = maxCount === 0 ? \"none\" : \"no more than \" + maxCount;\n    }\n    if (argError) {\n        const error = fnName + \" failed: Was called with \" + argCount + (argCount === 1 ? \" argument.\" : \" arguments.\") + \" Expects \" + argError + \".\";\n        throw new Error(error);\n    }\n};\n/**\r\n * Generates a string to prefix an error message about failed argument validation\r\n *\r\n * @param fnName The function name\r\n * @param argName The name of the argument\r\n * @return The prefix to add to the error thrown for validation.\r\n */ function errorPrefix(fnName, argName) {\n    return `${fnName} failed: ${argName} argument `;\n}\n/**\r\n * @param fnName\r\n * @param argumentNumber\r\n * @param namespace\r\n * @param optional\r\n */ function validateNamespace(fnName, namespace, optional) {\n    if (optional && !namespace) {\n        return;\n    }\n    if (typeof namespace !== \"string\") {\n        //TODO: I should do more validation here. We only allow certain chars in namespaces.\n        throw new Error(errorPrefix(fnName, \"namespace\") + \"must be a valid firebase namespace.\");\n    }\n}\nfunction validateCallback(fnName, argumentName, // eslint-disable-next-line @typescript-eslint/ban-types\ncallback, optional) {\n    if (optional && !callback) {\n        return;\n    }\n    if (typeof callback !== \"function\") {\n        throw new Error(errorPrefix(fnName, argumentName) + \"must be a valid function.\");\n    }\n}\nfunction validateContextObject(fnName, argumentName, context, optional) {\n    if (optional && !context) {\n        return;\n    }\n    if (typeof context !== \"object\" || context === null) {\n        throw new Error(errorPrefix(fnName, argumentName) + \"must be a valid context object.\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\n// so it's been modified.\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\n// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\n// pair).\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\n/**\r\n * @param {string} str\r\n * @return {Array}\r\n */ const stringToByteArray = function(str) {\n    const out = [];\n    let p = 0;\n    for(let i = 0; i < str.length; i++){\n        let c = str.charCodeAt(i);\n        // Is this the lead surrogate in a surrogate pair?\n        if (c >= 0xd800 && c <= 0xdbff) {\n            const high = c - 0xd800; // the high 10 bits.\n            i++;\n            assert(i < str.length, \"Surrogate pair missing trail surrogate.\");\n            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\n            c = 0x10000 + (high << 10) + low;\n        }\n        if (c < 128) {\n            out[p++] = c;\n        } else if (c < 2048) {\n            out[p++] = c >> 6 | 192;\n            out[p++] = c & 63 | 128;\n        } else if (c < 65536) {\n            out[p++] = c >> 12 | 224;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        } else {\n            out[p++] = c >> 18 | 240;\n            out[p++] = c >> 12 & 63 | 128;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        }\n    }\n    return out;\n};\n/**\r\n * Calculate length without actually converting; useful for doing cheaper validation.\r\n * @param {string} str\r\n * @return {number}\r\n */ const stringLength = function(str) {\n    let p = 0;\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        if (c < 128) {\n            p++;\n        } else if (c < 2048) {\n            p += 2;\n        } else if (c >= 0xd800 && c <= 0xdbff) {\n            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\n            p += 4;\n            i++; // skip trail surrogate.\n        } else {\n            p += 3;\n        }\n    }\n    return p;\n};\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Copied from https://stackoverflow.com/a/2117523\r\n * Generates a new uuid.\r\n * @public\r\n */ const uuidv4 = function() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n        const r = Math.random() * 16 | 0, v = c === \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n};\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The amount of milliseconds to exponentially increase.\r\n */ const DEFAULT_INTERVAL_MILLIS = 1000;\n/**\r\n * The factor to backoff by.\r\n * Should be a number greater than 1.\r\n */ const DEFAULT_BACKOFF_FACTOR = 2;\n/**\r\n * The maximum milliseconds to increase to.\r\n *\r\n * <p>Visible for testing\r\n */ const MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.\n/**\r\n * The percentage of backoff time to randomize by.\r\n * See\r\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\r\n * for context.\r\n *\r\n * <p>Visible for testing\r\n */ const RANDOM_FACTOR = 0.5;\n/**\r\n * Based on the backoff method from\r\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\r\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\r\n */ function calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {\n    // Calculates an exponentially increasing value.\n    // Deviation: calculates value from count and a constant interval, so we only need to save value\n    // and count to restore state.\n    const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);\n    // A random \"fuzz\" to avoid waves of retries.\n    // Deviation: randomFactor is required.\n    const randomWait = Math.round(// A fraction of the backoff value to add/subtract.\n    // Deviation: changes multiplication order to improve readability.\n    RANDOM_FACTOR * currBaseValue * // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\n    // if we add or subtract.\n    (Math.random() - 0.5) * 2);\n    // Limits backoff to max to avoid effectively permanent backoff.\n    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provide English ordinal letters after a number\r\n */ function ordinal(i) {\n    if (!Number.isFinite(i)) {\n        return `${i}`;\n    }\n    return i + indicator(i);\n}\nfunction indicator(i) {\n    i = Math.abs(i);\n    const cent = i % 100;\n    if (cent >= 10 && cent <= 20) {\n        return \"th\";\n    }\n    const dec = i % 10;\n    if (dec === 1) {\n        return \"st\";\n    }\n    if (dec === 2) {\n        return \"nd\";\n    }\n    if (dec === 3) {\n        return \"rd\";\n    }\n    return \"th\";\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function getModularInstance(service) {\n    if (service && service._delegate) {\n        return service._delegate;\n    } else {\n        return service;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Overriding the constant (we should be the only ones doing this)\nCONSTANTS.NODE_CLIENT = true;\n //# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Q0FFQyxHQUNELE1BQU1BLFlBQVk7SUFDZDs7S0FFQyxHQUNEQyxhQUFhO0lBQ2I7O0tBRUMsR0FDREMsWUFBWTtJQUNaOztLQUVDLEdBQ0RDLGFBQWE7QUFDakI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Q0FFQyxHQUNELE1BQU1DLFNBQVMsU0FBVUMsU0FBUyxFQUFFQyxPQUFPO0lBQ3ZDLElBQUksQ0FBQ0QsV0FBVztRQUNaLE1BQU1FLGVBQWVEO0lBQ3pCO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU1DLGlCQUFpQixTQUFVRCxPQUFPO0lBQ3BDLE9BQU8sSUFBSUUsTUFBTSx3QkFDYlIsVUFBVUcsV0FBVyxHQUNyQiwrQkFDQUc7QUFDUjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELE1BQU1HLHNCQUFzQixTQUFVQyxHQUFHO0lBQ3JDLDJEQUEyRDtJQUMzRCxNQUFNQyxNQUFNLEVBQUU7SUFDZCxJQUFJQyxJQUFJO0lBQ1IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILElBQUlJLE1BQU0sRUFBRUQsSUFBSztRQUNqQyxJQUFJRSxJQUFJTCxJQUFJTSxVQUFVLENBQUNIO1FBQ3ZCLElBQUlFLElBQUksS0FBSztZQUNUSixHQUFHLENBQUNDLElBQUksR0FBR0c7UUFDZixPQUNLLElBQUlBLElBQUksTUFBTTtZQUNmSixHQUFHLENBQUNDLElBQUksR0FBRyxLQUFNLElBQUs7WUFDdEJELEdBQUcsQ0FBQ0MsSUFBSSxHQUFHLElBQUssS0FBTTtRQUMxQixPQUNLLElBQUksQ0FBQ0csSUFBSSxNQUFLLE1BQU8sVUFD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QVM7SUFDNUIsT0FDSztRQUNELE9BQU85SjtJQUNYO0FBQ0o7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxrRUFBa0U7QUFDbEUxTSxVQUFVQyxXQUFXLEdBQUc7QUFFbzhCLENBQzU5QiwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcz85ZTdkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IEZpcmViYXNlIGNvbnN0YW50cy4gIFNvbWUgb2YgdGhlc2UgKEBkZWZpbmVzKSBjYW4gYmUgb3ZlcnJpZGRlbiBhdCBjb21waWxlLXRpbWUuXHJcbiAqL1xyXG5jb25zdCBDT05TVEFOVFMgPSB7XHJcbiAgICAvKipcclxuICAgICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBpcyB0aGUgY2xpZW50IE5vZGUuanMgU0RLLlxyXG4gICAgICovXHJcbiAgICBOT0RFX0NMSUVOVDogZmFsc2UsXHJcbiAgICAvKipcclxuICAgICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBpcyB0aGUgQWRtaW4gTm9kZS5qcyBTREsuXHJcbiAgICAgKi9cclxuICAgIE5PREVfQURNSU46IGZhbHNlLFxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlYmFzZSBTREsgVmVyc2lvblxyXG4gICAgICovXHJcbiAgICBTREtfVkVSU0lPTjogJyR7SlNDT1JFX1ZFUlNJT059J1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBwcm92aWRlZCBhc3NlcnRpb24gaXMgZmFsc3lcclxuICovXHJcbmNvbnN0IGFzc2VydCA9IGZ1bmN0aW9uIChhc3NlcnRpb24sIG1lc3NhZ2UpIHtcclxuICAgIGlmICghYXNzZXJ0aW9uKSB7XHJcbiAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IobWVzc2FnZSk7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIEVycm9yIG9iamVjdCBzdWl0YWJsZSBmb3IgdGhyb3dpbmcuXHJcbiAqL1xyXG5jb25zdCBhc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gbmV3IEVycm9yKCdGaXJlYmFzZSBEYXRhYmFzZSAoJyArXHJcbiAgICAgICAgQ09OU1RBTlRTLlNES19WRVJTSU9OICtcclxuICAgICAgICAnKSBJTlRFUk5BTCBBU1NFUlQgRkFJTEVEOiAnICtcclxuICAgICAgICBtZXNzYWdlKTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3Qgc3RyaW5nVG9CeXRlQXJyYXkkMSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIC8vIFRPRE8odXNlcik6IFVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb25zIGlmL3doZW4gYXZhaWxhYmxlXHJcbiAgICBjb25zdCBvdXQgPSBbXTtcclxuICAgIGxldCBwID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYyA8IDEyOCkge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmXHJcbiAgICAgICAgICAgIGkgKyAxIDwgc3RyLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAoc3RyLmNoYXJDb2RlQXQoaSArIDEpICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XHJcbiAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXHJcbiAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4MDNmZik7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTgpIHwgMjQwO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiAxMikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcbi8qKlxyXG4gKiBUdXJucyBhbiBhcnJheSBvZiBudW1iZXJzIGludG8gdGhlIHN0cmluZyBnaXZlbiBieSB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGVcclxuICogY2hhcmFjdGVycyB0byB3aGljaCB0aGUgbnVtYmVycyBjb3JyZXNwb25kLlxyXG4gKiBAcGFyYW0gYnl0ZXMgQXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgY2hhcmFjdGVycy5cclxuICogQHJldHVybiBTdHJpbmdpZmljYXRpb24gb2YgdGhlIGFycmF5LlxyXG4gKi9cclxuY29uc3QgYnl0ZUFycmF5VG9TdHJpbmcgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcclxuICAgIC8vIFRPRE8odXNlcik6IFVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb25zIGlmL3doZW4gYXZhaWxhYmxlXHJcbiAgICBjb25zdCBvdXQgPSBbXTtcclxuICAgIGxldCBwb3MgPSAwLCBjID0gMDtcclxuICAgIHdoaWxlIChwb3MgPCBieXRlcy5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBjMSA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICBpZiAoYzEgPCAxMjgpIHtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYzEgPiAxOTEgJiYgYzEgPCAyMjQpIHtcclxuICAgICAgICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMxICYgMzEpIDw8IDYpIHwgKGMyICYgNjMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYzEgPiAyMzkgJiYgYzEgPCAzNjUpIHtcclxuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcclxuICAgICAgICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIGNvbnN0IGMzID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBjb25zdCBjNCA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgY29uc3QgdSA9ICgoKGMxICYgNykgPDwgMTgpIHwgKChjMiAmIDYzKSA8PCAxMikgfCAoKGMzICYgNjMpIDw8IDYpIHwgKGM0ICYgNjMpKSAtXHJcbiAgICAgICAgICAgICAgICAweDEwMDAwO1xyXG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODAwICsgKHUgPj4gMTApKTtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZGMwMCArICh1ICYgMTAyMykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIGNvbnN0IGMzID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjMSAmIDE1KSA8PCAxMikgfCAoKGMyICYgNjMpIDw8IDYpIHwgKGMzICYgNjMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xyXG59O1xyXG4vLyBXZSBkZWZpbmUgaXQgYXMgYW4gb2JqZWN0IGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNsYXNzIGJlY2F1c2UgYSBjbGFzcyBjb21waWxlZCBkb3duIHRvIGVzNSBjYW4ndFxyXG4vLyBiZSB0cmVlc2hha2VkLiBodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cC9pc3N1ZXMvMTY5MVxyXG4vLyBTdGF0aWMgbG9va3VwIG1hcHMsIGxhemlseSBwb3B1bGF0ZWQgYnkgaW5pdF8oKVxyXG5jb25zdCBiYXNlNjQgPSB7XHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYnl0ZXMgdG8gY2hhcmFjdGVycy5cclxuICAgICAqL1xyXG4gICAgYnl0ZVRvQ2hhck1hcF86IG51bGwsXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgY2hhcmFjdGVycyB0byBieXRlcy5cclxuICAgICAqL1xyXG4gICAgY2hhclRvQnl0ZU1hcF86IG51bGwsXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYnl0ZXMgdG8gd2Vic2FmZSBjaGFyYWN0ZXJzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgYnl0ZVRvQ2hhck1hcFdlYlNhZmVfOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIHdlYnNhZmUgY2hhcmFjdGVycyB0byBieXRlcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNoYXJUb0J5dGVNYXBXZWJTYWZlXzogbnVsbCxcclxuICAgIC8qKlxyXG4gICAgICogT3VyIGRlZmF1bHQgYWxwaGFiZXQsIHNoYXJlZCBiZXR3ZWVuXHJcbiAgICAgKiBFTkNPREVEX1ZBTFMgYW5kIEVOQ09ERURfVkFMU19XRUJTQUZFXHJcbiAgICAgKi9cclxuICAgIEVOQ09ERURfVkFMU19CQVNFOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonICsgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyArICcwMTIzNDU2Nzg5JyxcclxuICAgIC8qKlxyXG4gICAgICogT3VyIGRlZmF1bHQgYWxwaGFiZXQuIFZhbHVlIDY0ICg9KSBpcyBzcGVjaWFsOyBpdCBtZWFucyBcIm5vdGhpbmcuXCJcclxuICAgICAqL1xyXG4gICAgZ2V0IEVOQ09ERURfVkFMUygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRSArICcrLz0nO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogT3VyIHdlYnNhZmUgYWxwaGFiZXQuXHJcbiAgICAgKi9cclxuICAgIGdldCBFTkNPREVEX1ZBTFNfV0VCU0FGRSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRSArICctXy4nO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgdGhlIGF0b2IgYW5kIGJ0b2EgZnVuY3Rpb25zLiBUaGlzIGV4dGVuc2lvblxyXG4gICAgICogc3RhcnRlZCBhdCBNb3ppbGxhIGJ1dCBpcyBub3cgaW1wbGVtZW50ZWQgYnkgbWFueSBicm93c2Vycy4gV2UgdXNlIHRoZVxyXG4gICAgICogQVNTVU1FXyogdmFyaWFibGVzIHRvIGF2b2lkIHB1bGxpbmcgaW4gdGhlIGZ1bGwgdXNlcmFnZW50IGRldGVjdGlvbiBsaWJyYXJ5XHJcbiAgICAgKiBidXQgc3RpbGwgYWxsb3dpbmcgdGhlIHN0YW5kYXJkIHBlci1icm93c2VyIGNvbXBpbGF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIEhBU19OQVRJVkVfU1VQUE9SVDogdHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbicsXHJcbiAgICAvKipcclxuICAgICAqIEJhc2U2NC1lbmNvZGUgYW4gYXJyYXkgb2YgYnl0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlucHV0IEFuIGFycmF5IG9mIGJ5dGVzIChudW1iZXJzIHdpdGhcclxuICAgICAqICAgICB2YWx1ZSBpbiBbMCwgMjU1XSkgdG8gZW5jb2RlLlxyXG4gICAgICogQHBhcmFtIHdlYlNhZmUgQm9vbGVhbiBpbmRpY2F0aW5nIHdlIHNob3VsZCB1c2UgdGhlXHJcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGVuY29kZUJ5dGVBcnJheShpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ2VuY29kZUJ5dGVBcnJheSB0YWtlcyBhbiBhcnJheSBhcyBhIHBhcmFtZXRlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmluaXRfKCk7XHJcbiAgICAgICAgY29uc3QgYnl0ZVRvQ2hhck1hcCA9IHdlYlNhZmVcclxuICAgICAgICAgICAgPyB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1xyXG4gICAgICAgICAgICA6IHRoaXMuYnl0ZVRvQ2hhck1hcF87XHJcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICAgICAgICBjb25zdCBieXRlMSA9IGlucHV0W2ldO1xyXG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTIgPSBpICsgMSA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTIgPSBoYXZlQnl0ZTIgPyBpbnB1dFtpICsgMV0gOiAwO1xyXG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTMgPSBpICsgMiA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBpbnB1dFtpICsgMl0gOiAwO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRCeXRlMSA9IGJ5dGUxID4+IDI7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMSAmIDB4MDMpIDw8IDQpIHwgKGJ5dGUyID4+IDQpO1xyXG4gICAgICAgICAgICBsZXQgb3V0Qnl0ZTMgPSAoKGJ5dGUyICYgMHgwZikgPDwgMikgfCAoYnl0ZTMgPj4gNik7XHJcbiAgICAgICAgICAgIGxldCBvdXRCeXRlNCA9IGJ5dGUzICYgMHgzZjtcclxuICAgICAgICAgICAgaWYgKCFoYXZlQnl0ZTMpIHtcclxuICAgICAgICAgICAgICAgIG91dEJ5dGU0ID0gNjQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhdmVCeXRlMikge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dEJ5dGUzID0gNjQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0cHV0LnB1c2goYnl0ZVRvQ2hhck1hcFtvdXRCeXRlMV0sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTJdLCBieXRlVG9DaGFyTWFwW291dEJ5dGUzXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlNF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQmFzZTY0LWVuY29kZSBhIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgQSBzdHJpbmcgdG8gZW5jb2RlLlxyXG4gICAgICogQHBhcmFtIHdlYlNhZmUgSWYgdHJ1ZSwgd2Ugc2hvdWxkIHVzZSB0aGVcclxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cclxuICAgICAqIEByZXR1cm4gVGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgZW5jb2RlU3RyaW5nKGlucHV0LCB3ZWJTYWZlKSB7XHJcbiAgICAgICAgLy8gU2hvcnRjdXQgZm9yIE1vemlsbGEgYnJvd3NlcnMgdGhhdCBpbXBsZW1lbnRcclxuICAgICAgICAvLyBhIG5hdGl2ZSBiYXNlNjQgZW5jb2RlciBpbiB0aGUgZm9ybSBvZiBcImJ0b2EvYXRvYlwiXHJcbiAgICAgICAgaWYgKHRoaXMuSEFTX05BVElWRV9TVVBQT1JUICYmICF3ZWJTYWZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBidG9hKGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlQnl0ZUFycmF5KHN0cmluZ1RvQnl0ZUFycmF5JDEoaW5wdXQpLCB3ZWJTYWZlKTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlucHV0IHRvIGRlY29kZS5cclxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIFRydWUgaWYgd2Ugc2hvdWxkIHVzZSB0aGVcclxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cclxuICAgICAqIEByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZGVjb2RlZCB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgZGVjb2RlU3RyaW5nKGlucHV0LCB3ZWJTYWZlKSB7XHJcbiAgICAgICAgLy8gU2hvcnRjdXQgZm9yIE1vemlsbGEgYnJvd3NlcnMgdGhhdCBpbXBsZW1lbnRcclxuICAgICAgICAvLyBhIG5hdGl2ZSBiYXNlNjQgZW5jb2RlciBpbiB0aGUgZm9ybSBvZiBcImJ0b2EvYXRvYlwiXHJcbiAgICAgICAgaWYgKHRoaXMuSEFTX05BVElWRV9TVVBQT1JUICYmICF3ZWJTYWZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhdG9iKGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJ5dGVBcnJheVRvU3RyaW5nKHRoaXMuZGVjb2RlU3RyaW5nVG9CeXRlQXJyYXkoaW5wdXQsIHdlYlNhZmUpKTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogSW4gYmFzZS02NCBkZWNvZGluZywgZ3JvdXBzIG9mIGZvdXIgY2hhcmFjdGVycyBhcmUgY29udmVydGVkIGludG8gdGhyZWVcclxuICAgICAqIGJ5dGVzLiAgSWYgdGhlIGVuY29kZXIgZGlkIG5vdCBhcHBseSBwYWRkaW5nLCB0aGUgaW5wdXQgbGVuZ3RoIG1heSBub3RcclxuICAgICAqIGJlIGEgbXVsdGlwbGUgb2YgNC5cclxuICAgICAqXHJcbiAgICAgKiBJbiB0aGlzIGNhc2UsIHRoZSBsYXN0IGdyb3VwIHdpbGwgaGF2ZSBmZXdlciB0aGFuIDQgY2hhcmFjdGVycywgYW5kXHJcbiAgICAgKiBwYWRkaW5nIHdpbGwgYmUgaW5mZXJyZWQuICBJZiB0aGUgZ3JvdXAgaGFzIG9uZSBvciB0d28gY2hhcmFjdGVycywgaXQgZGVjb2Rlc1xyXG4gICAgICogdG8gb25lIGJ5dGUuICBJZiB0aGUgZ3JvdXAgaGFzIHRocmVlIGNoYXJhY3RlcnMsIGl0IGRlY29kZXMgdG8gdHdvIGJ5dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnB1dCBJbnB1dCB0byBkZWNvZGUuXHJcbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlIHdlYi1zYWZlIGFscGhhYmV0LlxyXG4gICAgICogQHJldHVybiBieXRlcyByZXByZXNlbnRpbmcgdGhlIGRlY29kZWQgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSB7XHJcbiAgICAgICAgdGhpcy5pbml0XygpO1xyXG4gICAgICAgIGNvbnN0IGNoYXJUb0J5dGVNYXAgPSB3ZWJTYWZlXHJcbiAgICAgICAgICAgID8gdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9cclxuICAgICAgICAgICAgOiB0aGlzLmNoYXJUb0J5dGVNYXBfO1xyXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOykge1xyXG4gICAgICAgICAgICBjb25zdCBieXRlMSA9IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkrKyldO1xyXG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTIgPSBpIDwgaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBieXRlMiA9IGhhdmVCeXRlMiA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDA7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUzID0gaSA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiA2NDtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTQgPSBpIDwgaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBieXRlNCA9IGhhdmVCeXRlNCA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDY0O1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGlmIChieXRlMSA9PSBudWxsIHx8IGJ5dGUyID09IG51bGwgfHwgYnl0ZTMgPT0gbnVsbCB8fCBieXRlNCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBvdXRCeXRlMSA9IChieXRlMSA8PCAyKSB8IChieXRlMiA+PiA0KTtcclxuICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTEpO1xyXG4gICAgICAgICAgICBpZiAoYnl0ZTMgIT09IDY0KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRCeXRlMiA9ICgoYnl0ZTIgPDwgNCkgJiAweGYwKSB8IChieXRlMyA+PiAyKTtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUyKTtcclxuICAgICAgICAgICAgICAgIGlmIChieXRlNCAhPT0gNjQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRCeXRlMyA9ICgoYnl0ZTMgPDwgNikgJiAweGMwKSB8IGJ5dGU0O1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogTGF6eSBzdGF0aWMgaW5pdGlhbGl6YXRpb24gZnVuY3Rpb24uIENhbGxlZCBiZWZvcmVcclxuICAgICAqIGFjY2Vzc2luZyBhbnkgb2YgdGhlIHN0YXRpYyBtYXAgdmFyaWFibGVzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgaW5pdF8oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmJ5dGVUb0NoYXJNYXBfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcF8gPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwXyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlXyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlXyA9IHt9O1xyXG4gICAgICAgICAgICAvLyBXZSB3YW50IHF1aWNrIG1hcHBpbmdzIGJhY2sgYW5kIGZvcnRoLCBzbyB3ZSBwcmVjb21wdXRlIHR3byBtYXBzLlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRU5DT0RFRF9WQUxTLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBfW2ldID0gdGhpcy5FTkNPREVEX1ZBTFMuY2hhckF0KGkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwX1t0aGlzLmJ5dGVUb0NoYXJNYXBfW2ldXSA9IGk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTX1dFQlNBRkUuY2hhckF0KGkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9bdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9baV1dID0gaTtcclxuICAgICAgICAgICAgICAgIC8vIEJlIGZvcmdpdmluZyB3aGVuIGRlY29kaW5nIGFuZCBjb3JyZWN0bHkgZGVjb2RlIGJvdGggZW5jb2RpbmdzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfW3RoaXMuRU5DT0RFRF9WQUxTX1dFQlNBRkUuY2hhckF0KGkpXSA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9bdGhpcy5FTkNPREVEX1ZBTFMuY2hhckF0KGkpXSA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBBbiBlcnJvciBlbmNvdW50ZXJlZCB3aGlsZSBkZWNvZGluZyBiYXNlNjQgc3RyaW5nLlxyXG4gKi9cclxuY2xhc3MgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdEZWNvZGVCYXNlNjRTdHJpbmdFcnJvcic7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZ1xyXG4gKi9cclxuY29uc3QgYmFzZTY0RW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgY29uc3QgdXRmOEJ5dGVzID0gc3RyaW5nVG9CeXRlQXJyYXkkMShzdHIpO1xyXG4gICAgcmV0dXJuIGJhc2U2NC5lbmNvZGVCeXRlQXJyYXkodXRmOEJ5dGVzLCB0cnVlKTtcclxufTtcclxuLyoqXHJcbiAqIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZyAod2l0aG91dCBcIi5cIiBwYWRkaW5nIGluIHRoZSBlbmQpLlxyXG4gKiBlLmcuIFVzZWQgaW4gSlNPTiBXZWIgVG9rZW4gKEpXVCkgcGFydHMuXHJcbiAqL1xyXG5jb25zdCBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIC8vIFVzZSBiYXNlNjR1cmwgZW5jb2RpbmcgYW5kIHJlbW92ZSBwYWRkaW5nIGluIHRoZSBlbmQgKGRvdCBjaGFyYWN0ZXJzKS5cclxuICAgIHJldHVybiBiYXNlNjRFbmNvZGUoc3RyKS5yZXBsYWNlKC9cXC4vZywgJycpO1xyXG59O1xyXG4vKipcclxuICogVVJMLXNhZmUgYmFzZTY0IGRlY29kaW5nXHJcbiAqXHJcbiAqIE5PVEU6IERPIE5PVCB1c2UgdGhlIGdsb2JhbCBhdG9iKCkgZnVuY3Rpb24gLSBpdCBkb2VzIE5PVCBzdXBwb3J0IHRoZVxyXG4gKiBiYXNlNjRVcmwgdmFyaWFudCBlbmNvZGluZy5cclxuICpcclxuICogQHBhcmFtIHN0ciBUbyBiZSBkZWNvZGVkXHJcbiAqIEByZXR1cm4gRGVjb2RlZCByZXN1bHQsIGlmIHBvc3NpYmxlXHJcbiAqL1xyXG5jb25zdCBiYXNlNjREZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBiYXNlNjQuZGVjb2RlU3RyaW5nKHN0ciwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Jhc2U2NERlY29kZSBmYWlsZWQ6ICcsIGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBEbyBhIGRlZXAtY29weSBvZiBiYXNpYyBKYXZhU2NyaXB0IE9iamVjdHMgb3IgQXJyYXlzLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcENvcHkodmFsdWUpIHtcclxuICAgIHJldHVybiBkZWVwRXh0ZW5kKHVuZGVmaW5lZCwgdmFsdWUpO1xyXG59XHJcbi8qKlxyXG4gKiBDb3B5IHByb3BlcnRpZXMgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0IChyZWN1cnNpdmVseSBhbGxvd3MgZXh0ZW5zaW9uXHJcbiAqIG9mIE9iamVjdHMgYW5kIEFycmF5cykuICBTY2FsYXIgdmFsdWVzIGluIHRoZSB0YXJnZXQgYXJlIG92ZXItd3JpdHRlbi5cclxuICogSWYgdGFyZ2V0IGlzIHVuZGVmaW5lZCwgYW4gb2JqZWN0IG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlIHdpbGwgYmUgY3JlYXRlZFxyXG4gKiAoYW5kIHJldHVybmVkKS5cclxuICpcclxuICogV2UgcmVjdXJzaXZlbHkgY29weSBhbGwgY2hpbGQgcHJvcGVydGllcyBvZiBwbGFpbiBPYmplY3RzIGluIHRoZSBzb3VyY2UtIHNvXHJcbiAqIHRoYXQgbmFtZXNwYWNlLSBsaWtlIGRpY3Rpb25hcmllcyBhcmUgbWVyZ2VkLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdGhlIHRhcmdldCBjYW4gYmUgYSBmdW5jdGlvbiwgaW4gd2hpY2ggY2FzZSB0aGUgcHJvcGVydGllcyBpblxyXG4gKiB0aGUgc291cmNlIE9iamVjdCBhcmUgY29waWVkIG9udG8gaXQgYXMgc3RhdGljIHByb3BlcnRpZXMgb2YgdGhlIEZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBOb3RlOiB3ZSBkb24ndCBtZXJnZSBfX3Byb3RvX18gdG8gcHJldmVudCBwcm90b3R5cGUgcG9sbHV0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwRXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XHJcbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgIH1cclxuICAgIHN3aXRjaCAoc291cmNlLmNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgY2FzZSBEYXRlOlxyXG4gICAgICAgICAgICAvLyBUcmVhdCBEYXRlcyBsaWtlIHNjYWxhcnM7IGlmIHRoZSB0YXJnZXQgZGF0ZSBvYmplY3QgaGFkIGFueSBjaGlsZFxyXG4gICAgICAgICAgICAvLyBwcm9wZXJ0aWVzIC0gdGhleSB3aWxsIGJlIGxvc3QhXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGVWYWx1ZSA9IHNvdXJjZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGVWYWx1ZS5nZXRUaW1lKCkpO1xyXG4gICAgICAgIGNhc2UgT2JqZWN0OlxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQXJyYXk6XHJcbiAgICAgICAgICAgIC8vIEFsd2F5cyBjb3B5IHRoZSBhcnJheSBzb3VyY2UgYW5kIG92ZXJ3cml0ZSB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAgICB0YXJnZXQgPSBbXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgLy8gTm90IGEgcGxhaW4gT2JqZWN0IC0gdHJlYXQgaXQgYXMgYSBzY2FsYXIuXHJcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gc291cmNlKSB7XHJcbiAgICAgICAgLy8gdXNlIGlzVmFsaWRLZXkgdG8gZ3VhcmQgYWdhaW5zdCBwcm90b3R5cGUgcG9sbHV0aW9uLiBTZWUgaHR0cHM6Ly9zbnlrLmlvL3Z1bG4vU05ZSy1KUy1MT0RBU0gtNDUwMjAyXHJcbiAgICAgICAgaWYgKCFzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgIWlzVmFsaWRLZXkocHJvcCkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IGRlZXBFeHRlbmQodGFyZ2V0W3Byb3BdLCBzb3VyY2VbcHJvcF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xyXG4gICAgcmV0dXJuIGtleSAhPT0gJ19fcHJvdG9fXyc7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFBvbHlmaWxsIGZvciBgZ2xvYmFsVGhpc2Agb2JqZWN0LlxyXG4gKiBAcmV0dXJucyB0aGUgYGdsb2JhbFRoaXNgIG9iamVjdCBmb3IgdGhlIGdpdmVuIGVudmlyb25tZW50LlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRHbG9iYWwoKSB7XHJcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gd2luZG93O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0LicpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRzRnJvbUdsb2JhbCA9ICgpID0+IGdldEdsb2JhbCgpLl9fRklSRUJBU0VfREVGQVVMVFNfXztcclxuLyoqXHJcbiAqIEF0dGVtcHQgdG8gcmVhZCBkZWZhdWx0cyBmcm9tIGEgSlNPTiBzdHJpbmcgcHJvdmlkZWQgdG9cclxuICogcHJvY2VzcyguKWVudiguKV9fRklSRUJBU0VfREVGQVVMVFNfXyBvciBhIEpTT04gZmlsZSB3aG9zZSBwYXRoIGlzIGluXHJcbiAqIHByb2Nlc3MoLillbnYoLilfX0ZJUkVCQVNFX0RFRkFVTFRTX1BBVEhfX1xyXG4gKiBUaGUgZG90cyBhcmUgaW4gcGFyZW5zIGJlY2F1c2UgY2VydGFpbiBjb21waWxlcnMgKFZpdGU/KSBjYW5ub3RcclxuICogaGFuZGxlIHNlZWluZyB0aGF0IHZhcmlhYmxlIGluIGNvbW1lbnRzLlxyXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9pc3N1ZXMvNjgzOFxyXG4gKi9cclxuY29uc3QgZ2V0RGVmYXVsdHNGcm9tRW52VmFyaWFibGUgPSAoKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBwcm9jZXNzLmVudiA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWZhdWx0c0pzb25TdHJpbmcgPSBwcm9jZXNzLmVudi5fX0ZJUkVCQVNFX0RFRkFVTFRTX187XHJcbiAgICBpZiAoZGVmYXVsdHNKc29uU3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVmYXVsdHNKc29uU3RyaW5nKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgZ2V0RGVmYXVsdHNGcm9tQ29va2llID0gKCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgbWF0Y2g7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKC9fX0ZJUkVCQVNFX0RFRkFVTFRTX189KFteO10rKS8pO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBTb21lIGVudmlyb25tZW50cyBzdWNoIGFzIEFuZ3VsYXIgVW5pdmVyc2FsIFNTUiBoYXZlIGFcclxuICAgICAgICAvLyBgZG9jdW1lbnRgIG9iamVjdCBidXQgZXJyb3Igb24gYWNjZXNzaW5nIGBkb2N1bWVudC5jb29raWVgLlxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGRlY29kZWQgPSBtYXRjaCAmJiBiYXNlNjREZWNvZGUobWF0Y2hbMV0pO1xyXG4gICAgcmV0dXJuIGRlY29kZWQgJiYgSlNPTi5wYXJzZShkZWNvZGVkKTtcclxufTtcclxuLyoqXHJcbiAqIEdldCB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdC4gSXQgY2hlY2tzIGluIG9yZGVyOlxyXG4gKiAoMSkgaWYgc3VjaCBhbiBvYmplY3QgZXhpc3RzIGFzIGEgcHJvcGVydHkgb2YgYGdsb2JhbFRoaXNgXHJcbiAqICgyKSBpZiBzdWNoIGFuIG9iamVjdCB3YXMgcHJvdmlkZWQgb24gYSBzaGVsbCBlbnZpcm9ubWVudCB2YXJpYWJsZVxyXG4gKiAoMykgaWYgc3VjaCBhbiBvYmplY3QgZXhpc3RzIGluIGEgY29va2llXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRzID0gKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gKGdldERlZmF1bHRzRnJvbUdsb2JhbCgpIHx8XHJcbiAgICAgICAgICAgIGdldERlZmF1bHRzRnJvbUVudlZhcmlhYmxlKCkgfHxcclxuICAgICAgICAgICAgZ2V0RGVmYXVsdHNGcm9tQ29va2llKCkpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYXRjaC1hbGwgZm9yIGJlaW5nIHVuYWJsZSB0byBnZXQgX19GSVJFQkFTRV9ERUZBVUxUU19fIGR1ZVxyXG4gICAgICAgICAqIHRvIGFueSBlbnZpcm9ubWVudCBjYXNlIHdlIGhhdmUgbm90IGFjY291bnRlZCBmb3IuIExvZyB0b1xyXG4gICAgICAgICAqIGluZm8gaW5zdGVhZCBvZiBzd2FsbG93aW5nIHNvIHdlIGNhbiBmaW5kIHRoZXNlIHVua25vd24gY2FzZXNcclxuICAgICAgICAgKiBhbmQgYWRkIHBhdGhzIGZvciB0aGVtIGlmIG5lZWRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zb2xlLmluZm8oYFVuYWJsZSB0byBnZXQgX19GSVJFQkFTRV9ERUZBVUxUU19fIGR1ZSB0bzogJHtlfWApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgZW11bGF0b3IgaG9zdCBzdG9yZWQgaW4gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3RcclxuICogZm9yIHRoZSBnaXZlbiBwcm9kdWN0LlxyXG4gKiBAcmV0dXJucyBhIFVSTCBob3N0IGZvcm1hdHRlZCBsaWtlIGAxMjcuMC4wLjE6OTk5OWAgb3IgYFs6OjFdOjQwMDBgIGlmIGF2YWlsYWJsZVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0RW11bGF0b3JIb3N0ID0gKHByb2R1Y3ROYW1lKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW11bGF0b3JIb3N0cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW3Byb2R1Y3ROYW1lXTsgfTtcclxuLyoqXHJcbiAqIFJldHVybnMgZW11bGF0b3IgaG9zdG5hbWUgYW5kIHBvcnQgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0XHJcbiAqIGZvciB0aGUgZ2l2ZW4gcHJvZHVjdC5cclxuICogQHJldHVybnMgYSBwYWlyIG9mIGhvc3RuYW1lIGFuZCBwb3J0IGxpa2UgYFtcIjo6MVwiLCA0MDAwXWAgaWYgYXZhaWxhYmxlXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCA9IChwcm9kdWN0TmFtZSkgPT4ge1xyXG4gICAgY29uc3QgaG9zdCA9IGdldERlZmF1bHRFbXVsYXRvckhvc3QocHJvZHVjdE5hbWUpO1xyXG4gICAgaWYgKCFob3N0KSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGNvbnN0IHNlcGFyYXRvckluZGV4ID0gaG9zdC5sYXN0SW5kZXhPZignOicpOyAvLyBGaW5kaW5nIHRoZSBsYXN0IHNpbmNlIElQdjYgYWRkciBhbHNvIGhhcyBjb2xvbnMuXHJcbiAgICBpZiAoc2VwYXJhdG9ySW5kZXggPD0gMCB8fCBzZXBhcmF0b3JJbmRleCArIDEgPT09IGhvc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhvc3QgJHtob3N0fSB3aXRoIG5vIHNlcGFyYXRlIGhvc3RuYW1lIGFuZCBwb3J0IWApO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xyXG4gICAgY29uc3QgcG9ydCA9IHBhcnNlSW50KGhvc3Quc3Vic3RyaW5nKHNlcGFyYXRvckluZGV4ICsgMSksIDEwKTtcclxuICAgIGlmIChob3N0WzBdID09PSAnWycpIHtcclxuICAgICAgICAvLyBCcmFja2V0LXF1b3RlZCBgW2lwdjZhZGRyXTpwb3J0YCA9PiByZXR1cm4gXCJpcHY2YWRkclwiICh3aXRob3V0IGJyYWNrZXRzKS5cclxuICAgICAgICByZXR1cm4gW2hvc3Quc3Vic3RyaW5nKDEsIHNlcGFyYXRvckluZGV4IC0gMSksIHBvcnRdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFtob3N0LnN1YnN0cmluZygwLCBzZXBhcmF0b3JJbmRleCksIHBvcnRdO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogUmV0dXJucyBGaXJlYmFzZSBhcHAgY29uZmlnIHN0b3JlZCBpbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdC5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgZ2V0RGVmYXVsdEFwcENvbmZpZyA9ICgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZzsgfTtcclxuLyoqXHJcbiAqIFJldHVybnMgYW4gZXhwZXJpbWVudGFsIHNldHRpbmcgb24gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QgKHByb3BlcnRpZXNcclxuICogcHJlZml4ZWQgYnkgXCJfXCIpXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGdldEV4cGVyaW1lbnRhbFNldHRpbmcgPSAobmFtZSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYF8ke25hbWV9YF07IH07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIERlZmVycmVkIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucmVqZWN0ID0gKCkgPT4geyB9O1xyXG4gICAgICAgIHRoaXMucmVzb2x2ZSA9ICgpID0+IHsgfTtcclxuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdXIgQVBJIGludGVybmFscyBhcmUgbm90IHByb21pc2VpZmllZCBhbmQgY2Fubm90IGJlY2F1c2Ugb3VyIGNhbGxiYWNrIEFQSXMgaGF2ZSBzdWJ0bGUgZXhwZWN0YXRpb25zIGFyb3VuZFxyXG4gICAgICogaW52b2tpbmcgcHJvbWlzZXMgaW5saW5lLCB3aGljaCBQcm9taXNlcyBhcmUgZm9yYmlkZGVuIHRvIGRvLiBUaGlzIG1ldGhvZCBhY2NlcHRzIGFuIG9wdGlvbmFsIG5vZGUtc3R5bGUgY2FsbGJhY2tcclxuICAgICAqIGFuZCByZXR1cm5zIGEgbm9kZS1zdHlsZSBjYWxsYmFjayB3aGljaCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBEZWZlcnJlZCdzIHByb21pc2UuXHJcbiAgICAgKi9cclxuICAgIHdyYXBDYWxsYmFjayhjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiAoZXJyb3IsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBdHRhY2hpbmcgbm9vcCBoYW5kbGVyIGp1c3QgaW4gY2FzZSBkZXZlbG9wZXIgd2Fzbid0IGV4cGVjdGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gcHJvbWlzZXNcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzZS5jYXRjaCgoKSA9PiB7IH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gU29tZSBvZiBvdXIgY2FsbGJhY2tzIGRvbid0IGV4cGVjdCBhIHZhbHVlIGFuZCBvdXIgb3duIHRlc3RzXHJcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQgdGhhdCB0aGUgcGFyYW1ldGVyIGxlbmd0aCBpcyAxXHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2subGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlTW9ja1VzZXJUb2tlbih0b2tlbiwgcHJvamVjdElkKSB7XHJcbiAgICBpZiAodG9rZW4udWlkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgXCJ1aWRcIiBmaWVsZCBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGJ5IG1vY2tVc2VyVG9rZW4uIFBsZWFzZSB1c2UgXCJzdWJcIiBpbnN0ZWFkIGZvciBGaXJlYmFzZSBBdXRoIFVzZXIgSUQuJyk7XHJcbiAgICB9XHJcbiAgICAvLyBVbnNlY3VyZWQgSldUcyB1c2UgXCJub25lXCIgYXMgdGhlIGFsZ29yaXRobS5cclxuICAgIGNvbnN0IGhlYWRlciA9IHtcclxuICAgICAgICBhbGc6ICdub25lJyxcclxuICAgICAgICB0eXBlOiAnSldUJ1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2plY3QgPSBwcm9qZWN0SWQgfHwgJ2RlbW8tcHJvamVjdCc7XHJcbiAgICBjb25zdCBpYXQgPSB0b2tlbi5pYXQgfHwgMDtcclxuICAgIGNvbnN0IHN1YiA9IHRva2VuLnN1YiB8fCB0b2tlbi51c2VyX2lkO1xyXG4gICAgaWYgKCFzdWIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2NrVXNlclRva2VuIG11c3QgY29udGFpbiAnc3ViJyBvciAndXNlcl9pZCcgZmllbGQhXCIpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oeyBcclxuICAgICAgICAvLyBTZXQgYWxsIHJlcXVpcmVkIGZpZWxkcyB0byBkZWNlbnQgZGVmYXVsdHNcclxuICAgICAgICBpc3M6IGBodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vJHtwcm9qZWN0fWAsIGF1ZDogcHJvamVjdCwgaWF0LCBleHA6IGlhdCArIDM2MDAsIGF1dGhfdGltZTogaWF0LCBzdWIsIHVzZXJfaWQ6IHN1YiwgZmlyZWJhc2U6IHtcclxuICAgICAgICAgICAgc2lnbl9pbl9wcm92aWRlcjogJ2N1c3RvbScsXHJcbiAgICAgICAgICAgIGlkZW50aXRpZXM6IHt9XHJcbiAgICAgICAgfSB9LCB0b2tlbik7XHJcbiAgICAvLyBVbnNlY3VyZWQgSldUcyB1c2UgdGhlIGVtcHR5IHN0cmluZyBhcyBhIHNpZ25hdHVyZS5cclxuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICcnO1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeShoZWFkZXIpKSxcclxuICAgICAgICBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSksXHJcbiAgICAgICAgc2lnbmF0dXJlXHJcbiAgICBdLmpvaW4oJy4nKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyBuYXZpZ2F0b3IudXNlckFnZW50IHN0cmluZyBvciAnJyBpZiBpdCdzIG5vdCBkZWZpbmVkLlxyXG4gKiBAcmV0dXJuIHVzZXIgYWdlbnQgc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRVQSgpIHtcclxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3JbJ3VzZXJBZ2VudCddID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3JbJ3VzZXJBZ2VudCddO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBEZXRlY3QgQ29yZG92YSAvIFBob25lR2FwIC8gSW9uaWMgZnJhbWV3b3JrcyBvbiBhIG1vYmlsZSBkZXZpY2UuXHJcbiAqXHJcbiAqIERlbGliZXJhdGVseSBkb2VzIG5vdCByZWx5IG9uIGNoZWNraW5nIGBmaWxlOi8vYCBVUkxzIChhcyB0aGlzIGZhaWxzIFBob25lR2FwXHJcbiAqIGluIHRoZSBSaXBwbGUgZW11bGF0b3IpIG5vciBDb3Jkb3ZhIGBvbkRldmljZVJlYWR5YCwgd2hpY2ggd291bGQgbm9ybWFsbHlcclxuICogd2FpdCBmb3IgYSBjYWxsYmFjay5cclxuICovXHJcbmZ1bmN0aW9uIGlzTW9iaWxlQ29yZG92YSgpIHtcclxuICAgIHJldHVybiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAvLyBAdHMtaWdub3JlIFNldHRpbmcgdXAgYW4gYnJvYWRseSBhcHBsaWNhYmxlIGluZGV4IHNpZ25hdHVyZSBmb3IgV2luZG93XHJcbiAgICAgICAgLy8ganVzdCB0byBkZWFsIHdpdGggdGhpcyBjYXNlIHdvdWxkIHByb2JhYmx5IGJlIGEgYmFkIGlkZWEuXHJcbiAgICAgICAgISEod2luZG93Wydjb3Jkb3ZhJ10gfHwgd2luZG93WydwaG9uZWdhcCddIHx8IHdpbmRvd1snUGhvbmVHYXAnXSkgJiZcclxuICAgICAgICAvaW9zfGlwaG9uZXxpcG9kfGlwYWR8YW5kcm9pZHxibGFja2JlcnJ5fGllbW9iaWxlL2kudGVzdChnZXRVQSgpKSk7XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCBOb2RlLmpzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHRydWUgaWYgTm9kZS5qcyBlbnZpcm9ubWVudCBpcyBkZXRlY3RlZCBvciBzcGVjaWZpZWQuXHJcbiAqL1xyXG4vLyBOb2RlIGRldGVjdGlvbiBsb2dpYyBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vaWxpYWthbi9kZXRlY3Qtbm9kZS9cclxuZnVuY3Rpb24gaXNOb2RlKCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgZm9yY2VFbnZpcm9ubWVudCA9IChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JjZUVudmlyb25tZW50O1xyXG4gICAgaWYgKGZvcmNlRW52aXJvbm1lbnQgPT09ICdub2RlJykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZm9yY2VFbnZpcm9ubWVudCA9PT0gJ2Jyb3dzZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRGV0ZWN0IEJyb3dzZXIgRW52aXJvbm1lbnRcclxuICovXHJcbmZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcclxuICAgIHJldHVybiB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiYgc2VsZi5zZWxmID09PSBzZWxmO1xyXG59XHJcbmZ1bmN0aW9uIGlzQnJvd3NlckV4dGVuc2lvbigpIHtcclxuICAgIGNvbnN0IHJ1bnRpbWUgPSB0eXBlb2YgY2hyb21lID09PSAnb2JqZWN0J1xyXG4gICAgICAgID8gY2hyb21lLnJ1bnRpbWVcclxuICAgICAgICA6IHR5cGVvZiBicm93c2VyID09PSAnb2JqZWN0J1xyXG4gICAgICAgICAgICA/IGJyb3dzZXIucnVudGltZVxyXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIHJldHVybiB0eXBlb2YgcnVudGltZSA9PT0gJ29iamVjdCcgJiYgcnVudGltZS5pZCAhPT0gdW5kZWZpbmVkO1xyXG59XHJcbi8qKlxyXG4gKiBEZXRlY3QgUmVhY3QgTmF0aXZlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHRydWUgaWYgUmVhY3ROYXRpdmUgZW52aXJvbm1lbnQgaXMgZGV0ZWN0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1JlYWN0TmF0aXZlKCkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJiBuYXZpZ2F0b3JbJ3Byb2R1Y3QnXSA9PT0gJ1JlYWN0TmF0aXZlJyk7XHJcbn1cclxuLyoqIERldGVjdHMgRWxlY3Ryb24gYXBwcy4gKi9cclxuZnVuY3Rpb24gaXNFbGVjdHJvbigpIHtcclxuICAgIHJldHVybiBnZXRVQSgpLmluZGV4T2YoJ0VsZWN0cm9uLycpID49IDA7XHJcbn1cclxuLyoqIERldGVjdHMgSW50ZXJuZXQgRXhwbG9yZXIuICovXHJcbmZ1bmN0aW9uIGlzSUUoKSB7XHJcbiAgICBjb25zdCB1YSA9IGdldFVBKCk7XHJcbiAgICByZXR1cm4gdWEuaW5kZXhPZignTVNJRSAnKSA+PSAwIHx8IHVhLmluZGV4T2YoJ1RyaWRlbnQvJykgPj0gMDtcclxufVxyXG4vKiogRGV0ZWN0cyBVbml2ZXJzYWwgV2luZG93cyBQbGF0Zm9ybSBhcHBzLiAqL1xyXG5mdW5jdGlvbiBpc1VXUCgpIHtcclxuICAgIHJldHVybiBnZXRVQSgpLmluZGV4T2YoJ01TQXBwSG9zdC8nKSA+PSAwO1xyXG59XHJcbi8qKlxyXG4gKiBEZXRlY3Qgd2hldGhlciB0aGUgY3VycmVudCBTREsgYnVpbGQgaXMgdGhlIE5vZGUgdmVyc2lvbi5cclxuICpcclxuICogQHJldHVybiB0cnVlIGlmIGl0J3MgdGhlIE5vZGUgU0RLIGJ1aWxkLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNOb2RlU2RrKCkge1xyXG4gICAgcmV0dXJuIENPTlNUQU5UUy5OT0RFX0NMSUVOVCA9PT0gdHJ1ZSB8fCBDT05TVEFOVFMuTk9ERV9BRE1JTiA9PT0gdHJ1ZTtcclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIHdlIGFyZSBydW5uaW5nIGluIFNhZmFyaS4gKi9cclxuZnVuY3Rpb24gaXNTYWZhcmkoKSB7XHJcbiAgICByZXR1cm4gKCFpc05vZGUoKSAmJlxyXG4gICAgICAgICEhbmF2aWdhdG9yLnVzZXJBZ2VudCAmJlxyXG4gICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ1NhZmFyaScpICYmXHJcbiAgICAgICAgIW5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ0Nocm9tZScpKTtcclxufVxyXG4vKipcclxuICogVGhpcyBtZXRob2QgY2hlY2tzIGlmIGluZGV4ZWREQiBpcyBzdXBwb3J0ZWQgYnkgY3VycmVudCBicm93c2VyL3NlcnZpY2Ugd29ya2VyIGNvbnRleHRcclxuICogQHJldHVybiB0cnVlIGlmIGluZGV4ZWREQiBpcyBzdXBwb3J0ZWQgYnkgY3VycmVudCBicm93c2VyL3NlcnZpY2Ugd29ya2VyIGNvbnRleHRcclxuICovXHJcbmZ1bmN0aW9uIGlzSW5kZXhlZERCQXZhaWxhYmxlKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIGluZGV4ZWREQiA9PT0gJ29iamVjdCc7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhpcyBtZXRob2QgdmFsaWRhdGVzIGJyb3dzZXIvc3cgY29udGV4dCBmb3IgaW5kZXhlZERCIGJ5IG9wZW5pbmcgYSBkdW1teSBpbmRleGVkREIgZGF0YWJhc2UgYW5kIHJlamVjdFxyXG4gKiBpZiBlcnJvcnMgb2NjdXIgZHVyaW5nIHRoZSBkYXRhYmFzZSBvcGVuIG9wZXJhdGlvbi5cclxuICpcclxuICogQHRocm93cyBleGNlcHRpb24gaWYgY3VycmVudCBicm93c2VyL3N3IGNvbnRleHQgY2FuJ3QgcnVuIGlkYi5vcGVuIChleDogU2FmYXJpIGlmcmFtZSwgRmlyZWZveFxyXG4gKiBwcml2YXRlIGJyb3dzaW5nKVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSgpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IHByZUV4aXN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgREJfQ0hFQ0tfTkFNRSA9ICd2YWxpZGF0ZS1icm93c2VyLWNvbnRleHQtZm9yLWluZGV4ZWRkYi1hbmFseXRpY3MtbW9kdWxlJztcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHNlbGYuaW5kZXhlZERCLm9wZW4oREJfQ0hFQ0tfTkFNRSk7XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXN1bHQuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBkYXRhYmFzZSBvbmx5IHdoZW4gaXQgZG9lc24ndCBwcmUtZXhpc3RcclxuICAgICAgICAgICAgICAgIGlmICghcHJlRXhpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShEQl9DSEVDS19OQU1FKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcHJlRXhpc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KCgoX2EgPSByZXF1ZXN0LmVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZSkgfHwgJycpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICpcclxuICogVGhpcyBtZXRob2QgY2hlY2tzIHdoZXRoZXIgY29va2llIGlzIGVuYWJsZWQgd2l0aGluIGN1cnJlbnQgYnJvd3NlclxyXG4gKiBAcmV0dXJuIHRydWUgaWYgY29va2llIGlzIGVuYWJsZWQgd2l0aGluIGN1cnJlbnQgYnJvd3NlclxyXG4gKi9cclxuZnVuY3Rpb24gYXJlQ29va2llc0VuYWJsZWQoKSB7XHJcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvci5jb29raWVFbmFibGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgU3RhbmRhcmRpemVkIEZpcmViYXNlIEVycm9yLlxyXG4gKlxyXG4gKiBVc2FnZTpcclxuICpcclxuICogICAvLyBUeXBlc2NyaXB0IHN0cmluZyBsaXRlcmFscyBmb3IgdHlwZS1zYWZlIGNvZGVzXHJcbiAqICAgdHlwZSBFcnIgPVxyXG4gKiAgICAgJ3Vua25vd24nIHxcclxuICogICAgICdvYmplY3Qtbm90LWZvdW5kJ1xyXG4gKiAgICAgO1xyXG4gKlxyXG4gKiAgIC8vIENsb3N1cmUgZW51bSBmb3IgdHlwZS1zYWZlIGVycm9yIGNvZGVzXHJcbiAqICAgLy8gYXQtZW51bSB7c3RyaW5nfVxyXG4gKiAgIHZhciBFcnIgPSB7XHJcbiAqICAgICBVTktOT1dOOiAndW5rbm93bicsXHJcbiAqICAgICBPQkpFQ1RfTk9UX0ZPVU5EOiAnb2JqZWN0LW5vdC1mb3VuZCcsXHJcbiAqICAgfVxyXG4gKlxyXG4gKiAgIGxldCBlcnJvcnM6IE1hcDxFcnIsIHN0cmluZz4gPSB7XHJcbiAqICAgICAnZ2VuZXJpYy1lcnJvcic6IFwiVW5rbm93biBlcnJvclwiLFxyXG4gKiAgICAgJ2ZpbGUtbm90LWZvdW5kJzogXCJDb3VsZCBub3QgZmluZCBmaWxlOiB7JGZpbGV9XCIsXHJcbiAqICAgfTtcclxuICpcclxuICogICAvLyBUeXBlLXNhZmUgZnVuY3Rpb24gLSBtdXN0IHBhc3MgYSB2YWxpZCBlcnJvciBjb2RlIGFzIHBhcmFtLlxyXG4gKiAgIGxldCBlcnJvciA9IG5ldyBFcnJvckZhY3Rvcnk8RXJyPignc2VydmljZScsICdTZXJ2aWNlJywgZXJyb3JzKTtcclxuICpcclxuICogICAuLi5cclxuICogICB0aHJvdyBlcnJvci5jcmVhdGUoRXJyLkdFTkVSSUMpO1xyXG4gKiAgIC4uLlxyXG4gKiAgIHRocm93IGVycm9yLmNyZWF0ZShFcnIuRklMRV9OT1RfRk9VTkQsIHsnZmlsZSc6IGZpbGVOYW1lfSk7XHJcbiAqICAgLi4uXHJcbiAqICAgLy8gU2VydmljZTogQ291bGQgbm90IGZpbGUgZmlsZTogZm9vLnR4dCAoc2VydmljZS9maWxlLW5vdC1mb3VuZCkuXHJcbiAqXHJcbiAqICAgY2F0Y2ggKGUpIHtcclxuICogICAgIGFzc2VydChlLm1lc3NhZ2UgPT09IFwiQ291bGQgbm90IGZpbmQgZmlsZTogZm9vLnR4dC5cIik7XHJcbiAqICAgICBpZiAoKGUgYXMgRmlyZWJhc2VFcnJvcik/LmNvZGUgPT09ICdzZXJ2aWNlL2ZpbGUtbm90LWZvdW5kJykge1xyXG4gKiAgICAgICBjb25zb2xlLmxvZyhcIkNvdWxkIG5vdCByZWFkIGZpbGU6IFwiICsgZVsnZmlsZSddKTtcclxuICogICAgIH1cclxuICogICB9XHJcbiAqL1xyXG5jb25zdCBFUlJPUl9OQU1FID0gJ0ZpcmViYXNlRXJyb3InO1xyXG4vLyBCYXNlZCBvbiBjb2RlIGZyb206XHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0N1c3RvbV9FcnJvcl9UeXBlc1xyXG5jbGFzcyBGaXJlYmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogVGhlIGVycm9yIGNvZGUgZm9yIHRoaXMgZXJyb3IuICovXHJcbiAgICBjb2RlLCBtZXNzYWdlLCBcclxuICAgIC8qKiBDdXN0b20gZGF0YSBmb3IgdGhpcyBlcnJvci4gKi9cclxuICAgIGN1c3RvbURhdGEpIHtcclxuICAgICAgICBzdXBlcihtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgIHRoaXMuY3VzdG9tRGF0YSA9IGN1c3RvbURhdGE7XHJcbiAgICAgICAgLyoqIFRoZSBjdXN0b20gbmFtZSBmb3IgYWxsIEZpcmViYXNlRXJyb3JzLiAqL1xyXG4gICAgICAgIHRoaXMubmFtZSA9IEVSUk9SX05BTUU7XHJcbiAgICAgICAgLy8gRml4IEZvciBFUzVcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQtd2lraS9ibG9iL21hc3Rlci9CcmVha2luZy1DaGFuZ2VzLm1kI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29ya1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBGaXJlYmFzZUVycm9yLnByb3RvdHlwZSk7XHJcbiAgICAgICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24uXHJcbiAgICAgICAgLy8gT25seSBhdmFpbGFibGUgb24gVjguXHJcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XHJcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEVycm9yRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRXJyb3JGYWN0b3J5IHtcclxuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UsIHNlcnZpY2VOYW1lLCBlcnJvcnMpIHtcclxuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xyXG4gICAgICAgIHRoaXMuc2VydmljZU5hbWUgPSBzZXJ2aWNlTmFtZTtcclxuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcclxuICAgIH1cclxuICAgIGNyZWF0ZShjb2RlLCAuLi5kYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY3VzdG9tRGF0YSA9IGRhdGFbMF0gfHwge307XHJcbiAgICAgICAgY29uc3QgZnVsbENvZGUgPSBgJHt0aGlzLnNlcnZpY2V9LyR7Y29kZX1gO1xyXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5lcnJvcnNbY29kZV07XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRlbXBsYXRlID8gcmVwbGFjZVRlbXBsYXRlKHRlbXBsYXRlLCBjdXN0b21EYXRhKSA6ICdFcnJvcic7XHJcbiAgICAgICAgLy8gU2VydmljZSBOYW1lOiBFcnJvciBtZXNzYWdlIChzZXJ2aWNlL2NvZGUpLlxyXG4gICAgICAgIGNvbnN0IGZ1bGxNZXNzYWdlID0gYCR7dGhpcy5zZXJ2aWNlTmFtZX06ICR7bWVzc2FnZX0gKCR7ZnVsbENvZGV9KS5gO1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEZpcmViYXNlRXJyb3IoZnVsbENvZGUsIGZ1bGxNZXNzYWdlLCBjdXN0b21EYXRhKTtcclxuICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVwbGFjZVRlbXBsYXRlKHRlbXBsYXRlLCBkYXRhKSB7XHJcbiAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZShQQVRURVJOLCAoXywga2V5KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhW2tleV07XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyBTdHJpbmcodmFsdWUpIDogYDwke2tleX0/PmA7XHJcbiAgICB9KTtcclxufVxyXG5jb25zdCBQQVRURVJOID0gL1xce1xcJChbXn1dKyl9L2c7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBFdmFsdWF0ZXMgYSBKU09OIHN0cmluZyBpbnRvIGEgamF2YXNjcmlwdCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgQSBzdHJpbmcgY29udGFpbmluZyBKU09OLlxyXG4gKiBAcmV0dXJuIHsqfSBUaGUgamF2YXNjcmlwdCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgSlNPTi5cclxuICovXHJcbmZ1bmN0aW9uIGpzb25FdmFsKHN0cikge1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBKU09OIHJlcHJlc2VudGluZyBhIGphdmFzY3JpcHQgb2JqZWN0LlxyXG4gKiBAcGFyYW0geyp9IGRhdGEgSmF2YXNjcmlwdCBvYmplY3QgdG8gYmUgc3RyaW5naWZpZWQuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEpTT04gY29udGVudHMgb2YgdGhlIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeShkYXRhKSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBpbnRvIGNvbnN0aXR1ZW50IHBhcnRzLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogLSBNYXkgcmV0dXJuIHdpdGggaW52YWxpZCAvIGluY29tcGxldGUgY2xhaW1zIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgZGVjb2RlID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBsZXQgaGVhZGVyID0ge30sIGNsYWltcyA9IHt9LCBkYXRhID0ge30sIHNpZ25hdHVyZSA9ICcnO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBwYXJ0cyA9IHRva2VuLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgaGVhZGVyID0ganNvbkV2YWwoYmFzZTY0RGVjb2RlKHBhcnRzWzBdKSB8fCAnJyk7XHJcbiAgICAgICAgY2xhaW1zID0ganNvbkV2YWwoYmFzZTY0RGVjb2RlKHBhcnRzWzFdKSB8fCAnJyk7XHJcbiAgICAgICAgc2lnbmF0dXJlID0gcGFydHNbMl07XHJcbiAgICAgICAgZGF0YSA9IGNsYWltc1snZCddIHx8IHt9O1xyXG4gICAgICAgIGRlbGV0ZSBjbGFpbXNbJ2QnXTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7IH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaGVhZGVyLFxyXG4gICAgICAgIGNsYWltcyxcclxuICAgICAgICBkYXRhLFxyXG4gICAgICAgIHNpZ25hdHVyZVxyXG4gICAgfTtcclxufTtcclxuLyoqXHJcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgY2hlY2tzIHRoZSB2YWxpZGl0eSBvZiBpdHMgdGltZS1iYXNlZCBjbGFpbXMuIFdpbGwgcmV0dXJuIHRydWUgaWYgdGhlXHJcbiAqIHRva2VuIGlzIHdpdGhpbiB0aGUgdGltZSB3aW5kb3cgYXV0aG9yaXplZCBieSB0aGUgJ25iZicgKG5vdC1iZWZvcmUpIGFuZCAnaWF0JyAoaXNzdWVkLWF0KSBjbGFpbXMuXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cclxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cclxuICovXHJcbmNvbnN0IGlzVmFsaWRUaW1lc3RhbXAgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGNvbnN0IGNsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xyXG4gICAgY29uc3Qgbm93ID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApO1xyXG4gICAgbGV0IHZhbGlkU2luY2UgPSAwLCB2YWxpZFVudGlsID0gMDtcclxuICAgIGlmICh0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ25iZicpKSB7XHJcbiAgICAgICAgICAgIHZhbGlkU2luY2UgPSBjbGFpbXNbJ25iZiddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpKSB7XHJcbiAgICAgICAgICAgIHZhbGlkU2luY2UgPSBjbGFpbXNbJ2lhdCddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCdleHAnKSkge1xyXG4gICAgICAgICAgICB2YWxpZFVudGlsID0gY2xhaW1zWydleHAnXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRva2VuIHdpbGwgZXhwaXJlIGFmdGVyIDI0aCBieSBkZWZhdWx0XHJcbiAgICAgICAgICAgIHZhbGlkVW50aWwgPSB2YWxpZFNpbmNlICsgODY0MDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuICghIW5vdyAmJlxyXG4gICAgICAgICEhdmFsaWRTaW5jZSAmJlxyXG4gICAgICAgICEhdmFsaWRVbnRpbCAmJlxyXG4gICAgICAgIG5vdyA+PSB2YWxpZFNpbmNlICYmXHJcbiAgICAgICAgbm93IDw9IHZhbGlkVW50aWwpO1xyXG59O1xyXG4vKipcclxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCByZXR1cm5zIGl0cyBpc3N1ZWQgYXQgdGltZSBpZiB2YWxpZCwgbnVsbCBvdGhlcndpc2UuXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIE1heSByZXR1cm4gbnVsbCBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cclxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cclxuICovXHJcbmNvbnN0IGlzc3VlZEF0VGltZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XHJcbiAgICBpZiAodHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKSkge1xyXG4gICAgICAgIHJldHVybiBjbGFpbXNbJ2lhdCddO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIGNoZWNrcyB0aGUgdmFsaWRpdHkgb2YgaXRzIGZvcm1hdC4gRXhwZWN0cyBhIHZhbGlkIGlzc3VlZC1hdCB0aW1lLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXHJcbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXHJcbiAqL1xyXG5jb25zdCBpc1ZhbGlkRm9ybWF0ID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlKHRva2VuKSwgY2xhaW1zID0gZGVjb2RlZC5jbGFpbXM7XHJcbiAgICByZXR1cm4gISFjbGFpbXMgJiYgdHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKTtcclxufTtcclxuLyoqXHJcbiAqIEF0dGVtcHRzIHRvIHBlZXIgaW50byBhbiBhdXRoIHRva2VuIGFuZCBkZXRlcm1pbmUgaWYgaXQncyBhbiBhZG1pbiBhdXRoIHRva2VuIGJ5IGxvb2tpbmcgYXQgdGhlIGNsYWltcyBwb3J0aW9uLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXHJcbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXHJcbiAqL1xyXG5jb25zdCBpc0FkbWluID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBjb25zdCBjbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcclxuICAgIHJldHVybiB0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXNbJ2FkbWluJ10gPT09IHRydWU7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGNvbnRhaW5zKG9iaiwga2V5KSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcclxufVxyXG5mdW5jdGlvbiBzYWZlR2V0KG9iaiwga2V5KSB7XHJcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgIHJldHVybiBvYmpba2V5XTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBtYXAob2JqLCBmbiwgY29udGV4dE9iaikge1xyXG4gICAgY29uc3QgcmVzID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgICByZXNba2V5XSA9IGZuLmNhbGwoY29udGV4dE9iaiwgb2JqW2tleV0sIGtleSwgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbi8qKlxyXG4gKiBEZWVwIGVxdWFsIHR3byBvYmplY3RzLiBTdXBwb3J0IEFycmF5cyBhbmQgT2JqZWN0cy5cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XHJcbiAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcclxuICAgIGNvbnN0IGJLZXlzID0gT2JqZWN0LmtleXMoYik7XHJcbiAgICBmb3IgKGNvbnN0IGsgb2YgYUtleXMpIHtcclxuICAgICAgICBpZiAoIWJLZXlzLmluY2x1ZGVzKGspKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYVByb3AgPSBhW2tdO1xyXG4gICAgICAgIGNvbnN0IGJQcm9wID0gYltrXTtcclxuICAgICAgICBpZiAoaXNPYmplY3QoYVByb3ApICYmIGlzT2JqZWN0KGJQcm9wKSkge1xyXG4gICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChhUHJvcCwgYlByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYVByb3AgIT09IGJQcm9wKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGsgb2YgYktleXMpIHtcclxuICAgICAgICBpZiAoIWFLZXlzLmluY2x1ZGVzKGspKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBpc09iamVjdCh0aGluZykge1xyXG4gICAgcmV0dXJuIHRoaW5nICE9PSBudWxsICYmIHR5cGVvZiB0aGluZyA9PT0gJ29iamVjdCc7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJlamVjdHMgaWYgdGhlIGdpdmVuIHByb21pc2UgZG9lc24ndCByZXNvbHZlIGluIHRpbWVJbk1TIG1pbGxpc2Vjb25kcy5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBwcm9taXNlV2l0aFRpbWVvdXQocHJvbWlzZSwgdGltZUluTVMgPSAyMDAwKSB7XHJcbiAgICBjb25zdCBkZWZlcnJlZFByb21pc2UgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4gZGVmZXJyZWRQcm9taXNlLnJlamVjdCgndGltZW91dCEnKSwgdGltZUluTVMpO1xyXG4gICAgcHJvbWlzZS50aGVuKGRlZmVycmVkUHJvbWlzZS5yZXNvbHZlLCBkZWZlcnJlZFByb21pc2UucmVqZWN0KTtcclxuICAgIHJldHVybiBkZWZlcnJlZFByb21pc2UucHJvbWlzZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyBhIHF1ZXJ5c3RyaW5nLWZvcm1hdHRlZCBzdHJpbmcgKGUuZy4gJmFyZz12YWwmYXJnMj12YWwyKSBmcm9tIGFcclxuICogcGFyYW1zIG9iamVjdCAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcclxuICogTm90ZTogWW91IG11c3QgcHJlcGVuZCBpdCB3aXRoID8gd2hlbiBhZGRpbmcgaXQgdG8gYSBVUkwuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeXN0cmluZ1BhcmFtcykge1xyXG4gICAgY29uc3QgcGFyYW1zID0gW107XHJcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhxdWVyeXN0cmluZ1BhcmFtcykpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChhcnJheVZhbCA9PiB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChhcnJheVZhbCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcmFtcy5sZW5ndGggPyAnJicgKyBwYXJhbXMuam9pbignJicpIDogJyc7XHJcbn1cclxuLyoqXHJcbiAqIERlY29kZXMgYSBxdWVyeXN0cmluZyAoZS5nLiA/YXJnPXZhbCZhcmcyPXZhbDIpIGludG8gYSBwYXJhbXMgb2JqZWN0XHJcbiAqIChlLmcuIHthcmc6ICd2YWwnLCBhcmcyOiAndmFsMid9KVxyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnlzdHJpbmdEZWNvZGUocXVlcnlzdHJpbmcpIHtcclxuICAgIGNvbnN0IG9iaiA9IHt9O1xyXG4gICAgY29uc3QgdG9rZW5zID0gcXVlcnlzdHJpbmcucmVwbGFjZSgvXlxcPy8sICcnKS5zcGxpdCgnJicpO1xyXG4gICAgdG9rZW5zLmZvckVhY2godG9rZW4gPT4ge1xyXG4gICAgICAgIGlmICh0b2tlbikge1xyXG4gICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSB0b2tlbi5zcGxpdCgnPScpO1xyXG4gICAgICAgICAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KGtleSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBvYmo7XHJcbn1cclxuLyoqXHJcbiAqIEV4dHJhY3QgdGhlIHF1ZXJ5IHN0cmluZyBwYXJ0IG9mIGEgVVJMLCBpbmNsdWRpbmcgdGhlIGxlYWRpbmcgcXVlc3Rpb24gbWFyayAoaWYgcHJlc2VudCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0UXVlcnlzdHJpbmcodXJsKSB7XHJcbiAgICBjb25zdCBxdWVyeVN0YXJ0ID0gdXJsLmluZGV4T2YoJz8nKTtcclxuICAgIGlmICghcXVlcnlTdGFydCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIGNvbnN0IGZyYWdtZW50U3RhcnQgPSB1cmwuaW5kZXhPZignIycsIHF1ZXJ5U3RhcnQpO1xyXG4gICAgcmV0dXJuIHVybC5zdWJzdHJpbmcocXVlcnlTdGFydCwgZnJhZ21lbnRTdGFydCA+IDAgPyBmcmFnbWVudFN0YXJ0IDogdW5kZWZpbmVkKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBTSEEtMSBjcnlwdG9ncmFwaGljIGhhc2guXHJcbiAqIFZhcmlhYmxlIG5hbWVzIGZvbGxvdyB0aGUgbm90YXRpb24gaW4gRklQUyBQVUIgMTgwLTM6XHJcbiAqIGh0dHA6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9maXBzL2ZpcHMxODAtMy9maXBzMTgwLTNfZmluYWwucGRmLlxyXG4gKlxyXG4gKiBVc2FnZTpcclxuICogICB2YXIgc2hhMSA9IG5ldyBzaGExKCk7XHJcbiAqICAgc2hhMS51cGRhdGUoYnl0ZXMpO1xyXG4gKiAgIHZhciBoYXNoID0gc2hhMS5kaWdlc3QoKTtcclxuICpcclxuICogUGVyZm9ybWFuY2U6XHJcbiAqICAgQ2hyb21lIDIzOiAgIH40MDAgTWJpdC9zXHJcbiAqICAgRmlyZWZveCAxNjogIH4yNTAgTWJpdC9zXHJcbiAqXHJcbiAqL1xyXG4vKipcclxuICogU0hBLTEgY3J5cHRvZ3JhcGhpYyBoYXNoIGNvbnN0cnVjdG9yLlxyXG4gKlxyXG4gKiBUaGUgcHJvcGVydGllcyBkZWNsYXJlZCBoZXJlIGFyZSBkaXNjdXNzZWQgaW4gdGhlIGFib3ZlIGFsZ29yaXRobSBkb2N1bWVudC5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBmaW5hbFxyXG4gKiBAc3RydWN0XHJcbiAqL1xyXG5jbGFzcyBTaGExIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhvbGRzIHRoZSBwcmV2aW91cyB2YWx1ZXMgb2YgYWNjdW11bGF0ZWQgdmFyaWFibGVzIGEtZSBpbiB0aGUgY29tcHJlc3NfXHJcbiAgICAgICAgICogZnVuY3Rpb24uXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNoYWluXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgYnVmZmVyIGhvbGRpbmcgdGhlIHBhcnRpYWxseSBjb21wdXRlZCBoYXNoIHJlc3VsdC5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYnVmXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGFycmF5IG9mIDgwIGJ5dGVzLCBlYWNoIGEgcGFydCBvZiB0aGUgbWVzc2FnZSB0byBiZSBoYXNoZWQuICBSZWZlcnJlZCB0b1xyXG4gICAgICAgICAqIGFzIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGluIHRoZSBkb2NzLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5XXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnRhaW5zIGRhdGEgbmVlZGVkIHRvIHBhZCBtZXNzYWdlcyBsZXNzIHRoYW4gNjQgYnl0ZXMuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBhZF8gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaW5idWZfID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudG90YWxfID0gMDtcclxuICAgICAgICB0aGlzLmJsb2NrU2l6ZSA9IDUxMiAvIDg7XHJcbiAgICAgICAgdGhpcy5wYWRfWzBdID0gMTI4O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5ibG9ja1NpemU7ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLnBhZF9baV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLmNoYWluX1swXSA9IDB4Njc0NTIzMDE7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMV0gPSAweGVmY2RhYjg5O1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzJdID0gMHg5OGJhZGNmZTtcclxuICAgICAgICB0aGlzLmNoYWluX1szXSA9IDB4MTAzMjU0NzY7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bNF0gPSAweGMzZDJlMWYwO1xyXG4gICAgICAgIHRoaXMuaW5idWZfID0gMDtcclxuICAgICAgICB0aGlzLnRvdGFsXyA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIGNvbXByZXNzIGhlbHBlciBmdW5jdGlvbi5cclxuICAgICAqIEBwYXJhbSBidWYgQmxvY2sgdG8gY29tcHJlc3MuXHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IE9mZnNldCBvZiB0aGUgYmxvY2sgaW4gdGhlIGJ1ZmZlci5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNvbXByZXNzXyhidWYsIG9mZnNldCkge1xyXG4gICAgICAgIGlmICghb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IFcgPSB0aGlzLldfO1xyXG4gICAgICAgIC8vIGdldCAxNiBiaWcgZW5kaWFuIHdvcmRzXHJcbiAgICAgICAgaWYgKHR5cGVvZiBidWYgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyh1c2VyKTogW2J1ZyA4MTQwMTIyXSBSZWNlbnQgdmVyc2lvbnMgb2YgU2FmYXJpIGZvciBNYWMgT1MgYW5kIGlPU1xyXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBhIGJ1ZyB0aGF0IHR1cm5zIHRoZSBwb3N0LWluY3JlbWVudCArKyBvcGVyYXRvciBpbnRvIHByZS1pbmNyZW1lbnRcclxuICAgICAgICAgICAgICAgIC8vIGR1cmluZyBKSVQgY29tcGlsYXRpb24uICBXZSBoYXZlIGNvZGUgdGhhdCBkZXBlbmRzIGhlYXZpbHkgb24gU0hBLTEgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0bmVzcyBhbmQgd2hpY2ggaXMgYWZmZWN0ZWQgYnkgdGhpcyBidWcsIHNvIEkndmUgcmVtb3ZlZCBhbGwgdXNlc1xyXG4gICAgICAgICAgICAgICAgLy8gb2YgcG9zdC1pbmNyZW1lbnQgKysgaW4gd2hpY2ggdGhlIHJlc3VsdCB2YWx1ZSBpcyB1c2VkLiAgV2UgY2FuIHJldmVydFxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjaGFuZ2Ugb25jZSB0aGUgU2FmYXJpIGJ1Z1xyXG4gICAgICAgICAgICAgICAgLy8gKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDkwMzYpIGhhcyBiZWVuIGZpeGVkIGFuZFxyXG4gICAgICAgICAgICAgICAgLy8gbW9zdCBjbGllbnRzIGhhdmUgYmVlbiB1cGRhdGVkLlxyXG4gICAgICAgICAgICAgICAgV1tpXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCkgPDwgMjQpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCArIDEpIDw8IDE2KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWYuY2hhckNvZGVBdChvZmZzZXQgKyAyKSA8PCA4KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCArIDMpO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgV1tpXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgKGJ1ZltvZmZzZXRdIDw8IDI0KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWZbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZltvZmZzZXQgKyAyXSA8PCA4KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZltvZmZzZXQgKyAzXTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGV4cGFuZCB0byA4MCB3b3Jkc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl07XHJcbiAgICAgICAgICAgIFdbaV0gPSAoKHQgPDwgMSkgfCAodCA+Pj4gMzEpKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBhID0gdGhpcy5jaGFpbl9bMF07XHJcbiAgICAgICAgbGV0IGIgPSB0aGlzLmNoYWluX1sxXTtcclxuICAgICAgICBsZXQgYyA9IHRoaXMuY2hhaW5fWzJdO1xyXG4gICAgICAgIGxldCBkID0gdGhpcy5jaGFpbl9bM107XHJcbiAgICAgICAgbGV0IGUgPSB0aGlzLmNoYWluX1s0XTtcclxuICAgICAgICBsZXQgZiwgaztcclxuICAgICAgICAvLyBUT0RPKHVzZXIpOiBUcnkgdG8gdW5yb2xsIHRoaXMgbG9vcCB0byBzcGVlZCB1cCB0aGUgY29tcHV0YXRpb24uXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpIDwgNDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChpIDwgMjApIHtcclxuICAgICAgICAgICAgICAgICAgICBmID0gZCBeIChiICYgKGMgXiBkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4NWE4Mjc5OTk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmID0gYiBeIGMgXiBkO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDZlZDllYmExO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCA2MCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGYgPSAoYiAmIGMpIHwgKGQgJiAoYiB8IGMpKTtcclxuICAgICAgICAgICAgICAgICAgICBrID0gMHg4ZjFiYmNkYztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4Y2E2MmMxZDY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdCA9ICgoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgayArIFdbaV0pICYgMHhmZmZmZmZmZjtcclxuICAgICAgICAgICAgZSA9IGQ7XHJcbiAgICAgICAgICAgIGQgPSBjO1xyXG4gICAgICAgICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgICAgICBiID0gYTtcclxuICAgICAgICAgICAgYSA9IHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2hhaW5fWzBdID0gKHRoaXMuY2hhaW5fWzBdICsgYSkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzFdID0gKHRoaXMuY2hhaW5fWzFdICsgYikgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzJdID0gKHRoaXMuY2hhaW5fWzJdICsgYykgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzNdID0gKHRoaXMuY2hhaW5fWzNdICsgZCkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzRdID0gKHRoaXMuY2hhaW5fWzRdICsgZSkgJiAweGZmZmZmZmZmO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGJ5dGVzLCBsZW5ndGgpIHtcclxuICAgICAgICAvLyBUT0RPKGpvaG5sZW56KTogdGlnaHRlbiB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlIGFuZCByZW1vdmUgdGhpcyBjaGVja1xyXG4gICAgICAgIGlmIChieXRlcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoTWludXNCbG9jayA9IGxlbmd0aCAtIHRoaXMuYmxvY2tTaXplO1xyXG4gICAgICAgIGxldCBuID0gMDtcclxuICAgICAgICAvLyBVc2luZyBsb2NhbCBpbnN0ZWFkIG9mIG1lbWJlciB2YXJpYWJsZXMgZ2l2ZXMgfjUlIHNwZWVkdXAgb24gRmlyZWZveCAxNi5cclxuICAgICAgICBjb25zdCBidWYgPSB0aGlzLmJ1Zl87XHJcbiAgICAgICAgbGV0IGluYnVmID0gdGhpcy5pbmJ1Zl87XHJcbiAgICAgICAgLy8gVGhlIG91dGVyIHdoaWxlIGxvb3Agc2hvdWxkIGV4ZWN1dGUgYXQgbW9zdCB0d2ljZS5cclxuICAgICAgICB3aGlsZSAobiA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGhhdmUgbm8gZGF0YSBpbiB0aGUgYmxvY2sgdG8gdG9wIHVwLCB3ZSBjYW4gZGlyZWN0bHkgcHJvY2VzcyB0aGVcclxuICAgICAgICAgICAgLy8gaW5wdXQgYnVmZmVyIChhc3N1bWluZyBpdCBjb250YWlucyBzdWZmaWNpZW50IGRhdGEpLiBUaGlzIGdpdmVzIH4yNSVcclxuICAgICAgICAgICAgLy8gc3BlZWR1cCBvbiBDaHJvbWUgMjMgYW5kIH4xNSUgc3BlZWR1cCBvbiBGaXJlZm94IDE2LCBidXQgcmVxdWlyZXMgdGhhdFxyXG4gICAgICAgICAgICAvLyB0aGUgZGF0YSBpcyBwcm92aWRlZCBpbiBsYXJnZSBjaHVua3MgKG9yIGluIG11bHRpcGxlcyBvZiA2NCBieXRlcykuXHJcbiAgICAgICAgICAgIGlmIChpbmJ1ZiA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPD0gbGVuZ3RoTWludXNCbG9jaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ5dGVzLCBuKTtcclxuICAgICAgICAgICAgICAgICAgICBuICs9IHRoaXMuYmxvY2tTaXplO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZltpbmJ1Zl0gPSBieXRlcy5jaGFyQ29kZUF0KG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICsraW5idWY7XHJcbiAgICAgICAgICAgICAgICAgICAgKytuO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmJ1ZiA9PT0gdGhpcy5ibG9ja1NpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnVmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5idWYgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKdW1wIHRvIHRoZSBvdXRlciBsb29wIHNvIHdlIHVzZSB0aGUgZnVsbC1ibG9jayBvcHRpbWl6YXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzW25dO1xyXG4gICAgICAgICAgICAgICAgICAgICsraW5idWY7XHJcbiAgICAgICAgICAgICAgICAgICAgKytuO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmJ1ZiA9PT0gdGhpcy5ibG9ja1NpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnVmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5idWYgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKdW1wIHRvIHRoZSBvdXRlciBsb29wIHNvIHdlIHVzZSB0aGUgZnVsbC1ibG9jayBvcHRpbWl6YXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmluYnVmXyA9IGluYnVmO1xyXG4gICAgICAgIHRoaXMudG90YWxfICs9IGxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cclxuICAgIGRpZ2VzdCgpIHtcclxuICAgICAgICBjb25zdCBkaWdlc3QgPSBbXTtcclxuICAgICAgICBsZXQgdG90YWxCaXRzID0gdGhpcy50b3RhbF8gKiA4O1xyXG4gICAgICAgIC8vIEFkZCBwYWQgMHg4MCAweDAwKi5cclxuICAgICAgICBpZiAodGhpcy5pbmJ1Zl8gPCA1Nikge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLnBhZF8sIDU2IC0gdGhpcy5pbmJ1Zl8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUodGhpcy5wYWRfLCB0aGlzLmJsb2NrU2l6ZSAtICh0aGlzLmluYnVmXyAtIDU2KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkZCAjIGJpdHMuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYmxvY2tTaXplIC0gMTsgaSA+PSA1NjsgaS0tKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmX1tpXSA9IHRvdGFsQml0cyAmIDI1NTtcclxuICAgICAgICAgICAgdG90YWxCaXRzIC89IDI1NjsgLy8gRG9uJ3QgdXNlIGJpdC1zaGlmdGluZyBoZXJlIVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbXByZXNzXyh0aGlzLmJ1Zl8pO1xyXG4gICAgICAgIGxldCBuID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMjQ7IGogPj0gMDsgaiAtPSA4KSB7XHJcbiAgICAgICAgICAgICAgICBkaWdlc3Rbbl0gPSAodGhpcy5jaGFpbl9baV0gPj4gaikgJiAyNTU7XHJcbiAgICAgICAgICAgICAgICArK247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpZ2VzdDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogSGVscGVyIHRvIG1ha2UgYSBTdWJzY3JpYmUgZnVuY3Rpb24gKGp1c3QgbGlrZSBQcm9taXNlIGhlbHBzIG1ha2UgYVxyXG4gKiBUaGVuYWJsZSkuXHJcbiAqXHJcbiAqIEBwYXJhbSBleGVjdXRvciBGdW5jdGlvbiB3aGljaCBjYW4gbWFrZSBjYWxscyB0byBhIHNpbmdsZSBPYnNlcnZlclxyXG4gKiAgICAgYXMgYSBwcm94eS5cclxuICogQHBhcmFtIG9uTm9PYnNlcnZlcnMgQ2FsbGJhY2sgd2hlbiBjb3VudCBvZiBPYnNlcnZlcnMgZ29lcyB0byB6ZXJvLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlU3Vic2NyaWJlKGV4ZWN1dG9yLCBvbk5vT2JzZXJ2ZXJzKSB7XHJcbiAgICBjb25zdCBwcm94eSA9IG5ldyBPYnNlcnZlclByb3h5KGV4ZWN1dG9yLCBvbk5vT2JzZXJ2ZXJzKTtcclxuICAgIHJldHVybiBwcm94eS5zdWJzY3JpYmUuYmluZChwcm94eSk7XHJcbn1cclxuLyoqXHJcbiAqIEltcGxlbWVudCBmYW4tb3V0IGZvciBhbnkgbnVtYmVyIG9mIE9ic2VydmVycyBhdHRhY2hlZCB2aWEgYSBzdWJzY3JpYmVcclxuICogZnVuY3Rpb24uXHJcbiAqL1xyXG5jbGFzcyBPYnNlcnZlclByb3h5IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGV4ZWN1dG9yIEZ1bmN0aW9uIHdoaWNoIGNhbiBtYWtlIGNhbGxzIHRvIGEgc2luZ2xlIE9ic2VydmVyXHJcbiAgICAgKiAgICAgYXMgYSBwcm94eS5cclxuICAgICAqIEBwYXJhbSBvbk5vT2JzZXJ2ZXJzIENhbGxiYWNrIHdoZW4gY291bnQgb2YgT2JzZXJ2ZXJzIGdvZXMgdG8gemVyby5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpIHtcclxuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVzID0gW107XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlckNvdW50ID0gMDtcclxuICAgICAgICAvLyBNaWNyby10YXNrIHNjaGVkdWxpbmcgYnkgY2FsbGluZyB0YXNrLnRoZW4oKS5cclxuICAgICAgICB0aGlzLnRhc2sgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMub25Ob09ic2VydmVycyA9IG9uTm9PYnNlcnZlcnM7XHJcbiAgICAgICAgLy8gQ2FsbCB0aGUgZXhlY3V0b3IgYXN5bmNocm9ub3VzbHkgc28gc3Vic2NyaWJlcnMgdGhhdCBhcmUgY2FsbGVkXHJcbiAgICAgICAgLy8gc3luY2hyb25vdXNseSBhZnRlciB0aGUgY3JlYXRpb24gb2YgdGhlIHN1YnNjcmliZSBmdW5jdGlvblxyXG4gICAgICAgIC8vIGNhbiBzdGlsbCByZWNlaXZlIHRoZSB2ZXJ5IGZpcnN0IHZhbHVlIGdlbmVyYXRlZCBpbiB0aGUgZXhlY3V0b3IuXHJcbiAgICAgICAgdGhpcy50YXNrXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgZXhlY3V0b3IodGhpcyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yKGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbmV4dCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcikgPT4ge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVycm9yKGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyKSA9PiB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNsb3NlKGVycm9yKTtcclxuICAgIH1cclxuICAgIGNvbXBsZXRlKCkge1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcikgPT4ge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWRkIGFuIE9ic2VydmVyIHRvIHRoZSBmYW4tb3V0IGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogLSBXZSByZXF1aXJlIHRoYXQgbm8gZXZlbnQgaXMgc2VudCB0byBhIHN1YnNjcmliZXIgc3ljaHJvbm91c2x5IHRvIHRoZWlyXHJcbiAgICAgKiAgIGNhbGwgdG8gc3Vic2NyaWJlKCkuXHJcbiAgICAgKi9cclxuICAgIHN1YnNjcmliZShuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XHJcbiAgICAgICAgbGV0IG9ic2VydmVyO1xyXG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlciA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIGVycm9yID09PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgY29tcGxldGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgT2JzZXJ2ZXIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFzc2VtYmxlIGFuIE9ic2VydmVyIG9iamVjdCB3aGVuIHBhc3NlZCBhcyBjYWxsYmFjayBmdW5jdGlvbnMuXHJcbiAgICAgICAgaWYgKGltcGxlbWVudHNBbnlNZXRob2RzKG5leHRPck9ic2VydmVyLCBbXHJcbiAgICAgICAgICAgICduZXh0JyxcclxuICAgICAgICAgICAgJ2Vycm9yJyxcclxuICAgICAgICAgICAgJ2NvbXBsZXRlJ1xyXG4gICAgICAgIF0pKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyID0gbmV4dE9yT2JzZXJ2ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvYnNlcnZlciA9IHtcclxuICAgICAgICAgICAgICAgIG5leHQ6IG5leHRPck9ic2VydmVyLFxyXG4gICAgICAgICAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgPSBub29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JzZXJ2ZXIuZXJyb3IgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvciA9IG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYnNlcnZlci5jb21wbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlID0gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdW5zdWIgPSB0aGlzLnVuc3Vic2NyaWJlT25lLmJpbmQodGhpcywgdGhpcy5vYnNlcnZlcnMubGVuZ3RoKTtcclxuICAgICAgICAvLyBBdHRlbXB0IHRvIHN1YnNjcmliZSB0byBhIHRlcm1pbmF0ZWQgT2JzZXJ2YWJsZSAtIHdlXHJcbiAgICAgICAgLy8ganVzdCByZXNwb25kIHRvIHRoZSBPYnNlcnZlciB3aXRoIHRoZSBmaW5hbCBlcnJvciBvciBjb21wbGV0ZVxyXG4gICAgICAgIC8vIGV2ZW50LlxyXG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICAgICAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluYWxFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcih0aGlzLmZpbmFsRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xyXG4gICAgICAgIHJldHVybiB1bnN1YjtcclxuICAgIH1cclxuICAgIC8vIFVuc3Vic2NyaWJlIGlzIHN5bmNocm9ub3VzIC0gd2UgZ3VhcmFudGVlIHRoYXQgbm8gZXZlbnRzIGFyZSBzZW50IHRvXHJcbiAgICAvLyBhbnkgdW5zdWJzY3JpYmVkIE9ic2VydmVyLlxyXG4gICAgdW5zdWJzY3JpYmVPbmUoaSkge1xyXG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVycyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub2JzZXJ2ZXJzW2ldID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgdGhpcy5vYnNlcnZlcnNbaV07XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlckNvdW50IC09IDE7XHJcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJDb3VudCA9PT0gMCAmJiB0aGlzLm9uTm9PYnNlcnZlcnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnModGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yRWFjaE9ic2VydmVyKGZuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XHJcbiAgICAgICAgICAgIC8vIEFscmVhZHkgY2xvc2VkIGJ5IHByZXZpb3VzIGV2ZW50Li4uLmp1c3QgZWF0IHRoZSBhZGRpdGlvbmFsIHZhbHVlcy5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTaW5jZSBzZW5kT25lIGNhbGxzIGFzeW5jaHJvbm91c2x5IC0gdGhlcmUgaXMgbm8gY2hhbmNlIHRoYXRcclxuICAgICAgICAvLyB0aGlzLm9ic2VydmVycyB3aWxsIGJlY29tZSB1bmRlZmluZWQuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9ic2VydmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRPbmUoaSwgZm4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIENhbGwgdGhlIE9ic2VydmVyIHZpYSBvbmUgb2YgaXQncyBjYWxsYmFjayBmdW5jdGlvbi4gV2UgYXJlIGNhcmVmdWwgdG9cclxuICAgIC8vIGNvbmZpcm0gdGhhdCB0aGUgb2JzZXJ2ZSBoYXMgbm90IGJlZW4gdW5zdWJzY3JpYmVkIHNpbmNlIHRoaXMgYXN5bmNocm9ub3VzXHJcbiAgICAvLyBmdW5jdGlvbiBoYWQgYmVlbiBxdWV1ZWQuXHJcbiAgICBzZW5kT25lKGksIGZuKSB7XHJcbiAgICAgICAgLy8gRXhlY3V0ZSB0aGUgY2FsbGJhY2sgYXN5bmNocm9ub3VzbHlcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICAgICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vYnNlcnZlcnMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9ic2VydmVyc1tpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZuKHRoaXMub2JzZXJ2ZXJzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGV4Y2VwdGlvbnMgcmFpc2VkIGluIE9ic2VydmVycyBvciBtaXNzaW5nIG1ldGhvZHMgb2YgYW5cclxuICAgICAgICAgICAgICAgICAgICAvLyBPYnNlcnZlci5cclxuICAgICAgICAgICAgICAgICAgICAvLyBMb2cgZXJyb3IgdG8gY29uc29sZS4gYi8zMTQwNDgwNlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY2xvc2UoZXJyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmIChlcnIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmZpbmFsRXJyb3IgPSBlcnI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByb3h5IGlzIG5vIGxvbmdlciBuZWVkZWQgLSBnYXJiYWdlIGNvbGxlY3QgcmVmZXJlbmNlc1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqIFR1cm4gc3luY2hyb25vdXMgZnVuY3Rpb24gaW50byBvbmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5LiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xyXG5mdW5jdGlvbiBhc3luYyhmbiwgb25FcnJvcikge1xyXG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHRydWUpXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgZm4oLi4uYXJncyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xyXG4gICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBvYmplY3QgcGFzc2VkIGluIGltcGxlbWVudHMgYW55IG9mIHRoZSBuYW1lZCBtZXRob2RzLlxyXG4gKi9cclxuZnVuY3Rpb24gaW1wbGVtZW50c0FueU1ldGhvZHMob2JqLCBtZXRob2RzKSB7XHJcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xyXG4gICAgICAgIGlmIChtZXRob2QgaW4gb2JqICYmIHR5cGVvZiBvYmpbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gbm9vcCgpIHtcclxuICAgIC8vIGRvIG5vdGhpbmdcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBhcHByb3ByaWF0ZSBudW1iZXIgb2YgYXJndW1lbnRzIGFyZSBwcm92aWRlZCBmb3IgYSBwdWJsaWMgZnVuY3Rpb24uXHJcbiAqIFRocm93cyBhbiBlcnJvciBpZiBpdCBmYWlscy5cclxuICpcclxuICogQHBhcmFtIGZuTmFtZSBUaGUgZnVuY3Rpb24gbmFtZVxyXG4gKiBAcGFyYW0gbWluQ291bnQgVGhlIG1pbmltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBhbGxvdyBmb3IgdGhlIGZ1bmN0aW9uIGNhbGxcclxuICogQHBhcmFtIG1heENvdW50IFRoZSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudCB0byBhbGxvdyBmb3IgdGhlIGZ1bmN0aW9uIGNhbGxcclxuICogQHBhcmFtIGFyZ0NvdW50IFRoZSBhY3R1YWwgbnVtYmVyIG9mIGFyZ3VtZW50cyBwcm92aWRlZC5cclxuICovXHJcbmNvbnN0IHZhbGlkYXRlQXJnQ291bnQgPSBmdW5jdGlvbiAoZm5OYW1lLCBtaW5Db3VudCwgbWF4Q291bnQsIGFyZ0NvdW50KSB7XHJcbiAgICBsZXQgYXJnRXJyb3I7XHJcbiAgICBpZiAoYXJnQ291bnQgPCBtaW5Db3VudCkge1xyXG4gICAgICAgIGFyZ0Vycm9yID0gJ2F0IGxlYXN0ICcgKyBtaW5Db3VudDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFyZ0NvdW50ID4gbWF4Q291bnQpIHtcclxuICAgICAgICBhcmdFcnJvciA9IG1heENvdW50ID09PSAwID8gJ25vbmUnIDogJ25vIG1vcmUgdGhhbiAnICsgbWF4Q291bnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoYXJnRXJyb3IpIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IGZuTmFtZSArXHJcbiAgICAgICAgICAgICcgZmFpbGVkOiBXYXMgY2FsbGVkIHdpdGggJyArXHJcbiAgICAgICAgICAgIGFyZ0NvdW50ICtcclxuICAgICAgICAgICAgKGFyZ0NvdW50ID09PSAxID8gJyBhcmd1bWVudC4nIDogJyBhcmd1bWVudHMuJykgK1xyXG4gICAgICAgICAgICAnIEV4cGVjdHMgJyArXHJcbiAgICAgICAgICAgIGFyZ0Vycm9yICtcclxuICAgICAgICAgICAgJy4nO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBzdHJpbmcgdG8gcHJlZml4IGFuIGVycm9yIG1lc3NhZ2UgYWJvdXQgZmFpbGVkIGFyZ3VtZW50IHZhbGlkYXRpb25cclxuICpcclxuICogQHBhcmFtIGZuTmFtZSBUaGUgZnVuY3Rpb24gbmFtZVxyXG4gKiBAcGFyYW0gYXJnTmFtZSBUaGUgbmFtZSBvZiB0aGUgYXJndW1lbnRcclxuICogQHJldHVybiBUaGUgcHJlZml4IHRvIGFkZCB0byB0aGUgZXJyb3IgdGhyb3duIGZvciB2YWxpZGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmdOYW1lKSB7XHJcbiAgICByZXR1cm4gYCR7Zm5OYW1lfSBmYWlsZWQ6ICR7YXJnTmFtZX0gYXJndW1lbnQgYDtcclxufVxyXG4vKipcclxuICogQHBhcmFtIGZuTmFtZVxyXG4gKiBAcGFyYW0gYXJndW1lbnROdW1iZXJcclxuICogQHBhcmFtIG5hbWVzcGFjZVxyXG4gKiBAcGFyYW0gb3B0aW9uYWxcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlTmFtZXNwYWNlKGZuTmFtZSwgbmFtZXNwYWNlLCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmICFuYW1lc3BhY2UpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAvL1RPRE86IEkgc2hvdWxkIGRvIG1vcmUgdmFsaWRhdGlvbiBoZXJlLiBXZSBvbmx5IGFsbG93IGNlcnRhaW4gY2hhcnMgaW4gbmFtZXNwYWNlcy5cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCAnbmFtZXNwYWNlJykgKyAnbXVzdCBiZSBhIHZhbGlkIGZpcmViYXNlIG5hbWVzcGFjZS4nKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZUNhbGxiYWNrKGZuTmFtZSwgYXJndW1lbnROYW1lLCBcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcclxuY2FsbGJhY2ssIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgIWNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TmFtZSkgKyAnbXVzdCBiZSBhIHZhbGlkIGZ1bmN0aW9uLicpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ29udGV4dE9iamVjdChmbk5hbWUsIGFyZ3VtZW50TmFtZSwgY29udGV4dCwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiAhY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcgfHwgY29udGV4dCA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TmFtZSkgKyAnbXVzdCBiZSBhIHZhbGlkIGNvbnRleHQgb2JqZWN0LicpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIENvZGUgb3JpZ2luYWxseSBjYW1lIGZyb20gZ29vZy5jcnlwdC5zdHJpbmdUb1V0ZjhCeXRlQXJyYXksIGJ1dCBmb3Igc29tZSByZWFzb24gdGhleVxyXG4vLyBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkICdcXHJcXG4nIHdpdGggJ1xcbicsIGFuZCB0aGV5IGRpZG4ndCBoYW5kbGUgc3Vycm9nYXRlIHBhaXJzLFxyXG4vLyBzbyBpdCdzIGJlZW4gbW9kaWZpZWQuXHJcbi8vIE5vdGUgdGhhdCBub3QgYWxsIFVuaWNvZGUgY2hhcmFjdGVycyBhcHBlYXIgYXMgc2luZ2xlIGNoYXJhY3RlcnMgaW4gSmF2YVNjcmlwdCBzdHJpbmdzLlxyXG4vLyBmcm9tQ2hhckNvZGUgcmV0dXJucyB0aGUgVVRGLTE2IGVuY29kaW5nIG9mIGEgY2hhcmFjdGVyIC0gc28gc29tZSBVbmljb2RlIGNoYXJhY3RlcnNcclxuLy8gdXNlIDIgY2hhcmFjdGVycyBpbiBKYXZhc2NyaXB0LiAgQWxsIDQtYnl0ZSBVVEYtOCBjaGFyYWN0ZXJzIGJlZ2luIHdpdGggYSBmaXJzdFxyXG4vLyBjaGFyYWN0ZXIgaW4gdGhlIHJhbmdlIDB4RDgwMCAtIDB4REJGRiAodGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHNvLWNhbGxlZCBzdXJyb2dhdGVcclxuLy8gcGFpcikuXHJcbi8vIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtMTUuMS4zXHJcbi8qKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKi9cclxuY29uc3Qgc3RyaW5nVG9CeXRlQXJyYXkgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICBjb25zdCBvdXQgPSBbXTtcclxuICAgIGxldCBwID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICAvLyBJcyB0aGlzIHRoZSBsZWFkIHN1cnJvZ2F0ZSBpbiBhIHN1cnJvZ2F0ZSBwYWlyP1xyXG4gICAgICAgIGlmIChjID49IDB4ZDgwMCAmJiBjIDw9IDB4ZGJmZikge1xyXG4gICAgICAgICAgICBjb25zdCBoaWdoID0gYyAtIDB4ZDgwMDsgLy8gdGhlIGhpZ2ggMTAgYml0cy5cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICBhc3NlcnQoaSA8IHN0ci5sZW5ndGgsICdTdXJyb2dhdGUgcGFpciBtaXNzaW5nIHRyYWlsIHN1cnJvZ2F0ZS4nKTtcclxuICAgICAgICAgICAgY29uc3QgbG93ID0gc3RyLmNoYXJDb2RlQXQoaSkgLSAweGRjMDA7IC8vIHRoZSBsb3cgMTAgYml0cy5cclxuICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoaGlnaCA8PCAxMCkgKyBsb3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gYztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiA2KSB8IDE5MjtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IDY1NTM2KSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTIpIHwgMjI0O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTgpIHwgMjQwO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiAxMikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgbGVuZ3RoIHdpdGhvdXQgYWN0dWFsbHkgY29udmVydGluZzsgdXNlZnVsIGZvciBkb2luZyBjaGVhcGVyIHZhbGlkYXRpb24uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICogQHJldHVybiB7bnVtYmVyfVxyXG4gKi9cclxuY29uc3Qgc3RyaW5nTGVuZ3RoID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgbGV0IHAgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcclxuICAgICAgICAgICAgcCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xyXG4gICAgICAgICAgICBwICs9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XHJcbiAgICAgICAgICAgIC8vIExlYWQgc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuICBUaGUgcGFpciB0b2dldGhlciB3aWxsIHRha2UgNCBieXRlcyB0byByZXByZXNlbnQuXHJcbiAgICAgICAgICAgIHAgKz0gNDtcclxuICAgICAgICAgICAgaSsrOyAvLyBza2lwIHRyYWlsIHN1cnJvZ2F0ZS5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHAgKz0gMztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcDtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENvcGllZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMTE3NTIzXHJcbiAqIEdlbmVyYXRlcyBhIG5ldyB1dWlkLlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCB1dWlkdjQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBjID0+IHtcclxuICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4ODtcclxuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XHJcbiAgICB9KTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIGV4cG9uZW50aWFsbHkgaW5jcmVhc2UuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0lOVEVSVkFMX01JTExJUyA9IDEwMDA7XHJcbi8qKlxyXG4gKiBUaGUgZmFjdG9yIHRvIGJhY2tvZmYgYnkuXHJcbiAqIFNob3VsZCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMS5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfQkFDS09GRl9GQUNUT1IgPSAyO1xyXG4vKipcclxuICogVGhlIG1heGltdW0gbWlsbGlzZWNvbmRzIHRvIGluY3JlYXNlIHRvLlxyXG4gKlxyXG4gKiA8cD5WaXNpYmxlIGZvciB0ZXN0aW5nXHJcbiAqL1xyXG5jb25zdCBNQVhfVkFMVUVfTUlMTElTID0gNCAqIDYwICogNjAgKiAxMDAwOyAvLyBGb3VyIGhvdXJzLCBsaWtlIGlPUyBhbmQgQW5kcm9pZC5cclxuLyoqXHJcbiAqIFRoZSBwZXJjZW50YWdlIG9mIGJhY2tvZmYgdGltZSB0byByYW5kb21pemUgYnkuXHJcbiAqIFNlZVxyXG4gKiBodHRwOi8vZ28vc2FmZS1jbGllbnQtYmVoYXZpb3Ijc3RlcC0xLWRldGVybWluZS10aGUtYXBwcm9wcmlhdGUtcmV0cnktaW50ZXJ2YWwtdG8taGFuZGxlLXNwaWtlLXRyYWZmaWNcclxuICogZm9yIGNvbnRleHQuXHJcbiAqXHJcbiAqIDxwPlZpc2libGUgZm9yIHRlc3RpbmdcclxuICovXHJcbmNvbnN0IFJBTkRPTV9GQUNUT1IgPSAwLjU7XHJcbi8qKlxyXG4gKiBCYXNlZCBvbiB0aGUgYmFja29mZiBtZXRob2QgZnJvbVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iL21hc3Rlci9jbG9zdXJlL2dvb2cvbWF0aC9leHBvbmVudGlhbGJhY2tvZmYuanMuXHJcbiAqIEV4dHJhY3RlZCBoZXJlIHNvIHdlIGRvbid0IG5lZWQgdG8gcGFzcyBtZXRhZGF0YSBhbmQgYSBzdGF0ZWZ1bCBFeHBvbmVudGlhbEJhY2tvZmYgb2JqZWN0IGFyb3VuZC5cclxuICovXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMoYmFja29mZkNvdW50LCBpbnRlcnZhbE1pbGxpcyA9IERFRkFVTFRfSU5URVJWQUxfTUlMTElTLCBiYWNrb2ZmRmFjdG9yID0gREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUikge1xyXG4gICAgLy8gQ2FsY3VsYXRlcyBhbiBleHBvbmVudGlhbGx5IGluY3JlYXNpbmcgdmFsdWUuXHJcbiAgICAvLyBEZXZpYXRpb246IGNhbGN1bGF0ZXMgdmFsdWUgZnJvbSBjb3VudCBhbmQgYSBjb25zdGFudCBpbnRlcnZhbCwgc28gd2Ugb25seSBuZWVkIHRvIHNhdmUgdmFsdWVcclxuICAgIC8vIGFuZCBjb3VudCB0byByZXN0b3JlIHN0YXRlLlxyXG4gICAgY29uc3QgY3VyckJhc2VWYWx1ZSA9IGludGVydmFsTWlsbGlzICogTWF0aC5wb3coYmFja29mZkZhY3RvciwgYmFja29mZkNvdW50KTtcclxuICAgIC8vIEEgcmFuZG9tIFwiZnV6elwiIHRvIGF2b2lkIHdhdmVzIG9mIHJldHJpZXMuXHJcbiAgICAvLyBEZXZpYXRpb246IHJhbmRvbUZhY3RvciBpcyByZXF1aXJlZC5cclxuICAgIGNvbnN0IHJhbmRvbVdhaXQgPSBNYXRoLnJvdW5kKFxyXG4gICAgLy8gQSBmcmFjdGlvbiBvZiB0aGUgYmFja29mZiB2YWx1ZSB0byBhZGQvc3VidHJhY3QuXHJcbiAgICAvLyBEZXZpYXRpb246IGNoYW5nZXMgbXVsdGlwbGljYXRpb24gb3JkZXIgdG8gaW1wcm92ZSByZWFkYWJpbGl0eS5cclxuICAgIFJBTkRPTV9GQUNUT1IgKlxyXG4gICAgICAgIGN1cnJCYXNlVmFsdWUgKlxyXG4gICAgICAgIC8vIEEgcmFuZG9tIGZsb2F0IChyb3VuZGVkIHRvIGludCBieSBNYXRoLnJvdW5kIGFib3ZlKSBpbiB0aGUgcmFuZ2UgWy0xLCAxXS4gRGV0ZXJtaW5lc1xyXG4gICAgICAgIC8vIGlmIHdlIGFkZCBvciBzdWJ0cmFjdC5cclxuICAgICAgICAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKlxyXG4gICAgICAgIDIpO1xyXG4gICAgLy8gTGltaXRzIGJhY2tvZmYgdG8gbWF4IHRvIGF2b2lkIGVmZmVjdGl2ZWx5IHBlcm1hbmVudCBiYWNrb2ZmLlxyXG4gICAgcmV0dXJuIE1hdGgubWluKE1BWF9WQUxVRV9NSUxMSVMsIGN1cnJCYXNlVmFsdWUgKyByYW5kb21XYWl0KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUHJvdmlkZSBFbmdsaXNoIG9yZGluYWwgbGV0dGVycyBhZnRlciBhIG51bWJlclxyXG4gKi9cclxuZnVuY3Rpb24gb3JkaW5hbChpKSB7XHJcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpKSkge1xyXG4gICAgICAgIHJldHVybiBgJHtpfWA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaSArIGluZGljYXRvcihpKTtcclxufVxyXG5mdW5jdGlvbiBpbmRpY2F0b3IoaSkge1xyXG4gICAgaSA9IE1hdGguYWJzKGkpO1xyXG4gICAgY29uc3QgY2VudCA9IGkgJSAxMDA7XHJcbiAgICBpZiAoY2VudCA+PSAxMCAmJiBjZW50IDw9IDIwKSB7XHJcbiAgICAgICAgcmV0dXJuICd0aCc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWMgPSBpICUgMTA7XHJcbiAgICBpZiAoZGVjID09PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuICdzdCc7XHJcbiAgICB9XHJcbiAgICBpZiAoZGVjID09PSAyKSB7XHJcbiAgICAgICAgcmV0dXJuICduZCc7XHJcbiAgICB9XHJcbiAgICBpZiAoZGVjID09PSAzKSB7XHJcbiAgICAgICAgcmV0dXJuICdyZCc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ3RoJztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNb2R1bGFySW5zdGFuY2Uoc2VydmljZSkge1xyXG4gICAgaWYgKHNlcnZpY2UgJiYgc2VydmljZS5fZGVsZWdhdGUpIHtcclxuICAgICAgICByZXR1cm4gc2VydmljZS5fZGVsZWdhdGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gc2VydmljZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBPdmVycmlkaW5nIHRoZSBjb25zdGFudCAod2Ugc2hvdWxkIGJlIHRoZSBvbmx5IG9uZXMgZG9pbmcgdGhpcylcclxuQ09OU1RBTlRTLk5PREVfQ0xJRU5UID0gdHJ1ZTtcblxuZXhwb3J0IHsgQ09OU1RBTlRTLCBEZWNvZGVCYXNlNjRTdHJpbmdFcnJvciwgRGVmZXJyZWQsIEVycm9yRmFjdG9yeSwgRmlyZWJhc2VFcnJvciwgTUFYX1ZBTFVFX01JTExJUywgUkFORE9NX0ZBQ1RPUiwgU2hhMSwgYXJlQ29va2llc0VuYWJsZWQsIGFzc2VydCwgYXNzZXJ0aW9uRXJyb3IsIGFzeW5jLCBiYXNlNjQsIGJhc2U2NERlY29kZSwgYmFzZTY0RW5jb2RlLCBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZywgY2FsY3VsYXRlQmFja29mZk1pbGxpcywgY29udGFpbnMsIGNyZWF0ZU1vY2tVc2VyVG9rZW4sIGNyZWF0ZVN1YnNjcmliZSwgZGVjb2RlLCBkZWVwQ29weSwgZGVlcEVxdWFsLCBkZWVwRXh0ZW5kLCBlcnJvclByZWZpeCwgZXh0cmFjdFF1ZXJ5c3RyaW5nLCBnZXREZWZhdWx0QXBwQ29uZmlnLCBnZXREZWZhdWx0RW11bGF0b3JIb3N0LCBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQsIGdldERlZmF1bHRzLCBnZXRFeHBlcmltZW50YWxTZXR0aW5nLCBnZXRHbG9iYWwsIGdldE1vZHVsYXJJbnN0YW5jZSwgZ2V0VUEsIGlzQWRtaW4sIGlzQnJvd3NlciwgaXNCcm93c2VyRXh0ZW5zaW9uLCBpc0VsZWN0cm9uLCBpc0VtcHR5LCBpc0lFLCBpc0luZGV4ZWREQkF2YWlsYWJsZSwgaXNNb2JpbGVDb3Jkb3ZhLCBpc05vZGUsIGlzTm9kZVNkaywgaXNSZWFjdE5hdGl2ZSwgaXNTYWZhcmksIGlzVVdQLCBpc1ZhbGlkRm9ybWF0LCBpc1ZhbGlkVGltZXN0YW1wLCBpc3N1ZWRBdFRpbWUsIGpzb25FdmFsLCBtYXAsIG9yZGluYWwsIHByb21pc2VXaXRoVGltZW91dCwgcXVlcnlzdHJpbmcsIHF1ZXJ5c3RyaW5nRGVjb2RlLCBzYWZlR2V0LCBzdHJpbmdMZW5ndGgsIHN0cmluZ1RvQnl0ZUFycmF5LCBzdHJpbmdpZnksIHV1aWR2NCwgdmFsaWRhdGVBcmdDb3VudCwgdmFsaWRhdGVDYWxsYmFjaywgdmFsaWRhdGVDb250ZXh0T2JqZWN0LCB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlLCB2YWxpZGF0ZU5hbWVzcGFjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiQ09OU1RBTlRTIiwiTk9ERV9DTElFTlQiLCJOT0RFX0FETUlOIiwiU0RLX1ZFUlNJT04iLCJhc3NlcnQiLCJhc3NlcnRpb24iLCJtZXNzYWdlIiwiYXNzZXJ0aW9uRXJyb3IiLCJFcnJvciIsInN0cmluZ1RvQnl0ZUFycmF5JDEiLCJzdHIiLCJvdXQiLCJwIiwiaSIsImxlbmd0aCIsImMiLCJjaGFyQ29kZUF0IiwiYnl0ZUFycmF5VG9TdHJpbmciLCJieXRlcyIsInBvcyIsImMxIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYzIiLCJjMyIsImM0IiwidSIsImpvaW4iLCJiYXNlNjQiLCJieXRlVG9DaGFyTWFwXyIsImNoYXJUb0J5dGVNYXBfIiwiYnl0ZVRvQ2hhck1hcFdlYlNhZmVfIiwiY2hhclRvQnl0ZU1hcFdlYlNhZmVfIiwiRU5DT0RFRF9WQUxTX0JBU0UiLCJFTkNPREVEX1ZBTFMiLCJFTkNPREVEX1ZBTFNfV0VCU0FGRSIsIkhBU19OQVRJVkVfU1VQUE9SVCIsImF0b2IiLCJlbmNvZGVCeXRlQXJyYXkiLCJpbnB1dCIsIndlYlNhZmUiLCJBcnJheSIsImlzQXJyYXkiLCJpbml0XyIsImJ5dGVUb0NoYXJNYXAiLCJvdXRwdXQiLCJieXRlMSIsImhhdmVCeXRlMiIsImJ5dGUyIiwiaGF2ZUJ5dGUzIiwiYnl0ZTMiLCJvdXRCeXRlMSIsIm91dEJ5dGUyIiwib3V0Qnl0ZTMiLCJvdXRCeXRlNCIsInB1c2giLCJlbmNvZGVTdHJpbmciLCJidG9hIiwiZGVjb2RlU3RyaW5nIiwiZGVjb2RlU3RyaW5nVG9CeXRlQXJyYXkiLCJjaGFyVG9CeXRlTWFwIiwiY2hhckF0IiwiaGF2ZUJ5dGU0IiwiYnl0ZTQiLCJEZWNvZGVCYXNlNjRTdHJpbmdFcnJvciIsImNvbnN0cnVjdG9yIiwiYXJndW1lbnRzIiwibmFtZSIsImJhc2U2NEVuY29kZSIsInV0ZjhCeXRlcyIsImJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nIiwicmVwbGFjZSIsImJhc2U2NERlY29kZSIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJkZWVwQ29weSIsInZhbHVlIiwiZGVlcEV4dGVuZCIsInVuZGVmaW5lZCIsInRhcmdldCIsInNvdXJjZSIsIk9iamVjdCIsIkRhdGUiLCJkYXRlVmFsdWUiLCJnZXRUaW1lIiwicHJvcCIsImhhc093blByb3BlcnR5IiwiaXNWYWxpZEtleSIsImtleSIsImdldEdsb2JhbCIsInNlbGYiLCJ3aW5kb3ciLCJnbG9iYWwiLCJnZXREZWZhdWx0c0Zyb21HbG9iYWwiLCJfX0ZJUkVCQVNFX0RFRkFVTFRTX18iLCJnZXREZWZhdWx0c0Zyb21FbnZWYXJpYWJsZSIsInByb2Nlc3MiLCJlbnYiLCJkZWZhdWx0c0pzb25TdHJpbmciLCJKU09OIiwicGFyc2UiLCJnZXREZWZhdWx0c0Zyb21Db29raWUiLCJkb2N1bWVudCIsIm1hdGNoIiwiY29va2llIiwiZGVjb2RlZCIsImdldERlZmF1bHRzIiwiaW5mbyIsImdldERlZmF1bHRFbXVsYXRvckhvc3QiLCJwcm9kdWN0TmFtZSIsIl9hIiwiX2IiLCJlbXVsYXRvckhvc3RzIiwiZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0IiwiaG9zdCIsInNlcGFyYXRvckluZGV4IiwibGFzdEluZGV4T2YiLCJwb3J0IiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJnZXREZWZhdWx0QXBwQ29uZmlnIiwiY29uZmlnIiwiZ2V0RXhwZXJpbWVudGFsU2V0dGluZyIsIkRlZmVycmVkIiwicmVqZWN0IiwicmVzb2x2ZSIsInByb21pc2UiLCJQcm9taXNlIiwid3JhcENhbGxiYWNrIiwiY2FsbGJhY2siLCJjYXRjaCIsImNyZWF0ZU1vY2tVc2VyVG9rZW4iLCJ0b2tlbiIsInByb2plY3RJZCIsInVpZCIsImhlYWRlciIsImFsZyIsInR5cGUiLCJwcm9qZWN0IiwiaWF0Iiwic3ViIiwidXNlcl9pZCIsInBheWxvYWQiLCJhc3NpZ24iLCJpc3MiLCJhdWQiLCJleHAiLCJhdXRoX3RpbWUiLCJmaXJlYmFzZSIsInNpZ25faW5fcHJvdmlkZXIiLCJpZGVudGl0aWVzIiwic2lnbmF0dXJlIiwic3RyaW5naWZ5IiwiZ2V0VUEiLCJuYXZpZ2F0b3IiLCJpc01vYmlsZUNvcmRvdmEiLCJ0ZXN0IiwiaXNOb2RlIiwiZm9yY2VFbnZpcm9ubWVudCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImlzQnJvd3NlciIsImlzQnJvd3NlckV4dGVuc2lvbiIsInJ1bnRpbWUiLCJjaHJvbWUiLCJicm93c2VyIiwiaWQiLCJpc1JlYWN0TmF0aXZlIiwiaXNFbGVjdHJvbiIsImluZGV4T2YiLCJpc0lFIiwidWEiLCJpc1VXUCIsImlzTm9kZVNkayIsImlzU2FmYXJpIiwidXNlckFnZW50IiwiaW5jbHVkZXMiLCJpc0luZGV4ZWREQkF2YWlsYWJsZSIsImluZGV4ZWREQiIsInZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUiLCJwcmVFeGlzdCIsIkRCX0NIRUNLX05BTUUiLCJyZXF1ZXN0Iiwib3BlbiIsIm9uc3VjY2VzcyIsInJlc3VsdCIsImNsb3NlIiwiZGVsZXRlRGF0YWJhc2UiLCJvbnVwZ3JhZGVuZWVkZWQiLCJvbmVycm9yIiwiYXJlQ29va2llc0VuYWJsZWQiLCJjb29raWVFbmFibGVkIiwiRVJST1JfTkFNRSIsIkZpcmViYXNlRXJyb3IiLCJjb2RlIiwiY3VzdG9tRGF0YSIsInNldFByb3RvdHlwZU9mIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJFcnJvckZhY3RvcnkiLCJjcmVhdGUiLCJzZXJ2aWNlIiwic2VydmljZU5hbWUiLCJlcnJvcnMiLCJkYXRhIiwiZnVsbENvZGUiLCJ0ZW1wbGF0ZSIsInJlcGxhY2VUZW1wbGF0ZSIsImZ1bGxNZXNzYWdlIiwiUEFUVEVSTiIsIl8iLCJqc29uRXZhbCIsImRlY29kZSIsImNsYWltcyIsInBhcnRzIiwic3BsaXQiLCJpc1ZhbGlkVGltZXN0YW1wIiwibm93IiwiTWF0aCIsImZsb29yIiwidmFsaWRTaW5jZSIsInZhbGlkVW50aWwiLCJpc3N1ZWRBdFRpbWUiLCJpc1ZhbGlkRm9ybWF0IiwiaXNBZG1pbiIsImNvbnRhaW5zIiwib2JqIiwic2FmZUdldCIsImlzRW1wdHkiLCJtYXAiLCJmbiIsImNvbnRleHRPYmoiLCJyZXMiLCJkZWVwRXF1YWwiLCJhIiwiYiIsImFLZXlzIiwia2V5cyIsImJLZXlzIiwiayIsImFQcm9wIiwiYlByb3AiLCJpc09iamVjdCIsInRoaW5nIiwicHJvbWlzZVdpdGhUaW1lb3V0IiwidGltZUluTVMiLCJkZWZlcnJlZFByb21pc2UiLCJzZXRUaW1lb3V0IiwidGhlbiIsInF1ZXJ5c3RyaW5nIiwicXVlcnlzdHJpbmdQYXJhbXMiLCJwYXJhbXMiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImFycmF5VmFsIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicXVlcnlzdHJpbmdEZWNvZGUiLCJ0b2tlbnMiLCJkZWNvZGVVUklDb21wb25lbnQiLCJleHRyYWN0UXVlcnlzdHJpbmciLCJ1cmwiLCJxdWVyeVN0YXJ0IiwiZnJhZ21lbnRTdGFydCIsIlNoYTEiLCJjaGFpbl8iLCJidWZfIiwiV18iLCJwYWRfIiwiaW5idWZfIiwidG90YWxfIiwiYmxvY2tTaXplIiwicmVzZXQiLCJjb21wcmVzc18iLCJidWYiLCJvZmZzZXQiLCJXIiwidCIsImQiLCJmIiwidXBkYXRlIiwibGVuZ3RoTWludXNCbG9jayIsIm4iLCJpbmJ1ZiIsImRpZ2VzdCIsInRvdGFsQml0cyIsImoiLCJjcmVhdGVTdWJzY3JpYmUiLCJleGVjdXRvciIsIm9uTm9PYnNlcnZlcnMiLCJwcm94eSIsIk9ic2VydmVyUHJveHkiLCJzdWJzY3JpYmUiLCJiaW5kIiwib2JzZXJ2ZXJzIiwidW5zdWJzY3JpYmVzIiwib2JzZXJ2ZXJDb3VudCIsInRhc2siLCJmaW5hbGl6ZWQiLCJuZXh0IiwiZm9yRWFjaE9ic2VydmVyIiwib2JzZXJ2ZXIiLCJjb21wbGV0ZSIsIm5leHRPck9ic2VydmVyIiwiaW1wbGVtZW50c0FueU1ldGhvZHMiLCJub29wIiwidW5zdWIiLCJ1bnN1YnNjcmliZU9uZSIsImZpbmFsRXJyb3IiLCJzZW5kT25lIiwiZXJyIiwiYXN5bmMiLCJvbkVycm9yIiwiYXJncyIsIm1ldGhvZHMiLCJtZXRob2QiLCJ2YWxpZGF0ZUFyZ0NvdW50IiwiZm5OYW1lIiwibWluQ291bnQiLCJtYXhDb3VudCIsImFyZ0NvdW50IiwiYXJnRXJyb3IiLCJlcnJvclByZWZpeCIsImFyZ05hbWUiLCJ2YWxpZGF0ZU5hbWVzcGFjZSIsIm5hbWVzcGFjZSIsIm9wdGlvbmFsIiwidmFsaWRhdGVDYWxsYmFjayIsImFyZ3VtZW50TmFtZSIsInZhbGlkYXRlQ29udGV4dE9iamVjdCIsImNvbnRleHQiLCJzdHJpbmdUb0J5dGVBcnJheSIsImhpZ2giLCJsb3ciLCJzdHJpbmdMZW5ndGgiLCJ1dWlkdjQiLCJyIiwicmFuZG9tIiwidiIsIkRFRkFVTFRfSU5URVJWQUxfTUlMTElTIiwiREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUiIsIk1BWF9WQUxVRV9NSUxMSVMiLCJSQU5ET01fRkFDVE9SIiwiY2FsY3VsYXRlQmFja29mZk1pbGxpcyIsImJhY2tvZmZDb3VudCIsImludGVydmFsTWlsbGlzIiwiYmFja29mZkZhY3RvciIsImN1cnJCYXNlVmFsdWUiLCJwb3ciLCJyYW5kb21XYWl0Iiwicm91bmQiLCJtaW4iLCJvcmRpbmFsIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJpbmRpY2F0b3IiLCJhYnMiLCJjZW50IiwiZGVjIiwiZ2V0TW9kdWxhckluc3RhbmNlIiwiX2RlbGVnYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\n");

/***/ })

};
;